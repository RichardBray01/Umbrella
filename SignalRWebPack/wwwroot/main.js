/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		if (null) script.crossOrigin = null;
/******/ 		head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "5ba611392d375be9c0ee";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "main";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted
/******/ 			)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@aspnet/signalr/dist/esm/AbortController.js":
/*!******************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/AbortController.js ***!
  \******************************************************************/
/*! exports provided: AbortController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbortController", function() { return AbortController; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController
// We don't actually ever use the API being polyfilled, we always use the polyfill because
// it's a very new API right now.
// Not exported from index.
/** @private */
var AbortController = /** @class */ (function () {
    function AbortController() {
        this.isAborted = false;
        this.onabort = null;
    }
    AbortController.prototype.abort = function () {
        if (!this.isAborted) {
            this.isAborted = true;
            if (this.onabort) {
                this.onabort();
            }
        }
    };
    Object.defineProperty(AbortController.prototype, "signal", {
        get: function () {
            return this;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbortController.prototype, "aborted", {
        get: function () {
            return this.isAborted;
        },
        enumerable: true,
        configurable: true
    });
    return AbortController;
}());

//# sourceMappingURL=AbortController.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/DefaultHttpClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/DefaultHttpClient.js ***!
  \********************************************************************/
/*! exports provided: DefaultHttpClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultHttpClient", function() { return DefaultHttpClient; });
/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ "./node_modules/@aspnet/signalr/dist/esm/Errors.js");
/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ "./node_modules/@aspnet/signalr/dist/esm/HttpClient.js");
/* harmony import */ var _XhrHttpClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./XhrHttpClient */ "./node_modules/@aspnet/signalr/dist/esm/XhrHttpClient.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var nodeHttpClientModule;
if (typeof XMLHttpRequest === "undefined") {
    // In order to ignore the dynamic require in webpack builds we need to do this magic
    // @ts-ignore: TS doesn't know about these names
    var requireFunc =  true ? require : undefined;
    nodeHttpClientModule = requireFunc("./NodeHttpClient");
}
/** Default implementation of {@link @aspnet/signalr.HttpClient}. */
var DefaultHttpClient = /** @class */ (function (_super) {
    __extends(DefaultHttpClient, _super);
    /** Creates a new instance of the {@link @aspnet/signalr.DefaultHttpClient}, using the provided {@link @aspnet/signalr.ILogger} to log messages. */
    function DefaultHttpClient(logger) {
        var _this = _super.call(this) || this;
        if (typeof XMLHttpRequest !== "undefined") {
            _this.httpClient = new _XhrHttpClient__WEBPACK_IMPORTED_MODULE_2__["XhrHttpClient"](logger);
        }
        else if (typeof nodeHttpClientModule !== "undefined") {
            _this.httpClient = new nodeHttpClientModule.NodeHttpClient(logger);
        }
        else {
            throw new Error("No HttpClient could be created.");
        }
        return _this;
    }
    /** @inheritDoc */
    DefaultHttpClient.prototype.send = function (request) {
        // Check that abort was not signaled before calling send
        if (request.abortSignal && request.abortSignal.aborted) {
            return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__["AbortError"]());
        }
        if (!request.method) {
            return Promise.reject(new Error("No method defined."));
        }
        if (!request.url) {
            return Promise.reject(new Error("No url defined."));
        }
        return this.httpClient.send(request);
    };
    DefaultHttpClient.prototype.getCookieString = function (url) {
        return this.httpClient.getCookieString(url);
    };
    return DefaultHttpClient;
}(_HttpClient__WEBPACK_IMPORTED_MODULE_1__["HttpClient"]));

//# sourceMappingURL=DefaultHttpClient.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/Errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/Errors.js ***!
  \*********************************************************/
/*! exports provided: HttpError, TimeoutError, AbortError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpError", function() { return HttpError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeoutError", function() { return TimeoutError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbortError", function() { return AbortError; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/** Error thrown when an HTTP request fails. */
var HttpError = /** @class */ (function (_super) {
    __extends(HttpError, _super);
    /** Constructs a new instance of {@link @aspnet/signalr.HttpError}.
     *
     * @param {string} errorMessage A descriptive error message.
     * @param {number} statusCode The HTTP status code represented by this error.
     */
    function HttpError(errorMessage, statusCode) {
        var _newTarget = this.constructor;
        var _this = this;
        var trueProto = _newTarget.prototype;
        _this = _super.call(this, errorMessage) || this;
        _this.statusCode = statusCode;
        // Workaround issue in Typescript compiler
        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
        _this.__proto__ = trueProto;
        return _this;
    }
    return HttpError;
}(Error));

/** Error thrown when a timeout elapses. */
var TimeoutError = /** @class */ (function (_super) {
    __extends(TimeoutError, _super);
    /** Constructs a new instance of {@link @aspnet/signalr.TimeoutError}.
     *
     * @param {string} errorMessage A descriptive error message.
     */
    function TimeoutError(errorMessage) {
        var _newTarget = this.constructor;
        if (errorMessage === void 0) { errorMessage = "A timeout occurred."; }
        var _this = this;
        var trueProto = _newTarget.prototype;
        _this = _super.call(this, errorMessage) || this;
        // Workaround issue in Typescript compiler
        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
        _this.__proto__ = trueProto;
        return _this;
    }
    return TimeoutError;
}(Error));

/** Error thrown when an action is aborted. */
var AbortError = /** @class */ (function (_super) {
    __extends(AbortError, _super);
    /** Constructs a new instance of {@link AbortError}.
     *
     * @param {string} errorMessage A descriptive error message.
     */
    function AbortError(errorMessage) {
        var _newTarget = this.constructor;
        if (errorMessage === void 0) { errorMessage = "An abort occurred."; }
        var _this = this;
        var trueProto = _newTarget.prototype;
        _this = _super.call(this, errorMessage) || this;
        // Workaround issue in Typescript compiler
        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
        _this.__proto__ = trueProto;
        return _this;
    }
    return AbortError;
}(Error));

//# sourceMappingURL=Errors.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/HandshakeProtocol.js":
/*!********************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/HandshakeProtocol.js ***!
  \********************************************************************/
/*! exports provided: HandshakeProtocol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HandshakeProtocol", function() { return HandshakeProtocol; });
/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextMessageFormat */ "./node_modules/@aspnet/signalr/dist/esm/TextMessageFormat.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./node_modules/@aspnet/signalr/dist/esm/Utils.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.


/** @private */
var HandshakeProtocol = /** @class */ (function () {
    function HandshakeProtocol() {
    }
    // Handshake request is always JSON
    HandshakeProtocol.prototype.writeHandshakeRequest = function (handshakeRequest) {
        return _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__["TextMessageFormat"].write(JSON.stringify(handshakeRequest));
    };
    HandshakeProtocol.prototype.parseHandshakeResponse = function (data) {
        var responseMessage;
        var messageData;
        var remainingData;
        if (Object(_Utils__WEBPACK_IMPORTED_MODULE_1__["isArrayBuffer"])(data) || (typeof Buffer !== "undefined" && data instanceof Buffer)) {
            // Format is binary but still need to read JSON text from handshake response
            var binaryData = new Uint8Array(data);
            var separatorIndex = binaryData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__["TextMessageFormat"].RecordSeparatorCode);
            if (separatorIndex === -1) {
                throw new Error("Message is incomplete.");
            }
            // content before separator is handshake response
            // optional content after is additional messages
            var responseLength = separatorIndex + 1;
            messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));
            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;
        }
        else {
            var textData = data;
            var separatorIndex = textData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__["TextMessageFormat"].RecordSeparator);
            if (separatorIndex === -1) {
                throw new Error("Message is incomplete.");
            }
            // content before separator is handshake response
            // optional content after is additional messages
            var responseLength = separatorIndex + 1;
            messageData = textData.substring(0, responseLength);
            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;
        }
        // At this point we should have just the single handshake message
        var messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__["TextMessageFormat"].parse(messageData);
        var response = JSON.parse(messages[0]);
        if (response.type) {
            throw new Error("Expected a handshake response from the server.");
        }
        responseMessage = response;
        // multiple messages could have arrived with handshake
        // return additional data to be parsed as usual, or null if all parsed
        return [remainingData, responseMessage];
    };
    return HandshakeProtocol;
}());

//# sourceMappingURL=HandshakeProtocol.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/HttpClient.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/HttpClient.js ***!
  \*************************************************************/
/*! exports provided: HttpResponse, HttpClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpResponse", function() { return HttpResponse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpClient", function() { return HttpClient; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
/** Represents an HTTP response. */
var HttpResponse = /** @class */ (function () {
    function HttpResponse(statusCode, statusText, content) {
        this.statusCode = statusCode;
        this.statusText = statusText;
        this.content = content;
    }
    return HttpResponse;
}());

/** Abstraction over an HTTP client.
 *
 * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.
 */
var HttpClient = /** @class */ (function () {
    function HttpClient() {
    }
    HttpClient.prototype.get = function (url, options) {
        return this.send(__assign({}, options, { method: "GET", url: url }));
    };
    HttpClient.prototype.post = function (url, options) {
        return this.send(__assign({}, options, { method: "POST", url: url }));
    };
    HttpClient.prototype.delete = function (url, options) {
        return this.send(__assign({}, options, { method: "DELETE", url: url }));
    };
    /** Gets all cookies that apply to the specified URL.
     *
     * @param url The URL that the cookies are valid for.
     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.
     */
    // @ts-ignore
    HttpClient.prototype.getCookieString = function (url) {
        return "";
    };
    return HttpClient;
}());

//# sourceMappingURL=HttpClient.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/HttpConnection.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/HttpConnection.js ***!
  \*****************************************************************/
/*! exports provided: HttpConnection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpConnection", function() { return HttpConnection; });
/* harmony import */ var _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultHttpClient */ "./node_modules/@aspnet/signalr/dist/esm/DefaultHttpClient.js");
/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ILogger */ "./node_modules/@aspnet/signalr/dist/esm/ILogger.js");
/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ITransport */ "./node_modules/@aspnet/signalr/dist/esm/ITransport.js");
/* harmony import */ var _LongPollingTransport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LongPollingTransport */ "./node_modules/@aspnet/signalr/dist/esm/LongPollingTransport.js");
/* harmony import */ var _ServerSentEventsTransport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ServerSentEventsTransport */ "./node_modules/@aspnet/signalr/dist/esm/ServerSentEventsTransport.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Utils */ "./node_modules/@aspnet/signalr/dist/esm/Utils.js");
/* harmony import */ var _WebSocketTransport__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WebSocketTransport */ "./node_modules/@aspnet/signalr/dist/esm/WebSocketTransport.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};







var MAX_REDIRECTS = 100;
var WebSocketModule = null;
var EventSourceModule = null;
if (typeof window === "undefined" && "function" !== "undefined") {
    // In order to ignore the dynamic require in webpack builds we need to do this magic
    // @ts-ignore: TS doesn't know about these names
    var requireFunc =  true ? require : undefined;
    WebSocketModule = requireFunc("ws");
    EventSourceModule = requireFunc("eventsource");
}
/** @private */
var HttpConnection = /** @class */ (function () {
    function HttpConnection(url, options) {
        if (options === void 0) { options = {}; }
        this.features = {};
        _Utils__WEBPACK_IMPORTED_MODULE_5__["Arg"].isRequired(url, "url");
        this.logger = Object(_Utils__WEBPACK_IMPORTED_MODULE_5__["createLogger"])(options.logger);
        this.baseUrl = this.resolveUrl(url);
        options = options || {};
        options.logMessageContent = options.logMessageContent || false;
        var isNode = typeof window === "undefined";
        if (!isNode && typeof WebSocket !== "undefined" && !options.WebSocket) {
            options.WebSocket = WebSocket;
        }
        else if (isNode && !options.WebSocket) {
            if (WebSocketModule) {
                options.WebSocket = WebSocketModule;
            }
        }
        if (!isNode && typeof EventSource !== "undefined" && !options.EventSource) {
            options.EventSource = EventSource;
        }
        else if (isNode && !options.EventSource) {
            if (typeof EventSourceModule !== "undefined") {
                options.EventSource = EventSourceModule;
            }
        }
        this.httpClient = options.httpClient || new _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_0__["DefaultHttpClient"](this.logger);
        this.connectionState = 2 /* Disconnected */;
        this.options = options;
        this.onreceive = null;
        this.onclose = null;
    }
    HttpConnection.prototype.start = function (transferFormat) {
        transferFormat = transferFormat || _ITransport__WEBPACK_IMPORTED_MODULE_2__["TransferFormat"].Binary;
        _Utils__WEBPACK_IMPORTED_MODULE_5__["Arg"].isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_2__["TransferFormat"], "transferFormat");
        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Debug, "Starting connection with transfer format '" + _ITransport__WEBPACK_IMPORTED_MODULE_2__["TransferFormat"][transferFormat] + "'.");
        if (this.connectionState !== 2 /* Disconnected */) {
            return Promise.reject(new Error("Cannot start a connection that is not in the 'Disconnected' state."));
        }
        this.connectionState = 0 /* Connecting */;
        this.startPromise = this.startInternal(transferFormat);
        return this.startPromise;
    };
    HttpConnection.prototype.send = function (data) {
        if (this.connectionState !== 1 /* Connected */) {
            throw new Error("Cannot send data if the connection is not in the 'Connected' State.");
        }
        // Transport will not be null if state is connected
        return this.transport.send(data);
    };
    HttpConnection.prototype.stop = function (error) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.connectionState = 2 /* Disconnected */;
                        // Set error as soon as possible otherwise there is a race between
                        // the transport closing and providing an error and the error from a close message
                        // We would prefer the close message error.
                        this.stopError = error;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.startPromise];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        return [3 /*break*/, 4];
                    case 4:
                        if (!this.transport) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.transport.stop()];
                    case 5:
                        _a.sent();
                        this.transport = undefined;
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    HttpConnection.prototype.startInternal = function (transferFormat) {
        return __awaiter(this, void 0, void 0, function () {
            var url, negotiateResponse, redirects, _loop_1, this_1, state_1, e_2;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.baseUrl;
                        this.accessTokenFactory = this.options.accessTokenFactory;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 12, , 13]);
                        if (!this.options.skipNegotiation) return [3 /*break*/, 5];
                        if (!(this.options.transport === _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"].WebSockets)) return [3 /*break*/, 3];
                        // No need to add a connection ID in this case
                        this.transport = this.constructTransport(_ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"].WebSockets);
                        // We should just call connect directly in this case.
                        // No fallback or negotiate in this case.
                        return [4 /*yield*/, this.transport.connect(url, transferFormat)];
                    case 2:
                        // We should just call connect directly in this case.
                        // No fallback or negotiate in this case.
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3: throw Error("Negotiation can only be skipped when using the WebSocket transport directly.");
                    case 4: return [3 /*break*/, 11];
                    case 5:
                        negotiateResponse = null;
                        redirects = 0;
                        _loop_1 = function () {
                            var accessToken_1;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this_1.getNegotiationResponse(url)];
                                    case 1:
                                        negotiateResponse = _a.sent();
                                        // the user tries to stop the connection when it is being started
                                        if (this_1.connectionState === 2 /* Disconnected */) {
                                            return [2 /*return*/, { value: void 0 }];
                                        }
                                        if (negotiateResponse.error) {
                                            throw Error(negotiateResponse.error);
                                        }
                                        if (negotiateResponse.ProtocolVersion) {
                                            throw Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                                        }
                                        if (negotiateResponse.url) {
                                            url = negotiateResponse.url;
                                        }
                                        if (negotiateResponse.accessToken) {
                                            accessToken_1 = negotiateResponse.accessToken;
                                            this_1.accessTokenFactory = function () { return accessToken_1; };
                                        }
                                        redirects++;
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _a.label = 6;
                    case 6: return [5 /*yield**/, _loop_1()];
                    case 7:
                        state_1 = _a.sent();
                        if (typeof state_1 === "object")
                            return [2 /*return*/, state_1.value];
                        _a.label = 8;
                    case 8:
                        if (negotiateResponse.url && redirects < MAX_REDIRECTS) return [3 /*break*/, 6];
                        _a.label = 9;
                    case 9:
                        if (redirects === MAX_REDIRECTS && negotiateResponse.url) {
                            throw Error("Negotiate redirection limit exceeded.");
                        }
                        return [4 /*yield*/, this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];
                    case 10:
                        _a.sent();
                        _a.label = 11;
                    case 11:
                        if (this.transport instanceof _LongPollingTransport__WEBPACK_IMPORTED_MODULE_3__["LongPollingTransport"]) {
                            this.features.inherentKeepAlive = true;
                        }
                        this.transport.onreceive = this.onreceive;
                        this.transport.onclose = function (e) { return _this.stopConnection(e); };
                        // only change the state if we were connecting to not overwrite
                        // the state if the connection is already marked as Disconnected
                        this.changeState(0 /* Connecting */, 1 /* Connected */);
                        return [3 /*break*/, 13];
                    case 12:
                        e_2 = _a.sent();
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Error, "Failed to start the connection: " + e_2);
                        this.connectionState = 2 /* Disconnected */;
                        this.transport = undefined;
                        throw e_2;
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    HttpConnection.prototype.getNegotiationResponse = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, headers, token, negotiateUrl, response, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.accessTokenFactory) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.accessTokenFactory()];
                    case 1:
                        token = _b.sent();
                        if (token) {
                            headers = (_a = {},
                                _a["Authorization"] = "Bearer " + token,
                                _a);
                        }
                        _b.label = 2;
                    case 2:
                        negotiateUrl = this.resolveNegotiateUrl(url);
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Debug, "Sending negotiation request: " + negotiateUrl + ".");
                        _b.label = 3;
                    case 3:
                        _b.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.httpClient.post(negotiateUrl, {
                                content: "",
                                headers: headers,
                            })];
                    case 4:
                        response = _b.sent();
                        if (response.statusCode !== 200) {
                            throw Error("Unexpected status code returned from negotiate " + response.statusCode);
                        }
                        return [2 /*return*/, JSON.parse(response.content)];
                    case 5:
                        e_3 = _b.sent();
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Error, "Failed to complete negotiation with the server: " + e_3);
                        throw e_3;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    HttpConnection.prototype.createConnectUrl = function (url, connectionId) {
        if (!connectionId) {
            return url;
        }
        return url + (url.indexOf("?") === -1 ? "?" : "&") + ("id=" + connectionId);
    };
    HttpConnection.prototype.createTransport = function (url, requestedTransport, negotiateResponse, requestedTransferFormat) {
        return __awaiter(this, void 0, void 0, function () {
            var connectUrl, transports, _i, transports_1, endpoint, transport, ex_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);
                        if (!this.isITransport(requestedTransport)) return [3 /*break*/, 2];
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Debug, "Connection was provided an instance of ITransport, using that directly.");
                        this.transport = requestedTransport;
                        return [4 /*yield*/, this.transport.connect(connectUrl, requestedTransferFormat)];
                    case 1:
                        _a.sent();
                        // only change the state if we were connecting to not overwrite
                        // the state if the connection is already marked as Disconnected
                        this.changeState(0 /* Connecting */, 1 /* Connected */);
                        return [2 /*return*/];
                    case 2:
                        transports = negotiateResponse.availableTransports || [];
                        _i = 0, transports_1 = transports;
                        _a.label = 3;
                    case 3:
                        if (!(_i < transports_1.length)) return [3 /*break*/, 9];
                        endpoint = transports_1[_i];
                        this.connectionState = 0 /* Connecting */;
                        transport = this.resolveTransport(endpoint, requestedTransport, requestedTransferFormat);
                        if (!(typeof transport === "number")) return [3 /*break*/, 8];
                        this.transport = this.constructTransport(transport);
                        if (!!negotiateResponse.connectionId) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.getNegotiationResponse(url)];
                    case 4:
                        negotiateResponse = _a.sent();
                        connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, , 8]);
                        return [4 /*yield*/, this.transport.connect(connectUrl, requestedTransferFormat)];
                    case 6:
                        _a.sent();
                        this.changeState(0 /* Connecting */, 1 /* Connected */);
                        return [2 /*return*/];
                    case 7:
                        ex_1 = _a.sent();
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Error, "Failed to start the transport '" + _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"][transport] + "': " + ex_1);
                        this.connectionState = 2 /* Disconnected */;
                        negotiateResponse.connectionId = undefined;
                        return [3 /*break*/, 8];
                    case 8:
                        _i++;
                        return [3 /*break*/, 3];
                    case 9: throw new Error("Unable to initialize any of the available transports.");
                }
            });
        });
    };
    HttpConnection.prototype.constructTransport = function (transport) {
        switch (transport) {
            case _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"].WebSockets:
                if (!this.options.WebSocket) {
                    throw new Error("'WebSocket' is not supported in your environment.");
                }
                return new _WebSocketTransport__WEBPACK_IMPORTED_MODULE_6__["WebSocketTransport"](this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket);
            case _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"].ServerSentEvents:
                if (!this.options.EventSource) {
                    throw new Error("'EventSource' is not supported in your environment.");
                }
                return new _ServerSentEventsTransport__WEBPACK_IMPORTED_MODULE_4__["ServerSentEventsTransport"](this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource);
            case _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"].LongPolling:
                return new _LongPollingTransport__WEBPACK_IMPORTED_MODULE_3__["LongPollingTransport"](this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false);
            default:
                throw new Error("Unknown transport: " + transport + ".");
        }
    };
    HttpConnection.prototype.resolveTransport = function (endpoint, requestedTransport, requestedTransferFormat) {
        var transport = _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"][endpoint.transport];
        if (transport === null || transport === undefined) {
            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Debug, "Skipping transport '" + endpoint.transport + "' because it is not supported by this client.");
        }
        else {
            var transferFormats = endpoint.transferFormats.map(function (s) { return _ITransport__WEBPACK_IMPORTED_MODULE_2__["TransferFormat"][s]; });
            if (transportMatches(requestedTransport, transport)) {
                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {
                    if ((transport === _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"].WebSockets && !this.options.WebSocket) ||
                        (transport === _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"].ServerSentEvents && !this.options.EventSource)) {
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Debug, "Skipping transport '" + _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"][transport] + "' because it is not supported in your environment.'");
                    }
                    else {
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Debug, "Selecting transport '" + _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"][transport] + "'.");
                        return transport;
                    }
                }
                else {
                    this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Debug, "Skipping transport '" + _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"][transport] + "' because it does not support the requested transfer format '" + _ITransport__WEBPACK_IMPORTED_MODULE_2__["TransferFormat"][requestedTransferFormat] + "'.");
                }
            }
            else {
                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Debug, "Skipping transport '" + _ITransport__WEBPACK_IMPORTED_MODULE_2__["HttpTransportType"][transport] + "' because it was disabled by the client.");
            }
        }
        return null;
    };
    HttpConnection.prototype.isITransport = function (transport) {
        return transport && typeof (transport) === "object" && "connect" in transport;
    };
    HttpConnection.prototype.changeState = function (from, to) {
        if (this.connectionState === from) {
            this.connectionState = to;
            return true;
        }
        return false;
    };
    HttpConnection.prototype.stopConnection = function (error) {
        this.transport = undefined;
        // If we have a stopError, it takes precedence over the error from the transport
        error = this.stopError || error;
        if (error) {
            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Error, "Connection disconnected with error '" + error + "'.");
        }
        else {
            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Information, "Connection disconnected.");
        }
        this.connectionState = 2 /* Disconnected */;
        if (this.onclose) {
            this.onclose(error);
        }
    };
    HttpConnection.prototype.resolveUrl = function (url) {
        // startsWith is not supported in IE
        if (url.lastIndexOf("https://", 0) === 0 || url.lastIndexOf("http://", 0) === 0) {
            return url;
        }
        if (typeof window === "undefined" || !window || !window.document) {
            throw new Error("Cannot resolve '" + url + "'.");
        }
        // Setting the url to the href propery of an anchor tag handles normalization
        // for us. There are 3 main cases.
        // 1. Relative  path normalization e.g "b" -> "http://localhost:5000/a/b"
        // 2. Absolute path normalization e.g "/a/b" -> "http://localhost:5000/a/b"
        // 3. Networkpath reference normalization e.g "//localhost:5000/a/b" -> "http://localhost:5000/a/b"
        var aTag = window.document.createElement("a");
        aTag.href = url;
        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Information, "Normalizing '" + url + "' to '" + aTag.href + "'.");
        return aTag.href;
    };
    HttpConnection.prototype.resolveNegotiateUrl = function (url) {
        var index = url.indexOf("?");
        var negotiateUrl = url.substring(0, index === -1 ? url.length : index);
        if (negotiateUrl[negotiateUrl.length - 1] !== "/") {
            negotiateUrl += "/";
        }
        negotiateUrl += "negotiate";
        negotiateUrl += index === -1 ? "" : url.substring(index);
        return negotiateUrl;
    };
    return HttpConnection;
}());

function transportMatches(requestedTransport, actualTransport) {
    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);
}
//# sourceMappingURL=HttpConnection.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/HubConnection.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/HubConnection.js ***!
  \****************************************************************/
/*! exports provided: HubConnectionState, HubConnection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HubConnectionState", function() { return HubConnectionState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HubConnection", function() { return HubConnection; });
/* harmony import */ var _HandshakeProtocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HandshakeProtocol */ "./node_modules/@aspnet/signalr/dist/esm/HandshakeProtocol.js");
/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IHubProtocol */ "./node_modules/@aspnet/signalr/dist/esm/IHubProtocol.js");
/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ "./node_modules/@aspnet/signalr/dist/esm/ILogger.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ "./node_modules/@aspnet/signalr/dist/esm/Utils.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};




var DEFAULT_TIMEOUT_IN_MS = 30 * 1000;
var DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;
/** Describes the current state of the {@link HubConnection} to the server. */
var HubConnectionState;
(function (HubConnectionState) {
    /** The hub connection is disconnected. */
    HubConnectionState[HubConnectionState["Disconnected"] = 0] = "Disconnected";
    /** The hub connection is connected. */
    HubConnectionState[HubConnectionState["Connected"] = 1] = "Connected";
})(HubConnectionState || (HubConnectionState = {}));
/** Represents a connection to a SignalR Hub. */
var HubConnection = /** @class */ (function () {
    function HubConnection(connection, logger, protocol) {
        var _this = this;
        _Utils__WEBPACK_IMPORTED_MODULE_3__["Arg"].isRequired(connection, "connection");
        _Utils__WEBPACK_IMPORTED_MODULE_3__["Arg"].isRequired(logger, "logger");
        _Utils__WEBPACK_IMPORTED_MODULE_3__["Arg"].isRequired(protocol, "protocol");
        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;
        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;
        this.logger = logger;
        this.protocol = protocol;
        this.connection = connection;
        this.handshakeProtocol = new _HandshakeProtocol__WEBPACK_IMPORTED_MODULE_0__["HandshakeProtocol"]();
        this.connection.onreceive = function (data) { return _this.processIncomingData(data); };
        this.connection.onclose = function (error) { return _this.connectionClosed(error); };
        this.callbacks = {};
        this.methods = {};
        this.closedCallbacks = [];
        this.id = 0;
        this.receivedHandshakeResponse = false;
        this.connectionState = HubConnectionState.Disconnected;
        this.cachedPingMessage = this.protocol.writeMessage({ type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Ping });
    }
    /** @internal */
    // Using a public static factory method means we can have a private constructor and an _internal_
    // create method that can be used by HubConnectionBuilder. An "internal" constructor would just
    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a
    // public parameter-less constructor.
    HubConnection.create = function (connection, logger, protocol) {
        return new HubConnection(connection, logger, protocol);
    };
    Object.defineProperty(HubConnection.prototype, "state", {
        /** Indicates the state of the {@link HubConnection} to the server. */
        get: function () {
            return this.connectionState;
        },
        enumerable: true,
        configurable: true
    });
    /** Starts the connection.
     *
     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.
     */
    HubConnection.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            var handshakeRequest, handshakePromise;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        handshakeRequest = {
                            protocol: this.protocol.name,
                            version: this.protocol.version,
                        };
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Debug, "Starting HubConnection.");
                        this.receivedHandshakeResponse = false;
                        handshakePromise = new Promise(function (resolve, reject) {
                            _this.handshakeResolver = resolve;
                            _this.handshakeRejecter = reject;
                        });
                        return [4 /*yield*/, this.connection.start(this.protocol.transferFormat)];
                    case 1:
                        _a.sent();
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Debug, "Sending handshake request.");
                        return [4 /*yield*/, this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];
                    case 2:
                        _a.sent();
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Information, "Using HubProtocol '" + this.protocol.name + "'.");
                        // defensively cleanup timeout in case we receive a message from the server before we finish start
                        this.cleanupTimeout();
                        this.resetTimeoutPeriod();
                        this.resetKeepAliveInterval();
                        // Wait for the handshake to complete before marking connection as connected
                        return [4 /*yield*/, handshakePromise];
                    case 3:
                        // Wait for the handshake to complete before marking connection as connected
                        _a.sent();
                        this.connectionState = HubConnectionState.Connected;
                        return [2 /*return*/];
                }
            });
        });
    };
    /** Stops the connection.
     *
     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.
     */
    HubConnection.prototype.stop = function () {
        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Debug, "Stopping HubConnection.");
        this.cleanupTimeout();
        this.cleanupPingTimer();
        return this.connection.stop();
    };
    /** Invokes a streaming hub method on the server using the specified name and arguments.
     *
     * @typeparam T The type of the items returned by the server.
     * @param {string} methodName The name of the server method to invoke.
     * @param {any[]} args The arguments used to invoke the server method.
     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.
     */
    HubConnection.prototype.stream = function (methodName) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var invocationDescriptor = this.createStreamInvocation(methodName, args);
        var subject = new _Utils__WEBPACK_IMPORTED_MODULE_3__["Subject"](function () {
            var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);
            var cancelMessage = _this.protocol.writeMessage(cancelInvocation);
            delete _this.callbacks[invocationDescriptor.invocationId];
            return _this.sendMessage(cancelMessage);
        });
        this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {
            if (error) {
                subject.error(error);
                return;
            }
            else if (invocationEvent) {
                // invocationEvent will not be null when an error is not passed to the callback
                if (invocationEvent.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Completion) {
                    if (invocationEvent.error) {
                        subject.error(new Error(invocationEvent.error));
                    }
                    else {
                        subject.complete();
                    }
                }
                else {
                    subject.next((invocationEvent.item));
                }
            }
        };
        var message = this.protocol.writeMessage(invocationDescriptor);
        this.sendMessage(message)
            .catch(function (e) {
            subject.error(e);
            delete _this.callbacks[invocationDescriptor.invocationId];
        });
        return subject;
    };
    HubConnection.prototype.sendMessage = function (message) {
        this.resetKeepAliveInterval();
        return this.connection.send(message);
    };
    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.
     *
     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still
     * be processing the invocation.
     *
     * @param {string} methodName The name of the server method to invoke.
     * @param {any[]} args The arguments used to invoke the server method.
     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.
     */
    HubConnection.prototype.send = function (methodName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var invocationDescriptor = this.createInvocation(methodName, args, true);
        var message = this.protocol.writeMessage(invocationDescriptor);
        return this.sendMessage(message);
    };
    /** Invokes a hub method on the server using the specified name and arguments.
     *
     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise
     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of
     * resolving the Promise.
     *
     * @typeparam T The expected return type.
     * @param {string} methodName The name of the server method to invoke.
     * @param {any[]} args The arguments used to invoke the server method.
     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.
     */
    HubConnection.prototype.invoke = function (methodName) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var invocationDescriptor = this.createInvocation(methodName, args, false);
        var p = new Promise(function (resolve, reject) {
            // invocationId will always have a value for a non-blocking invocation
            _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {
                if (error) {
                    reject(error);
                    return;
                }
                else if (invocationEvent) {
                    // invocationEvent will not be null when an error is not passed to the callback
                    if (invocationEvent.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Completion) {
                        if (invocationEvent.error) {
                            reject(new Error(invocationEvent.error));
                        }
                        else {
                            resolve(invocationEvent.result);
                        }
                    }
                    else {
                        reject(new Error("Unexpected message type: " + invocationEvent.type));
                    }
                }
            };
            var message = _this.protocol.writeMessage(invocationDescriptor);
            _this.sendMessage(message)
                .catch(function (e) {
                reject(e);
                // invocationId will always have a value for a non-blocking invocation
                delete _this.callbacks[invocationDescriptor.invocationId];
            });
        });
        return p;
    };
    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.
     *
     * @param {string} methodName The name of the hub method to define.
     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.
     */
    HubConnection.prototype.on = function (methodName, newMethod) {
        if (!methodName || !newMethod) {
            return;
        }
        methodName = methodName.toLowerCase();
        if (!this.methods[methodName]) {
            this.methods[methodName] = [];
        }
        // Preventing adding the same handler multiple times.
        if (this.methods[methodName].indexOf(newMethod) !== -1) {
            return;
        }
        this.methods[methodName].push(newMethod);
    };
    HubConnection.prototype.off = function (methodName, method) {
        if (!methodName) {
            return;
        }
        methodName = methodName.toLowerCase();
        var handlers = this.methods[methodName];
        if (!handlers) {
            return;
        }
        if (method) {
            var removeIdx = handlers.indexOf(method);
            if (removeIdx !== -1) {
                handlers.splice(removeIdx, 1);
                if (handlers.length === 0) {
                    delete this.methods[methodName];
                }
            }
        }
        else {
            delete this.methods[methodName];
        }
    };
    /** Registers a handler that will be invoked when the connection is closed.
     *
     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).
     */
    HubConnection.prototype.onclose = function (callback) {
        if (callback) {
            this.closedCallbacks.push(callback);
        }
    };
    HubConnection.prototype.processIncomingData = function (data) {
        this.cleanupTimeout();
        if (!this.receivedHandshakeResponse) {
            data = this.processHandshakeResponse(data);
            this.receivedHandshakeResponse = true;
        }
        // Data may have all been read when processing handshake response
        if (data) {
            // Parse the messages
            var messages = this.protocol.parseMessages(data, this.logger);
            for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
                var message = messages_1[_i];
                switch (message.type) {
                    case _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Invocation:
                        this.invokeClientMethod(message);
                        break;
                    case _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].StreamItem:
                    case _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Completion:
                        var callback = this.callbacks[message.invocationId];
                        if (callback != null) {
                            if (message.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Completion) {
                                delete this.callbacks[message.invocationId];
                            }
                            callback(message);
                        }
                        break;
                    case _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Ping:
                        // Don't care about pings
                        break;
                    case _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Close:
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Information, "Close message received from server.");
                        // We don't want to wait on the stop itself.
                        // tslint:disable-next-line:no-floating-promises
                        this.connection.stop(message.error ? new Error("Server returned an error on close: " + message.error) : undefined);
                        break;
                    default:
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Warning, "Invalid message type: " + message.type + ".");
                        break;
                }
            }
        }
        this.resetTimeoutPeriod();
    };
    HubConnection.prototype.processHandshakeResponse = function (data) {
        var _a;
        var responseMessage;
        var remainingData;
        try {
            _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];
        }
        catch (e) {
            var message = "Error parsing handshake response: " + e;
            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Error, message);
            var error = new Error(message);
            // We don't want to wait on the stop itself.
            // tslint:disable-next-line:no-floating-promises
            this.connection.stop(error);
            this.handshakeRejecter(error);
            throw error;
        }
        if (responseMessage.error) {
            var message = "Server returned handshake error: " + responseMessage.error;
            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Error, message);
            this.handshakeRejecter(message);
            // We don't want to wait on the stop itself.
            // tslint:disable-next-line:no-floating-promises
            this.connection.stop(new Error(message));
            throw new Error(message);
        }
        else {
            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Debug, "Server handshake complete.");
        }
        this.handshakeResolver();
        return remainingData;
    };
    HubConnection.prototype.resetKeepAliveInterval = function () {
        var _this = this;
        this.cleanupPingTimer();
        this.pingServerHandle = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.connectionState === HubConnectionState.Connected)) return [3 /*break*/, 4];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.sendMessage(this.cachedPingMessage)];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        // We don't care about the error. It should be seen elsewhere in the client.
                        // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering
                        this.cleanupPingTimer();
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); }, this.keepAliveIntervalInMilliseconds);
    };
    HubConnection.prototype.resetTimeoutPeriod = function () {
        var _this = this;
        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {
            // Set the timeout timer
            this.timeoutHandle = setTimeout(function () { return _this.serverTimeout(); }, this.serverTimeoutInMilliseconds);
        }
    };
    HubConnection.prototype.serverTimeout = function () {
        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(
        // Terminate the connection, but we don't need to wait on the promise.
        // tslint:disable-next-line:no-floating-promises
        this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
    };
    HubConnection.prototype.invokeClientMethod = function (invocationMessage) {
        var _this = this;
        var methods = this.methods[invocationMessage.target.toLowerCase()];
        if (methods) {
            methods.forEach(function (m) { return m.apply(_this, invocationMessage.arguments); });
            if (invocationMessage.invocationId) {
                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.
                var message = "Server requested a response, which is not supported in this version of the client.";
                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Error, message);
                // We don't need to wait on this Promise.
                // tslint:disable-next-line:no-floating-promises
                this.connection.stop(new Error(message));
            }
        }
        else {
            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Warning, "No client method with the name '" + invocationMessage.target + "' found.");
        }
    };
    HubConnection.prototype.connectionClosed = function (error) {
        var _this = this;
        var callbacks = this.callbacks;
        this.callbacks = {};
        this.connectionState = HubConnectionState.Disconnected;
        // if handshake is in progress start will be waiting for the handshake promise, so we complete it
        // if it has already completed this should just noop
        if (this.handshakeRejecter) {
            this.handshakeRejecter(error);
        }
        Object.keys(callbacks)
            .forEach(function (key) {
            var callback = callbacks[key];
            callback(null, error ? error : new Error("Invocation canceled due to connection being closed."));
        });
        this.cleanupTimeout();
        this.cleanupPingTimer();
        this.closedCallbacks.forEach(function (c) { return c.apply(_this, [error]); });
    };
    HubConnection.prototype.cleanupPingTimer = function () {
        if (this.pingServerHandle) {
            clearTimeout(this.pingServerHandle);
        }
    };
    HubConnection.prototype.cleanupTimeout = function () {
        if (this.timeoutHandle) {
            clearTimeout(this.timeoutHandle);
        }
    };
    HubConnection.prototype.createInvocation = function (methodName, args, nonblocking) {
        if (nonblocking) {
            return {
                arguments: args,
                target: methodName,
                type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Invocation,
            };
        }
        else {
            var id = this.id;
            this.id++;
            return {
                arguments: args,
                invocationId: id.toString(),
                target: methodName,
                type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Invocation,
            };
        }
    };
    HubConnection.prototype.createStreamInvocation = function (methodName, args) {
        var id = this.id;
        this.id++;
        return {
            arguments: args,
            invocationId: id.toString(),
            target: methodName,
            type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].StreamInvocation,
        };
    };
    HubConnection.prototype.createCancelInvocation = function (id) {
        return {
            invocationId: id,
            type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].CancelInvocation,
        };
    };
    return HubConnection;
}());

//# sourceMappingURL=HubConnection.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/HubConnectionBuilder.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/HubConnectionBuilder.js ***!
  \***********************************************************************/
/*! exports provided: HubConnectionBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HubConnectionBuilder", function() { return HubConnectionBuilder; });
/* harmony import */ var _HttpConnection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HttpConnection */ "./node_modules/@aspnet/signalr/dist/esm/HttpConnection.js");
/* harmony import */ var _HubConnection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HubConnection */ "./node_modules/@aspnet/signalr/dist/esm/HubConnection.js");
/* harmony import */ var _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JsonHubProtocol */ "./node_modules/@aspnet/signalr/dist/esm/JsonHubProtocol.js");
/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Loggers */ "./node_modules/@aspnet/signalr/dist/esm/Loggers.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ "./node_modules/@aspnet/signalr/dist/esm/Utils.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.





/** A builder for configuring {@link @aspnet/signalr.HubConnection} instances. */
var HubConnectionBuilder = /** @class */ (function () {
    function HubConnectionBuilder() {
    }
    HubConnectionBuilder.prototype.configureLogging = function (logging) {
        _Utils__WEBPACK_IMPORTED_MODULE_4__["Arg"].isRequired(logging, "logging");
        if (isLogger(logging)) {
            this.logger = logging;
        }
        else {
            this.logger = new _Utils__WEBPACK_IMPORTED_MODULE_4__["ConsoleLogger"](logging);
        }
        return this;
    };
    HubConnectionBuilder.prototype.withUrl = function (url, transportTypeOrOptions) {
        _Utils__WEBPACK_IMPORTED_MODULE_4__["Arg"].isRequired(url, "url");
        this.url = url;
        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed
        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.
        if (typeof transportTypeOrOptions === "object") {
            this.httpConnectionOptions = transportTypeOrOptions;
        }
        else {
            this.httpConnectionOptions = {
                transport: transportTypeOrOptions,
            };
        }
        return this;
    };
    /** Configures the {@link @aspnet/signalr.HubConnection} to use the specified Hub Protocol.
     *
     * @param {IHubProtocol} protocol The {@link @aspnet/signalr.IHubProtocol} implementation to use.
     */
    HubConnectionBuilder.prototype.withHubProtocol = function (protocol) {
        _Utils__WEBPACK_IMPORTED_MODULE_4__["Arg"].isRequired(protocol, "protocol");
        this.protocol = protocol;
        return this;
    };
    /** Creates a {@link @aspnet/signalr.HubConnection} from the configuration options specified in this builder.
     *
     * @returns {HubConnection} The configured {@link @aspnet/signalr.HubConnection}.
     */
    HubConnectionBuilder.prototype.build = function () {
        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one
        // provided to configureLogger
        var httpConnectionOptions = this.httpConnectionOptions || {};
        // If it's 'null', the user **explicitly** asked for null, don't mess with it.
        if (httpConnectionOptions.logger === undefined) {
            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.
            httpConnectionOptions.logger = this.logger;
        }
        // Now create the connection
        if (!this.url) {
            throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
        }
        var connection = new _HttpConnection__WEBPACK_IMPORTED_MODULE_0__["HttpConnection"](this.url, httpConnectionOptions);
        return _HubConnection__WEBPACK_IMPORTED_MODULE_1__["HubConnection"].create(connection, this.logger || _Loggers__WEBPACK_IMPORTED_MODULE_3__["NullLogger"].instance, this.protocol || new _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_2__["JsonHubProtocol"]());
    };
    return HubConnectionBuilder;
}());

function isLogger(logger) {
    return logger.log !== undefined;
}
//# sourceMappingURL=HubConnectionBuilder.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/IHubProtocol.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/IHubProtocol.js ***!
  \***************************************************************/
/*! exports provided: MessageType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageType", function() { return MessageType; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
/** Defines the type of a Hub Message. */
var MessageType;
(function (MessageType) {
    /** Indicates the message is an Invocation message and implements the {@link @aspnet/signalr.InvocationMessage} interface. */
    MessageType[MessageType["Invocation"] = 1] = "Invocation";
    /** Indicates the message is a StreamItem message and implements the {@link @aspnet/signalr.StreamItemMessage} interface. */
    MessageType[MessageType["StreamItem"] = 2] = "StreamItem";
    /** Indicates the message is a Completion message and implements the {@link @aspnet/signalr.CompletionMessage} interface. */
    MessageType[MessageType["Completion"] = 3] = "Completion";
    /** Indicates the message is a Stream Invocation message and implements the {@link @aspnet/signalr.StreamInvocationMessage} interface. */
    MessageType[MessageType["StreamInvocation"] = 4] = "StreamInvocation";
    /** Indicates the message is a Cancel Invocation message and implements the {@link @aspnet/signalr.CancelInvocationMessage} interface. */
    MessageType[MessageType["CancelInvocation"] = 5] = "CancelInvocation";
    /** Indicates the message is a Ping message and implements the {@link @aspnet/signalr.PingMessage} interface. */
    MessageType[MessageType["Ping"] = 6] = "Ping";
    /** Indicates the message is a Close message and implements the {@link @aspnet/signalr.CloseMessage} interface. */
    MessageType[MessageType["Close"] = 7] = "Close";
})(MessageType || (MessageType = {}));
//# sourceMappingURL=IHubProtocol.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/ILogger.js":
/*!**********************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/ILogger.js ***!
  \**********************************************************/
/*! exports provided: LogLevel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLevel", function() { return LogLevel; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.
/** Indicates the severity of a log message.
 *
 * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.
 */
var LogLevel;
(function (LogLevel) {
    /** Log level for very low severity diagnostic messages. */
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    /** Log level for low severity diagnostic messages. */
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    /** Log level for informational diagnostic messages. */
    LogLevel[LogLevel["Information"] = 2] = "Information";
    /** Log level for diagnostic messages that indicate a non-fatal problem. */
    LogLevel[LogLevel["Warning"] = 3] = "Warning";
    /** Log level for diagnostic messages that indicate a failure in the current operation. */
    LogLevel[LogLevel["Error"] = 4] = "Error";
    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */
    LogLevel[LogLevel["Critical"] = 5] = "Critical";
    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */
    LogLevel[LogLevel["None"] = 6] = "None";
})(LogLevel || (LogLevel = {}));
//# sourceMappingURL=ILogger.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/ITransport.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/ITransport.js ***!
  \*************************************************************/
/*! exports provided: HttpTransportType, TransferFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpTransportType", function() { return HttpTransportType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransferFormat", function() { return TransferFormat; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// This will be treated as a bit flag in the future, so we keep it using power-of-two values.
/** Specifies a specific HTTP transport type. */
var HttpTransportType;
(function (HttpTransportType) {
    /** Specifies no transport preference. */
    HttpTransportType[HttpTransportType["None"] = 0] = "None";
    /** Specifies the WebSockets transport. */
    HttpTransportType[HttpTransportType["WebSockets"] = 1] = "WebSockets";
    /** Specifies the Server-Sent Events transport. */
    HttpTransportType[HttpTransportType["ServerSentEvents"] = 2] = "ServerSentEvents";
    /** Specifies the Long Polling transport. */
    HttpTransportType[HttpTransportType["LongPolling"] = 4] = "LongPolling";
})(HttpTransportType || (HttpTransportType = {}));
/** Specifies the transfer format for a connection. */
var TransferFormat;
(function (TransferFormat) {
    /** Specifies that only text data will be transmitted over the connection. */
    TransferFormat[TransferFormat["Text"] = 1] = "Text";
    /** Specifies that binary data will be transmitted over the connection. */
    TransferFormat[TransferFormat["Binary"] = 2] = "Binary";
})(TransferFormat || (TransferFormat = {}));
//# sourceMappingURL=ITransport.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/JsonHubProtocol.js":
/*!******************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/JsonHubProtocol.js ***!
  \******************************************************************/
/*! exports provided: JsonHubProtocol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonHubProtocol", function() { return JsonHubProtocol; });
/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IHubProtocol */ "./node_modules/@aspnet/signalr/dist/esm/IHubProtocol.js");
/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ILogger */ "./node_modules/@aspnet/signalr/dist/esm/ILogger.js");
/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ITransport */ "./node_modules/@aspnet/signalr/dist/esm/ITransport.js");
/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Loggers */ "./node_modules/@aspnet/signalr/dist/esm/Loggers.js");
/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextMessageFormat */ "./node_modules/@aspnet/signalr/dist/esm/TextMessageFormat.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.





var JSON_HUB_PROTOCOL_NAME = "json";
/** Implements the JSON Hub Protocol. */
var JsonHubProtocol = /** @class */ (function () {
    function JsonHubProtocol() {
        /** @inheritDoc */
        this.name = JSON_HUB_PROTOCOL_NAME;
        /** @inheritDoc */
        this.version = 1;
        /** @inheritDoc */
        this.transferFormat = _ITransport__WEBPACK_IMPORTED_MODULE_2__["TransferFormat"].Text;
    }
    /** Creates an array of {@link @aspnet/signalr.HubMessage} objects from the specified serialized representation.
     *
     * @param {string} input A string containing the serialized representation.
     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.
     */
    JsonHubProtocol.prototype.parseMessages = function (input, logger) {
        // The interface does allow "ArrayBuffer" to be passed in, but this implementation does not. So let's throw a useful error.
        if (typeof input !== "string") {
            throw new Error("Invalid input for JSON hub protocol. Expected a string.");
        }
        if (!input) {
            return [];
        }
        if (logger === null) {
            logger = _Loggers__WEBPACK_IMPORTED_MODULE_3__["NullLogger"].instance;
        }
        // Parse the messages
        var messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_4__["TextMessageFormat"].parse(input);
        var hubMessages = [];
        for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
            var message = messages_1[_i];
            var parsedMessage = JSON.parse(message);
            if (typeof parsedMessage.type !== "number") {
                throw new Error("Invalid payload.");
            }
            switch (parsedMessage.type) {
                case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Invocation:
                    this.isInvocationMessage(parsedMessage);
                    break;
                case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__["MessageType"].StreamItem:
                    this.isStreamItemMessage(parsedMessage);
                    break;
                case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Completion:
                    this.isCompletionMessage(parsedMessage);
                    break;
                case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Ping:
                    // Single value, no need to validate
                    break;
                case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Close:
                    // All optional values, no need to validate
                    break;
                default:
                    // Future protocol changes can add message types, old clients can ignore them
                    logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Information, "Unknown message type '" + parsedMessage.type + "' ignored.");
                    continue;
            }
            hubMessages.push(parsedMessage);
        }
        return hubMessages;
    };
    /** Writes the specified {@link @aspnet/signalr.HubMessage} to a string and returns it.
     *
     * @param {HubMessage} message The message to write.
     * @returns {string} A string containing the serialized representation of the message.
     */
    JsonHubProtocol.prototype.writeMessage = function (message) {
        return _TextMessageFormat__WEBPACK_IMPORTED_MODULE_4__["TextMessageFormat"].write(JSON.stringify(message));
    };
    JsonHubProtocol.prototype.isInvocationMessage = function (message) {
        this.assertNotEmptyString(message.target, "Invalid payload for Invocation message.");
        if (message.invocationId !== undefined) {
            this.assertNotEmptyString(message.invocationId, "Invalid payload for Invocation message.");
        }
    };
    JsonHubProtocol.prototype.isStreamItemMessage = function (message) {
        this.assertNotEmptyString(message.invocationId, "Invalid payload for StreamItem message.");
        if (message.item === undefined) {
            throw new Error("Invalid payload for StreamItem message.");
        }
    };
    JsonHubProtocol.prototype.isCompletionMessage = function (message) {
        if (message.result && message.error) {
            throw new Error("Invalid payload for Completion message.");
        }
        if (!message.result && message.error) {
            this.assertNotEmptyString(message.error, "Invalid payload for Completion message.");
        }
        this.assertNotEmptyString(message.invocationId, "Invalid payload for Completion message.");
    };
    JsonHubProtocol.prototype.assertNotEmptyString = function (value, errorMessage) {
        if (typeof value !== "string" || value === "") {
            throw new Error(errorMessage);
        }
    };
    return JsonHubProtocol;
}());

//# sourceMappingURL=JsonHubProtocol.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/Loggers.js":
/*!**********************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/Loggers.js ***!
  \**********************************************************/
/*! exports provided: NullLogger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NullLogger", function() { return NullLogger; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
/** A logger that does nothing when log messages are sent to it. */
var NullLogger = /** @class */ (function () {
    function NullLogger() {
    }
    /** @inheritDoc */
    // tslint:disable-next-line
    NullLogger.prototype.log = function (_logLevel, _message) {
    };
    /** The singleton instance of the {@link @aspnet/signalr.NullLogger}. */
    NullLogger.instance = new NullLogger();
    return NullLogger;
}());

//# sourceMappingURL=Loggers.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/LongPollingTransport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/LongPollingTransport.js ***!
  \***********************************************************************/
/*! exports provided: LongPollingTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LongPollingTransport", function() { return LongPollingTransport; });
/* harmony import */ var _AbortController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbortController */ "./node_modules/@aspnet/signalr/dist/esm/AbortController.js");
/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Errors */ "./node_modules/@aspnet/signalr/dist/esm/Errors.js");
/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ "./node_modules/@aspnet/signalr/dist/esm/ILogger.js");
/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ITransport */ "./node_modules/@aspnet/signalr/dist/esm/ITransport.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ "./node_modules/@aspnet/signalr/dist/esm/Utils.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};





// Not exported from 'index', this type is internal.
/** @private */
var LongPollingTransport = /** @class */ (function () {
    function LongPollingTransport(httpClient, accessTokenFactory, logger, logMessageContent) {
        this.httpClient = httpClient;
        this.accessTokenFactory = accessTokenFactory;
        this.logger = logger;
        this.pollAbort = new _AbortController__WEBPACK_IMPORTED_MODULE_0__["AbortController"]();
        this.logMessageContent = logMessageContent;
        this.running = false;
        this.onreceive = null;
        this.onclose = null;
    }
    Object.defineProperty(LongPollingTransport.prototype, "pollAborted", {
        // This is an internal type, not exported from 'index' so this is really just internal.
        get: function () {
            return this.pollAbort.aborted;
        },
        enumerable: true,
        configurable: true
    });
    LongPollingTransport.prototype.connect = function (url, transferFormat) {
        return __awaiter(this, void 0, void 0, function () {
            var pollOptions, token, pollUrl, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _Utils__WEBPACK_IMPORTED_MODULE_4__["Arg"].isRequired(url, "url");
                        _Utils__WEBPACK_IMPORTED_MODULE_4__["Arg"].isRequired(transferFormat, "transferFormat");
                        _Utils__WEBPACK_IMPORTED_MODULE_4__["Arg"].isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_3__["TransferFormat"], "transferFormat");
                        this.url = url;
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) Connecting.");
                        // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)
                        if (transferFormat === _ITransport__WEBPACK_IMPORTED_MODULE_3__["TransferFormat"].Binary &&
                            (typeof XMLHttpRequest !== "undefined" && typeof new XMLHttpRequest().responseType !== "string")) {
                            throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
                        }
                        pollOptions = {
                            abortSignal: this.pollAbort.signal,
                            headers: {},
                            timeout: 100000,
                        };
                        if (transferFormat === _ITransport__WEBPACK_IMPORTED_MODULE_3__["TransferFormat"].Binary) {
                            pollOptions.responseType = "arraybuffer";
                        }
                        return [4 /*yield*/, this.getAccessToken()];
                    case 1:
                        token = _a.sent();
                        this.updateHeaderToken(pollOptions, token);
                        pollUrl = url + "&_=" + Date.now();
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) polling: " + pollUrl + ".");
                        return [4 /*yield*/, this.httpClient.get(pollUrl, pollOptions)];
                    case 2:
                        response = _a.sent();
                        if (response.statusCode !== 200) {
                            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + ".");
                            // Mark running as false so that the poll immediately ends and runs the close logic
                            this.closeError = new _Errors__WEBPACK_IMPORTED_MODULE_1__["HttpError"](response.statusText || "", response.statusCode);
                            this.running = false;
                        }
                        else {
                            this.running = true;
                        }
                        this.receiving = this.poll(this.url, pollOptions);
                        return [2 /*return*/];
                }
            });
        });
    };
    LongPollingTransport.prototype.getAccessToken = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.accessTokenFactory) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.accessTokenFactory()];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/, null];
                }
            });
        });
    };
    LongPollingTransport.prototype.updateHeaderToken = function (request, token) {
        if (!request.headers) {
            request.headers = {};
        }
        if (token) {
            // tslint:disable-next-line:no-string-literal
            request.headers["Authorization"] = "Bearer " + token;
            return;
        }
        // tslint:disable-next-line:no-string-literal
        if (request.headers["Authorization"]) {
            // tslint:disable-next-line:no-string-literal
            delete request.headers["Authorization"];
        }
    };
    LongPollingTransport.prototype.poll = function (url, pollOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var token, pollUrl, response, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, , 8, 9]);
                        _a.label = 1;
                    case 1:
                        if (!this.running) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.getAccessToken()];
                    case 2:
                        token = _a.sent();
                        this.updateHeaderToken(pollOptions, token);
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        pollUrl = url + "&_=" + Date.now();
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) polling: " + pollUrl + ".");
                        return [4 /*yield*/, this.httpClient.get(pollUrl, pollOptions)];
                    case 4:
                        response = _a.sent();
                        if (response.statusCode === 204) {
                            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Information, "(LongPolling transport) Poll terminated by server.");
                            this.running = false;
                        }
                        else if (response.statusCode !== 200) {
                            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + ".");
                            // Unexpected status code
                            this.closeError = new _Errors__WEBPACK_IMPORTED_MODULE_1__["HttpError"](response.statusText || "", response.statusCode);
                            this.running = false;
                        }
                        else {
                            // Process the response
                            if (response.content) {
                                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) data received. " + Object(_Utils__WEBPACK_IMPORTED_MODULE_4__["getDataDetail"])(response.content, this.logMessageContent) + ".");
                                if (this.onreceive) {
                                    this.onreceive(response.content);
                                }
                            }
                            else {
                                // This is another way timeout manifest.
                                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) Poll timed out, reissuing.");
                            }
                        }
                        return [3 /*break*/, 6];
                    case 5:
                        e_1 = _a.sent();
                        if (!this.running) {
                            // Log but disregard errors that occur after stopping
                            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) Poll errored after shutdown: " + e_1.message);
                        }
                        else {
                            if (e_1 instanceof _Errors__WEBPACK_IMPORTED_MODULE_1__["TimeoutError"]) {
                                // Ignore timeouts and reissue the poll.
                                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) Poll timed out, reissuing.");
                            }
                            else {
                                // Close the connection with the error as the result.
                                this.closeError = e_1;
                                this.running = false;
                            }
                        }
                        return [3 /*break*/, 6];
                    case 6: return [3 /*break*/, 1];
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) Polling complete.");
                        // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.
                        // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.
                        if (!this.pollAborted) {
                            this.raiseOnClose();
                        }
                        return [7 /*endfinally*/];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    LongPollingTransport.prototype.send = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!this.running) {
                    return [2 /*return*/, Promise.reject(new Error("Cannot send until the transport is connected"))];
                }
                return [2 /*return*/, Object(_Utils__WEBPACK_IMPORTED_MODULE_4__["sendMessage"])(this.logger, "LongPolling", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent)];
            });
        });
    };
    LongPollingTransport.prototype.stop = function () {
        return __awaiter(this, void 0, void 0, function () {
            var deleteOptions, token;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) Stopping polling.");
                        // Tell receiving loop to stop, abort any current request, and then wait for it to finish
                        this.running = false;
                        this.pollAbort.abort();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 5, 6]);
                        return [4 /*yield*/, this.receiving];
                    case 2:
                        _a.sent();
                        // Send DELETE to clean up long polling on the server
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) sending DELETE request to " + this.url + ".");
                        deleteOptions = {
                            headers: {},
                        };
                        return [4 /*yield*/, this.getAccessToken()];
                    case 3:
                        token = _a.sent();
                        this.updateHeaderToken(deleteOptions, token);
                        return [4 /*yield*/, this.httpClient.delete(this.url, deleteOptions)];
                    case 4:
                        _a.sent();
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) DELETE request sent.");
                        return [3 /*break*/, 6];
                    case 5:
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, "(LongPolling transport) Stop finished.");
                        // Raise close event here instead of in polling
                        // It needs to happen after the DELETE request is sent
                        this.raiseOnClose();
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    LongPollingTransport.prototype.raiseOnClose = function () {
        if (this.onclose) {
            var logMessage = "(LongPolling transport) Firing onclose event.";
            if (this.closeError) {
                logMessage += " Error: " + this.closeError;
            }
            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Trace, logMessage);
            this.onclose(this.closeError);
        }
    };
    return LongPollingTransport;
}());

//# sourceMappingURL=LongPollingTransport.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/ServerSentEventsTransport.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/ServerSentEventsTransport.js ***!
  \****************************************************************************/
/*! exports provided: ServerSentEventsTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ServerSentEventsTransport", function() { return ServerSentEventsTransport; });
/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ "./node_modules/@aspnet/signalr/dist/esm/ILogger.js");
/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ITransport */ "./node_modules/@aspnet/signalr/dist/esm/ITransport.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./node_modules/@aspnet/signalr/dist/esm/Utils.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



/** @private */
var ServerSentEventsTransport = /** @class */ (function () {
    function ServerSentEventsTransport(httpClient, accessTokenFactory, logger, logMessageContent, eventSourceConstructor) {
        this.httpClient = httpClient;
        this.accessTokenFactory = accessTokenFactory;
        this.logger = logger;
        this.logMessageContent = logMessageContent;
        this.eventSourceConstructor = eventSourceConstructor;
        this.onreceive = null;
        this.onclose = null;
    }
    ServerSentEventsTransport.prototype.connect = function (url, transferFormat) {
        return __awaiter(this, void 0, void 0, function () {
            var token;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _Utils__WEBPACK_IMPORTED_MODULE_2__["Arg"].isRequired(url, "url");
                        _Utils__WEBPACK_IMPORTED_MODULE_2__["Arg"].isRequired(transferFormat, "transferFormat");
                        _Utils__WEBPACK_IMPORTED_MODULE_2__["Arg"].isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_1__["TransferFormat"], "transferFormat");
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, "(SSE transport) Connecting.");
                        // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send
                        this.url = url;
                        if (!this.accessTokenFactory) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.accessTokenFactory()];
                    case 1:
                        token = _a.sent();
                        if (token) {
                            url += (url.indexOf("?") < 0 ? "?" : "&") + ("access_token=" + encodeURIComponent(token));
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/, new Promise(function (resolve, reject) {
                            var opened = false;
                            if (transferFormat !== _ITransport__WEBPACK_IMPORTED_MODULE_1__["TransferFormat"].Text) {
                                reject(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
                                return;
                            }
                            var eventSource;
                            if (typeof window !== "undefined") {
                                eventSource = new _this.eventSourceConstructor(url, { withCredentials: true });
                            }
                            else {
                                // Non-browser passes cookies via the dictionary
                                var cookies = _this.httpClient.getCookieString(url);
                                eventSource = new _this.eventSourceConstructor(url, { withCredentials: true, headers: { Cookie: cookies } });
                            }
                            try {
                                eventSource.onmessage = function (e) {
                                    if (_this.onreceive) {
                                        try {
                                            _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, "(SSE transport) data received. " + Object(_Utils__WEBPACK_IMPORTED_MODULE_2__["getDataDetail"])(e.data, _this.logMessageContent) + ".");
                                            _this.onreceive(e.data);
                                        }
                                        catch (error) {
                                            _this.close(error);
                                            return;
                                        }
                                    }
                                };
                                eventSource.onerror = function (e) {
                                    var error = new Error(e.data || "Error occurred");
                                    if (opened) {
                                        _this.close(error);
                                    }
                                    else {
                                        reject(error);
                                    }
                                };
                                eventSource.onopen = function () {
                                    _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Information, "SSE connected to " + _this.url);
                                    _this.eventSource = eventSource;
                                    opened = true;
                                    resolve();
                                };
                            }
                            catch (e) {
                                reject(e);
                                return;
                            }
                        })];
                }
            });
        });
    };
    ServerSentEventsTransport.prototype.send = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!this.eventSource) {
                    return [2 /*return*/, Promise.reject(new Error("Cannot send until the transport is connected"))];
                }
                return [2 /*return*/, Object(_Utils__WEBPACK_IMPORTED_MODULE_2__["sendMessage"])(this.logger, "SSE", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent)];
            });
        });
    };
    ServerSentEventsTransport.prototype.stop = function () {
        this.close();
        return Promise.resolve();
    };
    ServerSentEventsTransport.prototype.close = function (e) {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = undefined;
            if (this.onclose) {
                this.onclose(e);
            }
        }
    };
    return ServerSentEventsTransport;
}());

//# sourceMappingURL=ServerSentEventsTransport.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/TextMessageFormat.js":
/*!********************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/TextMessageFormat.js ***!
  \********************************************************************/
/*! exports provided: TextMessageFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextMessageFormat", function() { return TextMessageFormat; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// Not exported from index
/** @private */
var TextMessageFormat = /** @class */ (function () {
    function TextMessageFormat() {
    }
    TextMessageFormat.write = function (output) {
        return "" + output + TextMessageFormat.RecordSeparator;
    };
    TextMessageFormat.parse = function (input) {
        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {
            throw new Error("Message is incomplete.");
        }
        var messages = input.split(TextMessageFormat.RecordSeparator);
        messages.pop();
        return messages;
    };
    TextMessageFormat.RecordSeparatorCode = 0x1e;
    TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);
    return TextMessageFormat;
}());

//# sourceMappingURL=TextMessageFormat.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/Utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/Utils.js ***!
  \********************************************************/
/*! exports provided: Arg, getDataDetail, formatArrayBuffer, isArrayBuffer, sendMessage, createLogger, Subject, SubjectSubscription, ConsoleLogger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Arg", function() { return Arg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDataDetail", function() { return getDataDetail; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatArrayBuffer", function() { return formatArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return isArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sendMessage", function() { return sendMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLogger", function() { return createLogger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Subject", function() { return Subject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubjectSubscription", function() { return SubjectSubscription; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleLogger", function() { return ConsoleLogger; });
/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ "./node_modules/@aspnet/signalr/dist/esm/ILogger.js");
/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loggers */ "./node_modules/@aspnet/signalr/dist/esm/Loggers.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


/** @private */
var Arg = /** @class */ (function () {
    function Arg() {
    }
    Arg.isRequired = function (val, name) {
        if (val === null || val === undefined) {
            throw new Error("The '" + name + "' argument is required.");
        }
    };
    Arg.isIn = function (val, values, name) {
        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.
        if (!(val in values)) {
            throw new Error("Unknown " + name + " value: " + val + ".");
        }
    };
    return Arg;
}());

/** @private */
function getDataDetail(data, includeContent) {
    var detail = "";
    if (isArrayBuffer(data)) {
        detail = "Binary data of length " + data.byteLength;
        if (includeContent) {
            detail += ". Content: '" + formatArrayBuffer(data) + "'";
        }
    }
    else if (typeof data === "string") {
        detail = "String data of length " + data.length;
        if (includeContent) {
            detail += ". Content: '" + data + "'";
        }
    }
    return detail;
}
/** @private */
function formatArrayBuffer(data) {
    var view = new Uint8Array(data);
    // Uint8Array.map only supports returning another Uint8Array?
    var str = "";
    view.forEach(function (num) {
        var pad = num < 16 ? "0" : "";
        str += "0x" + pad + num.toString(16) + " ";
    });
    // Trim of trailing space.
    return str.substr(0, str.length - 1);
}
// Also in signalr-protocol-msgpack/Utils.ts
/** @private */
function isArrayBuffer(val) {
    return val && typeof ArrayBuffer !== "undefined" &&
        (val instanceof ArrayBuffer ||
            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof
            (val.constructor && val.constructor.name === "ArrayBuffer"));
}
/** @private */
function sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, logMessageContent) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, headers, token, responseType, response;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!accessTokenFactory) return [3 /*break*/, 2];
                    return [4 /*yield*/, accessTokenFactory()];
                case 1:
                    token = _b.sent();
                    if (token) {
                        headers = (_a = {},
                            _a["Authorization"] = "Bearer " + token,
                            _a);
                    }
                    _b.label = 2;
                case 2:
                    logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, "(" + transportName + " transport) sending data. " + getDataDetail(content, logMessageContent) + ".");
                    responseType = isArrayBuffer(content) ? "arraybuffer" : "text";
                    return [4 /*yield*/, httpClient.post(url, {
                            content: content,
                            headers: headers,
                            responseType: responseType,
                        })];
                case 3:
                    response = _b.sent();
                    logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, "(" + transportName + " transport) request complete. Response status: " + response.statusCode + ".");
                    return [2 /*return*/];
            }
        });
    });
}
/** @private */
function createLogger(logger) {
    if (logger === undefined) {
        return new ConsoleLogger(_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Information);
    }
    if (logger === null) {
        return _Loggers__WEBPACK_IMPORTED_MODULE_1__["NullLogger"].instance;
    }
    if (logger.log) {
        return logger;
    }
    return new ConsoleLogger(logger);
}
/** @private */
var Subject = /** @class */ (function () {
    function Subject(cancelCallback) {
        this.observers = [];
        this.cancelCallback = cancelCallback;
    }
    Subject.prototype.next = function (item) {
        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
            var observer = _a[_i];
            observer.next(item);
        }
    };
    Subject.prototype.error = function (err) {
        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
            var observer = _a[_i];
            if (observer.error) {
                observer.error(err);
            }
        }
    };
    Subject.prototype.complete = function () {
        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
            var observer = _a[_i];
            if (observer.complete) {
                observer.complete();
            }
        }
    };
    Subject.prototype.subscribe = function (observer) {
        this.observers.push(observer);
        return new SubjectSubscription(this, observer);
    };
    return Subject;
}());

/** @private */
var SubjectSubscription = /** @class */ (function () {
    function SubjectSubscription(subject, observer) {
        this.subject = subject;
        this.observer = observer;
    }
    SubjectSubscription.prototype.dispose = function () {
        var index = this.subject.observers.indexOf(this.observer);
        if (index > -1) {
            this.subject.observers.splice(index, 1);
        }
        if (this.subject.observers.length === 0) {
            this.subject.cancelCallback().catch(function (_) { });
        }
    };
    return SubjectSubscription;
}());

/** @private */
var ConsoleLogger = /** @class */ (function () {
    function ConsoleLogger(minimumLogLevel) {
        this.minimumLogLevel = minimumLogLevel;
    }
    ConsoleLogger.prototype.log = function (logLevel, message) {
        if (logLevel >= this.minimumLogLevel) {
            switch (logLevel) {
                case _ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Critical:
                case _ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Error:
                    console.error("[" + new Date().toISOString() + "] " + _ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"][logLevel] + ": " + message);
                    break;
                case _ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Warning:
                    console.warn("[" + new Date().toISOString() + "] " + _ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"][logLevel] + ": " + message);
                    break;
                case _ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Information:
                    console.info("[" + new Date().toISOString() + "] " + _ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"][logLevel] + ": " + message);
                    break;
                default:
                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug
                    console.log("[" + new Date().toISOString() + "] " + _ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"][logLevel] + ": " + message);
                    break;
            }
        }
    };
    return ConsoleLogger;
}());

//# sourceMappingURL=Utils.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/WebSocketTransport.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/WebSocketTransport.js ***!
  \*********************************************************************/
/*! exports provided: WebSocketTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebSocketTransport", function() { return WebSocketTransport; });
/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ "./node_modules/@aspnet/signalr/dist/esm/ILogger.js");
/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ITransport */ "./node_modules/@aspnet/signalr/dist/esm/ITransport.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./node_modules/@aspnet/signalr/dist/esm/Utils.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



/** @private */
var WebSocketTransport = /** @class */ (function () {
    function WebSocketTransport(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor) {
        this.logger = logger;
        this.accessTokenFactory = accessTokenFactory;
        this.logMessageContent = logMessageContent;
        this.webSocketConstructor = webSocketConstructor;
        this.httpClient = httpClient;
        this.onreceive = null;
        this.onclose = null;
    }
    WebSocketTransport.prototype.connect = function (url, transferFormat) {
        return __awaiter(this, void 0, void 0, function () {
            var token;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _Utils__WEBPACK_IMPORTED_MODULE_2__["Arg"].isRequired(url, "url");
                        _Utils__WEBPACK_IMPORTED_MODULE_2__["Arg"].isRequired(transferFormat, "transferFormat");
                        _Utils__WEBPACK_IMPORTED_MODULE_2__["Arg"].isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_1__["TransferFormat"], "transferFormat");
                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, "(WebSockets transport) Connecting.");
                        if (!this.accessTokenFactory) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.accessTokenFactory()];
                    case 1:
                        token = _a.sent();
                        if (token) {
                            url += (url.indexOf("?") < 0 ? "?" : "&") + ("access_token=" + encodeURIComponent(token));
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/, new Promise(function (resolve, reject) {
                            url = url.replace(/^http/, "ws");
                            var webSocket;
                            var cookies = _this.httpClient.getCookieString(url);
                            if (typeof window === "undefined" && cookies) {
                                // Only pass cookies when in non-browser environments
                                webSocket = new _this.webSocketConstructor(url, undefined, {
                                    headers: {
                                        Cookie: "" + cookies,
                                    },
                                });
                            }
                            if (!webSocket) {
                                // Chrome is not happy with passing 'undefined' as protocol
                                webSocket = new _this.webSocketConstructor(url);
                            }
                            if (transferFormat === _ITransport__WEBPACK_IMPORTED_MODULE_1__["TransferFormat"].Binary) {
                                webSocket.binaryType = "arraybuffer";
                            }
                            // tslint:disable-next-line:variable-name
                            webSocket.onopen = function (_event) {
                                _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Information, "WebSocket connected to " + url + ".");
                                _this.webSocket = webSocket;
                                resolve();
                            };
                            webSocket.onerror = function (event) {
                                var error = null;
                                // ErrorEvent is a browser only type we need to check if the type exists before using it
                                if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                                    error = event.error;
                                }
                                reject(error);
                            };
                            webSocket.onmessage = function (message) {
                                _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, "(WebSockets transport) data received. " + Object(_Utils__WEBPACK_IMPORTED_MODULE_2__["getDataDetail"])(message.data, _this.logMessageContent) + ".");
                                if (_this.onreceive) {
                                    _this.onreceive(message.data);
                                }
                            };
                            webSocket.onclose = function (event) { return _this.close(event); };
                        })];
                }
            });
        });
    };
    WebSocketTransport.prototype.send = function (data) {
        if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {
            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, "(WebSockets transport) sending data. " + Object(_Utils__WEBPACK_IMPORTED_MODULE_2__["getDataDetail"])(data, this.logMessageContent) + ".");
            this.webSocket.send(data);
            return Promise.resolve();
        }
        return Promise.reject("WebSocket is not in the OPEN state");
    };
    WebSocketTransport.prototype.stop = function () {
        if (this.webSocket) {
            // Clear websocket handlers because we are considering the socket closed now
            this.webSocket.onclose = function () { };
            this.webSocket.onmessage = function () { };
            this.webSocket.onerror = function () { };
            this.webSocket.close();
            this.webSocket = undefined;
            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning
            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects
            this.close(undefined);
        }
        return Promise.resolve();
    };
    WebSocketTransport.prototype.close = function (event) {
        // webSocket will be null if the transport did not start successfully
        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, "(WebSockets transport) socket closed.");
        if (this.onclose) {
            if (event && (event.wasClean === false || event.code !== 1000)) {
                this.onclose(new Error("WebSocket closed with status code: " + event.code + " (" + event.reason + ")."));
            }
            else {
                this.onclose();
            }
        }
    };
    return WebSocketTransport;
}());

//# sourceMappingURL=WebSocketTransport.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/XhrHttpClient.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/XhrHttpClient.js ***!
  \****************************************************************/
/*! exports provided: XhrHttpClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XhrHttpClient", function() { return XhrHttpClient; });
/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ "./node_modules/@aspnet/signalr/dist/esm/Errors.js");
/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ "./node_modules/@aspnet/signalr/dist/esm/HttpClient.js");
/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ "./node_modules/@aspnet/signalr/dist/esm/ILogger.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var XhrHttpClient = /** @class */ (function (_super) {
    __extends(XhrHttpClient, _super);
    function XhrHttpClient(logger) {
        var _this = _super.call(this) || this;
        _this.logger = logger;
        return _this;
    }
    /** @inheritDoc */
    XhrHttpClient.prototype.send = function (request) {
        var _this = this;
        // Check that abort was not signaled before calling send
        if (request.abortSignal && request.abortSignal.aborted) {
            return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__["AbortError"]());
        }
        if (!request.method) {
            return Promise.reject(new Error("No method defined."));
        }
        if (!request.url) {
            return Promise.reject(new Error("No url defined."));
        }
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open(request.method, request.url, true);
            xhr.withCredentials = true;
            xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            // Explicitly setting the Content-Type header for React Native on Android platform.
            xhr.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
            var headers = request.headers;
            if (headers) {
                Object.keys(headers)
                    .forEach(function (header) {
                    xhr.setRequestHeader(header, headers[header]);
                });
            }
            if (request.responseType) {
                xhr.responseType = request.responseType;
            }
            if (request.abortSignal) {
                request.abortSignal.onabort = function () {
                    xhr.abort();
                    reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__["AbortError"]());
                };
            }
            if (request.timeout) {
                xhr.timeout = request.timeout;
            }
            xhr.onload = function () {
                if (request.abortSignal) {
                    request.abortSignal.onabort = null;
                }
                if (xhr.status >= 200 && xhr.status < 300) {
                    resolve(new _HttpClient__WEBPACK_IMPORTED_MODULE_1__["HttpResponse"](xhr.status, xhr.statusText, xhr.response || xhr.responseText));
                }
                else {
                    reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__["HttpError"](xhr.statusText, xhr.status));
                }
            };
            xhr.onerror = function () {
                _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Warning, "Error from HTTP request. " + xhr.status + ": " + xhr.statusText + ".");
                reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__["HttpError"](xhr.statusText, xhr.status));
            };
            xhr.ontimeout = function () {
                _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Warning, "Timeout from HTTP request.");
                reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__["TimeoutError"]());
            };
            xhr.send(request.content || "");
        });
    };
    return XhrHttpClient;
}(_HttpClient__WEBPACK_IMPORTED_MODULE_1__["HttpClient"]));

//# sourceMappingURL=XhrHttpClient.js.map

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/index.js ***!
  \********************************************************/
/*! exports provided: VERSION, AbortError, HttpError, TimeoutError, HttpClient, HttpResponse, DefaultHttpClient, HubConnection, HubConnectionState, HubConnectionBuilder, MessageType, LogLevel, HttpTransportType, TransferFormat, NullLogger, JsonHubProtocol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ "./node_modules/@aspnet/signalr/dist/esm/Errors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AbortError", function() { return _Errors__WEBPACK_IMPORTED_MODULE_0__["AbortError"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpError", function() { return _Errors__WEBPACK_IMPORTED_MODULE_0__["HttpError"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeoutError", function() { return _Errors__WEBPACK_IMPORTED_MODULE_0__["TimeoutError"]; });

/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ "./node_modules/@aspnet/signalr/dist/esm/HttpClient.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpClient", function() { return _HttpClient__WEBPACK_IMPORTED_MODULE_1__["HttpClient"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpResponse", function() { return _HttpClient__WEBPACK_IMPORTED_MODULE_1__["HttpResponse"]; });

/* harmony import */ var _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DefaultHttpClient */ "./node_modules/@aspnet/signalr/dist/esm/DefaultHttpClient.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultHttpClient", function() { return _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_2__["DefaultHttpClient"]; });

/* harmony import */ var _HubConnection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HubConnection */ "./node_modules/@aspnet/signalr/dist/esm/HubConnection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HubConnection", function() { return _HubConnection__WEBPACK_IMPORTED_MODULE_3__["HubConnection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HubConnectionState", function() { return _HubConnection__WEBPACK_IMPORTED_MODULE_3__["HubConnectionState"]; });

/* harmony import */ var _HubConnectionBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HubConnectionBuilder */ "./node_modules/@aspnet/signalr/dist/esm/HubConnectionBuilder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HubConnectionBuilder", function() { return _HubConnectionBuilder__WEBPACK_IMPORTED_MODULE_4__["HubConnectionBuilder"]; });

/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IHubProtocol */ "./node_modules/@aspnet/signalr/dist/esm/IHubProtocol.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MessageType", function() { return _IHubProtocol__WEBPACK_IMPORTED_MODULE_5__["MessageType"]; });

/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ILogger */ "./node_modules/@aspnet/signalr/dist/esm/ILogger.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LogLevel", function() { return _ILogger__WEBPACK_IMPORTED_MODULE_6__["LogLevel"]; });

/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ITransport */ "./node_modules/@aspnet/signalr/dist/esm/ITransport.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpTransportType", function() { return _ITransport__WEBPACK_IMPORTED_MODULE_7__["HttpTransportType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransferFormat", function() { return _ITransport__WEBPACK_IMPORTED_MODULE_7__["TransferFormat"]; });

/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Loggers */ "./node_modules/@aspnet/signalr/dist/esm/Loggers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NullLogger", function() { return _Loggers__WEBPACK_IMPORTED_MODULE_8__["NullLogger"]; });

/* harmony import */ var _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./JsonHubProtocol */ "./node_modules/@aspnet/signalr/dist/esm/JsonHubProtocol.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JsonHubProtocol", function() { return _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_9__["JsonHubProtocol"]; });

// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// Version token that will be replaced by the prepack command
/** The version of the SignalR client. */
var VERSION = "1.1.0";










//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/ansi-html/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ansi-html/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),

/***/ "./node_modules/ansi-regex/index.js":
/*!******************************************!*\
  !*** ./node_modules/ansi-regex/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/buffer/node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/buffer/node_modules/isarray/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/buffer/node_modules/isarray/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/html-entities/index.js":
/*!*********************************************!*\
  !*** ./node_modules/html-entities/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(/*! ./lib/xml-entities.js */ "./node_modules/html-entities/lib/xml-entities.js"),
  Html4Entities: __webpack_require__(/*! ./lib/html4-entities.js */ "./node_modules/html-entities/lib/html4-entities.js"),
  Html5Entities: __webpack_require__(/*! ./lib/html5-entities.js */ "./node_modules/html-entities/lib/html5-entities.js"),
  AllHtmlEntities: __webpack_require__(/*! ./lib/html5-entities.js */ "./node_modules/html-entities/lib/html5-entities.js")
};


/***/ }),

/***/ "./node_modules/html-entities/lib/html4-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html4-entities.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),

/***/ "./node_modules/html-entities/lib/html5-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html5-entities.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),

/***/ "./node_modules/html-entities/lib/xml-entities.js":
/*!********************************************************!*\
  !*** ./node_modules/html-entities/lib/xml-entities.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/konva/konva.js":
/*!*************************************!*\
  !*** ./node_modules/konva/konva.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*
 * Konva JavaScript Framework v2.5.1
 * http://konvajs.github.io/
 * Licensed under the MIT
 * Date: Thu Nov 08 2018
 *
 * Original work Copyright (C) 2011 - 2013 by Eric Rowell (KineticJS)
 * Modified work Copyright (C) 2014 - present by Anton Lavrenov (Konva)
 *
 * @license
 */

// runtime check for already included Konva
(function() {
  'use strict';
  /**
   * @namespace Konva
   */

  var PI_OVER_180 = Math.PI / 180;

  var Konva = {
    // public
    version: '2.5.1',

    // private
    stages: [],
    idCounter: 0,
    ids: {},
    names: {},
    shapes: {},
    listenClickTap: false,
    inDblClickWindow: false,

    isBrowser:
      typeof window !== 'undefined' &&
      // browser case
      ({}.toString.call(window) === '[object Window]' ||
        // electron case
        {}.toString.call(window) === '[object global]'),

    isUnminified: /comment/.test(function() {
      /* comment */
    }),

    // configurations
    enableTrace: false,
    traceArrMax: 100,
    dblClickWindow: 400,
    /**
     * Global pixel ratio configuration. KonvaJS automatically detect pixel ratio of current device.
     * But you may override such property, if you want to use your value.
     * @property pixelRatio
     * @default undefined
     * @memberof Konva
     * @example
     * Konva.pixelRatio = 1;
     */
    pixelRatio: undefined,
    /**
     * Drag distance property. If you start to drag a node you may want to wait until pointer is moved to some distance from start point,
     * only then start dragging. Default is 3px.
     * @property dragDistance
     * @default 0
     * @memberof Konva
     * @example
     * Konva.dragDistance = 10;
     */
    dragDistance: 3,
    /**
     * Use degree values for angle properties. You may set this property to false if you want to use radiant values.
     * @property angleDeg
     * @default true
     * @memberof Konva
     * @example
     * node.rotation(45); // 45 degrees
     * Konva.angleDeg = false;
     * node.rotation(Math.PI / 2); // PI/2 radian
     */
    angleDeg: true,
    /**
     * Show different warnings about errors or wrong API usage
     * @property showWarnings
     * @default true
     * @memberof Konva
     * @example
     * Konva.showWarnings = false;
     */
    showWarnings: true,

    /**
     * @namespace Filters
     * @memberof Konva
     */
    Filters: {},

    /**
     * returns whether or not drag and drop is currently active
     * @method
     * @memberof Konva
     */
    isDragging: function() {
      var dd = Konva.DD;

      // if DD is not included with the build, then
      // drag and drop is not even possible
      if (dd) {
        return dd.isDragging;
      }
      return false;
    },
    /**
     * returns whether or not a drag and drop operation is ready, but may
     *  not necessarily have started
     * @method
     * @memberof Konva
     */
    isDragReady: function() {
      var dd = Konva.DD;

      // if DD is not included with the build, then
      // drag and drop is not even possible
      if (dd) {
        return !!dd.node;
      }
      return false;
    },
    _addId: function(node, id) {
      if (!id) {
        return;
      }
      // do we need this warning?
      // if (this.ids[id]) {
      //   Konva.Util.warn(
      //     'Duplicate id "' +
      //       id +
      //       '". Please don not use same id several times. It may break find() method look up.'
      //   );
      // }
      this.ids[id] = node;
    },
    _removeId: function(id) {
      if (id !== undefined) {
        delete this.ids[id];
      }
    },
    _addName: function(node, name) {
      if (name) {
        if (!this.names[name]) {
          this.names[name] = [];
        }
        this.names[name].push(node);
      }
    },
    _removeName: function(name, _id) {
      if (!name) {
        return;
      }
      var nodes = this.names[name];
      if (!nodes) {
        return;
      }
      for (var n = 0; n < nodes.length; n++) {
        var no = nodes[n];
        if (no._id === _id) {
          nodes.splice(n, 1);
        }
      }
      if (nodes.length === 0) {
        delete this.names[name];
      }
    },
    getAngle: function(angle) {
      return this.angleDeg ? angle * PI_OVER_180 : angle;
    },
    _detectIE: function(ua) {
      var msie = ua.indexOf('msie ');
      if (msie > 0) {
        // IE 10 or older => return version number
        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
      }

      var trident = ua.indexOf('trident/');
      if (trident > 0) {
        // IE 11 => return version number
        var rv = ua.indexOf('rv:');
        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
      }

      var edge = ua.indexOf('edge/');
      if (edge > 0) {
        // Edge (IE 12+) => return version number
        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
      }

      // other browser
      return false;
    },
    _parseUA: function(userAgent) {
      var ua = userAgent.toLowerCase(),
        // jQuery UA regex
        match =
          /(chrome)[ /]([\w.]+)/.exec(ua) ||
          /(webkit)[ /]([\w.]+)/.exec(ua) ||
          /(opera)(?:.*version|)[ /]([\w.]+)/.exec(ua) ||
          /(msie) ([\w.]+)/.exec(ua) ||
          (ua.indexOf('compatible') < 0 &&
            /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua)) ||
          [],
        // adding mobile flag as well
        mobile = !!userAgent.match(
          /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i
        ),
        ieMobile = !!userAgent.match(/IEMobile/i);

      return {
        browser: match[1] || '',
        version: match[2] || '0',
        isIE: Konva._detectIE(ua),
        // adding mobile flab
        mobile: mobile,
        ieMobile: ieMobile // If this is true (i.e., WP8), then Konva touch events are executed instead of equivalent Konva mouse events
      };
    },
    // user agent
    UA: undefined
  };

  var glob =
    typeof global !== 'undefined'
      ? global
      : typeof window !== 'undefined'
        ? window
        : typeof WorkerGlobalScope !== 'undefined'
          ? self
          : {};

  Konva.UA = Konva._parseUA((glob.navigator && glob.navigator.userAgent) || '');

  if (glob.Konva) {
    console.error(
      'Konva instance is already exist in current eviroment. ' +
        'Please use only one instance.'
    );
  }
  glob.Konva = Konva;
  Konva.global = glob;
  Konva.window = glob;
  Konva.document = glob.document;

  if (true) {
    module.exports = Konva;
  } else {}
})();

/*eslint-disable  eqeqeq, no-cond-assign, no-empty*/
(function() {
  'use strict';
  /**
   * Collection constructor.  Collection extends
   *  Array.  This class is used in conjunction with {@link Konva.Container#get}
   * @constructor
   * @memberof Konva
   */
  Konva.Collection = function() {
    var args = [].slice.call(arguments),
      length = args.length,
      i = 0;

    this.length = length;
    for (; i < length; i++) {
      this[i] = args[i];
    }
    return this;
  };
  Konva.Collection.prototype = [];
  /**
   * iterate through node array and run a function for each node.
   *  The node and index is passed into the function
   * @method
   * @memberof Konva.Collection.prototype
   * @param {Function} func
   * @example
   * // get all nodes with name foo inside layer, and set x to 10 for each
   * layer.get('.foo').each(function(shape, n) {
   *   shape.setX(10);
   * });
   */
  Konva.Collection.prototype.each = function(func) {
    for (var n = 0; n < this.length; n++) {
      func(this[n], n);
    }
  };
  /**
   * convert collection into an array
   * @method
   * @memberof Konva.Collection.prototype
   */
  Konva.Collection.prototype.toArray = function() {
    var arr = [],
      len = this.length,
      n;

    for (n = 0; n < len; n++) {
      arr.push(this[n]);
    }
    return arr;
  };
  /**
   * convert array into a collection
   * @method
   * @memberof Konva.Collection
   * @param {Array} arr
   */
  Konva.Collection.toCollection = function(arr) {
    var collection = new Konva.Collection(),
      len = arr.length,
      n;

    for (n = 0; n < len; n++) {
      collection.push(arr[n]);
    }
    return collection;
  };

  // map one method by it's name
  Konva.Collection._mapMethod = function(methodName) {
    Konva.Collection.prototype[methodName] = function() {
      var len = this.length,
        i;

      var args = [].slice.call(arguments);
      for (i = 0; i < len; i++) {
        this[i][methodName].apply(this[i], args);
      }

      return this;
    };
  };

  Konva.Collection.mapMethods = function(constructor) {
    var prot = constructor.prototype;
    for (var methodName in prot) {
      Konva.Collection._mapMethod(methodName);
    }
  };

  /*
    * Last updated November 2011
    * By Simon Sarris
    * www.simonsarris.com
    * sarris@acm.org
    *
    * Free to use and distribute at will
    * So long as you are nice to people, etc
    */

  /*
    * The usage of this class was inspired by some of the work done by a forked
    * project, KineticJS-Ext by Wappworks, which is based on Simon's Transform
    * class.  Modified by Eric Rowell
    */

  /**
   * Transform constructor. Transform object is a private class of Konva framework.
   * In most of the cases you don't need to use it in your app.
   * But there is a documentation for that class in case you still want
   * to make some manual calculations.
   * @constructor
   * @param {Array} [m] Optional six-element matrix
   * @memberof Konva
   */
  Konva.Transform = function(m) {
    this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];
  };

  Konva.Transform.prototype = {
    /**
     * Copy Konva.Transform object
     * @method
     * @memberof Konva.Transform.prototype
     * @returns {Konva.Transform}
     */
    copy: function() {
      return new Konva.Transform(this.m);
    },
    /**
     * Transform point
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Object} point 2D point(x, y)
     * @returns {Object} 2D point(x, y)
     */
    point: function(point) {
      var m = this.m;
      return {
        x: m[0] * point.x + m[2] * point.y + m[4],
        y: m[1] * point.x + m[3] * point.y + m[5]
      };
    },
    /**
     * Apply translation
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Number} x
     * @param {Number} y
     * @returns {Konva.Transform}
     */
    translate: function(x, y) {
      this.m[4] += this.m[0] * x + this.m[2] * y;
      this.m[5] += this.m[1] * x + this.m[3] * y;
      return this;
    },
    /**
     * Apply scale
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Number} sx
     * @param {Number} sy
     * @returns {Konva.Transform}
     */
    scale: function(sx, sy) {
      this.m[0] *= sx;
      this.m[1] *= sx;
      this.m[2] *= sy;
      this.m[3] *= sy;
      return this;
    },
    /**
     * Apply rotation
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Number} rad  Angle in radians
     * @returns {Konva.Transform}
     */
    rotate: function(rad) {
      var c = Math.cos(rad);
      var s = Math.sin(rad);
      var m11 = this.m[0] * c + this.m[2] * s;
      var m12 = this.m[1] * c + this.m[3] * s;
      var m21 = this.m[0] * -s + this.m[2] * c;
      var m22 = this.m[1] * -s + this.m[3] * c;
      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      return this;
    },
    /**
     * Returns the translation
     * @method
     * @memberof Konva.Transform.prototype
     * @returns {Object} 2D point(x, y)
     */
    getTranslation: function() {
      return {
        x: this.m[4],
        y: this.m[5]
      };
    },
    /**
     * Apply skew
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Number} sx
     * @param {Number} sy
     * @returns {Konva.Transform}
     */
    skew: function(sx, sy) {
      var m11 = this.m[0] + this.m[2] * sy;
      var m12 = this.m[1] + this.m[3] * sy;
      var m21 = this.m[2] + this.m[0] * sx;
      var m22 = this.m[3] + this.m[1] * sx;
      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      return this;
    },
    /**
     * Transform multiplication
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Konva.Transform} matrix
     * @returns {Konva.Transform}
     */
    multiply: function(matrix) {
      var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
      var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

      var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
      var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

      var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
      var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      this.m[4] = dx;
      this.m[5] = dy;
      return this;
    },
    /**
     * Invert the matrix
     * @method
     * @memberof Konva.Transform.prototype
     * @returns {Konva.Transform}
     */
    invert: function() {
      var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
      var m0 = this.m[3] * d;
      var m1 = -this.m[1] * d;
      var m2 = -this.m[2] * d;
      var m3 = this.m[0] * d;
      var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
      var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
      this.m[0] = m0;
      this.m[1] = m1;
      this.m[2] = m2;
      this.m[3] = m3;
      this.m[4] = m4;
      this.m[5] = m5;
      return this;
    },
    /**
     * return matrix
     * @method
     * @memberof Konva.Transform.prototype
     */
    getMatrix: function() {
      return this.m;
    },
    /**
     * set to absolute position via translation
     * @method
     * @memberof Konva.Transform.prototype
     * @returns {Konva.Transform}
     * @author ericdrowell
     */
    setAbsolutePosition: function(x, y) {
      var m0 = this.m[0],
        m1 = this.m[1],
        m2 = this.m[2],
        m3 = this.m[3],
        m4 = this.m[4],
        m5 = this.m[5],
        yt = (m0 * (y - m5) - m1 * (x - m4)) / (m0 * m3 - m1 * m2),
        xt = (x - m4 - m2 * yt) / m0;

      return this.translate(xt, yt);
    }
  };

  // CONSTANTS
  var CONTEXT_2D = '2d',
    OBJECT_ARRAY = '[object Array]',
    OBJECT_NUMBER = '[object Number]',
    OBJECT_STRING = '[object String]',
    OBJECT_BOOLEAN = '[object Boolean]',
    PI_OVER_DEG180 = Math.PI / 180,
    DEG180_OVER_PI = 180 / Math.PI,
    HASH = '#',
    EMPTY_STRING = '',
    ZERO = '0',
    KONVA_WARNING = 'Konva warning: ',
    KONVA_ERROR = 'Konva error: ',
    RGB_PAREN = 'rgb(',
    COLORS = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 132, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 255, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 203],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [119, 128, 144],
      slategrey: [119, 128, 144],
      snow: [255, 255, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      transparent: [255, 255, 255, 0],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 5]
    },
    RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;

  /**
   * @namespace Util
   * @memberof Konva
   */
  Konva.Util = {
    /*
    * cherry-picked utilities from underscore.js
    */
    _isElement: function(obj) {
      return !!(obj && obj.nodeType == 1);
    },
    _isFunction: function(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
    },
    _isObject: function(obj) {
      return !!obj && obj.constructor === Object;
    },
    _isArray: function(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
    },
    _isNumber: function(obj) {
      return (
        Object.prototype.toString.call(obj) === OBJECT_NUMBER &&
        !isNaN(obj) &&
        isFinite(obj)
      );
    },
    _isString: function(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_STRING;
    },
    _isBoolean: function(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN;
    },
    // arrays are objects too
    isObject: function(val) {
      return val instanceof Object;
    },
    isValidSelector: function(selector) {
      if (typeof selector !== 'string') {
        return false;
      }
      var firstChar = selector[0];
      return (
        firstChar === '#' ||
        firstChar === '.' ||
        firstChar === firstChar.toUpperCase()
      );
    },
    _sign: function(number) {
      if (number === 0) {
        return 0;
      }
      if (number > 0) {
        return 1;
      } else {
        return -1;
      }
    },
    createCanvasElement: function() {
      var canvas = Konva.isBrowser
        ? Konva.document.createElement('canvas')
        : new Konva._nodeCanvas();
      // on some environments canvas.style is readonly
      try {
        canvas.style = canvas.style || {};
      } catch (e) {}
      return canvas;
    },
    _isInDocument: function(el) {
      while ((el = el.parentNode)) {
        if (el == Konva.document) {
          return true;
        }
      }
      return false;
    },
    _simplifyArray: function(arr) {
      var retArr = [],
        len = arr.length,
        util = Konva.Util,
        n,
        val;

      for (n = 0; n < len; n++) {
        val = arr[n];
        if (util._isNumber(val)) {
          val = Math.round(val * 1000) / 1000;
        } else if (!util._isString(val)) {
          val = val.toString();
        }

        retArr.push(val);
      }

      return retArr;
    },
    /*
    * arg can be an image object or image data
    */
    _getImage: function(arg, callback) {
      var imageObj, canvas;

      // if arg is null or undefined
      if (!arg) {
        callback(null);
      } else if (this._isElement(arg)) {
        // if arg is already an image object
        callback(arg);
      } else if (this._isString(arg)) {
        // if arg is a string, then it's a data url
        imageObj = new Konva.window.Image();
        imageObj.onload = function() {
          callback(imageObj);
        };
        imageObj.src = arg;
      } else if (arg.data) {
        //if arg is an object that contains the data property, it's an image object
        canvas = Konva.Util.createCanvasElement();
        canvas.width = arg.width;
        canvas.height = arg.height;
        var _context = canvas.getContext(CONTEXT_2D);
        _context.putImageData(arg, 0, 0);
        this._getImage(canvas.toDataURL(), callback);
      } else {
        callback(null);
      }
    },
    _getRGBAString: function(obj) {
      var red = obj.red || 0,
        green = obj.green || 0,
        blue = obj.blue || 0,
        alpha = obj.alpha || 1;

      return ['rgba(', red, ',', green, ',', blue, ',', alpha, ')'].join(
        EMPTY_STRING
      );
    },
    _rgbToHex: function(r, g, b) {
      return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    },
    _hexToRgb: function(hex) {
      hex = hex.replace(HASH, EMPTY_STRING);
      var bigint = parseInt(hex, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    },
    /**
     * return random hex color
     * @method
     * @memberof Konva.Util.prototype
     */
    getRandomColor: function() {
      var randColor = ((Math.random() * 0xffffff) << 0).toString(16);
      while (randColor.length < 6) {
        randColor = ZERO + randColor;
      }
      return HASH + randColor;
    },
    /**
     * return value with default fallback
     * @method
     * @memberof Konva.Util.prototype
     */
    get: function(val, def) {
      if (val === undefined) {
        return def;
      } else {
        return val;
      }
    },
    /**
     * get RGB components of a color
     * @method
     * @memberof Konva.Util.prototype
     * @param {String} color
     * @example
     * // each of the following examples return {r:0, g:0, b:255}
     * var rgb = Konva.Util.getRGB('blue');
     * var rgb = Konva.Util.getRGB('#0000ff');
     * var rgb = Konva.Util.getRGB('rgb(0,0,255)');
     */
    getRGB: function(color) {
      var rgb;
      // color string
      if (color in COLORS) {
        rgb = COLORS[color];
        return {
          r: rgb[0],
          g: rgb[1],
          b: rgb[2]
        };
      } else if (color[0] === HASH) {
        // hex
        return this._hexToRgb(color.substring(1));
      } else if (color.substr(0, 4) === RGB_PAREN) {
        // rgb string
        rgb = RGB_REGEX.exec(color.replace(/ /g, ''));
        return {
          r: parseInt(rgb[1], 10),
          g: parseInt(rgb[2], 10),
          b: parseInt(rgb[3], 10)
        };
      } else {
        // default
        return {
          r: 0,
          g: 0,
          b: 0
        };
      }
    },
    // convert any color string to RGBA object
    // from https://github.com/component/color-parser
    colorToRGBA: function(str) {
      str = str || 'black';
      return (
        Konva.Util._namedColorToRBA(str) ||
        Konva.Util._hex3ColorToRGBA(str) ||
        Konva.Util._hex6ColorToRGBA(str) ||
        Konva.Util._rgbColorToRGBA(str) ||
        Konva.Util._rgbaColorToRGBA(str)
      );
    },
    // Parse named css color. Like "green"
    _namedColorToRBA: function(str) {
      var c = COLORS[str.toLowerCase()];
      if (!c) {
        return null;
      }
      return {
        r: c[0],
        g: c[1],
        b: c[2],
        a: 1
      };
    },
    // Parse rgb(n, n, n)
    _rgbColorToRGBA: function(str) {
      if (str.indexOf('rgb(') === 0) {
        str = str.match(/rgb\(([^)]+)\)/)[1];
        var parts = str.split(/ *, */).map(Number);
        return {
          r: parts[0],
          g: parts[1],
          b: parts[2],
          a: 1
        };
      }
    },
    // Parse rgba(n, n, n, n)
    _rgbaColorToRGBA: function(str) {
      if (str.indexOf('rgba(') === 0) {
        str = str.match(/rgba\(([^)]+)\)/)[1];
        var parts = str.split(/ *, */).map(Number);
        return {
          r: parts[0],
          g: parts[1],
          b: parts[2],
          a: parts[3]
        };
      }
    },
    // Parse #nnnnnn
    _hex6ColorToRGBA: function(str) {
      if (str[0] === '#' && str.length === 7) {
        return {
          r: parseInt(str.slice(1, 3), 16),
          g: parseInt(str.slice(3, 5), 16),
          b: parseInt(str.slice(5, 7), 16),
          a: 1
        };
      }
    },
    // Parse #nnn
    _hex3ColorToRGBA: function(str) {
      if (str[0] === '#' && str.length === 4) {
        return {
          r: parseInt(str[1] + str[1], 16),
          g: parseInt(str[2] + str[2], 16),
          b: parseInt(str[3] + str[3], 16),
          a: 1
        };
      }
    },
    // o1 takes precedence over o2
    _merge: function(o1, o2) {
      var retObj = this._clone(o2);
      for (var key in o1) {
        if (this._isObject(o1[key])) {
          retObj[key] = this._merge(o1[key], retObj[key]);
        } else {
          retObj[key] = o1[key];
        }
      }
      return retObj;
    },
    trimRight: function(str) {
      return str.replace(/\s+$/, '');
    },
    trimLeft: function(str) {
      return str.replace(/^\s+/, '');
    },
    /**
     * check intersection of two client rectangles
     * @method
     * @memberof Konva.Util.prototype
     */
    haveIntersection: function(r1, r2) {
      return !(
        r2.x > r1.x + r1.width ||
        r2.x + r2.width < r1.x ||
        r2.y > r1.y + r1.height ||
        r2.y + r2.height < r1.y
      );
    },
    cloneObject: function(obj) {
      var retObj = {};
      for (var key in obj) {
        if (this._isObject(obj[key])) {
          retObj[key] = this.cloneObject(obj[key]);
        } else if (this._isArray(obj[key])) {
          retObj[key] = this.cloneArray(obj[key]);
        } else {
          retObj[key] = obj[key];
        }
      }
      return retObj;
    },
    cloneArray: function(arr) {
      return arr.slice(0);
    },
    _degToRad: function(deg) {
      return deg * PI_OVER_DEG180;
    },
    _radToDeg: function(rad) {
      return rad * DEG180_OVER_PI;
    },
    _capitalize: function(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    },
    throw: function(str) {
      throw new Error(KONVA_ERROR + str);
    },
    error: function(str) {
      console.error(KONVA_ERROR + str);
    },
    warn: function(str) {
      /*
             * IE9 on Windows7 64bit will throw a JS error
             * if we don't use window.console in the conditional
             */
      if (Konva.global.console && console.warn && Konva.showWarnings) {
        console.warn(KONVA_WARNING + str);
      }
    },
    extend: function(child, parent) {
      function Ctor() {
        this.constructor = child;
      }
      Ctor.prototype = parent.prototype;
      var oldProto = child.prototype;
      child.prototype = new Ctor();
      for (var key in oldProto) {
        if (oldProto.hasOwnProperty(key)) {
          child.prototype[key] = oldProto[key];
        }
      }
      child.__super__ = parent.prototype;
      // create reference to parent
      child.super = parent;
    },
    /**
     * adds methods to a constructor prototype
     * @method
     * @memberof Konva.Util.prototype
     * @param {Function} constructor
     * @param {Object} methods
     */
    addMethods: function(constructor, methods) {
      var key;

      for (key in methods) {
        constructor.prototype[key] = methods[key];
      }
    },
    _getControlPoints: function(x0, y0, x1, y1, x2, y2, t) {
      var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)),
        d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),
        fa = t * d01 / (d01 + d12),
        fb = t * d12 / (d01 + d12),
        p1x = x1 - fa * (x2 - x0),
        p1y = y1 - fa * (y2 - y0),
        p2x = x1 + fb * (x2 - x0),
        p2y = y1 + fb * (y2 - y0);

      return [p1x, p1y, p2x, p2y];
    },
    _expandPoints: function(p, tension) {
      var len = p.length,
        allPoints = [],
        n,
        cp;

      for (n = 2; n < len - 2; n += 2) {
        cp = Konva.Util._getControlPoints(
          p[n - 2],
          p[n - 1],
          p[n],
          p[n + 1],
          p[n + 2],
          p[n + 3],
          tension
        );
        allPoints.push(cp[0]);
        allPoints.push(cp[1]);
        allPoints.push(p[n]);
        allPoints.push(p[n + 1]);
        allPoints.push(cp[2]);
        allPoints.push(cp[3]);
      }

      return allPoints;
    },
    _removeLastLetter: function(str) {
      return str.substring(0, str.length - 1);
    },
    each: function(obj, func) {
      for (var key in obj) {
        func(key, obj[key]);
      }
    },
    _inRange: function(val, left, right) {
      return left <= val && val < right;
    },
    _getProjectionToSegment: function(x1, y1, x2, y2, x3, y3) {
      var x, y, dist;

      var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
      if (pd2 == 0) {
        x = x1;
        y = y1;
        dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
      } else {
        var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
        if (u < 0) {
          x = x1;
          y = y1;
          dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
        } else if (u > 1.0) {
          x = x2;
          y = y2;
          dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
        } else {
          x = x1 + u * (x2 - x1);
          y = y1 + u * (y2 - y1);
          dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
        }
      }
      return [x, y, dist];
    },
    // line as array of points.
    // line might be closed
    _getProjectionToLine: function(pt, line, isClosed) {
      var pc = Konva.Util.cloneObject(pt);
      var dist = Number.MAX_VALUE;
      line.forEach(function(p1, i) {
        if (!isClosed && i === line.length - 1) {
          return;
        }
        var p2 = line[(i + 1) % line.length];
        var proj = Konva.Util._getProjectionToSegment(
          p1.x,
          p1.y,
          p2.x,
          p2.y,
          pt.x,
          pt.y
        );
        var px = proj[0],
          py = proj[1],
          pdist = proj[2];
        if (pdist < dist) {
          pc.x = px;
          pc.y = py;
          dist = pdist;
        }
      });
      return pc;
    },
    _prepareArrayForTween: function(startArray, endArray, isClosed) {
      var n,
        start = [],
        end = [];
      if (startArray.length > endArray.length) {
        var temp = endArray;
        endArray = startArray;
        startArray = temp;
      }
      for (n = 0; n < startArray.length; n += 2) {
        start.push({
          x: startArray[n],
          y: startArray[n + 1]
        });
      }
      for (n = 0; n < endArray.length; n += 2) {
        end.push({
          x: endArray[n],
          y: endArray[n + 1]
        });
      }

      var newStart = [];
      end.forEach(function(point) {
        var pr = Konva.Util._getProjectionToLine(point, start, isClosed);
        newStart.push(pr.x);
        newStart.push(pr.y);
      });
      return newStart;
    },
    _prepareToStringify: function(obj) {
      var desc;

      obj.visitedByCircularReferenceRemoval = true;

      for (var key in obj) {
        if (
          !(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == 'object')
        ) {
          continue;
        }
        desc = Object.getOwnPropertyDescriptor(obj, key);
        if (
          obj[key].visitedByCircularReferenceRemoval ||
          Konva.Util._isElement(obj[key])
        ) {
          if (desc.configurable) {
            delete obj[key];
          } else {
            return null;
          }
        } else if (Konva.Util._prepareToStringify(obj[key]) === null) {
          if (desc.configurable) {
            delete obj[key];
          } else {
            return null;
          }
        }
      }

      delete obj.visitedByCircularReferenceRemoval;

      return obj;
    }
  };
})();

(function() {
  'use strict';
  // calculate pixel ratio

  var _pixelRatio;
  function getDevicePixelRatio() {
    if (_pixelRatio) {
      return _pixelRatio;
    }
    var canvas = Konva.Util.createCanvasElement();
    var context = canvas.getContext('2d');
    _pixelRatio = (function() {
      var devicePixelRatio = Konva.window.devicePixelRatio || 1,
        backingStoreRatio =
          context.webkitBackingStorePixelRatio ||
          context.mozBackingStorePixelRatio ||
          context.msBackingStorePixelRatio ||
          context.oBackingStorePixelRatio ||
          context.backingStorePixelRatio ||
          1;
      return devicePixelRatio / backingStoreRatio;
    })();
    return _pixelRatio;
  }

  /**
   * Canvas Renderer constructor
   * @constructor
   * @abstract
   * @memberof Konva
   * @param {Object} config
   * @param {Number} config.width
   * @param {Number} config.height
   * @param {Number} config.pixelRatio KonvaJS automatically handles pixel ratio adjustments in order to render crisp drawings
   *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
   *  of 1.  Some high end tablets and phones, like iPhones and iPads (not the mini) have a device pixel ratio
   *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
   *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
   *  specified, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
   *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
   */
  Konva.Canvas = function(config) {
    this.init(config);
  };

  Konva.Canvas.prototype = {
    init: function(config) {
      var conf = config || {};

      var pixelRatio =
        conf.pixelRatio || Konva.pixelRatio || getDevicePixelRatio();

      this.pixelRatio = pixelRatio;
      this._canvas = Konva.Util.createCanvasElement();

      // set inline styles
      this._canvas.style.padding = 0;
      this._canvas.style.margin = 0;
      this._canvas.style.border = 0;
      this._canvas.style.background = 'transparent';
      this._canvas.style.position = 'absolute';
      this._canvas.style.top = 0;
      this._canvas.style.left = 0;
    },
    /**
     * get canvas context
     * @method
     * @memberof Konva.Canvas.prototype
     * @returns {CanvasContext} context
     */
    getContext: function() {
      return this.context;
    },
    /**
     * get pixel ratio
     * @method
     * @memberof Konva.Canvas.prototype
     * @returns {Number} pixel ratio
     */
    getPixelRatio: function() {
      return this.pixelRatio;
    },
    /**
     * get pixel ratio
     * @method
     * @memberof Konva.Canvas.prototype
     * @param {Number} pixelRatio KonvaJS automatically handles pixel ratio adustments in order to render crisp drawings
     *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
     *  of 1.  Some high end tablets and phones, like iPhones and iPads have a device pixel ratio
     *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
     *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
     *  specificed, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
     *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
     */
    setPixelRatio: function(pixelRatio) {
      var previousRatio = this.pixelRatio;
      this.pixelRatio = pixelRatio;
      this.setSize(
        this.getWidth() / previousRatio,
        this.getHeight() / previousRatio
      );
    },
    /**
     * set width
     * @method
     * @memberof Konva.Canvas.prototype
     * @param {Number} width
     */
    setWidth: function(width) {
      // take into account pixel ratio
      this.width = this._canvas.width = width * this.pixelRatio;
      this._canvas.style.width = width + 'px';

      var pixelRatio = this.pixelRatio,
        _context = this.getContext()._context;
      _context.scale(pixelRatio, pixelRatio);
    },
    /**
     * set height
     * @method
     * @memberof Konva.Canvas.prototype
     * @param {Number} height
     */
    setHeight: function(height) {
      // take into account pixel ratio
      this.height = this._canvas.height = height * this.pixelRatio;
      this._canvas.style.height = height + 'px';
      var pixelRatio = this.pixelRatio,
        _context = this.getContext()._context;
      _context.scale(pixelRatio, pixelRatio);
    },
    /**
     * get width
     * @method
     * @memberof Konva.Canvas.prototype
     * @returns {Number} width
     */
    getWidth: function() {
      return this.width;
    },
    /**
     * get height
     * @method
     * @memberof Konva.Canvas.prototype
     * @returns {Number} height
     */
    getHeight: function() {
      return this.height;
    },
    /**
     * set size
     * @method
     * @memberof Konva.Canvas.prototype
     * @param {Number} width
     * @param {Number} height
     */
    setSize: function(width, height) {
      this.setWidth(width);
      this.setHeight(height);
    },
    /**
     * to data url
     * @method
     * @memberof Konva.Canvas.prototype
     * @param {String} mimeType
     * @param {Number} quality between 0 and 1 for jpg mime types
     * @returns {String} data url string
     */
    toDataURL: function(mimeType, quality) {
      try {
        // If this call fails (due to browser bug, like in Firefox 3.6),
        // then revert to previous no-parameter image/png behavior
        return this._canvas.toDataURL(mimeType, quality);
      } catch (e) {
        try {
          return this._canvas.toDataURL();
        } catch (err) {
          Konva.Util.warn('Unable to get data URL. ' + err.message);
          return '';
        }
      }
    }
  };

  Konva.SceneCanvas = function(config) {
    var conf = config || {};
    var width = conf.width || 0,
      height = conf.height || 0;

    Konva.Canvas.call(this, conf);
    this.context = new Konva.SceneContext(this);
    this.setSize(width, height);
  };

  Konva.Util.extend(Konva.SceneCanvas, Konva.Canvas);

  Konva.HitCanvas = function(config) {
    var conf = config || {};
    var width = conf.width || 0,
      height = conf.height || 0;

    Konva.Canvas.call(this, conf);
    this.context = new Konva.HitContext(this);
    this.setSize(width, height);
    this.hitCanvas = true;
  };
  Konva.Util.extend(Konva.HitCanvas, Konva.Canvas);
})();

(function() {
  'use strict';
  var COMMA = ',',
    OPEN_PAREN = '(',
    CLOSE_PAREN = ')',
    OPEN_PAREN_BRACKET = '([',
    CLOSE_BRACKET_PAREN = '])',
    SEMICOLON = ';',
    DOUBLE_PAREN = '()',
    // EMPTY_STRING = '',
    EQUALS = '=',
    // SET = 'set',
    CONTEXT_METHODS = [
      'arc',
      'arcTo',
      'beginPath',
      'bezierCurveTo',
      'clearRect',
      'clip',
      'closePath',
      'createLinearGradient',
      'createPattern',
      'createRadialGradient',
      'drawImage',
      'fill',
      'fillText',
      'getImageData',
      'createImageData',
      'lineTo',
      'moveTo',
      'putImageData',
      'quadraticCurveTo',
      'rect',
      'restore',
      'rotate',
      'save',
      'scale',
      'setLineDash',
      'setTransform',
      'stroke',
      'strokeText',
      'transform',
      'translate'
    ];

  var CONTEXT_PROPERTIES = [
    'fillStyle',
    'strokeStyle',
    'shadowColor',
    'shadowBlur',
    'shadowOffsetX',
    'shadowOffsetY',
    'lineCap',
    'lineDashOffset',
    'lineJoin',
    'lineWidth',
    'miterLimit',
    'font',
    'textAlign',
    'textBaseline',
    'globalAlpha',
    'globalCompositeOperation'
  ];

  /**
   * Canvas Context constructor
   * @constructor
   * @abstract
   * @memberof Konva
   */
  Konva.Context = function(canvas) {
    this.init(canvas);
  };

  Konva.Context.prototype = {
    init: function(canvas) {
      this.canvas = canvas;
      this._context = canvas._canvas.getContext('2d');

      if (Konva.enableTrace) {
        this.traceArr = [];
        this._enableTrace();
      }
    },
    /**
     * fill shape
     * @method
     * @memberof Konva.Context.prototype
     * @param {Konva.Shape} shape
     */
    fillShape: function(shape) {
      if (shape.getFillEnabled()) {
        this._fill(shape);
      }
    },
    /**
     * stroke shape
     * @method
     * @memberof Konva.Context.prototype
     * @param {Konva.Shape} shape
     */
    strokeShape: function(shape) {
      if (shape.getStrokeEnabled()) {
        this._stroke(shape);
      }
    },
    /**
     * fill then stroke
     * @method
     * @memberof Konva.Context.prototype
     * @param {Konva.Shape} shape
     */
    fillStrokeShape: function(shape) {
      var fillEnabled = shape.getFillEnabled();
      if (fillEnabled) {
        this._fill(shape);
      }
      if (shape.getStrokeEnabled()) {
        this._stroke(shape);
      }
    },
    /**
     * get context trace if trace is enabled
     * @method
     * @memberof Konva.Context.prototype
     * @param {Boolean} relaxed if false, return strict context trace, which includes method names, method parameters
     *  properties, and property values.  If true, return relaxed context trace, which only returns method names and
     *  properites.
     * @returns {String}
     */
    getTrace: function(relaxed) {
      var traceArr = this.traceArr,
        len = traceArr.length,
        str = '',
        n,
        trace,
        method,
        args;

      for (n = 0; n < len; n++) {
        trace = traceArr[n];
        method = trace.method;

        // methods
        if (method) {
          args = trace.args;
          str += method;
          if (relaxed) {
            str += DOUBLE_PAREN;
          } else {
            if (Konva.Util._isArray(args[0])) {
              str +=
                OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
            } else {
              str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
            }
          }
        } else {
          // properties
          str += trace.property;
          if (!relaxed) {
            str += EQUALS + trace.val;
          }
        }

        str += SEMICOLON;
      }

      return str;
    },
    /**
     * clear trace if trace is enabled
     * @method
     * @memberof Konva.Context.prototype
     */
    clearTrace: function() {
      this.traceArr = [];
    },
    _trace: function(str) {
      var traceArr = this.traceArr,
        len;

      traceArr.push(str);
      len = traceArr.length;

      if (len >= Konva.traceArrMax) {
        traceArr.shift();
      }
    },
    /**
     * reset canvas context transform
     * @method
     * @memberof Konva.Context.prototype
     */
    reset: function() {
      var pixelRatio = this.getCanvas().getPixelRatio();
      this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
    },
    /**
     * get canvas
     * @method
     * @memberof Konva.Context.prototype
     * @returns {Konva.Canvas}
     */
    getCanvas: function() {
      return this.canvas;
    },
    /**
     * clear canvas
     * @method
     * @memberof Konva.Context.prototype
     * @param {Object} [bounds]
     * @param {Number} [bounds.x]
     * @param {Number} [bounds.y]
     * @param {Number} [bounds.width]
     * @param {Number} [bounds.height]
     */
    clear: function(bounds) {
      var canvas = this.getCanvas();

      if (bounds) {
        this.clearRect(
          bounds.x || 0,
          bounds.y || 0,
          bounds.width || 0,
          bounds.height || 0
        );
      } else {
        this.clearRect(
          0,
          0,
          canvas.getWidth() / canvas.pixelRatio,
          canvas.getHeight() / canvas.pixelRatio
        );
      }
    },
    _applyLineCap: function(shape) {
      var lineCap = shape.getLineCap();
      if (lineCap) {
        this.setAttr('lineCap', lineCap);
      }
    },
    _applyOpacity: function(shape) {
      var absOpacity = shape.getAbsoluteOpacity();
      if (absOpacity !== 1) {
        this.setAttr('globalAlpha', absOpacity);
      }
    },
    _applyLineJoin: function(shape) {
      var lineJoin = shape.getLineJoin();
      if (lineJoin) {
        this.setAttr('lineJoin', lineJoin);
      }
    },
    setAttr: function(attr, val) {
      this._context[attr] = val;
    },

    // context pass through methods
    arc: function() {
      var a = arguments;
      this._context.arc(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    beginPath: function() {
      this._context.beginPath();
    },
    bezierCurveTo: function() {
      var a = arguments;
      this._context.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    clearRect: function() {
      var a = arguments;
      this._context.clearRect(a[0], a[1], a[2], a[3]);
    },
    clip: function() {
      this._context.clip();
    },
    closePath: function() {
      this._context.closePath();
    },
    createImageData: function() {
      var a = arguments;
      if (a.length === 2) {
        return this._context.createImageData(a[0], a[1]);
      } else if (a.length === 1) {
        return this._context.createImageData(a[0]);
      }
    },
    createLinearGradient: function() {
      var a = arguments;
      return this._context.createLinearGradient(a[0], a[1], a[2], a[3]);
    },
    createPattern: function() {
      var a = arguments;
      return this._context.createPattern(a[0], a[1]);
    },
    createRadialGradient: function() {
      var a = arguments;
      return this._context.createRadialGradient(
        a[0],
        a[1],
        a[2],
        a[3],
        a[4],
        a[5]
      );
    },
    drawImage: function() {
      var a = arguments,
        _context = this._context;

      if (a.length === 3) {
        _context.drawImage(a[0], a[1], a[2]);
      } else if (a.length === 5) {
        _context.drawImage(a[0], a[1], a[2], a[3], a[4]);
      } else if (a.length === 9) {
        _context.drawImage(
          a[0],
          a[1],
          a[2],
          a[3],
          a[4],
          a[5],
          a[6],
          a[7],
          a[8]
        );
      }
    },
    isPointInPath: function(x, y) {
      return this._context.isPointInPath(x, y);
    },
    fill: function() {
      this._context.fill();
    },
    fillRect: function(x, y, width, height) {
      this._context.fillRect(x, y, width, height);
    },
    strokeRect: function(x, y, width, height) {
      this._context.strokeRect(x, y, width, height);
    },
    fillText: function() {
      var a = arguments;
      this._context.fillText(a[0], a[1], a[2]);
    },
    measureText: function(text) {
      return this._context.measureText(text);
    },
    getImageData: function() {
      var a = arguments;
      return this._context.getImageData(a[0], a[1], a[2], a[3]);
    },
    lineTo: function() {
      var a = arguments;
      this._context.lineTo(a[0], a[1]);
    },
    moveTo: function() {
      var a = arguments;
      this._context.moveTo(a[0], a[1]);
    },
    rect: function() {
      var a = arguments;
      this._context.rect(a[0], a[1], a[2], a[3]);
    },
    putImageData: function() {
      var a = arguments;
      this._context.putImageData(a[0], a[1], a[2]);
    },
    quadraticCurveTo: function() {
      var a = arguments;
      this._context.quadraticCurveTo(a[0], a[1], a[2], a[3]);
    },
    restore: function() {
      this._context.restore();
    },
    rotate: function() {
      var a = arguments;
      this._context.rotate(a[0]);
    },
    save: function() {
      this._context.save();
    },
    scale: function() {
      var a = arguments;
      this._context.scale(a[0], a[1]);
    },
    setLineDash: function() {
      var a = arguments,
        _context = this._context;

      // works for Chrome and IE11
      if (this._context.setLineDash) {
        _context.setLineDash(a[0]);
      } else if ('mozDash' in _context) {
        // verified that this works in firefox
        _context.mozDash = a[0];
      } else if ('webkitLineDash' in _context) {
        // does not currently work for Safari
        _context.webkitLineDash = a[0];
      }

      // no support for IE9 and IE10
    },
    getLineDash: function() {
      return this._context.getLineDash();
    },
    setTransform: function() {
      var a = arguments;
      this._context.setTransform(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    stroke: function() {
      this._context.stroke();
    },
    strokeText: function() {
      var a = arguments;
      this._context.strokeText(a[0], a[1], a[2]);
    },
    transform: function() {
      var a = arguments;
      this._context.transform(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    translate: function() {
      var a = arguments;
      this._context.translate(a[0], a[1]);
    },
    _enableTrace: function() {
      var that = this,
        len = CONTEXT_METHODS.length,
        _simplifyArray = Konva.Util._simplifyArray,
        origSetter = this.setAttr,
        n,
        args;

      // to prevent creating scope function at each loop
      var func = function(methodName) {
        var origMethod = that[methodName],
          ret;

        that[methodName] = function() {
          args = _simplifyArray(Array.prototype.slice.call(arguments, 0));
          ret = origMethod.apply(that, arguments);

          that._trace({
            method: methodName,
            args: args
          });

          return ret;
        };
      };
      // methods
      for (n = 0; n < len; n++) {
        func(CONTEXT_METHODS[n]);
      }

      // attrs
      that.setAttr = function() {
        origSetter.apply(that, arguments);
        var prop = arguments[0];
        var val = arguments[1];
        if (
          prop === 'shadowOffsetX' ||
          prop === 'shadowOffsetY' ||
          prop === 'shadowBlur'
        ) {
          val = val / this.canvas.getPixelRatio();
        }
        that._trace({
          property: prop,
          val: val
        });
      };
    }
  };

  CONTEXT_PROPERTIES.forEach(function(prop) {
    Object.defineProperty(Konva.Context.prototype, prop, {
      get: function() {
        return this._context[prop];
      },
      set: function(val) {
        this._context[prop] = val;
      }
    });
  });

  Konva.SceneContext = function(canvas) {
    Konva.Context.call(this, canvas);
  };

  Konva.SceneContext.prototype = {
    _fillColor: function(shape) {
      var fill = shape.fill();

      this.setAttr('fillStyle', fill);
      shape._fillFunc(this);
    },
    _fillPattern: function(shape) {
      var fillPatternX = shape.getFillPatternX(),
        fillPatternY = shape.getFillPatternY(),
        fillPatternScale = shape.getFillPatternScale(),
        fillPatternRotation = Konva.getAngle(shape.getFillPatternRotation()),
        fillPatternOffset = shape.getFillPatternOffset();

      if (fillPatternX || fillPatternY) {
        this.translate(fillPatternX || 0, fillPatternY || 0);
      }
      if (fillPatternRotation) {
        this.rotate(fillPatternRotation);
      }
      if (fillPatternScale) {
        this.scale(fillPatternScale.x, fillPatternScale.y);
      }
      if (fillPatternOffset) {
        this.translate(-1 * fillPatternOffset.x, -1 * fillPatternOffset.y);
      }

      this.setAttr(
        'fillStyle',
        this.createPattern(
          shape.getFillPatternImage(),
          shape.getFillPatternRepeat() || 'repeat'
        )
      );
      this.fill();
    },
    _fillLinearGradient: function(shape) {
      var start = shape.getFillLinearGradientStartPoint(),
        end = shape.getFillLinearGradientEndPoint(),
        colorStops = shape.getFillLinearGradientColorStops(),
        grd = this.createLinearGradient(start.x, start.y, end.x, end.y);

      if (colorStops) {
        // build color stops
        for (var n = 0; n < colorStops.length; n += 2) {
          grd.addColorStop(colorStops[n], colorStops[n + 1]);
        }
        this.setAttr('fillStyle', grd);
        shape._fillFunc(this);
      }
    },
    _fillRadialGradient: function(shape) {
      var start = shape.getFillRadialGradientStartPoint(),
        end = shape.getFillRadialGradientEndPoint(),
        startRadius = shape.getFillRadialGradientStartRadius(),
        endRadius = shape.getFillRadialGradientEndRadius(),
        colorStops = shape.getFillRadialGradientColorStops(),
        grd = this.createRadialGradient(
          start.x,
          start.y,
          startRadius,
          end.x,
          end.y,
          endRadius
        );

      // build color stops
      for (var n = 0; n < colorStops.length; n += 2) {
        grd.addColorStop(colorStops[n], colorStops[n + 1]);
      }
      this.setAttr('fillStyle', grd);
      this.fill();
    },
    _fill: function(shape) {
      var hasColor = shape.fill(),
        fillPriority = shape.getFillPriority();

      // priority fills
      if (hasColor && fillPriority === 'color') {
        this._fillColor(shape);
        return;
      }

      var hasPattern = shape.getFillPatternImage();
      if (hasPattern && fillPriority === 'pattern') {
        this._fillPattern(shape);
        return;
      }

      var hasLinearGradient = shape.getFillLinearGradientColorStops();
      if (hasLinearGradient && fillPriority === 'linear-gradient') {
        this._fillLinearGradient(shape);
        return;
      }

      var hasRadialGradient = shape.getFillRadialGradientColorStops();
      if (hasRadialGradient && fillPriority === 'radial-gradient') {
        this._fillRadialGradient(shape);
        return;
      }

      // now just try and fill with whatever is available
      if (hasColor) {
        this._fillColor(shape);
      } else if (hasPattern) {
        this._fillPattern(shape);
      } else if (hasLinearGradient) {
        this._fillLinearGradient(shape);
      } else if (hasRadialGradient) {
        this._fillRadialGradient(shape);
      }
    },
    _strokeLinearGradient: function(shape) {
      var start = shape.getStrokeLinearGradientStartPoint(),
        end = shape.getStrokeLinearGradientEndPoint(),
        colorStops = shape.getStrokeLinearGradientColorStops(),
        grd = this.createLinearGradient(start.x, start.y, end.x, end.y);

      if (colorStops) {
        // build color stops
        for (var n = 0; n < colorStops.length; n += 2) {
          grd.addColorStop(colorStops[n], colorStops[n + 1]);
        }
        this.setAttr('strokeStyle', grd);
      }
    },
    _stroke: function(shape) {
      var dash = shape.dash(),
        // ignore strokeScaleEnabled for Text
        strokeScaleEnabled =
          shape.getStrokeScaleEnabled() || shape instanceof Konva.Text;

      if (shape.hasStroke()) {
        if (!strokeScaleEnabled) {
          this.save();
          this.setTransform(1, 0, 0, 1, 0, 0);
        }

        this._applyLineCap(shape);
        if (dash && shape.dashEnabled()) {
          this.setLineDash(dash);
          this.setAttr('lineDashOffset', shape.dashOffset());
        }

        this.setAttr('lineWidth', shape.strokeWidth());

        if (!shape.getShadowForStrokeEnabled()) {
          this.setAttr('shadowColor', 'rgba(0,0,0,0)');
        }

        // TODO - do we need to make like a fill function?

        var hasLinearGradient = shape.getStrokeLinearGradientColorStops();
        if (hasLinearGradient) {
          this._strokeLinearGradient(shape);
        } else {
          this.setAttr('strokeStyle', shape.stroke());
        }

        shape._strokeFunc(this);

        if (!strokeScaleEnabled) {
          this.restore();
        }
      }
    },
    _applyShadow: function(shape) {
      var util = Konva.Util,
        color = util.get(shape.getShadowRGBA(), 'black'),
        blur = util.get(shape.getShadowBlur(), 5),
        offset = util.get(shape.getShadowOffset(), {
          x: 0,
          y: 0
        }),
        scale = shape.getAbsoluteScale(),
        ratio = this.canvas.getPixelRatio(),
        scaleX = scale.x * ratio,
        scaleY = scale.y * ratio;

      this.setAttr('shadowColor', color);
      this.setAttr(
        'shadowBlur',
        blur * Math.min(Math.abs(scaleX), Math.abs(scaleY))
      );
      this.setAttr('shadowOffsetX', offset.x * scaleX);
      this.setAttr('shadowOffsetY', offset.y * scaleY);
    },
    _applyGlobalCompositeOperation: function(shape) {
      var globalCompositeOperation = shape.getGlobalCompositeOperation();
      if (globalCompositeOperation !== 'source-over') {
        this.setAttr('globalCompositeOperation', globalCompositeOperation);
      }
    }
  };
  Konva.Util.extend(Konva.SceneContext, Konva.Context);

  Konva.HitContext = function(canvas) {
    Konva.Context.call(this, canvas);
  };

  Konva.HitContext.prototype = {
    _fill: function(shape) {
      this.save();
      this.setAttr('fillStyle', shape.colorKey);
      shape._fillFuncHit(this);
      this.restore();
    },
    _stroke: function(shape) {
      if (shape.hasStroke() && shape.strokeHitEnabled()) {
        // ignore strokeScaleEnabled for Text
        var strokeScaleEnabled =
          shape.getStrokeScaleEnabled() || shape instanceof Konva.Text;
        if (!strokeScaleEnabled) {
          this.save();
          this.setTransform(1, 0, 0, 1, 0, 0);
        }
        this._applyLineCap(shape);
        this.setAttr('lineWidth', shape.strokeWidth());
        this.setAttr('strokeStyle', shape.colorKey);
        shape._strokeFuncHit(this);
        if (!strokeScaleEnabled) {
          this.restore();
        }
      }
    }
  };
  Konva.Util.extend(Konva.HitContext, Konva.Context);
})();

(function() {
  'use strict';
  // CONSTANTS
  var GET = 'get',
    SET = 'set';

  Konva.Factory = {
    addGetterSetter: function(constructor, attr, def, validator, after) {
      this.addGetter(constructor, attr, def);
      this.addSetter(constructor, attr, validator, after);
      this.addOverloadedGetterSetter(constructor, attr);
    },
    addGetter: function(constructor, attr, def) {
      var method = GET + Konva.Util._capitalize(attr);

      constructor.prototype[method] = function() {
        var val = this.attrs[attr];
        return val === undefined ? def : val;
      };
    },
    addSetter: function(constructor, attr, validator, after) {
      // if (!validator && validator !== null) {
      //   console.error(constructor, attr, 'has no validator.');
      // }
      var method = SET + Konva.Util._capitalize(attr);

      constructor.prototype[method] = function(val) {
        if (validator && val !== undefined && val !== null) {
          val = validator.call(this, val, attr);
        }

        this._setAttr(attr, val);

        if (after) {
          after.call(this);
        }

        return this;
      };
    },
    addComponentsGetterSetter: function(
      constructor,
      attr,
      components,
      validator,
      after
    ) {
      var len = components.length,
        capitalize = Konva.Util._capitalize,
        getter = GET + capitalize(attr),
        setter = SET + capitalize(attr),
        n,
        component;

      // getter
      constructor.prototype[getter] = function() {
        var ret = {};

        for (n = 0; n < len; n++) {
          component = components[n];
          ret[component] = this.getAttr(attr + capitalize(component));
        }

        return ret;
      };

      // setter
      constructor.prototype[setter] = function(val) {
        var oldVal = this.attrs[attr],
          key;

        if (validator) {
          val = validator.call(this, val);
        }

        for (key in val) {
          if (!val.hasOwnProperty(key)) {
            continue;
          }
          this._setAttr(attr + capitalize(key), val[key]);
        }

        this._fireChangeEvent(attr, oldVal, val);

        if (after) {
          after.call(this);
        }

        return this;
      };

      this.addOverloadedGetterSetter(constructor, attr);
    },
    addOverloadedGetterSetter: function(constructor, attr) {
      var capitalizedAttr = Konva.Util._capitalize(attr),
        setter = SET + capitalizedAttr,
        getter = GET + capitalizedAttr;

      constructor.prototype[attr] = function() {
        // setting
        if (arguments.length) {
          this[setter](arguments[0]);
          return this;
        }
        // getting
        return this[getter]();
      };
    },
    addDeprecatedGetterSetter: function(constructor, attr, def, validator) {
      Konva.Util.error('Adding deprecated ' + attr);

      var method = GET + Konva.Util._capitalize(attr);

      var message =
        attr +
        ' property is deprecated and will be removed soon. Look at Konva change log for more information.';
      constructor.prototype[method] = function() {
        Konva.Util.error(message);
        var val = this.attrs[attr];
        return val === undefined ? def : val;
      };
      this.addSetter(constructor, attr, validator, function() {
        Konva.Util.error(message);
      });
      this.addOverloadedGetterSetter(constructor, attr);
    },
    backCompat: function(constructor, methods) {
      Konva.Util.each(methods, function(oldMethodName, newMethodName) {
        var method = constructor.prototype[newMethodName];
        var oldGetter = GET + Konva.Util._capitalize(oldMethodName);
        var oldSetter = SET + Konva.Util._capitalize(oldMethodName);

        function deprecated() {
          method.apply(this, arguments);
          Konva.Util.error(
            '"' +
              oldMethodName +
              '" method is deprecated and will be removed soon. Use ""' +
              newMethodName +
              '" instead.'
          );
        }

        constructor.prototype[oldMethodName] = deprecated;
        constructor.prototype[oldGetter] = deprecated;
        constructor.prototype[oldSetter] = deprecated;
      });
    },
    afterSetFilter: function() {
      this._filterUpToDate = false;
    }
  };

  Konva.Validators = {
    /**
     * @return {number}
     */
    RGBComponent: function(val) {
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      }
      return Math.round(val);
    },
    alphaComponent: function(val) {
      if (val > 1) {
        return 1;
      } else if (val < 0.0001) {
        // chrome does not honor alpha values of 0
        return 0.0001;
      }

      return val;
    },
    _formatValue: function(val) {
      if (Konva.Util._isString(val)) {
        return '"' + val + '"';
      }
      if (Object.prototype.toString.call(val) === '[object Number]') {
        return val;
      }
      if (Konva.Util._isBoolean(val)) {
        return val;
      }
      return Object.prototype.toString.call(val);
    },
    getNumberValidator: function() {
      if (Konva.isUnminified) {
        return function(val, attr) {
          if (!Konva.Util._isNumber(val)) {
            Konva.Util.warn(
              Konva.Validators._formatValue(val) +
                ' is a not valid value for "' +
                attr +
                '" attribute. The value should be a number.'
            );
          }
          return val;
        };
      }
    },
    getNumberOrAutoValidator: function() {
      if (Konva.isUnminified) {
        return function(val, attr) {
          var isNumber = Konva.Util._isNumber(val);
          var isAuto = val === 'auto';

          if (!(isNumber || isAuto)) {
            Konva.Util.warn(
              Konva.Validators._formatValue(val) +
                ' is a not valid value for "' +
                attr +
                '" attribute. The value should be a number or "auto".'
            );
          }
          return val;
        };
      }
    },
    getStringValidator: function() {
      if (Konva.isUnminified) {
        return function(val, attr) {
          if (!Konva.Util._isString(val)) {
            Konva.Util.warn(
              Konva.Validators._formatValue(val) +
                ' is a not valid value for "' +
                attr +
                '" attribute. The value should be a string.'
            );
          }
          return val;
        };
      }
    },
    getFunctionValidator: function() {
      if (Konva.isUnminified) {
        return function(val, attr) {
          if (!Konva.Util._isFunction(val)) {
            Konva.Util.warn(
              Konva.Validators._formatValue(val) +
                ' is a not valid value for "' +
                attr +
                '" attribute. The value should be a function.'
            );
          }
          return val;
        };
      }
    },
    getNumberArrayValidator: function() {
      if (Konva.isUnminified) {
        return function(val, attr) {
          if (!Konva.Util._isArray(val)) {
            Konva.Util.warn(
              Konva.Validators._formatValue(val) +
                ' is a not valid value for "' +
                attr +
                '" attribute. The value should be a array of numbers.'
            );
          } else {
            val.forEach(function(item) {
              if (!Konva.Util._isNumber(item)) {
                Konva.Util.warn(
                  '"' +
                    attr +
                    '" attribute has non numeric element ' +
                    item +
                    '. Make sure that all elements are numbers.'
                );
              }
            });
          }
          return val;
        };
      }
    },
    getBooleanValidator: function() {
      if (Konva.isUnminified) {
        return function(val, attr) {
          var isBool = val === true || val === false;
          if (!isBool) {
            Konva.Util.warn(
              Konva.Validators._formatValue(val) +
                ' is a not valid value for "' +
                attr +
                '" attribute. The value should be a boolean.'
            );
          }
          return val;
        };
      }
    }
  };
})();

(function(Konva) {
  'use strict';
  // CONSTANTS
  var ABSOLUTE_OPACITY = 'absoluteOpacity',
    ABSOLUTE_TRANSFORM = 'absoluteTransform',
    ABSOLUTE_SCALE = 'absoluteScale',
    CHANGE = 'Change',
    CHILDREN = 'children',
    DOT = '.',
    EMPTY_STRING = '',
    GET = 'get',
    ID = 'id',
    KONVA = 'konva',
    LISTENING = 'listening',
    MOUSEENTER = 'mouseenter',
    MOUSELEAVE = 'mouseleave',
    NAME = 'name',
    SET = 'set',
    SHAPE = 'Shape',
    SPACE = ' ',
    STAGE = 'stage',
    TRANSFORM = 'transform',
    UPPER_STAGE = 'Stage',
    VISIBLE = 'visible',
    CLONE_BLACK_LIST = ['id'],
    TRANSFORM_CHANGE_STR = [
      'xChange.konva',
      'yChange.konva',
      'scaleXChange.konva',
      'scaleYChange.konva',
      'skewXChange.konva',
      'skewYChange.konva',
      'rotationChange.konva',
      'offsetXChange.konva',
      'offsetYChange.konva',
      'transformsEnabledChange.konva'
    ].join(SPACE),
    SCALE_CHANGE_STR = ['scaleXChange.konva', 'scaleYChange.konva'].join(SPACE);

  /**
   * Node constructor. Nodes are entities that can be transformed, layered,
   * and have bound events. The stage, layers, groups, and shapes all extend Node.
   * @constructor
   * @memberof Konva
   * @abstract
   * @param {Object} config
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   */
  Konva.Node = function(config) {
    this._init(config);
  };

  Konva.Util.addMethods(Konva.Node, {
    _init: function(config) {
      this._id = Konva.idCounter++;
      this.eventListeners = {};
      this.attrs = {};
      this._cache = {};
      this._filterUpToDate = false;
      this._isUnderCache = false;
      this.setAttrs(config);

      // event bindings for cache handling
      this.on(TRANSFORM_CHANGE_STR, function() {
        this._clearCache(TRANSFORM);
        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
      });

      this.on(SCALE_CHANGE_STR, function() {
        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
      });

      this.on('visibleChange.konva', function() {
        this._clearSelfAndDescendantCache(VISIBLE);
      });
      this.on('listeningChange.konva', function() {
        this._clearSelfAndDescendantCache(LISTENING);
      });
      this.on('opacityChange.konva', function() {
        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
      });
    },
    _clearCache: function(attr) {
      if (attr) {
        delete this._cache[attr];
      } else {
        this._cache = {};
      }
    },
    _getCache: function(attr, privateGetter) {
      var cache = this._cache[attr];

      // if not cached, we need to set it using the private getter method.
      if (cache === undefined) {
        this._cache[attr] = privateGetter.call(this);
      }

      return this._cache[attr];
    },
    /*
         * when the logic for a cached result depends on ancestor propagation, use this
         * method to clear self and children cache
         */
    _clearSelfAndDescendantCache: function(attr) {
      this._clearCache(attr);

      if (this.children) {
        this.getChildren().each(function(node) {
          node._clearSelfAndDescendantCache(attr);
        });
      }
    },
    /**
     * clear cached canvas
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     * @example
     * node.clearCache();
     */
    clearCache: function() {
      delete this._cache.canvas;
      this._filterUpToDate = false;
      return this;
    },
    /**
     *  cache node to improve drawing performance, apply filters, or create more accurate
     *  hit regions. For all basic shapes size of cache canvas will be automatically detected.
     *  If you need to cache your custom `Konva.Shape` instance you have to pass shape's bounding box
     *  properties. Look at [https://konvajs.github.io/docs/performance/Shape_Caching.html](link to demo page) for more information.
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} [config]
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Number} [config.offset]  increase canvas size by `offset` pixel in all directions.
     * @param {Boolean} [config.drawBorder] when set to true, a red border will be drawn around the cached
     *  region for debugging purposes
     * @param {Number} [config.pixelRatio] change quality (or pixel ratio) of cached image. pixelRatio = 2 will produce 2x sized cache.
     * @returns {Konva.Node}
     * @example
     * // cache a shape with the x,y position of the bounding box at the center and
     * // the width and height of the bounding box equal to the width and height of
     * // the shape obtained from shape.width() and shape.height()
     * image.cache();
     *
     * // cache a node and define the bounding box position and size
     * node.cache({
     *   x: -30,
     *   y: -30,
     *   width: 100,
     *   height: 200
     * });
     *
     * // cache a node and draw a red border around the bounding box
     * // for debugging purposes
     * node.cache({
     *   x: -30,
     *   y: -30,
     *   width: 100,
     *   height: 200,
     *   offset : 10,
     *   drawBorder: true
     * });
     */
    cache: function(config) {
      var conf = config || {};
      var rect = {};

      // don't call getClientRect if we have all attributes
      // it means call it only if have one undefined
      if (
        conf.x === undefined ||
        conf.y === undefined ||
        conf.width === undefined ||
        conf.height === undefined
      ) {
        rect = this.getClientRect({
          skipTransform: true,
          relativeTo: this.getParent()
        });
      }
      var width = conf.width || rect.width,
        height = conf.height || rect.height,
        pixelRatio = conf.pixelRatio,
        x = conf.x === undefined ? rect.x : conf.x,
        y = conf.y === undefined ? rect.y : conf.y,
        offset = conf.offset || 0,
        drawBorder = conf.drawBorder || false;

      if (!width || !height) {
        Konva.Util.error(
          'Can not cache the node. Width or height of the node equals 0. Caching is skipped.'
        );
        return;
      }

      width += offset * 2;
      height += offset * 2;

      x -= offset;
      y -= offset;

      var cachedSceneCanvas = new Konva.SceneCanvas({
          pixelRatio: pixelRatio,
          width: width,
          height: height
        }),
        cachedFilterCanvas = new Konva.SceneCanvas({
          pixelRatio: pixelRatio,
          width: width,
          height: height
        }),
        cachedHitCanvas = new Konva.HitCanvas({
          pixelRatio: 1,
          width: width,
          height: height
        }),
        sceneContext = cachedSceneCanvas.getContext(),
        hitContext = cachedHitCanvas.getContext();

      cachedHitCanvas.isCache = true;

      this.clearCache();

      sceneContext.save();
      hitContext.save();

      sceneContext.translate(-x, -y);
      hitContext.translate(-x, -y);

      // extra flag to skip on getAbsolute opacity calc
      this._isUnderCache = true;
      this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
      this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);

      this.drawScene(cachedSceneCanvas, this, true);
      this.drawHit(cachedHitCanvas, this, true);
      this._isUnderCache = false;

      sceneContext.restore();
      hitContext.restore();

      // this will draw a red border around the cached box for
      // debugging purposes
      if (drawBorder) {
        sceneContext.save();
        sceneContext.beginPath();
        sceneContext.rect(0, 0, width, height);
        sceneContext.closePath();
        sceneContext.setAttr('strokeStyle', 'red');
        sceneContext.setAttr('lineWidth', 5);
        sceneContext.stroke();
        sceneContext.restore();
      }

      this._cache.canvas = {
        scene: cachedSceneCanvas,
        filter: cachedFilterCanvas,
        hit: cachedHitCanvas,
        x: x,
        y: y
      };

      return this;
    },
    /**
     * Return client rectangle {x, y, width, height} of node. This rectangle also include all styling (strokes, shadows, etc).
     * The rectangle position is relative to parent container.
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} config
     * @param {Boolean} [config.skipTransform] should we apply transform to node for calculating rect?
     * @param {Boolean} [config.skipShadow] should we apply shadow to the node for calculating bound box?
     * @param {Object} [config.relativeTo] calculate client rect relative to one of the parents
     * @returns {Object} rect with {x, y, width, height} properties
     * @example
     * var rect = new Konva.Rect({
     *      width : 100,
     *      height : 100,
     *      x : 50,
     *      y : 50,
     *      strokeWidth : 4,
     *      stroke : 'black',
     *      offsetX : 50,
     *      scaleY : 2
     * });
     *
     * // get client rect without think off transformations (position, rotation, scale, offset, etc)
     * rect.getClientRect({ skipTransform: true});
     * // returns {
     * //     x : -2,   // two pixels for stroke / 2
     * //     y : -2,
     * //     width : 104, // increased by 4 for stroke
     * //     height : 104
     * //}
     *
     * // get client rect with transformation applied
     * rect.getClientRect();
     * // returns Object {x: -2, y: 46, width: 104, height: 208}
     */
    getClientRect: function() {
      // abstract method
      // redefine in Container and Shape
      throw new Error('abstract "getClientRect" method call');
    },
    _transformedRect: function(rect, top) {
      var points = [
        { x: rect.x, y: rect.y },
        { x: rect.x + rect.width, y: rect.y },
        { x: rect.x + rect.width, y: rect.y + rect.height },
        { x: rect.x, y: rect.y + rect.height }
      ];
      var minX, minY, maxX, maxY;
      var trans = this.getAbsoluteTransform(top);
      points.forEach(function(point) {
        var transformed = trans.point(point);
        if (minX === undefined) {
          minX = maxX = transformed.x;
          minY = maxY = transformed.y;
        }
        minX = Math.min(minX, transformed.x);
        minY = Math.min(minY, transformed.y);
        maxX = Math.max(maxX, transformed.x);
        maxY = Math.max(maxY, transformed.y);
      });
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    },
    _drawCachedSceneCanvas: function(context) {
      context.save();
      context._applyOpacity(this);
      context._applyGlobalCompositeOperation(this);
      context.translate(this._cache.canvas.x, this._cache.canvas.y);

      var cacheCanvas = this._getCachedSceneCanvas();
      var ratio = cacheCanvas.pixelRatio;

      context.drawImage(
        cacheCanvas._canvas,
        0,
        0,
        cacheCanvas.width / ratio,
        cacheCanvas.height / ratio
      );
      context.restore();
    },
    _drawCachedHitCanvas: function(context) {
      var cachedCanvas = this._cache.canvas,
        hitCanvas = cachedCanvas.hit;
      context.save();
      context.translate(this._cache.canvas.x, this._cache.canvas.y);
      context.drawImage(hitCanvas._canvas, 0, 0);
      context.restore();
    },
    _getCachedSceneCanvas: function() {
      var filters = this.filters(),
        cachedCanvas = this._cache.canvas,
        sceneCanvas = cachedCanvas.scene,
        filterCanvas = cachedCanvas.filter,
        filterContext = filterCanvas.getContext(),
        len,
        imageData,
        n,
        filter;

      if (filters) {
        if (!this._filterUpToDate) {
          var ratio = sceneCanvas.pixelRatio;

          try {
            len = filters.length;
            filterContext.clear();

            // copy cached canvas onto filter context
            filterContext.drawImage(
              sceneCanvas._canvas,
              0,
              0,
              sceneCanvas.getWidth() / ratio,
              sceneCanvas.getHeight() / ratio
            );
            imageData = filterContext.getImageData(
              0,
              0,
              filterCanvas.getWidth(),
              filterCanvas.getHeight()
            );

            // apply filters to filter context
            for (n = 0; n < len; n++) {
              filter = filters[n];
              if (typeof filter !== 'function') {
                Konva.Util.error(
                  'Filter should be type of function, but got ' +
                    typeof filter +
                    ' insted. Please check correct filters'
                );
                continue;
              }
              filter.call(this, imageData);
              filterContext.putImageData(imageData, 0, 0);
            }
          } catch (e) {
            Konva.Util.error('Unable to apply filter. ' + e.message);
          }

          this._filterUpToDate = true;
        }

        return filterCanvas;
      }
      return sceneCanvas;
    },
    /**
     * bind events to the node. KonvaJS supports mouseover, mousemove,
     *  mouseout, mouseenter, mouseleave, mousedown, mouseup, wheel, contextmenu, click, dblclick, touchstart, touchmove,
     *  touchend, tap, dbltap, dragstart, dragmove, and dragend events. The Konva Stage supports
     *  contentMouseover, contentMousemove, contentMouseout, contentMousedown, contentMouseup, contentWheel, contentContextmenu
     *  contentClick, contentDblclick, contentTouchstart, contentTouchmove, contentTouchend, contentTap,
     *  and contentDblTap.  Pass in a string of events delimited by a space to bind multiple events at once
     *  such as 'mousedown mouseup mousemove'. Include a namespace to bind an
     *  event by name such as 'click.foobar'.
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo touchstart.foo'
     * @param {Function} handler The handler function is passed an event object
     * @returns {Konva.Node}
     * @example
     * // add click listener
     * node.on('click', function() {
     *   console.log('you clicked me!');
     * });
     *
     * // get the target node
     * node.on('click', function(evt) {
     *   console.log(evt.target);
     * });
     *
     * // stop event propagation
     * node.on('click', function(evt) {
     *   evt.cancelBubble = true;
     * });
     *
     * // bind multiple listeners
     * node.on('click touchstart', function() {
     *   console.log('you clicked/touched me!');
     * });
     *
     * // namespace listener
     * node.on('click.foo', function() {
     *   console.log('you clicked/touched me!');
     * });
     *
     * // get the event type
     * node.on('click tap', function(evt) {
     *   var eventType = evt.type;
     * });
     *
     * // get native event object
     * node.on('click tap', function(evt) {
     *   var nativeEvent = evt.evt;
     * });
     *
     * // for change events, get the old and new val
     * node.on('xChange', function(evt) {
     *   var oldVal = evt.oldVal;
     *   var newVal = evt.newVal;
     * });
     *
     * // get event targets
     * // with event delegations
     * layer.on('click', 'Group', function(evt) {
     *   var shape = evt.target;
     *   var group = evtn.currentTarger;
     * });
     */
    on: function(evtStr, handler) {
      if (arguments.length === 3) {
        return this._delegate.apply(this, arguments);
      }
      var events = evtStr.split(SPACE),
        len = events.length,
        n,
        event,
        parts,
        baseEvent,
        name;

      /*
             * loop through types and attach event listeners to
             * each one.  eg. 'click mouseover.namespace mouseout'
             * will create three event bindings
             */
      for (n = 0; n < len; n++) {
        event = events[n];
        parts = event.split(DOT);
        baseEvent = parts[0];
        name = parts[1] || EMPTY_STRING;

        // create events array if it doesn't exist
        if (!this.eventListeners[baseEvent]) {
          this.eventListeners[baseEvent] = [];
        }

        this.eventListeners[baseEvent].push({
          name: name,
          handler: handler
        });
      }

      return this;
    },
    /**
     * remove event bindings from the node. Pass in a string of
     *  event types delimmited by a space to remove multiple event
     *  bindings at once such as 'mousedown mouseup mousemove'.
     *  include a namespace to remove an event binding by name
     *  such as 'click.foobar'. If you only give a name like '.foobar',
     *  all events in that namespace will be removed.
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} evtStr e.g. 'click', 'mousedown touchstart', '.foobar'
     * @returns {Konva.Node}
     * @example
     * // remove listener
     * node.off('click');
     *
     * // remove multiple listeners
     * node.off('click touchstart');
     *
     * // remove listener by name
     * node.off('click.foo');
     */
    off: function(evtStr, callback) {
      var events = (evtStr || '').split(SPACE),
        len = events.length,
        n,
        t,
        event,
        parts,
        baseEvent,
        name;

      if (!evtStr) {
        // remove all events
        for (t in this.eventListeners) {
          this._off(t);
        }
      }
      for (n = 0; n < len; n++) {
        event = events[n];
        parts = event.split(DOT);
        baseEvent = parts[0];
        name = parts[1];

        if (baseEvent) {
          if (this.eventListeners[baseEvent]) {
            this._off(baseEvent, name, callback);
          }
        } else {
          for (t in this.eventListeners) {
            this._off(t, name, callback);
          }
        }
      }
      return this;
    },
    // some event aliases for third party integration like HammerJS
    dispatchEvent: function(evt) {
      var e = {
        target: this,
        type: evt.type,
        evt: evt
      };
      this.fire(evt.type, e);
      return this;
    },
    addEventListener: function(type, handler) {
      // we have to pass native event to handler
      this.on(type, function(evt) {
        handler.call(this, evt.evt);
      });
      return this;
    },
    removeEventListener: function(type) {
      this.off(type);
      return this;
    },
    // like node.on
    _delegate: function(event, selector, handler) {
      var stopNode = this;
      this.on(event, function(evt) {
        var targets = evt.target.findAncestors(selector, true, stopNode);
        for (var i = 0; i < targets.length; i++) {
          evt = Konva.Util.cloneObject(evt);
          evt.currentTarget = targets[i];
          handler.call(targets[i], evt);
        }
      });
    },
    /**
     * remove self from parent, but don't destroy. You can reuse node later.
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     * @example
     * node.remove();
     */
    remove: function() {
      var parent = this.getParent();

      if (parent && parent.children) {
        parent.children.splice(this.index, 1);
        parent._setChildrenIndices();
        delete this.parent;
      }

      // every cached attr that is calculated via node tree
      // traversal must be cleared when removing a node
      this._clearSelfAndDescendantCache(STAGE);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
      this._clearSelfAndDescendantCache(VISIBLE);
      this._clearSelfAndDescendantCache(LISTENING);
      this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);

      return this;
    },
    /**
     * remove and destroy a node. Kill it forever! You should not reuse node after destroy().
     * @method
     * @memberof Konva.Node.prototype
     * @example
     * node.destroy();
     */
    destroy: function() {
      // remove from ids and names hashes
      Konva._removeId(this.getId());

      // remove all names
      var names = (this.getName() || '').split(/\s/g);
      for (var i = 0; i < names.length; i++) {
        var subname = names[i];
        Konva._removeName(subname, this._id);
      }

      this.remove();
      return this;
    },
    /**
     * get attr
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} attr
     * @returns {Integer|String|Object|Array}
     * @example
     * var x = node.getAttr('x');
     */
    getAttr: function(attr) {
      var method = GET + Konva.Util._capitalize(attr);
      if (Konva.Util._isFunction(this[method])) {
        return this[method]();
      }
      // otherwise get directly
      return this.attrs[attr];
    },
    /**
     * get ancestors
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Collection}
     * @example
     * shape.getAncestors().each(function(node) {
     *   console.log(node.getId());
     * })
     */
    getAncestors: function() {
      var parent = this.getParent(),
        ancestors = new Konva.Collection();

      while (parent) {
        ancestors.push(parent);
        parent = parent.getParent();
      }

      return ancestors;
    },
    /**
     * get attrs object literal
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     */
    getAttrs: function() {
      return this.attrs || {};
    },
    /**
     * set multiple attrs at once using an object literal
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} config object containing key value pairs
     * @returns {Konva.Node}
     * @example
     * node.setAttrs({
     *   x: 5,
     *   fill: 'red'
     * });
     */
    setAttrs: function(config) {
      var key, method;

      if (!config) {
        return this;
      }
      for (key in config) {
        if (key === CHILDREN) {
          continue;
        }
        method = SET + Konva.Util._capitalize(key);
        // use setter if available
        if (Konva.Util._isFunction(this[method])) {
          this[method](config[key]);
        } else {
          // otherwise set directly
          this._setAttr(key, config[key]);
        }
      }
      return this;
    },
    /**
     * determine if node is listening for events by taking into account ancestors.
     *
     * Parent    | Self      | isListening
     * listening | listening |
     * ----------+-----------+------------
     * T         | T         | T
     * T         | F         | F
     * F         | T         | T
     * F         | F         | F
     * ----------+-----------+------------
     * T         | I         | T
     * F         | I         | F
     * I         | I         | T
     *
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean}
     */
    isListening: function() {
      return this._getCache(LISTENING, this._isListening);
    },
    _isListening: function() {
      var listening = this.getListening(),
        parent = this.getParent();

      // the following conditions are a simplification of the truth table above.
      // please modify carefully
      if (listening === 'inherit') {
        if (parent) {
          return parent.isListening();
        } else {
          return true;
        }
      } else {
        return listening;
      }
    },
    /**
     * determine if node is visible by taking into account ancestors.
     *
     * Parent    | Self      | isVisible
     * visible   | visible   |
     * ----------+-----------+------------
     * T         | T         | T
     * T         | F         | F
     * F         | T         | T
     * F         | F         | F
     * ----------+-----------+------------
     * T         | I         | T
     * F         | I         | F
     * I         | I         | T

      * @method
      * @memberof Konva.Node.prototype
      * @returns {Boolean}
      */
    isVisible: function() {
      return this._getCache(VISIBLE, this._isVisible);
    },
    _isVisible: function(relativeTo) {
      var visible = this.getVisible(),
        parent = this.getParent();

      if (relativeTo === parent && visible === 'inherit') {
        return true;
      } else if (relativeTo === parent) {
        return visible;
      }
      // the following conditions are a simplification of the truth table above.
      // please modify carefully
      if (visible === 'inherit') {
        if (parent) {
          return parent._isVisible(relativeTo);
        } else {
          return true;
        }
      } else {
        return visible;
      }
    },
    /**
     * determine if listening is enabled by taking into account descendants.  If self or any children
     * have _isListeningEnabled set to true, then self also has listening enabled.
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean}
     */
    shouldDrawHit: function() {
      var layer = this.getLayer();

      return (
        (!layer && this.isListening() && this.isVisible()) ||
        (layer &&
          layer.hitGraphEnabled() &&
          this.isListening() &&
          this.isVisible())
      );
    },
    /**
     * show node
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     */
    show: function() {
      this.setVisible(true);
      return this;
    },
    /**
     * hide node.  Hidden nodes are no longer detectable
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     */
    hide: function() {
      this.setVisible(false);
      return this;
    },
    /**
     * get zIndex relative to the node's siblings who share the same parent
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Integer}
     */
    getZIndex: function() {
      return this.index || 0;
    },
    /**
     * get absolute z-index which takes into account sibling
     *  and ancestor indices
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Integer}
     */
    getAbsoluteZIndex: function() {
      var depth = this.getDepth(),
        that = this,
        index = 0,
        nodes,
        len,
        n,
        child;

      function addChildren(children) {
        nodes = [];
        len = children.length;
        for (n = 0; n < len; n++) {
          child = children[n];
          index++;

          if (child.nodeType !== SHAPE) {
            nodes = nodes.concat(child.getChildren().toArray());
          }

          if (child._id === that._id) {
            n = len;
          }
        }

        if (nodes.length > 0 && nodes[0].getDepth() <= depth) {
          addChildren(nodes);
        }
      }
      if (that.nodeType !== UPPER_STAGE) {
        addChildren(that.getStage().getChildren());
      }

      return index;
    },
    /**
     * get node depth in node tree.  Returns an integer.
     *  e.g. Stage depth will always be 0.  Layers will always be 1.  Groups and Shapes will always
     *  be >= 2
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Integer}
     */
    getDepth: function() {
      var depth = 0,
        parent = this.parent;

      while (parent) {
        depth++;
        parent = parent.parent;
      }
      return depth;
    },
    setPosition: function(pos) {
      this.setX(pos.x);
      this.setY(pos.y);
      return this;
    },
    getPosition: function() {
      return {
        x: this.getX(),
        y: this.getY()
      };
    },
    /**
     * get absolute position relative to the top left corner of the stage container div
     * or relative to passed node
     * @method
     * @param {Object} [top] optional parent node
     * @memberof Konva.Node.prototype
     * @returns {Object}
     */
    getAbsolutePosition: function(top) {
      var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(),
        absoluteTransform = new Konva.Transform(),
        offset = this.offset();

      // clone the matrix array
      absoluteTransform.m = absoluteMatrix.slice();
      absoluteTransform.translate(offset.x, offset.y);

      return absoluteTransform.getTranslation();
    },
    /**
     * set absolute position
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} pos
     * @param {Number} pos.x
     * @param {Number} pos.y
     * @returns {Konva.Node}
     */
    setAbsolutePosition: function(pos) {
      var origTrans = this._clearTransform(),
        it;

      // don't clear translation
      this.attrs.x = origTrans.x;
      this.attrs.y = origTrans.y;
      delete origTrans.x;
      delete origTrans.y;

      // unravel transform
      it = this.getAbsoluteTransform();

      it.invert();
      it.translate(pos.x, pos.y);
      pos = {
        x: this.attrs.x + it.getTranslation().x,
        y: this.attrs.y + it.getTranslation().y
      };

      this.setPosition({ x: pos.x, y: pos.y });
      this._setTransform(origTrans);

      return this;
    },
    _setTransform: function(trans) {
      var key;

      for (key in trans) {
        this.attrs[key] = trans[key];
      }

      this._clearCache(TRANSFORM);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    },
    _clearTransform: function() {
      var trans = {
        x: this.getX(),
        y: this.getY(),
        rotation: this.getRotation(),
        scaleX: this.getScaleX(),
        scaleY: this.getScaleY(),
        offsetX: this.getOffsetX(),
        offsetY: this.getOffsetY(),
        skewX: this.getSkewX(),
        skewY: this.getSkewY()
      };

      this.attrs.x = 0;
      this.attrs.y = 0;
      this.attrs.rotation = 0;
      this.attrs.scaleX = 1;
      this.attrs.scaleY = 1;
      this.attrs.offsetX = 0;
      this.attrs.offsetY = 0;
      this.attrs.skewX = 0;
      this.attrs.skewY = 0;

      this._clearCache(TRANSFORM);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);

      // return original transform
      return trans;
    },
    /**
     * move node by an amount relative to its current position
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} change
     * @param {Number} change.x
     * @param {Number} change.y
     * @returns {Konva.Node}
     * @example
     * // move node in x direction by 1px and y direction by 2px
     * node.move({
     *   x: 1,
     *   y: 2)
     * });
     */
    move: function(change) {
      var changeX = change.x,
        changeY = change.y,
        x = this.getX(),
        y = this.getY();

      if (changeX !== undefined) {
        x += changeX;
      }

      if (changeY !== undefined) {
        y += changeY;
      }

      this.setPosition({ x: x, y: y });
      return this;
    },
    _eachAncestorReverse: function(func, top) {
      var family = [],
        parent = this.getParent(),
        len,
        n;

      // if top node is defined, and this node is top node,
      // there's no need to build a family tree.  just execute
      // func with this because it will be the only node
      if (top && top._id === this._id) {
        func(this);
        return;
      }

      family.unshift(this);

      while (parent && (!top || parent._id !== top._id)) {
        family.unshift(parent);
        parent = parent.parent;
      }

      len = family.length;
      for (n = 0; n < len; n++) {
        func(family[n]);
      }
    },
    /**
     * rotate node by an amount in degrees relative to its current rotation
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} theta
     * @returns {Konva.Node}
     */
    rotate: function(theta) {
      this.setRotation(this.getRotation() + theta);
      return this;
    },
    /**
     * move node to the top of its siblings
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean}
     */
    moveToTop: function() {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. moveToTop function is ignored.');
        return false;
      }
      var index = this.index;
      this.parent.children.splice(index, 1);
      this.parent.children.push(this);
      this.parent._setChildrenIndices();
      return true;
    },
    /**
     * move node up
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean} flag is moved or not
     */
    moveUp: function() {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. moveUp function is ignored.');
        return false;
      }
      var index = this.index,
        len = this.parent.getChildren().length;
      if (index < len - 1) {
        this.parent.children.splice(index, 1);
        this.parent.children.splice(index + 1, 0, this);
        this.parent._setChildrenIndices();
        return true;
      }
      return false;
    },
    /**
     * move node down
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean}
     */
    moveDown: function() {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. moveDown function is ignored.');
        return false;
      }
      var index = this.index;
      if (index > 0) {
        this.parent.children.splice(index, 1);
        this.parent.children.splice(index - 1, 0, this);
        this.parent._setChildrenIndices();
        return true;
      }
      return false;
    },
    /**
     * move node to the bottom of its siblings
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean}
     */
    moveToBottom: function() {
      if (!this.parent) {
        Konva.Util.warn(
          'Node has no parent. moveToBottom function is ignored.'
        );
        return false;
      }
      var index = this.index;
      if (index > 0) {
        this.parent.children.splice(index, 1);
        this.parent.children.unshift(this);
        this.parent._setChildrenIndices();
        return true;
      }
      return false;
    },
    /**
     * set zIndex relative to siblings
     * @method
     * @memberof Konva.Node.prototype
     * @param {Integer} zIndex
     * @returns {Konva.Node}
     */
    setZIndex: function(zIndex) {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. zIndex parameter is ignored.');
        return false;
      }
      var index = this.index;
      this.parent.children.splice(index, 1);
      this.parent.children.splice(zIndex, 0, this);
      this.parent._setChildrenIndices();
      return this;
    },
    /**
     * get absolute opacity
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     */
    getAbsoluteOpacity: function() {
      return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
    },
    _getAbsoluteOpacity: function() {
      var absOpacity = this.getOpacity();
      var parent = this.getParent();
      if (parent && !parent._isUnderCache) {
        absOpacity *= this.getParent().getAbsoluteOpacity();
      }
      return absOpacity;
    },
    /**
     * move node to another container
     * @method
     * @memberof Konva.Node.prototype
     * @param {Container} newContainer
     * @returns {Konva.Node}
     * @example
     * // move node from current layer into layer2
     * node.moveTo(layer2);
     */
    moveTo: function(newContainer) {
      // do nothing if new container is already parent
      if (this.getParent() !== newContainer) {
        // this.remove my be overrided by drag and drop
        // buy we need original
        (this.__originalRemove || this.remove).call(this);
        newContainer.add(this);
      }
      return this;
    },
    /**
     * convert Node into an object for serialization.  Returns an object.
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     */
    toObject: function() {
      var obj = {},
        attrs = this.getAttrs(),
        key,
        val,
        getter,
        defaultValue;

      obj.attrs = {};

      for (key in attrs) {
        val = attrs[key];
        getter = typeof this[key] === 'function' && this[key];
        // remove attr value so that we can extract the default value from the getter
        delete attrs[key];
        defaultValue = getter ? getter.call(this) : null;
        // restore attr value
        attrs[key] = val;
        if (defaultValue !== val) {
          obj.attrs[key] = val;
        }
      }

      obj.className = this.getClassName();
      return Konva.Util._prepareToStringify(obj);
    },
    /**
     * convert Node into a JSON string.  Returns a JSON string.
     * @method
     * @memberof Konva.Node.prototype
     * @returns {String}}
     */
    toJSON: function() {
      return JSON.stringify(this.toObject());
    },
    /**
     * get parent container
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     */
    getParent: function() {
      return this.parent;
    },
    /**
     * get all ancestros (parent then parent of the parent, etc) of the node
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} [selector] selector for search
     * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
     * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
     * @returns {Array} [ancestors]
     * @example
     * // get one of the parent group
     * var parentGroups = node.findAncestors('Group');
     */
    findAncestors: function(selector, includeSelf, stopNode) {
      var res = [];

      if (includeSelf && this._isMatch(selector)) {
        res.push(this);
      }
      var ancestor = this.parent;
      while (ancestor) {
        if (ancestor === stopNode) {
          return res;
        }
        if (ancestor._isMatch(selector)) {
          res.push(ancestor);
        }
        ancestor = ancestor.parent;
      }
      return res;
    },
    /**
     * get ancestor (parent or parent of the parent, etc) of the node that match passed selector
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} [selector] selector for search
     * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
     * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
     * @returns {Konva.Node} ancestor
     * @example
     * // get one of the parent group
     * var group = node.findAncestors('.mygroup');
     */
    findAncestor: function(selector, includeSelf, stopNode) {
      return this.findAncestors(selector, includeSelf, stopNode)[0];
    },
    // is current node match passed selector?
    _isMatch: function(selector) {
      if (!selector) {
        return false;
      }
      var selectorArr = selector.replace(/ /g, '').split(','),
        len = selectorArr.length,
        n,
        sel;

      for (n = 0; n < len; n++) {
        sel = selectorArr[n];
        if (!Konva.Util.isValidSelector(sel)) {
          Konva.Util.warn(
            'Selector "' +
              sel +
              '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'
          );
          Konva.Util.warn(
            'If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'
          );
          Konva.Util.warn('Konva is awesome, right?');
        }
        // id selector
        if (sel.charAt(0) === '#') {
          if (this.id() === sel.slice(1)) {
            return true;
          }
        } else if (sel.charAt(0) === '.') {
          // name selector
          if (this.hasName(sel.slice(1))) {
            return true;
          }
        } else if (this._get(sel).length !== 0) {
          return true;
        }
      }
      return false;
    },
    /**
     * get layer ancestor
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Layer}
     */
    getLayer: function() {
      var parent = this.getParent();
      return parent ? parent.getLayer() : null;
    },
    /**
     * get stage ancestor
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Stage}
     */
    getStage: function() {
      return this._getCache(STAGE, this._getStage);
    },
    _getStage: function() {
      var parent = this.getParent();
      if (parent) {
        return parent.getStage();
      } else {
        return undefined;
      }
    },
    /**
     * fire event
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} eventType event type.  can be a regular event, like click, mouseover, or mouseout, or it can be a custom event, like myCustomEvent
     * @param {Event} [evt] event object
     * @param {Boolean} [bubble] setting the value to false, or leaving it undefined, will result in the event
     *  not bubbling.  Setting the value to true will result in the event bubbling.
     * @returns {Konva.Node}
     * @example
     * // manually fire click event
     * node.fire('click');
     *
     * // fire custom event
     * node.fire('foo');
     *
     * // fire custom event with custom event object
     * node.fire('foo', {
     *   bar: 10
     * });
     *
     * // fire click event that bubbles
     * node.fire('click', null, true);
     */
    fire: function(eventType, evt, bubble) {
      evt = evt || {};
      evt.target = evt.target || this;
      // bubble
      if (bubble) {
        this._fireAndBubble(eventType, evt);
      } else {
        // no bubble
        this._fire(eventType, evt);
      }
      return this;
    },
    /**
     * get absolute transform of the node which takes into
     *  account its ancestor transforms
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Transform}
     */
    getAbsoluteTransform: function(top) {
      // if using an argument, we can't cache the result.
      if (top) {
        return this._getAbsoluteTransform(top);
      } else {
        // if no argument, we can cache the result
        return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
      }
    },
    _getAbsoluteTransform: function(top) {
      var at = new Konva.Transform();

      // start with stage and traverse downwards to self
      this._eachAncestorReverse(function(node) {
        var transformsEnabled = node.transformsEnabled();

        if (transformsEnabled === 'all') {
          at.multiply(node.getTransform());
        } else if (transformsEnabled === 'position') {
          at.translate(
            node.getX() - node.getOffsetX(),
            node.getY() - node.getOffsetY()
          );
        }
      }, top);
      return at;
    },
    /**
     * get absolute scale of the node which takes into
     *  account its ancestor scales
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Transform}
     */
    getAbsoluteScale: function(top) {
      // if using an argument, we can't cache the result.
      if (top) {
        return this._getAbsoluteScale(top);
      } else {
        // if no argument, we can cache the result
        return this._getCache(ABSOLUTE_SCALE, this._getAbsoluteScale);
      }
    },
    _getAbsoluteScale: function(top) {
      // this is special logic for caching with some shapes with shadow
      var parent = this;
      while (parent) {
        if (parent._isUnderCache) {
          top = parent;
        }
        parent = parent.getParent();
      }

      var scaleX = 1,
        scaleY = 1;

      // start with stage and traverse downwards to self
      this._eachAncestorReverse(function(node) {
        scaleX *= node.scaleX();
        scaleY *= node.scaleY();
      }, top);
      return {
        x: scaleX,
        y: scaleY
      };
    },
    /**
     * get transform of the node
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Transform}
     */
    getTransform: function() {
      return this._getCache(TRANSFORM, this._getTransform);
    },
    _getTransform: function() {
      var m = new Konva.Transform(),
        x = this.getX(),
        y = this.getY(),
        rotation = Konva.getAngle(this.getRotation()),
        scaleX = this.getScaleX(),
        scaleY = this.getScaleY(),
        skewX = this.getSkewX(),
        skewY = this.getSkewY(),
        offsetX = this.getOffsetX(),
        offsetY = this.getOffsetY();

      if (x !== 0 || y !== 0) {
        m.translate(x, y);
      }
      if (rotation !== 0) {
        m.rotate(rotation);
      }
      if (skewX !== 0 || skewY !== 0) {
        m.skew(skewX, skewY);
      }
      if (scaleX !== 1 || scaleY !== 1) {
        m.scale(scaleX, scaleY);
      }
      if (offsetX !== 0 || offsetY !== 0) {
        m.translate(-1 * offsetX, -1 * offsetY);
      }

      return m;
    },
    /**
     * clone node.  Returns a new Node instance with identical attributes.  You can also override
     *  the node properties with an object literal, enabling you to use an existing node as a template
     *  for another node
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} obj override attrs
     * @returns {Konva.Node}
     * @example
     * // simple clone
     * var clone = node.clone();
     *
     * // clone a node and override the x position
     * var clone = rect.clone({
     *   x: 5
     * });
     */
    clone: function(obj) {
      // instantiate new node
      var attrs = Konva.Util.cloneObject(this.attrs),
        key,
        allListeners,
        len,
        n,
        listener;
      // filter black attrs
      for (var i in CLONE_BLACK_LIST) {
        var blockAttr = CLONE_BLACK_LIST[i];
        delete attrs[blockAttr];
      }
      // apply attr overrides
      for (key in obj) {
        attrs[key] = obj[key];
      }

      var node = new this.constructor(attrs);
      // copy over listeners
      for (key in this.eventListeners) {
        allListeners = this.eventListeners[key];
        len = allListeners.length;
        for (n = 0; n < len; n++) {
          listener = allListeners[n];
          /*
                     * don't include konva namespaced listeners because
                     *  these are generated by the constructors
                     */
          if (listener.name.indexOf(KONVA) < 0) {
            // if listeners array doesn't exist, then create it
            if (!node.eventListeners[key]) {
              node.eventListeners[key] = [];
            }
            node.eventListeners[key].push(listener);
          }
        }
      }
      return node;
    },
    _toKonvaCanvas: function(config) {
      config = config || {};

      var box = this.getClientRect();

      var stage = this.getStage(),
        x = config.x !== undefined ? config.x : box.x,
        y = config.y !== undefined ? config.y : box.y,
        pixelRatio = config.pixelRatio || 1,
        canvas = new Konva.SceneCanvas({
          width: config.width || box.width || (stage ? stage.getWidth() : 0),
          height:
            config.height || box.height || (stage ? stage.getHeight() : 0),
          pixelRatio: pixelRatio
        }),
        context = canvas.getContext();

      context.save();

      if (x || y) {
        context.translate(-1 * x, -1 * y);
      }

      this.drawScene(canvas);
      context.restore();

      return canvas;
    },
    /**
     * converts node into an canvas element.
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} config
     * @param {Function} config.callback function executed when the composite has completed
     * @param {Number} [config.x] x position of canvas section
     * @param {Number} [config.y] y position of canvas section
     * @param {Number} [config.width] width of canvas section
     * @param {Number} [config.height] height of canvas section
     * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image.  Default is 1.
     * @example
     * var canvas = node.toCanvas();
     */
    toCanvas: function(config) {
      return this._toKonvaCanvas(config)._canvas;
    },
    /**
     * Creates a composite data URL. If MIME type is not
     * specified, then "image/png" will result. For "image/jpeg", specify a quality
     * level as quality (range 0.0 - 1.0)
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} config
     * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
     *  "image/png" is the default
     * @param {Number} [config.x] x position of canvas section
     * @param {Number} [config.y] y position of canvas section
     * @param {Number} [config.width] width of canvas section
     * @param {Number} [config.height] height of canvas section
     * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
     *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
     *  is very high quality
     * @param {Number} [config.pixelRatio] pixelRatio of output image url. Default is 1
     * @returns {String}
     */
    toDataURL: function(config) {
      config = config || {};
      var mimeType = config.mimeType || null,
        quality = config.quality || null;
      var url = this._toKonvaCanvas(config).toDataURL(mimeType, quality);
      if (config.callback) {
        config.callback(url);
      }
      return url;
    },
    /**
     * converts node into an image.  Since the toImage
     *  method is asynchronous, a callback is required.  toImage is most commonly used
     *  to cache complex drawings as an image so that they don't have to constantly be redrawn
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} config
     * @param {Function} config.callback function executed when the composite has completed
     * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
     *  "image/png" is the default
     * @param {Number} [config.x] x position of canvas section
     * @param {Number} [config.y] y position of canvas section
     * @param {Number} [config.width] width of canvas section
     * @param {Number} [config.height] height of canvas section
     * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
     *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
     *  is very high quality
     * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image.  Default is 1.
     * @example
     * var image = node.toImage({
     *   callback: function(img) {
     *     // do stuff with img
     *   }
     * });
     */
    toImage: function(config) {
      if (!config || !config.callback) {
        throw 'callback required for toImage method config argument';
      }
      var callback = config.callback;
      delete config.callback;
      Konva.Util._getImage(this.toDataURL(config), function(img) {
        callback(img);
      });
    },
    setSize: function(size) {
      this.setWidth(size.width);
      this.setHeight(size.height);
      return this;
    },
    getSize: function() {
      return {
        width: this.getWidth(),
        height: this.getHeight()
      };
    },
    getWidth: function() {
      return this.attrs.width || 0;
    },
    getHeight: function() {
      return this.attrs.height || 0;
    },
    /**
     * get class name, which may return Stage, Layer, Group, or shape class names like Rect, Circle, Text, etc.
     * @method
     * @memberof Konva.Node.prototype
     * @returns {String}
     */
    getClassName: function() {
      return this.className || this.nodeType;
    },
    /**
     * get the node type, which may return Stage, Layer, Group, or Node
     * @method
     * @memberof Konva.Node.prototype
     * @returns {String}
     */
    getType: function() {
      return this.nodeType;
    },
    getDragDistance: function() {
      // compare with undefined because we need to track 0 value
      if (this.attrs.dragDistance !== undefined) {
        return this.attrs.dragDistance;
      } else if (this.parent) {
        return this.parent.getDragDistance();
      } else {
        return Konva.dragDistance;
      }
    },
    _get: function(selector) {
      return this.className === selector || this.nodeType === selector
        ? [this]
        : [];
    },
    _off: function(type, name, callback) {
      var evtListeners = this.eventListeners[type],
        i,
        evtName,
        handler;

      for (i = 0; i < evtListeners.length; i++) {
        evtName = evtListeners[i].name;
        handler = evtListeners[i].handler;

        // the following two conditions must be true in order to remove a handler:
        // 1) the current event name cannot be konva unless the event name is konva
        //    this enables developers to force remove a konva specific listener for whatever reason
        // 2) an event name is not specified, or if one is specified, it matches the current event name
        if (
          (evtName !== 'konva' || name === 'konva') &&
          (!name || evtName === name) &&
          (!callback || callback === handler)
        ) {
          evtListeners.splice(i, 1);
          if (evtListeners.length === 0) {
            delete this.eventListeners[type];
            break;
          }
          i--;
        }
      }
    },
    _fireChangeEvent: function(attr, oldVal, newVal) {
      this._fire(attr + CHANGE, {
        oldVal: oldVal,
        newVal: newVal
      });
    },
    setId: function(id) {
      var oldId = this.getId();

      Konva._removeId(oldId);
      Konva._addId(this, id);
      this._setAttr(ID, id);
      return this;
    },
    setName: function(name) {
      var oldNames = (this.getName() || '').split(/\s/g);
      var newNames = (name || '').split(/\s/g);
      var subname, i;
      // remove all subnames
      for (i = 0; i < oldNames.length; i++) {
        subname = oldNames[i];
        if (newNames.indexOf(subname) === -1 && subname) {
          Konva._removeName(subname, this._id);
        }
      }

      // add new names
      for (i = 0; i < newNames.length; i++) {
        subname = newNames[i];
        if (oldNames.indexOf(subname) === -1 && subname) {
          Konva._addName(this, subname);
        }
      }

      this._setAttr(NAME, name);
      return this;
    },
    // naming methods
    /**
     * add name to node
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} name
     * @returns {Konva.Node}
     * @example
     * node.name('red');
     * node.addName('selected');
     * node.name(); // return 'red selected'
     */
    addName: function(name) {
      if (!this.hasName(name)) {
        var oldName = this.name();
        var newName = oldName ? oldName + ' ' + name : name;
        this.setName(newName);
      }
      return this;
    },
    /**
     * check is node has name
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} name
     * @returns {Boolean}
     * @example
     * node.name('red');
     * node.hasName('red');   // return true
     * node.hasName('selected'); // return false
     */
    hasName: function(name) {
      var names = (this.name() || '').split(/\s/g);
      return names.indexOf(name) !== -1;
    },
    /**
     * remove name from node
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} name
     * @returns {Konva.Node}
     * @example
     * node.name('red selected');
     * node.removeName('selected');
     * node.hasName('selected'); // return false
     * node.name(); // return 'red'
     */
    removeName: function(name) {
      var names = (this.name() || '').split(/\s/g);
      var index = names.indexOf(name);
      if (index !== -1) {
        names.splice(index, 1);
        this.setName(names.join(' '));
      }
      return this;
    },
    /**
     * set attr
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} attr
     * @param {*} val
     * @returns {Konva.Node}
     * @example
     * node.setAttr('x', 5);
     */
    setAttr: function(attr, val) {
      var method = SET + Konva.Util._capitalize(attr),
        func = this[method];

      if (Konva.Util._isFunction(func)) {
        func.call(this, val);
      } else {
        // otherwise set directly
        this._setAttr(attr, val);
      }
      return this;
    },
    _setAttr: function(key, val) {
      var oldVal;
      oldVal = this.attrs[key];
      var same = oldVal === val;
      if (same && !Konva.Util.isObject(val)) {
        return;
      }
      if (val === undefined || val === null) {
        delete this.attrs[key];
      } else {
        this.attrs[key] = val;
      }
      this._fireChangeEvent(key, oldVal, val);
    },
    _setComponentAttr: function(key, component, val) {
      var oldVal;
      if (val !== undefined) {
        oldVal = this.attrs[key];

        if (!oldVal) {
          // set value to default value using getAttr
          this.attrs[key] = this.getAttr(key);
        }

        this.attrs[key][component] = val;
        this._fireChangeEvent(key, oldVal, val);
      }
    },
    _fireAndBubble: function(eventType, evt, compareShape) {
      var okayToRun = true;

      if (evt && this.nodeType === SHAPE) {
        evt.target = this;
      }

      if (
        eventType === MOUSEENTER &&
        compareShape &&
        (this._id === compareShape._id ||
          (this.isAncestorOf && this.isAncestorOf(compareShape)))
      ) {
        okayToRun = false;
      } else if (
        eventType === MOUSELEAVE &&
        compareShape &&
        (this._id === compareShape._id ||
          (this.isAncestorOf && this.isAncestorOf(compareShape)))
      ) {
        okayToRun = false;
      }
      if (okayToRun) {
        this._fire(eventType, evt);

        // simulate event bubbling
        var stopBubble =
          (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&
          (compareShape &&
            compareShape.isAncestorOf &&
            compareShape.isAncestorOf(this) &&
            !compareShape.isAncestorOf(this.parent));
        if (
          ((evt && !evt.cancelBubble) || !evt) &&
          this.parent &&
          this.parent.isListening() &&
          !stopBubble
        ) {
          if (compareShape && compareShape.parent) {
            this._fireAndBubble.call(
              this.parent,
              eventType,
              evt,
              compareShape.parent
            );
          } else {
            this._fireAndBubble.call(this.parent, eventType, evt);
          }
        }
      }
    },
    _fire: function(eventType, evt) {
      var events = this.eventListeners[eventType],
        i;

      evt = evt || {};
      evt.currentTarget = this;
      evt.type = eventType;

      if (events) {
        for (i = 0; i < events.length; i++) {
          events[i].handler.call(this, evt);
        }
      }
    },
    /**
     * draw both scene and hit graphs.  If the node being drawn is the stage, all of the layers will be cleared and redrawn
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     */
    draw: function() {
      this.drawScene();
      this.drawHit();
      return this;
    }
  });

  /**
   * create node with JSON string or an Object.  De-serializtion does not generate custom
   *  shape drawing functions, images, or event handlers (this would make the
   *  serialized object huge).  If your app uses custom shapes, images, and
   *  event handlers (it probably does), then you need to select the appropriate
   *  shapes after loading the stage and set these properties via on(), setSceneFunc(),
   *  and setImage() methods
   * @method
   * @memberof Konva.Node
   * @param {String|Object} json string or object
   * @param {Element} [container] optional container dom element used only if you're
   *  creating a stage node
   */
  Konva.Node.create = function(data, container) {
    if (Konva.Util._isString(data)) {
      data = JSON.parse(data);
    }
    return this._createNode(data, container);
  };
  Konva.Node._createNode = function(obj, container) {
    var className = Konva.Node.prototype.getClassName.call(obj),
      children = obj.children,
      no,
      len,
      n;

    // if container was passed in, add it to attrs
    if (container) {
      obj.attrs.container = container;
    }

    no = new Konva[className](obj.attrs);
    if (children) {
      len = children.length;
      for (n = 0; n < len; n++) {
        no.add(this._createNode(children[n]));
      }
    }

    return no;
  };

  // =========================== add getters setters ===========================

  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'position');
  /**
   * get/set node position relative to parent
   * @name position
   * @method
   * @memberof Konva.Node.prototype
   * @param {Object} pos
   * @param {Number} pos.x
   * @param {Number} pos.y
   * @returns {Object}
   * @example
   * // get position
   * var position = node.position();
   *
   * // set position
   * node.position({
   *   x: 5
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'x',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set x position
   * @name x
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} x
   * @returns {Object}
   * @example
   * // get x
   * var x = node.x();
   *
   * // set x
   * node.x(5);
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'y',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set y position
   * @name y
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} y
   * @returns {Integer}
   * @example
   * // get y
   * var y = node.y();
   *
   * // set y
   * node.y(5);
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'globalCompositeOperation',
    'source-over',
    Konva.Validators.getStringValidator()
  );

  /**
   * get/set globalCompositeOperation of a shape
   * @name globalCompositeOperation
   * @method
   * @memberof Konva.Node.prototype
   * @param {String} type
   * @returns {String}
   * @example
   * // get globalCompositeOperation
   * var globalCompositeOperation = shape.globalCompositeOperation();
   *
   * // set globalCompositeOperation
   * shape.globalCompositeOperation('source-in');
   */
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'opacity',
    1,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set opacity.  Opacity values range from 0 to 1.
   *  A node with an opacity of 0 is fully transparent, and a node
   *  with an opacity of 1 is fully opaque
   * @name opacity
   * @method
   * @memberof Konva.Node.prototype
   * @param {Object} opacity
   * @returns {Number}
   * @example
   * // get opacity
   * var opacity = node.opacity();
   *
   * // set opacity
   * node.opacity(0.5);
   */

  Konva.Factory.addGetter(Konva.Node, 'name');
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'name');

  /**
   * get/set name
   * @name name
   * @method
   * @memberof Konva.Node.prototype
   * @param {String} name
   * @returns {String}
   * @example
   * // get name
   * var name = node.name();
   *
   * // set name
   * node.name('foo');
   *
   * // also node may have multiple names (as css classes)
   * node.name('foo bar');
   */

  Konva.Factory.addGetter(Konva.Node, 'id');
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'id');

  /**
   * get/set id. Id is global for whole page.
   * @name id
   * @method
   * @memberof Konva.Node.prototype
   * @param {String} id
   * @returns {String}
   * @example
   * // get id
   * var name = node.id();
   *
   * // set id
   * node.id('foo');
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'rotation',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set rotation in degrees
   * @name rotation
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} rotation
   * @returns {Number}
   * @example
   * // get rotation in degrees
   * var rotation = node.rotation();
   *
   * // set rotation in degrees
   * node.rotation(45);
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Node, 'scale', ['x', 'y']);

  /**
   * get/set scale
   * @name scale
   * @param {Object} scale
   * @param {Number} scale.x
   * @param {Number} scale.y
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Object}
   * @example
   * // get scale
   * var scale = node.scale();
   *
   * // set scale
   * shape.scale({
   *   x: 2
   *   y: 3
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'scaleX',
    1,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set scale x
   * @name scaleX
   * @param {Number} x
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Number}
   * @example
   * // get scale x
   * var scaleX = node.scaleX();
   *
   * // set scale x
   * node.scaleX(2);
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'scaleY',
    1,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set scale y
   * @name scaleY
   * @param {Number} y
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Number}
   * @example
   * // get scale y
   * var scaleY = node.scaleY();
   *
   * // set scale y
   * node.scaleY(2);
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Node, 'skew', ['x', 'y']);

  /**
   * get/set skew
   * @name skew
   * @param {Object} skew
   * @param {Number} skew.x
   * @param {Number} skew.y
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Object}
   * @example
   * // get skew
   * var skew = node.skew();
   *
   * // set skew
   * node.skew({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'skewX',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set skew x
   * @name skewX
   * @param {Number} x
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Number}
   * @example
   * // get skew x
   * var skewX = node.skewX();
   *
   * // set skew x
   * node.skewX(3);
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'skewY',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set skew y
   * @name skewY
   * @param {Number} y
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Number}
   * @example
   * // get skew y
   * var skewY = node.skewY();
   *
   * // set skew y
   * node.skewY(3);
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Node, 'offset', ['x', 'y']);

  /**
   * get/set offset.  Offsets the default position and rotation point
   * @method
   * @memberof Konva.Node.prototype
   * @param {Object} offset
   * @param {Number} offset.x
   * @param {Number} offset.y
   * @returns {Object}
   * @example
   * // get offset
   * var offset = node.offset();
   *
   * // set offset
   * node.offset({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'offsetX',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set offset x
   * @name offsetX
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get offset x
   * var offsetX = node.offsetX();
   *
   * // set offset x
   * node.offsetX(3);
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'offsetY',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set offset y
   * @name offsetY
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get offset y
   * var offsetY = node.offsetY();
   *
   * // set offset y
   * node.offsetY(3);
   */

  Konva.Factory.addSetter(
    Konva.Node,
    'dragDistance',
    Konva.Validators.getNumberValidator()
  );
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'dragDistance');

  /**
   * get/set drag distance
   * @name dragDistance
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} distance
   * @returns {Number}
   * @example
   * // get drag distance
   * var dragDistance = node.dragDistance();
   *
   * // set distance
   * // node starts dragging only if pointer moved more then 3 pixels
   * node.dragDistance(3);
   * // or set globally
   * Konva.dragDistance = 3;
   */

  Konva.Factory.addSetter(
    Konva.Node,
    'width',
    Konva.Validators.getNumberValidator()
  );
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'width');
  /**
   * get/set width
   * @name width
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} width
   * @returns {Number}
   * @example
   * // get width
   * var width = node.width();
   *
   * // set width
   * node.width(100);
   */

  Konva.Factory.addSetter(
    Konva.Node,
    'height',
    Konva.Validators.getNumberValidator()
  );
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'height');
  /**
   * get/set height
   * @name height
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} height
   * @returns {Number}
   * @example
   * // get height
   * var height = node.height();
   *
   * // set height
   * node.height(100);
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'listening', 'inherit', function(
    val
  ) {
    var isValid = val === true || val === false || val === 'inherit';
    if (!isValid) {
      Konva.Util.warn(
        val +
          ' is a not valid value for "listening" attribute. The value may be true, false or "inherit".'
      );
    }
    return val;
  });
  /**
   * get/set listenig attr.  If you need to determine if a node is listening or not
   *   by taking into account its parents, use the isListening() method
   * @name listening
   * @method
   * @memberof Konva.Node.prototype
   * @param {Boolean|String} listening Can be "inherit", true, or false.  The default is "inherit".
   * @returns {Boolean|String}
   * @example
   * // get listening attr
   * var listening = node.listening();
   *
   * // stop listening for events
   * node.listening(false);
   *
   * // listen for events
   * node.listening(true);
   *
   * // listen to events according to the parent
   * node.listening('inherit');
   */

  /**
   * get/set preventDefault
   * By default all shapes will prevent default behaviour
   * of a browser on a pointer move or tap.
   * that will prevent native scrolling when you are trying to drag&drop a node
   * but sometimes you may need to enable default actions
   * in that case you can set the property to false
   * @name preventDefault
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} preventDefault
   * @returns {Number}
   * @example
   * // get preventDefault
   * var shouldPrevent = shape.preventDefault();
   *
   * // set preventDefault
   * shape.preventDefault(false);
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'preventDefault',
    true,
    Konva.Validators.getBooleanValidator()
  );

  Konva.Factory.addGetterSetter(Konva.Node, 'filters', null, function(val) {
    this._filterUpToDate = false;
    return val;
  });
  /**
   * get/set filters.  Filters are applied to cached canvases
   * @name filters
   * @method
   * @memberof Konva.Node.prototype
   * @param {Array} filters array of filters
   * @returns {Array}
   * @example
   * // get filters
   * var filters = node.filters();
   *
   * // set a single filter
   * node.cache();
   * node.filters([Konva.Filters.Blur]);
   *
   * // set multiple filters
   * node.cache();
   * node.filters([
   *   Konva.Filters.Blur,
   *   Konva.Filters.Sepia,
   *   Konva.Filters.Invert
   * ]);
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'visible', 'inherit', function(
    val
  ) {
    var isValid = val === true || val === false || val === 'inherit';
    if (!isValid) {
      Konva.Util.warn(
        val +
          ' is a not valid value for "visible" attribute. The value may be true, false or "inherit".'
      );
    }
    return val;
  });
  /**
   * get/set visible attr.  Can be "inherit", true, or false.  The default is "inherit".
   *   If you need to determine if a node is visible or not
   *   by taking into account its parents, use the isVisible() method
   * @name visible
   * @method
   * @memberof Konva.Node.prototype
   * @param {Boolean|String} visible
   * @returns {Boolean|String}
   * @example
   * // get visible attr
   * var visible = node.visible();
   *
   * // make invisible
   * node.visible(false);
   *
   * // make visible
   * node.visible(true);
   *
   * // make visible according to the parent
   * node.visible('inherit');
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'transformsEnabled',
    'all',
    Konva.Validators.getStringValidator()
  );

  /**
   * get/set transforms that are enabled.  Can be "all", "none", or "position".  The default
   *  is "all"
   * @name transformsEnabled
   * @method
   * @memberof Konva.Node.prototype
   * @param {String} enabled
   * @returns {String}
   * @example
   * // enable position transform only to improve draw performance
   * node.transformsEnabled('position');
   *
   * // enable all transforms
   * node.transformsEnabled('all');
   */

  /**
   * get/set node size
   * @name size
   * @method
   * @memberof Konva.Node.prototype
   * @param {Object} size
   * @param {Number} size.width
   * @param {Number} size.height
   * @returns {Object}
   * @example
   * // get node size
   * var size = node.size();
   * var x = size.x;
   * var y = size.y;
   *
   * // set size
   * node.size({
   *   width: 100,
   *   height: 200
   * });
   */
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'size');

  Konva.Factory.backCompat(Konva.Node, {
    rotateDeg: 'rotate',
    setRotationDeg: 'setRotation',
    getRotationDeg: 'getRotation'
  });

  Konva.Collection.mapMethods(Konva.Node);
})(Konva);

(function() {
  'use strict';
  /**
   * Grayscale Filter
   * @function
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Grayscale]);
   */
  Konva.Filters.Grayscale = function(imageData) {
    var data = imageData.data,
      len = data.length,
      i,
      brightness;

    for (i = 0; i < len; i += 4) {
      brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
      // red
      data[i] = brightness;
      // green
      data[i + 1] = brightness;
      // blue
      data[i + 2] = brightness;
    }
  };
})();

(function(Konva) {
  'use strict';
  /**
   * Brighten Filter.
   * @function
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Brighten]);
   * node.brightness(0.8);
   */
  Konva.Filters.Brighten = function(imageData) {
    var brightness = this.brightness() * 255,
      data = imageData.data,
      len = data.length,
      i;

    for (i = 0; i < len; i += 4) {
      // red
      data[i] += brightness;
      // green
      data[i + 1] += brightness;
      // blue
      data[i + 2] += brightness;
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'brightness',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set filter brightness.  The brightness is a number between -1 and 1.&nbsp; Positive values
   *  brighten the pixels and negative values darken them. Use with {@link Konva.Filters.Brighten} filter.
   * @name brightness
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} brightness value between -1 and 1
   * @returns {Number}
   */
})(Konva);

(function() {
  'use strict';
  /**
   * Invert Filter
   * @function
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Invert]);
   */
  Konva.Filters.Invert = function(imageData) {
    var data = imageData.data,
      len = data.length,
      i;

    for (i = 0; i < len; i += 4) {
      // red
      data[i] = 255 - data[i];
      // green
      data[i + 1] = 255 - data[i + 1];
      // blue
      data[i + 2] = 255 - data[i + 2];
    }
  };
})();

/*
 the Gauss filter
 master repo: https://github.com/pavelpower/kineticjsGaussFilter
*/
(function(Konva) {
  'use strict';
  /*

     StackBlur - a fast almost Gaussian Blur For Canvas

     Version:   0.5
     Author:    Mario Klingemann
     Contact:   mario@quasimondo.com
     Website:   http://www.quasimondo.com/StackBlurForCanvas
     Twitter:   @quasimondo

     In case you find this class useful - especially in commercial projects -
     I am not totally unhappy for a small donation to my PayPal account
     mario@quasimondo.de

     Or support me on flattr:
     https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

     Copyright (c) 2010 Mario Klingemann

     Permission is hereby granted, free of charge, to any person
     obtaining a copy of this software and associated documentation
     files (the "Software"), to deal in the Software without
     restriction, including without limitation the rights to use,
     copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the
     Software is furnished to do so, subject to the following
     conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
     OTHER DEALINGS IN THE SOFTWARE.
     */

  function BlurStack() {
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
    this.next = null;
  }

  var mul_table = [
    512,
    512,
    456,
    512,
    328,
    456,
    335,
    512,
    405,
    328,
    271,
    456,
    388,
    335,
    292,
    512,
    454,
    405,
    364,
    328,
    298,
    271,
    496,
    456,
    420,
    388,
    360,
    335,
    312,
    292,
    273,
    512,
    482,
    454,
    428,
    405,
    383,
    364,
    345,
    328,
    312,
    298,
    284,
    271,
    259,
    496,
    475,
    456,
    437,
    420,
    404,
    388,
    374,
    360,
    347,
    335,
    323,
    312,
    302,
    292,
    282,
    273,
    265,
    512,
    497,
    482,
    468,
    454,
    441,
    428,
    417,
    405,
    394,
    383,
    373,
    364,
    354,
    345,
    337,
    328,
    320,
    312,
    305,
    298,
    291,
    284,
    278,
    271,
    265,
    259,
    507,
    496,
    485,
    475,
    465,
    456,
    446,
    437,
    428,
    420,
    412,
    404,
    396,
    388,
    381,
    374,
    367,
    360,
    354,
    347,
    341,
    335,
    329,
    323,
    318,
    312,
    307,
    302,
    297,
    292,
    287,
    282,
    278,
    273,
    269,
    265,
    261,
    512,
    505,
    497,
    489,
    482,
    475,
    468,
    461,
    454,
    447,
    441,
    435,
    428,
    422,
    417,
    411,
    405,
    399,
    394,
    389,
    383,
    378,
    373,
    368,
    364,
    359,
    354,
    350,
    345,
    341,
    337,
    332,
    328,
    324,
    320,
    316,
    312,
    309,
    305,
    301,
    298,
    294,
    291,
    287,
    284,
    281,
    278,
    274,
    271,
    268,
    265,
    262,
    259,
    257,
    507,
    501,
    496,
    491,
    485,
    480,
    475,
    470,
    465,
    460,
    456,
    451,
    446,
    442,
    437,
    433,
    428,
    424,
    420,
    416,
    412,
    408,
    404,
    400,
    396,
    392,
    388,
    385,
    381,
    377,
    374,
    370,
    367,
    363,
    360,
    357,
    354,
    350,
    347,
    344,
    341,
    338,
    335,
    332,
    329,
    326,
    323,
    320,
    318,
    315,
    312,
    310,
    307,
    304,
    302,
    299,
    297,
    294,
    292,
    289,
    287,
    285,
    282,
    280,
    278,
    275,
    273,
    271,
    269,
    267,
    265,
    263,
    261,
    259
  ];

  var shg_table = [
    9,
    11,
    12,
    13,
    13,
    14,
    14,
    15,
    15,
    15,
    15,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24
  ];

  function filterGaussBlurRGBA(imageData, radius) {
    var pixels = imageData.data,
      width = imageData.width,
      height = imageData.height;

    var x,
      y,
      i,
      p,
      yp,
      yi,
      yw,
      r_sum,
      g_sum,
      b_sum,
      a_sum,
      r_out_sum,
      g_out_sum,
      b_out_sum,
      a_out_sum,
      r_in_sum,
      g_in_sum,
      b_in_sum,
      a_in_sum,
      pr,
      pg,
      pb,
      pa,
      rbs;

    var div = radius + radius + 1,
      widthMinus1 = width - 1,
      heightMinus1 = height - 1,
      radiusPlus1 = radius + 1,
      sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2,
      stackStart = new BlurStack(),
      stackEnd = null,
      stack = stackStart,
      stackIn = null,
      stackOut = null,
      mul_sum = mul_table[radius],
      shg_sum = shg_table[radius];

    for (i = 1; i < div; i++) {
      stack = stack.next = new BlurStack();
      if (i === radiusPlus1) {
        stackEnd = stack;
      }
    }

    stack.next = stackStart;

    yw = yi = 0;

    for (y = 0; y < height; y++) {
      r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

      r_out_sum = radiusPlus1 * (pr = pixels[yi]);
      g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
      b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
      a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

      r_sum += sumFactor * pr;
      g_sum += sumFactor * pg;
      b_sum += sumFactor * pb;
      a_sum += sumFactor * pa;

      stack = stackStart;

      for (i = 0; i < radiusPlus1; i++) {
        stack.r = pr;
        stack.g = pg;
        stack.b = pb;
        stack.a = pa;
        stack = stack.next;
      }

      for (i = 1; i < radiusPlus1; i++) {
        p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
        r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
        g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
        b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
        a_sum += (stack.a = pa = pixels[p + 3]) * rbs;

        r_in_sum += pr;
        g_in_sum += pg;
        b_in_sum += pb;
        a_in_sum += pa;

        stack = stack.next;
      }

      stackIn = stackStart;
      stackOut = stackEnd;
      for (x = 0; x < width; x++) {
        pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
        if (pa !== 0) {
          pa = 255 / pa;
          pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
          pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
          pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
        } else {
          pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
        }

        r_sum -= r_out_sum;
        g_sum -= g_out_sum;
        b_sum -= b_out_sum;
        a_sum -= a_out_sum;

        r_out_sum -= stackIn.r;
        g_out_sum -= stackIn.g;
        b_out_sum -= stackIn.b;
        a_out_sum -= stackIn.a;

        p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

        r_in_sum += stackIn.r = pixels[p];
        g_in_sum += stackIn.g = pixels[p + 1];
        b_in_sum += stackIn.b = pixels[p + 2];
        a_in_sum += stackIn.a = pixels[p + 3];

        r_sum += r_in_sum;
        g_sum += g_in_sum;
        b_sum += b_in_sum;
        a_sum += a_in_sum;

        stackIn = stackIn.next;

        r_out_sum += pr = stackOut.r;
        g_out_sum += pg = stackOut.g;
        b_out_sum += pb = stackOut.b;
        a_out_sum += pa = stackOut.a;

        r_in_sum -= pr;
        g_in_sum -= pg;
        b_in_sum -= pb;
        a_in_sum -= pa;

        stackOut = stackOut.next;

        yi += 4;
      }
      yw += width;
    }

    for (x = 0; x < width; x++) {
      g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

      yi = x << 2;
      r_out_sum = radiusPlus1 * (pr = pixels[yi]);
      g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
      b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
      a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

      r_sum += sumFactor * pr;
      g_sum += sumFactor * pg;
      b_sum += sumFactor * pb;
      a_sum += sumFactor * pa;

      stack = stackStart;

      for (i = 0; i < radiusPlus1; i++) {
        stack.r = pr;
        stack.g = pg;
        stack.b = pb;
        stack.a = pa;
        stack = stack.next;
      }

      yp = width;

      for (i = 1; i <= radius; i++) {
        yi = (yp + x) << 2;

        r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
        g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
        b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
        a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;

        r_in_sum += pr;
        g_in_sum += pg;
        b_in_sum += pb;
        a_in_sum += pa;

        stack = stack.next;

        if (i < heightMinus1) {
          yp += width;
        }
      }

      yi = x;
      stackIn = stackStart;
      stackOut = stackEnd;
      for (y = 0; y < height; y++) {
        p = yi << 2;
        pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
        if (pa > 0) {
          pa = 255 / pa;
          pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
          pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
          pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
        } else {
          pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
        }

        r_sum -= r_out_sum;
        g_sum -= g_out_sum;
        b_sum -= b_out_sum;
        a_sum -= a_out_sum;

        r_out_sum -= stackIn.r;
        g_out_sum -= stackIn.g;
        b_out_sum -= stackIn.b;
        a_out_sum -= stackIn.a;

        p =
          (x +
            ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) *
              width) <<
          2;

        r_sum += r_in_sum += stackIn.r = pixels[p];
        g_sum += g_in_sum += stackIn.g = pixels[p + 1];
        b_sum += b_in_sum += stackIn.b = pixels[p + 2];
        a_sum += a_in_sum += stackIn.a = pixels[p + 3];

        stackIn = stackIn.next;

        r_out_sum += pr = stackOut.r;
        g_out_sum += pg = stackOut.g;
        b_out_sum += pb = stackOut.b;
        a_out_sum += pa = stackOut.a;

        r_in_sum -= pr;
        g_in_sum -= pg;
        b_in_sum -= pb;
        a_in_sum -= pa;

        stackOut = stackOut.next;

        yi += width;
      }
    }
  }

  /**
   * Blur Filter
   * @function
   * @name Blur
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Blur]);
   * node.blurRadius(10);
   */
  Konva.Filters.Blur = function Blur(imageData) {
    var radius = Math.round(this.blurRadius());

    if (radius > 0) {
      filterGaussBlurRGBA(imageData, radius);
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'blurRadius',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );

  /**
   * get/set blur radius. Use with {@link Konva.Filters.Blur} filter
   * @name blurRadius
   * @method
   * @memberof Konva.Node.prototype
   * @param {Integer} radius
   * @returns {Integer}
   */
})(Konva);

/*eslint-disable  max-depth */
(function() {
  'use strict';
  function pixelAt(idata, x, y) {
    var idx = (y * idata.width + x) * 4;
    var d = [];
    d.push(
      idata.data[idx++],
      idata.data[idx++],
      idata.data[idx++],
      idata.data[idx++]
    );
    return d;
  }

  function rgbDistance(p1, p2) {
    return Math.sqrt(
      Math.pow(p1[0] - p2[0], 2) +
        Math.pow(p1[1] - p2[1], 2) +
        Math.pow(p1[2] - p2[2], 2)
    );
  }

  function rgbMean(pTab) {
    var m = [0, 0, 0];

    for (var i = 0; i < pTab.length; i++) {
      m[0] += pTab[i][0];
      m[1] += pTab[i][1];
      m[2] += pTab[i][2];
    }

    m[0] /= pTab.length;
    m[1] /= pTab.length;
    m[2] /= pTab.length;

    return m;
  }

  function backgroundMask(idata, threshold) {
    var rgbv_no = pixelAt(idata, 0, 0);
    var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
    var rgbv_so = pixelAt(idata, 0, idata.height - 1);
    var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);

    var thres = threshold || 10;
    if (
      rgbDistance(rgbv_no, rgbv_ne) < thres &&
      rgbDistance(rgbv_ne, rgbv_se) < thres &&
      rgbDistance(rgbv_se, rgbv_so) < thres &&
      rgbDistance(rgbv_so, rgbv_no) < thres
    ) {
      // Mean color
      var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);

      // Mask based on color distance
      var mask = [];
      for (var i = 0; i < idata.width * idata.height; i++) {
        var d = rgbDistance(mean, [
          idata.data[i * 4],
          idata.data[i * 4 + 1],
          idata.data[i * 4 + 2]
        ]);
        mask[i] = d < thres ? 0 : 255;
      }

      return mask;
    }
  }

  function applyMask(idata, mask) {
    for (var i = 0; i < idata.width * idata.height; i++) {
      idata.data[4 * i + 3] = mask[i];
    }
  }

  function erodeMask(mask, sw, sh) {
    var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);

    var maskResult = [];
    for (var y = 0; y < sh; y++) {
      for (var x = 0; x < sw; x++) {
        var so = y * sw + x;
        var a = 0;
        for (var cy = 0; cy < side; cy++) {
          for (var cx = 0; cx < side; cx++) {
            var scy = y + cy - halfSide;
            var scx = x + cx - halfSide;

            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
              var srcOff = scy * sw + scx;
              var wt = weights[cy * side + cx];

              a += mask[srcOff] * wt;
            }
          }
        }

        maskResult[so] = a === 255 * 8 ? 255 : 0;
      }
    }

    return maskResult;
  }

  function dilateMask(mask, sw, sh) {
    var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);

    var maskResult = [];
    for (var y = 0; y < sh; y++) {
      for (var x = 0; x < sw; x++) {
        var so = y * sw + x;
        var a = 0;
        for (var cy = 0; cy < side; cy++) {
          for (var cx = 0; cx < side; cx++) {
            var scy = y + cy - halfSide;
            var scx = x + cx - halfSide;

            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
              var srcOff = scy * sw + scx;
              var wt = weights[cy * side + cx];

              a += mask[srcOff] * wt;
            }
          }
        }

        maskResult[so] = a >= 255 * 4 ? 255 : 0;
      }
    }

    return maskResult;
  }

  function smoothEdgeMask(mask, sw, sh) {
    var weights = [
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9
    ];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);

    var maskResult = [];
    for (var y = 0; y < sh; y++) {
      for (var x = 0; x < sw; x++) {
        var so = y * sw + x;
        var a = 0;
        for (var cy = 0; cy < side; cy++) {
          for (var cx = 0; cx < side; cx++) {
            var scy = y + cy - halfSide;
            var scx = x + cx - halfSide;

            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
              var srcOff = scy * sw + scx;
              var wt = weights[cy * side + cx];

              a += mask[srcOff] * wt;
            }
          }
        }

        maskResult[so] = a;
      }
    }

    return maskResult;
  }

  /**
   * Mask Filter
   * @function
   * @name Mask
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Mask]);
   * node.threshold(200);
   */
  Konva.Filters.Mask = function(imageData) {
    // Detect pixels close to the background color
    var threshold = this.threshold(),
      mask = backgroundMask(imageData, threshold);
    if (mask) {
      // Erode
      mask = erodeMask(mask, imageData.width, imageData.height);

      // Dilate
      mask = dilateMask(mask, imageData.width, imageData.height);

      // Gradient
      mask = smoothEdgeMask(mask, imageData.width, imageData.height);

      // Apply mask
      applyMask(imageData, mask);

      // todo : Update hit region function according to mask
    }

    return imageData;
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'threshold',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
})();

(function() {
  'use strict';
  /**
   * RGB Filter
   * @function
   * @name RGB
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * node.cache();
   * node.filters([Konva.Filters.RGB]);
   * node.blue(120);
   * node.green(200);
   */
  Konva.Filters.RGB = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      red = this.red(),
      green = this.green(),
      blue = this.blue(),
      i,
      brightness;

    for (i = 0; i < nPixels; i += 4) {
      brightness =
        (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
      data[i] = brightness * red; // r
      data[i + 1] = brightness * green; // g
      data[i + 2] = brightness * blue; // b
      data[i + 3] = data[i + 3]; // alpha
    }
  };

  Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
   * get/set filter red value. Use with {@link Konva.Filters.RGB} filter.
   * @name red
   * @method
   * @memberof Konva.Node.prototype
   * @param {Integer} red value between 0 and 255
   * @returns {Integer}
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
   * get/set filter green value. Use with {@link Konva.Filters.RGB} filter.
   * @name green
   * @method
   * @memberof Konva.Node.prototype
   * @param {Integer} green value between 0 and 255
   * @returns {Integer}
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'blue',
    0,
    Konva.Validators.RGBComponent,
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set filter blue value. Use with {@link Konva.Filters.RGB} filter.
   * @name blue
   * @method
   * @memberof Konva.Node.prototype
   * @param {Integer} blue value between 0 and 255
   * @returns {Integer}
   */
})();

(function() {
  'use strict';
  /**
   * RGBA Filter
   * @function
   * @name RGBA
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author codefo
   * @example
   * node.cache();
   * node.filters([Konva.Filters.RGBA]);
   * node.blue(120);
   * node.green(200);
   * node.alpha(0.3);
   */
  Konva.Filters.RGBA = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      red = this.red(),
      green = this.green(),
      blue = this.blue(),
      alpha = this.alpha(),
      i,
      ia;

    for (i = 0; i < nPixels; i += 4) {
      ia = 1 - alpha;

      data[i] = red * alpha + data[i] * ia; // r
      data[i + 1] = green * alpha + data[i + 1] * ia; // g
      data[i + 2] = blue * alpha + data[i + 2] * ia; // b
    }
  };

  Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
   * get/set filter red value. Use with {@link Konva.Filters.RGBA} filter.
   * @name red
   * @method
   * @memberof Konva.Node.prototype
   * @param {Integer} red value between 0 and 255
   * @returns {Integer}
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
   * get/set filter green value. Use with {@link Konva.Filters.RGBA} filter.
   * @name green
   * @method
   * @memberof Konva.Node.prototype
   * @param {Integer} green value between 0 and 255
   * @returns {Integer}
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'blue',
    0,
    Konva.Validators.RGBComponent,
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set filter blue value. Use with {@link Konva.Filters.RGBA} filter.
   * @name blue
   * @method
   * @memberof Konva.Node.prototype
   * @param {Integer} blue value between 0 and 255
   * @returns {Integer}
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'alpha', 1, function(val) {
    this._filterUpToDate = false;
    if (val > 1) {
      return 1;
    } else if (val < 0) {
      return 0;
    } else {
      return val;
    }
  });
  /**
   * get/set filter alpha value. Use with {@link Konva.Filters.RGBA} filter.
   * @name alpha
   * @method
   * @memberof Konva.Node.prototype
   * @param {Float} alpha value between 0 and 1
   * @returns {Float}
   */
})();

(function() {
  'use strict';
  /**
   * HSV Filter. Adjusts the hue, saturation and value
   * @function
   * @name HSV
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * image.filters([Konva.Filters.HSV]);
   * image.value(200);
   */

  Konva.Filters.HSV = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      v = Math.pow(2, this.value()),
      s = Math.pow(2, this.saturation()),
      h = Math.abs(this.hue() + 360) % 360,
      i;

    // Basis for the technique used:
    // http://beesbuzz.biz/code/hsv_color_transforms.php
    // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
    // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
    // H is the hue shift in degrees (0 to 360)
    // vsu = V*S*cos(H*PI/180);
    // vsw = V*S*sin(H*PI/180);
    //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
    //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
    //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

    // Precompute the values in the matrix:
    var vsu = v * s * Math.cos(h * Math.PI / 180),
      vsw = v * s * Math.sin(h * Math.PI / 180);
    // (result spot)(source spot)
    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
      rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw,
      rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
      gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
      gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
    var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw,
      bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw,
      bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;

    var r, g, b, a;

    for (i = 0; i < nPixels; i += 4) {
      r = data[i + 0];
      g = data[i + 1];
      b = data[i + 2];
      a = data[i + 3];

      data[i + 0] = rr * r + rg * g + rb * b;
      data[i + 1] = gr * r + gg * g + gb * b;
      data[i + 2] = br * r + bg * g + bb * b;
      data[i + 3] = a; // alpha
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'hue',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
   * @name hue
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} hue value between 0 and 359
   * @returns {Number}
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'saturation',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
   * @name saturation
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
   * @returns {Number}
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'value',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set hsv value. Use with {@link Konva.Filters.HSV} filter.
   * @name value
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
   * @returns {Number}
   */
})();

(function() {
  'use strict';
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'hue',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
   * @name hue
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} hue value between 0 and 359
   * @returns {Number}
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'saturation',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
   * @name saturation
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
   * @returns {Number}
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'luminance',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set hsl luminance. Use with {@link Konva.Filters.HSL} filter.
   * @name value
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} value from -1 to 1
   * @returns {Number}
   */

  /**
   * HSL Filter. Adjusts the hue, saturation and luminance (or lightness)
   * @function
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * image.filters([Konva.Filters.HSL]);
   * image.luminance(200);
   */

  Konva.Filters.HSL = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      v = 1,
      s = Math.pow(2, this.saturation()),
      h = Math.abs(this.hue() + 360) % 360,
      l = this.luminance() * 127,
      i;

    // Basis for the technique used:
    // http://beesbuzz.biz/code/hsv_color_transforms.php
    // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
    // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
    // H is the hue shift in degrees (0 to 360)
    // vsu = V*S*cos(H*PI/180);
    // vsw = V*S*sin(H*PI/180);
    //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
    //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
    //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

    // Precompute the values in the matrix:
    var vsu = v * s * Math.cos(h * Math.PI / 180),
      vsw = v * s * Math.sin(h * Math.PI / 180);
    // (result spot)(source spot)
    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
      rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw,
      rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
      gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
      gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
    var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw,
      bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw,
      bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;

    var r, g, b, a;

    for (i = 0; i < nPixels; i += 4) {
      r = data[i + 0];
      g = data[i + 1];
      b = data[i + 2];
      a = data[i + 3];

      data[i + 0] = rr * r + rg * g + rb * b + l;
      data[i + 1] = gr * r + gg * g + gb * b + l;
      data[i + 2] = br * r + bg * g + bb * b + l;
      data[i + 3] = a; // alpha
    }
  };
})();

(function() {
  'use strict';
  /**
   * Emboss Filter.
   * Pixastic Lib - Emboss filter - v0.1.0
   * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
   * License: [http://www.pixastic.com/lib/license.txt]
   * @function
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Emboss]);
   * node.embossStrength(0.8);
   * node.embossWhiteLevel(0.3);
   * node.embossDirection('right');
   * node.embossBlend(true);
   */
  Konva.Filters.Emboss = function(imageData) {
    // pixastic strength is between 0 and 10.  I want it between 0 and 1
    // pixastic greyLevel is between 0 and 255.  I want it between 0 and 1.  Also,
    // a max value of greyLevel yields a white emboss, and the min value yields a black
    // emboss.  Therefore, I changed greyLevel to whiteLevel
    var strength = this.embossStrength() * 10,
      greyLevel = this.embossWhiteLevel() * 255,
      direction = this.embossDirection(),
      blend = this.embossBlend(),
      dirY = 0,
      dirX = 0,
      data = imageData.data,
      w = imageData.width,
      h = imageData.height,
      w4 = w * 4,
      y = h;

    switch (direction) {
      case 'top-left':
        dirY = -1;
        dirX = -1;
        break;
      case 'top':
        dirY = -1;
        dirX = 0;
        break;
      case 'top-right':
        dirY = -1;
        dirX = 1;
        break;
      case 'right':
        dirY = 0;
        dirX = 1;
        break;
      case 'bottom-right':
        dirY = 1;
        dirX = 1;
        break;
      case 'bottom':
        dirY = 1;
        dirX = 0;
        break;
      case 'bottom-left':
        dirY = 1;
        dirX = -1;
        break;
      case 'left':
        dirY = 0;
        dirX = -1;
        break;
      default:
        Konva.Util.error('Unknown emboss direction: ' + direction);
    }

    do {
      var offsetY = (y - 1) * w4;

      var otherY = dirY;
      if (y + otherY < 1) {
        otherY = 0;
      }
      if (y + otherY > h) {
        otherY = 0;
      }

      var offsetYOther = (y - 1 + otherY) * w * 4;

      var x = w;
      do {
        var offset = offsetY + (x - 1) * 4;

        var otherX = dirX;
        if (x + otherX < 1) {
          otherX = 0;
        }
        if (x + otherX > w) {
          otherX = 0;
        }

        var offsetOther = offsetYOther + (x - 1 + otherX) * 4;

        var dR = data[offset] - data[offsetOther];
        var dG = data[offset + 1] - data[offsetOther + 1];
        var dB = data[offset + 2] - data[offsetOther + 2];

        var dif = dR;
        var absDif = dif > 0 ? dif : -dif;

        var absG = dG > 0 ? dG : -dG;
        var absB = dB > 0 ? dB : -dB;

        if (absG > absDif) {
          dif = dG;
        }
        if (absB > absDif) {
          dif = dB;
        }

        dif *= strength;

        if (blend) {
          var r = data[offset] + dif;
          var g = data[offset + 1] + dif;
          var b = data[offset + 2] + dif;

          data[offset] = r > 255 ? 255 : r < 0 ? 0 : r;
          data[offset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
          data[offset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
        } else {
          var grey = greyLevel - dif;
          if (grey < 0) {
            grey = 0;
          } else if (grey > 255) {
            grey = 255;
          }

          data[offset] = data[offset + 1] = data[offset + 2] = grey;
        }
      } while (--x);
    } while (--y);
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossStrength',
    0.5,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set emboss strength. Use with {@link Konva.Filters.Emboss} filter.
   * @name embossStrength
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} level between 0 and 1.  Default is 0.5
   * @returns {Number}
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossWhiteLevel',
    0.5,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set emboss white level. Use with {@link Konva.Filters.Emboss} filter.
   * @name embossWhiteLevel
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} embossWhiteLevel between 0 and 1.  Default is 0.5
   * @returns {Number}
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossDirection',
    'top-left',
    null,
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set emboss direction. Use with {@link Konva.Filters.Emboss} filter.
   * @name embossDirection
   * @method
   * @memberof Konva.Node.prototype
   * @param {String} embossDirection can be top-left, top, top-right, right, bottom-right, bottom, bottom-left or left
   *   The default is top-left
   * @returns {String}
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossBlend',
    false,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set emboss blend. Use with {@link Konva.Filters.Emboss} filter.
   * @name embossBlend
   * @method
   * @memberof Konva.Node.prototype
   * @param {Boolean} embossBlend
   * @returns {Boolean}
   */
})();

(function() {
  'use strict';
  function remap(fromValue, fromMin, fromMax, toMin, toMax) {
    // Compute the range of the data
    var fromRange = fromMax - fromMin,
      toRange = toMax - toMin,
      toValue;

    // If either range is 0, then the value can only be mapped to 1 value
    if (fromRange === 0) {
      return toMin + toRange / 2;
    }
    if (toRange === 0) {
      return toMin;
    }

    // (1) untranslate, (2) unscale, (3) rescale, (4) retranslate
    toValue = (fromValue - fromMin) / fromRange;
    toValue = toRange * toValue + toMin;

    return toValue;
  }

  /**
   * Enhance Filter. Adjusts the colors so that they span the widest
   *  possible range (ie 0-255). Performs w*h pixel reads and w*h pixel
   *  writes.
   * @function
   * @name Enhance
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Enhance]);
   * node.enhance(0.4);
   */
  Konva.Filters.Enhance = function(imageData) {
    var data = imageData.data,
      nSubPixels = data.length,
      rMin = data[0],
      rMax = rMin,
      r,
      gMin = data[1],
      gMax = gMin,
      g,
      bMin = data[2],
      bMax = bMin,
      b,
      i;

    // If we are not enhancing anything - don't do any computation
    var enhanceAmount = this.enhance();
    if (enhanceAmount === 0) {
      return;
    }

    // 1st Pass - find the min and max for each channel:
    for (i = 0; i < nSubPixels; i += 4) {
      r = data[i + 0];
      if (r < rMin) {
        rMin = r;
      } else if (r > rMax) {
        rMax = r;
      }
      g = data[i + 1];
      if (g < gMin) {
        gMin = g;
      } else if (g > gMax) {
        gMax = g;
      }
      b = data[i + 2];
      if (b < bMin) {
        bMin = b;
      } else if (b > bMax) {
        bMax = b;
      }
      //a = data[i + 3];
      //if (a < aMin) { aMin = a; } else
      //if (a > aMax) { aMax = a; }
    }

    // If there is only 1 level - don't remap
    if (rMax === rMin) {
      rMax = 255;
      rMin = 0;
    }
    if (gMax === gMin) {
      gMax = 255;
      gMin = 0;
    }
    if (bMax === bMin) {
      bMax = 255;
      bMin = 0;
    }

    var rMid,
      rGoalMax,
      rGoalMin,
      gMid,
      gGoalMax,
      gGoalMin,
      bMid,
      bGoalMax,
      bGoalMin;

    // If the enhancement is positive - stretch the histogram
    if (enhanceAmount > 0) {
      rGoalMax = rMax + enhanceAmount * (255 - rMax);
      rGoalMin = rMin - enhanceAmount * (rMin - 0);
      gGoalMax = gMax + enhanceAmount * (255 - gMax);
      gGoalMin = gMin - enhanceAmount * (gMin - 0);
      bGoalMax = bMax + enhanceAmount * (255 - bMax);
      bGoalMin = bMin - enhanceAmount * (bMin - 0);
      // If the enhancement is negative -   compress the histogram
    } else {
      rMid = (rMax + rMin) * 0.5;
      rGoalMax = rMax + enhanceAmount * (rMax - rMid);
      rGoalMin = rMin + enhanceAmount * (rMin - rMid);
      gMid = (gMax + gMin) * 0.5;
      gGoalMax = gMax + enhanceAmount * (gMax - gMid);
      gGoalMin = gMin + enhanceAmount * (gMin - gMid);
      bMid = (bMax + bMin) * 0.5;
      bGoalMax = bMax + enhanceAmount * (bMax - bMid);
      bGoalMin = bMin + enhanceAmount * (bMin - bMid);
    }

    // Pass 2 - remap everything, except the alpha
    for (i = 0; i < nSubPixels; i += 4) {
      data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
      data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
      data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
      //data[i + 3] = remap(data[i + 3], aMin, aMax, aGoalMin, aGoalMax);
    }
  };

  /**
   * get/set enhance. Use with {@link Konva.Filters.Enhance} filter. -1 to 1 values
   * @name enhance
   * @method
   * @memberof Konva.Node.prototype
   * @param {Float} amount
   * @returns {Float}
   */
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'enhance',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
})();

(function() {
  'use strict';
  /**
   * Posterize Filter. Adjusts the channels so that there are no more
   *  than n different values for that channel. This is also applied
   *  to the alpha channel.
   * @function
   * @name Posterize
   * @author ippo615
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Posterize]);
   * node.levels(0.8); // between 0 and 1
   */

  Konva.Filters.Posterize = function(imageData) {
    // level must be between 1 and 255
    var levels = Math.round(this.levels() * 254) + 1,
      data = imageData.data,
      len = data.length,
      scale = 255 / levels,
      i;

    for (i = 0; i < len; i += 1) {
      data[i] = Math.floor(data[i] / scale) * scale;
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'levels',
    0.5,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );

  /**
   * get/set levels.  Must be a number between 0 and 1.  Use with {@link Konva.Filters.Posterize} filter.
   * @name levels
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} level between 0 and 1
   * @returns {Number}
   */
})();

(function() {
  'use strict';
  /**
   * Noise Filter. Randomly adds or substracts to the color channels
   * @function
   * @name Noise
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Noise]);
   * node.noise(0.8);
   */
  Konva.Filters.Noise = function(imageData) {
    var amount = this.noise() * 255,
      data = imageData.data,
      nPixels = data.length,
      half = amount / 2,
      i;

    for (i = 0; i < nPixels; i += 4) {
      data[i + 0] += half - 2 * half * Math.random();
      data[i + 1] += half - 2 * half * Math.random();
      data[i + 2] += half - 2 * half * Math.random();
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'noise',
    0.2,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set noise amount.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Noise} filter.
   * @name noise
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} noise
   * @returns {Number}
   */
})();

/*eslint-disable max-depth */
(function() {
  'use strict';
  /**
   * Pixelate Filter. Averages groups of pixels and redraws
   *  them as larger pixels
   * @function
   * @name Pixelate
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Pixelate]);
   * node.pixelSize(10);
   */

  Konva.Filters.Pixelate = function(imageData) {
    var pixelSize = Math.ceil(this.pixelSize()),
      width = imageData.width,
      height = imageData.height,
      x,
      y,
      i,
      //pixelsPerBin = pixelSize * pixelSize,
      red,
      green,
      blue,
      alpha,
      nBinsX = Math.ceil(width / pixelSize),
      nBinsY = Math.ceil(height / pixelSize),
      xBinStart,
      xBinEnd,
      yBinStart,
      yBinEnd,
      xBin,
      yBin,
      pixelsInBin;
    imageData = imageData.data;

    if (pixelSize <= 0) {
      Konva.Util.error('pixelSize value can not be <= 0');
      return;
    }

    for (xBin = 0; xBin < nBinsX; xBin += 1) {
      for (yBin = 0; yBin < nBinsY; yBin += 1) {
        // Initialize the color accumlators to 0
        red = 0;
        green = 0;
        blue = 0;
        alpha = 0;

        // Determine which pixels are included in this bin
        xBinStart = xBin * pixelSize;
        xBinEnd = xBinStart + pixelSize;
        yBinStart = yBin * pixelSize;
        yBinEnd = yBinStart + pixelSize;

        // Add all of the pixels to this bin!
        pixelsInBin = 0;
        for (x = xBinStart; x < xBinEnd; x += 1) {
          if (x >= width) {
            continue;
          }
          for (y = yBinStart; y < yBinEnd; y += 1) {
            if (y >= height) {
              continue;
            }
            i = (width * y + x) * 4;
            red += imageData[i + 0];
            green += imageData[i + 1];
            blue += imageData[i + 2];
            alpha += imageData[i + 3];
            pixelsInBin += 1;
          }
        }

        // Make sure the channels are between 0-255
        red = red / pixelsInBin;
        green = green / pixelsInBin;
        blue = blue / pixelsInBin;
        alpha = alpha / pixelsInBin;

        // Draw this bin
        for (x = xBinStart; x < xBinEnd; x += 1) {
          if (x >= width) {
            continue;
          }
          for (y = yBinStart; y < yBinEnd; y += 1) {
            if (y >= height) {
              continue;
            }
            i = (width * y + x) * 4;
            imageData[i + 0] = red;
            imageData[i + 1] = green;
            imageData[i + 2] = blue;
            imageData[i + 3] = alpha;
          }
        }
      }
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'pixelSize',
    8,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set pixel size. Use with {@link Konva.Filters.Pixelate} filter.
   * @name pixelSize
   * @method
   * @memberof Konva.Node.prototype
   * @param {Integer} pixelSize
   * @returns {Integer}
   */
})();

(function() {
  'use strict';
  /**
   * Threshold Filter. Pushes any value above the mid point to
   *  the max and any value below the mid point to the min.
   *  This affects the alpha channel.
   * @function
   * @name Threshold
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Threshold]);
   * node.threshold(0.1);
   */

  Konva.Filters.Threshold = function(imageData) {
    var level = this.threshold() * 255,
      data = imageData.data,
      len = data.length,
      i;

    for (i = 0; i < len; i += 1) {
      data[i] = data[i] < level ? 0 : 255;
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'threshold',
    0.5,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set threshold.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Threshold} or {@link Konva.Filters.Mask} filter.
   * @name threshold
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} threshold
   * @returns {Number}
   */
})();

(function() {
  'use strict';
  /**
   * Sepia Filter
   * Based on: Pixastic Lib - Sepia filter - v0.1.0
   * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
   * @function
   * @name Sepia
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author Jacob Seidelin <jseidelin@nihilogic.dk>
   * @license MPL v1.1 [http://www.pixastic.com/lib/license.txt]
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Sepia]);
   */
  Konva.Filters.Sepia = function(imageData) {
    var data = imageData.data,
      w = imageData.width,
      y = imageData.height,
      w4 = w * 4,
      offsetY,
      x,
      offset,
      or,
      og,
      ob,
      r,
      g,
      b;

    do {
      offsetY = (y - 1) * w4;
      x = w;
      do {
        offset = offsetY + (x - 1) * 4;

        or = data[offset];
        og = data[offset + 1];
        ob = data[offset + 2];

        r = or * 0.393 + og * 0.769 + ob * 0.189;
        g = or * 0.349 + og * 0.686 + ob * 0.168;
        b = or * 0.272 + og * 0.534 + ob * 0.131;

        data[offset] = r > 255 ? 255 : r;
        data[offset + 1] = g > 255 ? 255 : g;
        data[offset + 2] = b > 255 ? 255 : b;
        data[offset + 3] = data[offset + 3];
      } while (--x);
    } while (--y);
  };
})();

(function() {
  'use strict';
  /**
   * Solarize Filter
   * Pixastic Lib - Solarize filter - v0.1.0
   * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
   * License: [http://www.pixastic.com/lib/license.txt]
   * @function
   * @name Solarize
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Solarize]);
   */
  Konva.Filters.Solarize = function(imageData) {
    var data = imageData.data,
      w = imageData.width,
      h = imageData.height,
      w4 = w * 4,
      y = h;

    do {
      var offsetY = (y - 1) * w4;
      var x = w;
      do {
        var offset = offsetY + (x - 1) * 4;
        var r = data[offset];
        var g = data[offset + 1];
        var b = data[offset + 2];

        if (r > 127) {
          r = 255 - r;
        }
        if (g > 127) {
          g = 255 - g;
        }
        if (b > 127) {
          b = 255 - b;
        }

        data[offset] = r;
        data[offset + 1] = g;
        data[offset + 2] = b;
      } while (--x);
    } while (--y);
  };
})();

(function() {
  'use strict';
  /*
   * ToPolar Filter. Converts image data to polar coordinates. Performs
   *  w*h*4 pixel reads and w*h pixel writes. The r axis is placed along
   *  what would be the y axis and the theta axis along the x axis.
   * @function
   * @author ippo615
   * @memberof Konva.Filters
   * @param {ImageData} src, the source image data (what will be transformed)
   * @param {ImageData} dst, the destination image data (where it will be saved)
   * @param {Object} opt
   * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
   *  default is in the middle
   * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
   *  default is in the middle
   */

  var ToPolar = function(src, dst, opt) {
    var srcPixels = src.data,
      dstPixels = dst.data,
      xSize = src.width,
      ySize = src.height,
      xMid = opt.polarCenterX || xSize / 2,
      yMid = opt.polarCenterY || ySize / 2,
      i,
      x,
      y,
      r = 0,
      g = 0,
      b = 0,
      a = 0;

    // Find the largest radius
    var rad,
      rMax = Math.sqrt(xMid * xMid + yMid * yMid);
    x = xSize - xMid;
    y = ySize - yMid;
    rad = Math.sqrt(x * x + y * y);
    rMax = rad > rMax ? rad : rMax;

    // We'll be uisng y as the radius, and x as the angle (theta=t)
    var rSize = ySize,
      tSize = xSize,
      radius,
      theta;

    // We want to cover all angles (0-360) and we need to convert to
    // radians (*PI/180)
    var conversion = 360 / tSize * Math.PI / 180,
      sin,
      cos;

    // var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;

    for (theta = 0; theta < tSize; theta += 1) {
      sin = Math.sin(theta * conversion);
      cos = Math.cos(theta * conversion);
      for (radius = 0; radius < rSize; radius += 1) {
        x = Math.floor(xMid + rMax * radius / rSize * cos);
        y = Math.floor(yMid + rMax * radius / rSize * sin);
        i = (y * xSize + x) * 4;
        r = srcPixels[i + 0];
        g = srcPixels[i + 1];
        b = srcPixels[i + 2];
        a = srcPixels[i + 3];

        // Store it
        //i = (theta * xSize  +  radius) * 4;
        i = (theta + radius * xSize) * 4;
        dstPixels[i + 0] = r;
        dstPixels[i + 1] = g;
        dstPixels[i + 2] = b;
        dstPixels[i + 3] = a;
      }
    }
  };

  /*
     * FromPolar Filter. Converts image data from polar coordinates back to rectangular.
     *  Performs w*h*4 pixel reads and w*h pixel writes.
     * @function
     * @author ippo615
     * @memberof Konva.Filters
     * @param {ImageData} src, the source image data (what will be transformed)
     * @param {ImageData} dst, the destination image data (where it will be saved)
     * @param {Object} opt
     * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarRotation] amount to rotate the image counterclockwis,
     *  0 is no rotation, 360 degrees is a full rotation
     */

  var FromPolar = function(src, dst, opt) {
    var srcPixels = src.data,
      dstPixels = dst.data,
      xSize = src.width,
      ySize = src.height,
      xMid = opt.polarCenterX || xSize / 2,
      yMid = opt.polarCenterY || ySize / 2,
      i,
      x,
      y,
      dx,
      dy,
      r = 0,
      g = 0,
      b = 0,
      a = 0;

    // Find the largest radius
    var rad,
      rMax = Math.sqrt(xMid * xMid + yMid * yMid);
    x = xSize - xMid;
    y = ySize - yMid;
    rad = Math.sqrt(x * x + y * y);
    rMax = rad > rMax ? rad : rMax;

    // We'll be uisng x as the radius, and y as the angle (theta=t)
    var rSize = ySize,
      tSize = xSize,
      radius,
      theta,
      phaseShift = opt.polarRotation || 0;

    // We need to convert to degrees and we need to make sure
    // it's between (0-360)
    // var conversion = tSize/360*180/Math.PI;
    //var conversion = tSize/360*180/Math.PI;

    var x1, y1;

    for (x = 0; x < xSize; x += 1) {
      for (y = 0; y < ySize; y += 1) {
        dx = x - xMid;
        dy = y - yMid;
        radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
        theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
        theta = theta * tSize / 360;
        x1 = Math.floor(theta);
        y1 = Math.floor(radius);
        i = (y1 * xSize + x1) * 4;
        r = srcPixels[i + 0];
        g = srcPixels[i + 1];
        b = srcPixels[i + 2];
        a = srcPixels[i + 3];

        // Store it
        i = (y * xSize + x) * 4;
        dstPixels[i + 0] = r;
        dstPixels[i + 1] = g;
        dstPixels[i + 2] = b;
        dstPixels[i + 3] = a;
      }
    }
  };

  //Konva.Filters.ToPolar = Konva.Util._FilterWrapDoubleBuffer(ToPolar);
  //Konva.Filters.FromPolar = Konva.Util._FilterWrapDoubleBuffer(FromPolar);

  // create a temporary canvas for working - shared between multiple calls

  /*
     * Kaleidoscope Filter.
     * @function
     * @name Kaleidoscope
     * @author ippo615
     * @memberof Konva.Filters
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Kaleidoscope]);
     * node.kaleidoscopePower(3);
     * node.kaleidoscopeAngle(45);
     */
  Konva.Filters.Kaleidoscope = function(imageData) {
    var xSize = imageData.width,
      ySize = imageData.height;

    var x, y, xoff, i, r, g, b, a, srcPos, dstPos;
    var power = Math.round(this.kaleidoscopePower());
    var angle = Math.round(this.kaleidoscopeAngle());
    var offset = Math.floor(xSize * (angle % 360) / 360);

    if (power < 1) {
      return;
    }

    // Work with our shared buffer canvas
    var tempCanvas = Konva.Util.createCanvasElement();
    tempCanvas.width = xSize;
    tempCanvas.height = ySize;
    var scratchData = tempCanvas
      .getContext('2d')
      .getImageData(0, 0, xSize, ySize);

    // Convert thhe original to polar coordinates
    ToPolar(imageData, scratchData, {
      polarCenterX: xSize / 2,
      polarCenterY: ySize / 2
    });

    // Determine how big each section will be, if it's too small
    // make it bigger
    var minSectionSize = xSize / Math.pow(2, power);
    while (minSectionSize <= 8) {
      minSectionSize = minSectionSize * 2;
      power -= 1;
    }
    minSectionSize = Math.ceil(minSectionSize);
    var sectionSize = minSectionSize;

    // Copy the offset region to 0
    // Depending on the size of filter and location of the offset we may need
    // to copy the section backwards to prevent it from rewriting itself
    var xStart = 0,
      xEnd = sectionSize,
      xDelta = 1;
    if (offset + minSectionSize > xSize) {
      xStart = sectionSize;
      xEnd = 0;
      xDelta = -1;
    }
    for (y = 0; y < ySize; y += 1) {
      for (x = xStart; x !== xEnd; x += xDelta) {
        xoff = Math.round(x + offset) % xSize;
        srcPos = (xSize * y + xoff) * 4;
        r = scratchData.data[srcPos + 0];
        g = scratchData.data[srcPos + 1];
        b = scratchData.data[srcPos + 2];
        a = scratchData.data[srcPos + 3];
        dstPos = (xSize * y + x) * 4;
        scratchData.data[dstPos + 0] = r;
        scratchData.data[dstPos + 1] = g;
        scratchData.data[dstPos + 2] = b;
        scratchData.data[dstPos + 3] = a;
      }
    }

    // Perform the actual effect
    for (y = 0; y < ySize; y += 1) {
      sectionSize = Math.floor(minSectionSize);
      for (i = 0; i < power; i += 1) {
        for (x = 0; x < sectionSize + 1; x += 1) {
          srcPos = (xSize * y + x) * 4;
          r = scratchData.data[srcPos + 0];
          g = scratchData.data[srcPos + 1];
          b = scratchData.data[srcPos + 2];
          a = scratchData.data[srcPos + 3];
          dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
          scratchData.data[dstPos + 0] = r;
          scratchData.data[dstPos + 1] = g;
          scratchData.data[dstPos + 2] = b;
          scratchData.data[dstPos + 3] = a;
        }
        sectionSize *= 2;
      }
    }

    // Convert back from polar coordinates
    FromPolar(scratchData, imageData, { polarRotation: 0 });
  };

  /**
   * get/set kaleidoscope power. Use with {@link Konva.Filters.Kaleidoscope} filter.
   * @name kaleidoscopePower
   * @method
   * @memberof Konva.Node.prototype
   * @param {Integer} power of kaleidoscope
   * @returns {Integer}
   */
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'kaleidoscopePower',
    2,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );

  /**
   * get/set kaleidoscope angle. Use with {@link Konva.Filters.Kaleidoscope} filter.
   * @name kaleidoscopeAngle
   * @method
   * @memberof Konva.Node.prototype
   * @param {Integer} degrees
   * @returns {Integer}
   */
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'kaleidoscopeAngle',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
})();

(function(Konva) {
  'use strict';
  /**
   * Contrast Filter.
   * @function
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Contrast]);
   * node.contrast(10);
   */

  Konva.Filters.Contrast = function(imageData) {
    var adjust = Math.pow((parseInt(this.contrast()) + 100) / 100, 2);

    var data = imageData.data,
      nPixels = data.length,
      red = 150,
      green = 150,
      blue = 150,
      i;

    for (i = 0; i < nPixels; i += 4) {
      red = data[i];
      green = data[i + 1];
      blue = data[i + 2];

      //Red channel
      red /= 255;
      red -= 0.5;
      red *= adjust;
      red += 0.5;
      red *= 255;

      //Green channel
      green /= 255;
      green -= 0.5;
      green *= adjust;
      green += 0.5;
      green *= 255;

      //Blue channel
      blue /= 255;
      blue -= 0.5;
      blue *= adjust;
      blue += 0.5;
      blue *= 255;

      red = red < 0 ? 0 : red > 255 ? 255 : red;
      green = green < 0 ? 0 : green > 255 ? 255 : green;
      blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;

      data[i] = red;
      data[i + 1] = green;
      data[i + 2] = blue;
    }
  };

  /**
   * get/set filter contrast.  The contrast is a number between -100 and 100.
   * Use with {@link Konva.Filters.Contrast} filter.
   * @name contrast
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} contrast value between -100 and 100
   * @returns {Number}
   */
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'contrast',
    0,
    Konva.Validators.getNumberValidator(),
    Konva.Factory.afterSetFilter
  );
})(Konva);

(function() {
  'use strict';
  /**
   * Container constructor.&nbsp; Containers are used to contain nodes or other containers
   * @constructor
   * @memberof Konva
   * @augments Konva.Node
   * @abstract
   * @param {Object} config
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

   */
  Konva.Container = function(config) {
    this.__init(config);
  };

  Konva.Util.addMethods(Konva.Container, {
    __init: function(config) {
      this.children = new Konva.Collection();
      Konva.Node.call(this, config);
    },
    /**
     * returns a {@link Konva.Collection} of direct descendant nodes
     * @method
     * @memberof Konva.Container.prototype
     * @param {Function} [filterFunc] filter function
     * @returns {Konva.Collection}
     * @example
     * // get all children
     * var children = layer.getChildren();
     *
     * // get only circles
     * var circles = layer.getChildren(function(node){
     *    return node.getClassName() === 'Circle';
     * });
     */
    getChildren: function(filterFunc) {
      if (!filterFunc) {
        return this.children;
      }

      var results = new Konva.Collection();
      this.children.each(function(child) {
        if (filterFunc(child)) {
          results.push(child);
        }
      });
      return results;
    },
    /**
     * determine if node has children
     * @method
     * @memberof Konva.Container.prototype
     * @returns {Boolean}
     */
    hasChildren: function() {
      return this.getChildren().length > 0;
    },
    /**
     * remove all children
     * @method
     * @memberof Konva.Container.prototype
     */
    removeChildren: function() {
      var children = Konva.Collection.toCollection(this.children);
      var child;
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        // reset parent to prevent many _setChildrenIndices calls
        delete child.parent;
        child.index = 0;
        child.remove();
      }
      children = null;
      this.children = new Konva.Collection();
      return this;
    },
    /**
     * destroy all children
     * @method
     * @memberof Konva.Container.prototype
     */
    destroyChildren: function() {
      var children = Konva.Collection.toCollection(this.children);
      var child;
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        // reset parent to prevent many _setChildrenIndices calls
        delete child.parent;
        child.index = 0;
        child.destroy();
      }
      children = null;
      this.children = new Konva.Collection();
      return this;
    },
    /**
     * Add node or nodes to container.
     * @method
     * @memberof Konva.Container.prototype
     * @param {...Konva.Node} child
     * @returns {Container}
     * @example
     * layer.add(shape1, shape2, shape3);
     */
    add: function(child) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (child.getParent()) {
        child.moveTo(this);
        return this;
      }
      var children = this.children;
      this._validateAdd(child);
      child.index = children.length;
      child.parent = this;
      children.push(child);
      this._fire('add', {
        child: child
      });

      // if node under drag we need to update drag animation
      if (Konva.DD && child.isDragging()) {
        Konva.DD.anim.setLayers(child.getLayer());
      }

      // chainable
      return this;
    },
    destroy: function() {
      // destroy children
      if (this.hasChildren()) {
        this.destroyChildren();
      }
      // then destroy self
      Konva.Node.prototype.destroy.call(this);
      return this;
    },
    /**
     * return a {@link Konva.Collection} of nodes that match the selector.
     * You can provide a string with '#' for id selections and '.' for name selections.
     * Or a function that will return true/false when a node is passed through.  See example below.
     * With strings you can also select by type or class name. Pass multiple selectors
     * separated by a space.
     * @method
     * @memberof Konva.Container.prototype
     * @param {String | Function} selector
     * @returns {Collection}
     * @example
     *
     * Passing a string as a selector
     * // select node with id foo
     * var node = stage.find('#foo');
     *
     * // select nodes with name bar inside layer
     * var nodes = layer.find('.bar');
     *
     * // select all groups inside layer
     * var nodes = layer.find('Group');
     *
     * // select all rectangles inside layer
     * var nodes = layer.find('Rect');
     *
     * // select node with an id of foo or a name of bar inside layer
     * var nodes = layer.find('#foo, .bar');
     *
     * Passing a function as a selector
     *
     * // get all Groups
     * var groups = stage.find(node => {
     *  return node.getType() === 'Group';
     * });
     *
     * // get only Nodes with partial opacity
     * var alphaNodes = layer.find(node => {
     *  return node.getType() === 'Node' && node.getAbsoluteOpacity() < 1;
     * });
     */
    find: function(selector) {
      // protecting _generalFind to prevent user from accidentally adding
      // second argument and getting unexpected `findOne` result
      return this._generalFind(selector, false);
    },
    /**
     * return a first node from `find` method
     * @method
     * @memberof Konva.Container.prototype
     * @param {String | Function} selector
     * @returns {Konva.Node | Undefined}
     * @example
     * // select node with id foo
     * var node = stage.findOne('#foo');
     *
     * // select node with name bar inside layer
     * var nodes = layer.findOne('.bar');
     *
     * // select the first node to return true in a function
     * var node = stage.findOne(node => {
     *  return node.getType() === 'Shape'
     * })
     */
    findOne: function(selector) {
      var result = this._generalFind(selector, true);
      return result.length > 0 ? result[0] : undefined;
    },
    _generalFind: function(selector, findOne) {
      var retArr = [];

      if (typeof selector === 'string') {
        retArr = this._findByString(selector, findOne);
      } else if (typeof selector === 'function') {
        retArr = this._findByFunction(selector, findOne);
      }

      return Konva.Collection.toCollection(retArr);
    },
    _findByString: function(selector) {
      var retArr = [],
        selectorArr = selector.replace(/ /g, '').split(','),
        len = selectorArr.length,
        n,
        i,
        sel,
        arr,
        node,
        children,
        clen;

      for (n = 0; n < len; n++) {
        sel = selectorArr[n];
        if (!Konva.Util.isValidSelector(sel)) {
          var message =
            'Selector "' +
            sel +
            '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".\n' +
            'If you have a custom shape with such className, please change it to start with upper letter like "Triangle".\n' +
            'Konva is awesome, right?';
          Konva.Util.warn(message);
        }
        // id selector
        if (sel.charAt(0) === '#') {
          node = this._getNodeById(sel.slice(1));
          if (node) {
            retArr.push(node);
          }
        } else if (sel.charAt(0) === '.') {
          // name selector
          arr = this._getNodesByName(sel.slice(1));
          retArr = retArr.concat(arr);
        } else {
          // unrecognized selector, pass to children
          children = this.getChildren();
          clen = children.length;
          for (i = 0; i < clen; i++) {
            retArr = retArr.concat(children[i]._get(sel));
          }
        }
      }

      return retArr;
    },
    // (fn: ((Node) => boolean, findOne?: boolean)
    _findByFunction: function(fn, findOne) {
      var retArr = [];

      var addItems = function(el) {
        // escape function if we've already found one.
        if (findOne && retArr.length > 0) {
          return;
        }

        var children = el.getChildren();
        var clen = children.length;

        if (fn(el)) {
          retArr = retArr.concat(el);
        }

        for (var i = 0; i < clen; i++) {
          addItems(children[i]);
        }
      };

      addItems(this);

      return retArr;
    },
    _getNodeById: function(key) {
      var node = Konva.ids[key];

      if (node !== undefined && this.isAncestorOf(node)) {
        return node;
      }
      return null;
    },
    _getNodesByName: function(key) {
      var arr = Konva.names[key] || [];
      return this._getDescendants(arr);
    },
    _get: function(selector) {
      var retArr = Konva.Node.prototype._get.call(this, selector);
      var children = this.getChildren();
      var len = children.length;
      for (var n = 0; n < len; n++) {
        retArr = retArr.concat(children[n]._get(selector));
      }
      return retArr;
    },
    // extenders
    toObject: function() {
      var obj = Konva.Node.prototype.toObject.call(this);

      obj.children = [];

      var children = this.getChildren();
      var len = children.length;
      for (var n = 0; n < len; n++) {
        var child = children[n];
        obj.children.push(child.toObject());
      }

      return obj;
    },
    _getDescendants: function(arr) {
      var retArr = [];
      var len = arr.length;
      for (var n = 0; n < len; n++) {
        var node = arr[n];
        if (this.isAncestorOf(node)) {
          retArr.push(node);
        }
      }

      return retArr;
    },
    /**
     * determine if node is an ancestor
     * of descendant
     * @method
     * @memberof Konva.Container.prototype
     * @param {Konva.Node} node
     */
    isAncestorOf: function(node) {
      var parent = node.getParent();
      while (parent) {
        if (parent._id === this._id) {
          return true;
        }
        parent = parent.getParent();
      }

      return false;
    },
    clone: function(obj) {
      // call super method
      var node = Konva.Node.prototype.clone.call(this, obj);

      this.getChildren().each(function(no) {
        node.add(no.clone());
      });
      return node;
    },
    /**
     * get all shapes that intersect a point.  Note: because this method must clear a temporary
     * canvas and redraw every shape inside the container, it should only be used for special sitations
     * because it performs very poorly.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
     * because it performs much better
     * @method
     * @memberof Konva.Container.prototype
     * @param {Object} pos
     * @param {Number} pos.x
     * @param {Number} pos.y
     * @returns {Array} array of shapes
     */
    getAllIntersections: function(pos) {
      var arr = [];

      this.find('Shape').each(function(shape) {
        if (shape.isVisible() && shape.intersects(pos)) {
          arr.push(shape);
        }
      });

      return arr;
    },
    _setChildrenIndices: function() {
      this.children.each(function(child, n) {
        child.index = n;
      });
    },
    drawScene: function(can, top, caching) {
      var layer = this.getLayer(),
        canvas = can || (layer && layer.getCanvas()),
        context = canvas && canvas.getContext(),
        cachedCanvas = this._cache.canvas,
        cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;

      if (this.isVisible() || caching) {
        if (!caching && cachedSceneCanvas) {
          context.save();
          layer._applyTransform(this, context, top);
          this._drawCachedSceneCanvas(context);
          context.restore();
        } else {
          this._drawChildren(canvas, 'drawScene', top, false, caching);
        }
      }
      return this;
    },
    drawHit: function(can, top, caching) {
      var layer = this.getLayer(),
        canvas = can || (layer && layer.hitCanvas),
        context = canvas && canvas.getContext(),
        cachedCanvas = this._cache.canvas,
        cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

      if (this.shouldDrawHit(canvas) || caching) {
        if (layer) {
          layer.clearHitCache();
        }
        if (!caching && cachedHitCanvas) {
          context.save();
          layer._applyTransform(this, context, top);
          this._drawCachedHitCanvas(context);
          context.restore();
        } else {
          this._drawChildren(canvas, 'drawHit', top);
        }
      }
      return this;
    },
    _drawChildren: function(canvas, drawMethod, top, caching, skipBuffer) {
      var layer = this.getLayer(),
        context = canvas && canvas.getContext(),
        clipWidth = this.getClipWidth(),
        clipHeight = this.getClipHeight(),
        clipFunc = this.getClipFunc(),
        hasClip = (clipWidth && clipHeight) || clipFunc,
        clipX,
        clipY;

      if (hasClip && layer) {
        context.save();
        var transform = this.getAbsoluteTransform(top);
        var m = transform.getMatrix();
        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        context.beginPath();
        if (clipFunc) {
          clipFunc.call(this, context, this);
        } else {
          clipX = this.getClipX();
          clipY = this.getClipY();
          context.rect(clipX, clipY, clipWidth, clipHeight);
        }
        context.clip();
        m = transform
          .copy()
          .invert()
          .getMatrix();
        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      }

      this.children.each(function(child) {
        child[drawMethod](canvas, top, caching, skipBuffer);
      });

      if (hasClip) {
        context.restore();
      }
    },
    shouldDrawHit: function(canvas) {
      var layer = this.getLayer();
      var dd = Konva.DD;
      var layerUnderDrag =
        dd &&
        Konva.isDragging() &&
        Konva.DD.anim.getLayers().indexOf(layer) !== -1;
      return (
        (canvas && canvas.isCache) ||
        (layer &&
          layer.hitGraphEnabled() &&
          this.isVisible() &&
          !layerUnderDrag)
      );
    },
    getClientRect: function(attrs) {
      attrs = attrs || {};
      var skipTransform = attrs.skipTransform;
      var relativeTo = attrs.relativeTo;

      var minX, minY, maxX, maxY;
      var selfRect = {
        x: Infinity,
        y: Infinity,
        width: 0,
        height: 0
      };
      var that = this;
      this.children.each(function(child) {
        // skip invisible children
        if (!child.getVisible()) {
          return;
        }

        var rect = child.getClientRect({
          relativeTo: that,
          skipShadow: attrs.skipShadow
        });

        // skip invisible children (like empty groups)
        if (rect.width === 0 && rect.height === 0) {
          return;
        }

        if (minX === undefined) {
          // initial value for first child
          minX = rect.x;
          minY = rect.y;
          maxX = rect.x + rect.width;
          maxY = rect.y + rect.height;
        } else {
          minX = Math.min(minX, rect.x);
          minY = Math.min(minY, rect.y);
          maxX = Math.max(maxX, rect.x + rect.width);
          maxY = Math.max(maxY, rect.y + rect.height);
        }
      });

      // if child is group we need to make sure it has visible shapes inside
      var shapes = this.find('Shape');
      var hasVisible = false;
      for (var i = 0; i < shapes.length; i++) {
        var shape = shapes[i];
        if (shape._isVisible(this)) {
          hasVisible = true;
          break;
        }
      }

      if (hasVisible) {
        selfRect = {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      } else {
        selfRect = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }

      if (!skipTransform) {
        return this._transformedRect(selfRect, relativeTo);
      }
      return selfRect;
    }
  });

  Konva.Util.extend(Konva.Container, Konva.Node);
  // deprecated methods
  Konva.Container.prototype.get = Konva.Container.prototype.find;

  // add getters setters
  Konva.Factory.addComponentsGetterSetter(Konva.Container, 'clip', [
    'x',
    'y',
    'width',
    'height'
  ]);
  /**
   * get/set clip
   * @method
   * @name clip
   * @memberof Konva.Container.prototype
   * @param {Object} clip
   * @param {Number} clip.x
   * @param {Number} clip.y
   * @param {Number} clip.width
   * @param {Number} clip.height
   * @returns {Object}
   * @example
   * // get clip
   * var clip = container.clip();
   *
   * // set clip
   * container.setClip({
   *   x: 20,
   *   y: 20,
   *   width: 20,
   *   height: 20
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Container,
    'clipX',
    undefined,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set clip x
   * @name clipX
   * @method
   * @memberof Konva.Container.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get clip x
   * var clipX = container.clipX();
   *
   * // set clip x
   * container.clipX(10);
   */

  Konva.Factory.addGetterSetter(
    Konva.Container,
    'clipY',
    undefined,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set clip y
   * @name clipY
   * @method
   * @memberof Konva.Container.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get clip y
   * var clipY = container.clipY();
   *
   * // set clip y
   * container.clipY(10);
   */

  Konva.Factory.addGetterSetter(
    Konva.Container,
    'clipWidth',
    undefined,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set clip width
   * @name clipWidth
   * @method
   * @memberof Konva.Container.prototype
   * @param {Number} width
   * @returns {Number}
   * @example
   * // get clip width
   * var clipWidth = container.clipWidth();
   *
   * // set clip width
   * container.clipWidth(100);
   */

  Konva.Factory.addGetterSetter(
    Konva.Container,
    'clipHeight',
    undefined,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set clip height
   * @name clipHeight
   * @method
   * @memberof Konva.Container.prototype
   * @param {Number} height
   * @returns {Number}
   * @example
   * // get clip height
   * var clipHeight = container.clipHeight();
   *
   * // set clip height
   * container.clipHeight(100);
   */

  Konva.Factory.addGetterSetter(Konva.Container, 'clipFunc');
  /**
   * get/set clip function
   * @name clipFunc
   * @method
   * @memberof Konva.Container.prototype
   * @param {Function} function
   * @returns {Function}
   * @example
   * // get clip function
   * var clipFunction = container.clipFunc();
   *
   * // set clip height
   * container.clipFunc(function(ctx) {
   *   ctx.rect(0, 0, 100, 100);
   * });
   */

  Konva.Collection.mapMethods(Konva.Container);
})();

(function(Konva) {
  'use strict';
  var HAS_SHADOW = 'hasShadow';
  var SHADOW_RGBA = 'shadowRGBA';

  function _fillFunc(context) {
    context.fill();
  }
  function _strokeFunc(context) {
    context.stroke();
  }
  function _fillFuncHit(context) {
    context.fill();
  }
  function _strokeFuncHit(context) {
    context.stroke();
  }

  function _clearHasShadowCache() {
    this._clearCache(HAS_SHADOW);
  }

  function _clearGetShadowRGBACache() {
    this._clearCache(SHADOW_RGBA);
  }

  /**
   * Shape constructor.  Shapes are primitive objects such as rectangles,
   *  circles, text, lines, etc.
   * @constructor
   * @memberof Konva
   * @augments Konva.Node
   * @param {Object} config
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var customShape = new Konva.Shape({
   *   x: 5,
   *   y: 10,
   *   fill: 'red',
   *   // a Konva.Canvas renderer is passed into the sceneFunc function
   *   sceneFunc: function(context, shape) {
   *     context.beginPath();
   *     context.moveTo(200, 50);
   *     context.lineTo(420, 80);
   *     context.quadraticCurveTo(300, 100, 260, 170);
   *     context.closePath();
   *     // Konva specific method
   *     context.fillStrokeShape(shape);
   *   }
   *});
   */
  Konva.Shape = function(config) {
    this.__init(config);
  };

  Konva.Util.addMethods(Konva.Shape, {
    __init: function(config) {
      this.nodeType = 'Shape';
      this._fillFunc = _fillFunc;
      this._strokeFunc = _strokeFunc;
      this._fillFuncHit = _fillFuncHit;
      this._strokeFuncHit = _strokeFuncHit;

      // set colorKey
      var shapes = Konva.shapes;
      var key;

      while (true) {
        key = Konva.Util.getRandomColor();
        if (key && !(key in shapes)) {
          break;
        }
      }

      this.colorKey = key;
      shapes[key] = this;

      // call super constructor
      Konva.Node.call(this, config);

      this.on(
        'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva',
        _clearHasShadowCache
      );

      this.on(
        'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva',
        _clearGetShadowRGBACache
      );
    },
    hasChildren: function() {
      return false;
    },
    getChildren: function() {
      return [];
    },
    /**
     * get canvas context tied to the layer
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Konva.Context}
     */
    getContext: function() {
      return this.getLayer().getContext();
    },
    /**
     * get canvas renderer tied to the layer.  Note that this returns a canvas renderer, not a canvas element
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Konva.Canvas}
     */
    getCanvas: function() {
      return this.getLayer().getCanvas();
    },
    /**
     * returns whether or not a shadow will be rendered
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Boolean}
     */
    hasShadow: function() {
      return this._getCache(HAS_SHADOW, this._hasShadow);
    },
    _hasShadow: function() {
      return (
        this.getShadowEnabled() &&
        (this.getShadowOpacity() !== 0 &&
          !!(
            this.getShadowColor() ||
            this.getShadowBlur() ||
            this.getShadowOffsetX() ||
            this.getShadowOffsetY()
          ))
      );
    },
    getShadowRGBA: function() {
      return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
    },
    _getShadowRGBA: function() {
      if (this.hasShadow()) {
        var rgba = Konva.Util.colorToRGBA(this.shadowColor());
        return (
          'rgba(' +
          rgba.r +
          ',' +
          rgba.g +
          ',' +
          rgba.b +
          ',' +
          rgba.a * (this.getShadowOpacity() || 1) +
          ')'
        );
      }
    },
    /**
     * returns whether or not the shape will be filled
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Boolean}
     */
    hasFill: function() {
      return !!(
        this.getFill() ||
        this.getFillPatternImage() ||
        this.getFillLinearGradientColorStops() ||
        this.getFillRadialGradientColorStops()
      );
    },
    /**
     * returns whether or not the shape will be stroked
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Boolean}
     */
    hasStroke: function() {
      return (
        this.strokeEnabled() &&
        !!(this.stroke() || this.getStrokeLinearGradientColorStops())
        // TODO: do we need radial gradient
        // this.getStrokeRadialGradientColorStops()
      );
    },
    /**
     * determines if point is in the shape, regardless if other shapes are on top of it.  Note: because
     *  this method clears a temporary canvas and then redraws the shape, it performs very poorly if executed many times
     *  consecutively.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
     *  because it performs much better
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} point
     * @param {Number} point.x
     * @param {Number} point.y
     * @returns {Boolean}
     */
    intersects: function(point) {
      var stage = this.getStage(),
        bufferHitCanvas = stage.bufferHitCanvas,
        p;

      bufferHitCanvas.getContext().clear();
      this.drawHit(bufferHitCanvas);
      p = bufferHitCanvas.context.getImageData(
        Math.round(point.x),
        Math.round(point.y),
        1,
        1
      ).data;
      return p[3] > 0;
    },
    // extends Node.prototype.destroy
    destroy: function() {
      Konva.Node.prototype.destroy.call(this);
      delete Konva.shapes[this.colorKey];
      return this;
    },
    _useBufferCanvas: function(caching) {
      return (
        (!caching &&
          (this.perfectDrawEnabled() &&
            this.getAbsoluteOpacity() !== 1 &&
            this.hasFill() &&
            this.hasStroke() &&
            this.getStage())) ||
        (this.perfectDrawEnabled() &&
          this.hasShadow() &&
          this.getAbsoluteOpacity() !== 1 &&
          this.hasFill() &&
          this.hasStroke() &&
          this.getStage())
      );
    },
    /**
     * return self rectangle (x, y, width, height) of shape.
     * This method are not taken into account transformation and styles.
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Object} rect with {x, y, width, height} properties
     * @example
     *
     * rect.getSelfRect();  // return {x:0, y:0, width:rect.width(), height:rect.height()}
     * circle.getSelfRect();  // return {x: - circle.width() / 2, y: - circle.height() / 2, width:circle.width(), height:circle.height()}
     *
     */
    getSelfRect: function() {
      var size = this.getSize();
      return {
        x: this._centroid ? Math.round(-size.width / 2) : 0,
        y: this._centroid ? Math.round(-size.height / 2) : 0,
        width: size.width,
        height: size.height
      };
    },
    getClientRect: function(attrs) {
      attrs = attrs || {};
      var skipTransform = attrs.skipTransform;

      var relativeTo = attrs.relativeTo;

      var fillRect = this.getSelfRect();

      var strokeWidth = (this.hasStroke() && this.strokeWidth()) || 0;
      var fillAndStrokeWidth = fillRect.width + strokeWidth;
      var fillAndStrokeHeight = fillRect.height + strokeWidth;

      var applyShadow = !attrs.skipShadow && this.hasShadow();
      var shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;
      var shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;

      var preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
      var preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);

      var blurRadius = (applyShadow && this.shadowBlur()) || 0;

      var width = preWidth + blurRadius * 2;
      var height = preHeight + blurRadius * 2;

      // if stroke, for example = 3
      // we need to set x to 1.5, but after Math.round it will be 2
      // as we have additional offset we need to increase width and height by 1 pixel
      var roundingOffset = 0;
      if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {
        roundingOffset = 1;
      }
      var rect = {
        width: width + roundingOffset,
        height: height + roundingOffset,
        x:
          -Math.round(strokeWidth / 2 + blurRadius) +
          Math.min(shadowOffsetX, 0) +
          fillRect.x,
        y:
          -Math.round(strokeWidth / 2 + blurRadius) +
          Math.min(shadowOffsetY, 0) +
          fillRect.y
      };
      if (!skipTransform) {
        return this._transformedRect(rect, relativeTo);
      }
      return rect;
    },
    drawScene: function(can, top, caching, skipBuffer) {
      var layer = this.getLayer(),
        canvas = can || layer.getCanvas(),
        context = canvas.getContext(),
        cachedCanvas = this._cache.canvas,
        drawFunc = this.sceneFunc(),
        hasShadow = this.hasShadow(),
        hasStroke = this.hasStroke(),
        stage,
        bufferCanvas,
        bufferContext;

      if (!this.isVisible() && !caching) {
        return this;
      }
      if (cachedCanvas) {
        context.save();
        layer._applyTransform(this, context, top);
        this._drawCachedSceneCanvas(context);
        context.restore();
        return this;
      }
      if (!drawFunc) {
        return this;
      }
      context.save();
      // if buffer canvas is needed
      if (this._useBufferCanvas(caching) && !skipBuffer) {
        stage = this.getStage();
        bufferCanvas = stage.bufferCanvas;
        bufferContext = bufferCanvas.getContext();
        bufferContext.clear();
        bufferContext.save();
        bufferContext._applyLineJoin(this);
        // layer might be undefined if we are using cache before adding to layer
        if (!caching) {
          if (layer) {
            layer._applyTransform(this, bufferContext, top);
          } else {
            var m = this.getAbsoluteTransform(top).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          }
        }

        drawFunc.call(this, bufferContext, this);
        bufferContext.restore();

        var ratio = bufferCanvas.pixelRatio;
        if (hasShadow && !canvas.hitCanvas) {
          context.save();

          context._applyShadow(this);
          context._applyOpacity(this);
          context._applyGlobalCompositeOperation(this);
          context.drawImage(
            bufferCanvas._canvas,
            0,
            0,
            bufferCanvas.width / ratio,
            bufferCanvas.height / ratio
          );
          context.restore();
        } else {
          context._applyOpacity(this);
          context._applyGlobalCompositeOperation(this);
          context.drawImage(
            bufferCanvas._canvas,
            0,
            0,
            bufferCanvas.width / ratio,
            bufferCanvas.height / ratio
          );
        }
      } else {
        // if buffer canvas is not needed
        context._applyLineJoin(this);
        // layer might be undefined if we are using cache before adding to layer
        if (!caching) {
          if (layer) {
            layer._applyTransform(this, context, top);
          } else {
            var o = this.getAbsoluteTransform(top).getMatrix();
            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
          }
        }

        if (hasShadow && hasStroke && !canvas.hitCanvas) {
          context.save();
          // apply shadow
          if (!caching) {
            context._applyOpacity(this);
            context._applyGlobalCompositeOperation(this);
          }
          context._applyShadow(this);

          drawFunc.call(this, context, this);
          context.restore();
          // if shape has stroke we need to redraw shape
          // otherwise we will see a shadow under stroke (and over fill)
          // but I think this is unexpected behavior
          if (this.hasFill() && this.getShadowForStrokeEnabled()) {
            drawFunc.call(this, context, this);
          }
        } else if (hasShadow && !canvas.hitCanvas) {
          context.save();
          if (!caching) {
            context._applyOpacity(this);
            context._applyGlobalCompositeOperation(this);
          }
          context._applyShadow(this);
          drawFunc.call(this, context, this);
          context.restore();
        } else {
          if (!caching) {
            context._applyOpacity(this);
            context._applyGlobalCompositeOperation(this);
          }
          drawFunc.call(this, context, this);
        }
      }
      context.restore();
      return this;
    },
    drawHit: function(can, top, caching) {
      var layer = this.getLayer(),
        canvas = can || layer.hitCanvas,
        context = canvas.getContext(),
        drawFunc = this.hitFunc() || this.sceneFunc(),
        cachedCanvas = this._cache.canvas,
        cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

      if (!this.shouldDrawHit(canvas) && !caching) {
        return this;
      }
      if (layer) {
        layer.clearHitCache();
      }
      if (cachedHitCanvas) {
        context.save();
        layer._applyTransform(this, context, top);
        this._drawCachedHitCanvas(context);
        context.restore();
        return this;
      }
      if (!drawFunc) {
        return this;
      }
      context.save();
      context._applyLineJoin(this);
      if (!caching) {
        if (layer) {
          layer._applyTransform(this, context, top);
        } else {
          var o = this.getAbsoluteTransform(top).getMatrix();
          context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
        }
      }
      drawFunc.call(this, context, this);
      context.restore();
      return this;
    },
    /**
     * draw hit graph using the cached scene canvas
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Integer} alphaThreshold alpha channel threshold that determines whether or not
     *  a pixel should be drawn onto the hit graph.  Must be a value between 0 and 255.
     *  The default is 0
     * @returns {Konva.Shape}
     * @example
     * shape.cache();
     * shape.drawHitFromCache();
     */
    drawHitFromCache: function(alphaThreshold) {
      var threshold = alphaThreshold || 0,
        cachedCanvas = this._cache.canvas,
        sceneCanvas = this._getCachedSceneCanvas(),
        hitCanvas = cachedCanvas.hit,
        hitContext = hitCanvas.getContext(),
        hitWidth = hitCanvas.getWidth(),
        hitHeight = hitCanvas.getHeight(),
        hitImageData,
        hitData,
        len,
        rgbColorKey,
        i,
        alpha;

      hitContext.clear();
      hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);

      try {
        hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
        hitData = hitImageData.data;
        len = hitData.length;
        rgbColorKey = Konva.Util._hexToRgb(this.colorKey);

        // replace non transparent pixels with color key
        for (i = 0; i < len; i += 4) {
          alpha = hitData[i + 3];
          if (alpha > threshold) {
            hitData[i] = rgbColorKey.r;
            hitData[i + 1] = rgbColorKey.g;
            hitData[i + 2] = rgbColorKey.b;
            hitData[i + 3] = 255;
          } else {
            hitData[i + 3] = 0;
          }
        }
        hitContext.putImageData(hitImageData, 0, 0);
      } catch (e) {
        Konva.Util.error(
          'Unable to draw hit graph from cached scene canvas. ' + e.message
        );
      }

      return this;
    }
  });
  Konva.Util.extend(Konva.Shape, Konva.Node);

  // add getters and setters
  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'stroke',
    undefined,
    Konva.Validators.getStringValidator()
  );

  /**
   * get/set stroke color
   * @name stroke
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} color
   * @returns {String}
   * @example
   * // get stroke color
   * var stroke = shape.stroke();
   *
   * // set stroke color with color string
   * shape.stroke('green');
   *
   * // set stroke color with hex
   * shape.stroke('#00ff00');
   *
   * // set stroke color with rgb
   * shape.stroke('rgb(0,255,0)');
   *
   * // set stroke color with rgba and make it 50% opaque
   * shape.stroke('rgba(0,255,0,0.5');
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'strokeWidth',
    2,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set stroke width
   * @name strokeWidth
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} strokeWidth
   * @returns {Number}
   * @example
   * // get stroke width
   * var strokeWidth = shape.strokeWidth();
   *
   * // set stroke width
   * shape.strokeWidth();
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'strokeHitEnabled',
    true,
    Konva.Validators.getBooleanValidator()
  );

  /**
   * get/set strokeHitEnabled property. Useful for performance optimization.
   * You may set `shape.strokeHitEnabled(false)`. In this case stroke will be no draw on hit canvas, so hit area
   * of shape will be decreased (by lineWidth / 2). Remember that non closed line with `strokeHitEnabled = false`
   * will be not drawn on hit canvas, that is mean line will no trigger pointer events (like mouseover)
   * Default value is true
   * @name strokeHitEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} strokeHitEnabled
   * @returns {Boolean}
   * @example
   * // get strokeHitEnabled
   * var strokeHitEnabled = shape.strokeHitEnabled();
   *
   * // set strokeHitEnabled
   * shape.strokeHitEnabled();
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'perfectDrawEnabled',
    true,
    Konva.Validators.getBooleanValidator()
  );

  /**
   * get/set perfectDrawEnabled. If a shape has fill, stroke and opacity you may set `perfectDrawEnabled` to false to improve performance.
   * See http://konvajs.github.io/docs/performance/Disable_Perfect_Draw.html for more information.
   * Default value is true
   * @name perfectDrawEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} perfectDrawEnabled
   * @returns {Boolean}
   * @example
   * // get perfectDrawEnabled
   * var perfectDrawEnabled = shape.perfectDrawEnabled();
   *
   * // set perfectDrawEnabled
   * shape.perfectDrawEnabled();
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'shadowForStrokeEnabled',
    true,
    Konva.Validators.getBooleanValidator()
  );

  /**
   * get/set shadowForStrokeEnabled. Useful for performance optimization.
   * You may set `shape.shadowForStrokeEnabled(false)`. In this case stroke will be no draw shadow for stroke.
   * Remember if you set `shadowForStrokeEnabled = false` for non closed line - that line with have no shadow!.
   * Default value is true
   * @name shadowForStrokeEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} shadowForStrokeEnabled
   * @returns {Boolean}
   * @example
   * // get shadowForStrokeEnabled
   * var shadowForStrokeEnabled = shape.shadowForStrokeEnabled();
   *
   * // set shadowForStrokeEnabled
   * shape.shadowForStrokeEnabled();
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'lineJoin');

  /**
   * get/set line join.  Can be miter, round, or bevel.  The
   *  default is miter
   * @name lineJoin
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} lineJoin
   * @returns {String}
   * @example
   * // get line join
   * var lineJoin = shape.lineJoin();
   *
   * // set line join
   * shape.lineJoin('round');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'lineCap');

  /**
   * get/set line cap.  Can be butt, round, or square
   * @name lineCap
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} lineCap
   * @returns {String}
   * @example
   * // get line cap
   * var lineCap = shape.lineCap();
   *
   * // set line cap
   * shape.lineCap('round');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'sceneFunc');

  /**
   * get/set scene draw function
   * @name sceneFunc
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Function} drawFunc drawing function
   * @returns {Function}
   * @example
   * // get scene draw function
   * var sceneFunc = shape.sceneFunc();
   *
   * // set scene draw function
   * shape.sceneFunc(function(context) {
   *   context.beginPath();
   *   context.rect(0, 0, this.width(), this.height());
   *   context.closePath();
   *   context.fillStrokeShape(this);
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'hitFunc');

  /**
   * get/set hit draw function
   * @name hitFunc
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Function} drawFunc drawing function
   * @returns {Function}
   * @example
   * // get hit draw function
   * var hitFunc = shape.hitFunc();
   *
   * // set hit draw function
   * shape.hitFunc(function(context) {
   *   context.beginPath();
   *   context.rect(0, 0, this.width(), this.height());
   *   context.closePath();
   *   context.fillStrokeShape(this);
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'dash');

  /**
   * get/set dash array for stroke.
   * @name dash
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Array} dash
   * @returns {Array}
   * @example
   *  // apply dashed stroke that is 10px long and 5 pixels apart
   *  line.dash([10, 5]);
   *  // apply dashed stroke that is made up of alternating dashed
   *  // lines that are 10px long and 20px apart, and dots that have
   *  // a radius of 5px and are 20px apart
   *  line.dash([10, 20, 0.001, 20]);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'dashOffset',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set dash offset for stroke.
   * @name dash
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} dash offset
   * @returns {Number}
   * @example
   *  // apply dashed stroke that is 10px long and 5 pixels apart with an offset of 5px
   *  line.dash([10, 5]);
   *  line.dashOffset(5);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'shadowColor',
    undefined,
    Konva.Validators.getStringValidator()
  );

  /**
   * get/set shadow color
   * @name shadowColor
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} color
   * @returns {String}
   * @example
   * // get shadow color
   * var shadow = shape.shadowColor();
   *
   * // set shadow color with color string
   * shape.shadowColor('green');
   *
   * // set shadow color with hex
   * shape.shadowColor('#00ff00');
   *
   * // set shadow color with rgb
   * shape.shadowColor('rgb(0,255,0)');
   *
   * // set shadow color with rgba and make it 50% opaque
   * shape.shadowColor('rgba(0,255,0,0.5');
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'shadowBlur',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set shadow blur
   * @name shadowBlur
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} blur
   * @returns {Number}
   * @example
   * // get shadow blur
   * var shadowBlur = shape.shadowBlur();
   *
   * // set shadow blur
   * shape.shadowBlur(10);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'shadowOpacity',
    1,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set shadow opacity.  must be a value between 0 and 1
   * @name shadowOpacity
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} opacity
   * @returns {Number}
   * @example
   * // get shadow opacity
   * var shadowOpacity = shape.shadowOpacity();
   *
   * // set shadow opacity
   * shape.shadowOpacity(0.5);
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'shadowOffset', [
    'x',
    'y'
  ]);

  /**
   * get/set shadow offset
   * @name shadowOffset
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} offset
   * @param {Number} offset.x
   * @param {Number} offset.y
   * @returns {Object}
   * @example
   * // get shadow offset
   * var shadowOffset = shape.shadowOffset();
   *
   * // set shadow offset
   * shape.shadowOffset({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'shadowOffsetX',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set shadow offset x
   * @name shadowOffsetX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get shadow offset x
   * var shadowOffsetX = shape.shadowOffsetX();
   *
   * // set shadow offset x
   * shape.shadowOffsetX(5);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'shadowOffsetY',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set shadow offset y
   * @name shadowOffsetY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get shadow offset y
   * var shadowOffsetY = shape.shadowOffsetY();
   *
   * // set shadow offset y
   * shape.shadowOffsetY(5);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternImage');

  /**
   * get/set fill pattern image
   * @name fillPatternImage
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Image} image object
   * @returns {Image}
   * @example
   * // get fill pattern image
   * var fillPatternImage = shape.fillPatternImage();
   *
   * // set fill pattern image
   * var imageObj = new Image();
   * imageObj.onload = function() {
   *   shape.fillPatternImage(imageObj);
   * };
   * imageObj.src = 'path/to/image/jpg';
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fill',
    undefined,
    Konva.Validators.getStringValidator()
  );

  /**
   * get/set fill color
   * @name fill
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} color
   * @returns {String}
   * @example
   * // get fill color
   * var fill = shape.fill();
   *
   * // set fill color with color string
   * shape.fill('green');
   *
   * // set fill color with hex
   * shape.fill('#00ff00');
   *
   * // set fill color with rgb
   * shape.fill('rgb(0,255,0)');
   *
   * // set fill color with rgba and make it 50% opaque
   * shape.fill('rgba(0,255,0,0.5');
   *
   * // shape without fill
   * shape.fill(null);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillPatternX',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set fill pattern x
   * @name fillPatternX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill pattern x
   * var fillPatternX = shape.fillPatternX();
   * // set fill pattern x
   * shape.fillPatternX(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillPatternY',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set fill pattern y
   * @name fillPatternY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill pattern y
   * var fillPatternY = shape.fillPatternY();
   * // set fill pattern y
   * shape.fillPatternY(20);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientColorStops');

  /**
   * get/set fill linear gradient color stops
   * @name fillLinearGradientColorStops
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Array} colorStops
   * @returns {Array} colorStops
   * @example
   * // get fill linear gradient color stops
   * var colorStops = shape.fillLinearGradientColorStops();
   *
   * // create a linear gradient that starts with red, changes to blue
   * // halfway through, and then changes to green
   * shape.fillLinearGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeLinearGradientColorStops');

  /**
   * get/set stroke linear gradient color stops
   * @name strokeLinearGradientColorStops
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Array} colorStops
   * @returns {Array} colorStops
   * @example
   * // get stroke linear gradient color stops
   * var colorStops = shape.strokeLinearGradientColorStops();
   *
   * // create a linear gradient that starts with red, changes to blue
   * // halfway through, and then changes to green
   * shape.strokeLinearGradientColorStops([0, 'red', 0.5, 'blue', 1, 'green']);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartRadius',
    0
  );

  /**
   * get/set fill radial gradient start radius
   * @name fillRadialGradientStartRadius
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} radius
   * @returns {Number}
   * @example
   * // get radial gradient start radius
   * var startRadius = shape.fillRadialGradientStartRadius();
   *
   * // set radial gradient start radius
   * shape.fillRadialGradientStartRadius(0);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndRadius', 0);

  /**
   * get/set fill radial gradient end radius
   * @name fillRadialGradientEndRadius
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} radius
   * @returns {Number}
   * @example
   * // get radial gradient end radius
   * var endRadius = shape.fillRadialGradientEndRadius();
   *
   * // set radial gradient end radius
   * shape.fillRadialGradientEndRadius(100);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientColorStops');

  /**
   * get/set fill radial gradient color stops
   * @name fillRadialGradientColorStops
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} colorStops
   * @returns {Array}
   * @example
   * // get fill radial gradient color stops
   * var colorStops = shape.fillRadialGradientColorStops();
   *
   * // create a radial gradient that starts with red, changes to blue
   * // halfway through, and then changes to green
   * shape.fillRadialGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRepeat', 'repeat');

  /**
   * get/set fill pattern repeat.  Can be 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'.  The default is 'repeat'
   * @name fillPatternRepeat
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} repeat
   * @returns {String}
   * @example
   * // get fill pattern repeat
   * var repeat = shape.fillPatternRepeat();
   *
   * // repeat pattern in x direction only
   * shape.fillPatternRepeat('repeat-x');
   *
   * // do not repeat the pattern
   * shape.fillPatternRepeat('no repeat');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillEnabled', true);

  /**
   * get/set fill enabled flag
   * @name fillEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get fill enabled flag
   * var fillEnabled = shape.fillEnabled();
   *
   * // disable fill
   * shape.fillEnabled(false);
   *
   * // enable fill
   * shape.fillEnabled(true);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeEnabled', true);

  /**
   * get/set stroke enabled flag
   * @name strokeEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get stroke enabled flag
   * var strokeEnabled = shape.strokeEnabled();
   *
   * // disable stroke
   * shape.strokeEnabled(false);
   *
   * // enable stroke
   * shape.strokeEnabled(true);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowEnabled', true);

  /**
   * get/set shadow enabled flag
   * @name shadowEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get shadow enabled flag
   * var shadowEnabled = shape.shadowEnabled();
   *
   * // disable shadow
   * shape.shadowEnabled(false);
   *
   * // enable shadow
   * shape.shadowEnabled(true);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'dashEnabled', true);

  /**
   * get/set dash enabled flag
   * @name dashEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get dash enabled flag
   * var dashEnabled = shape.dashEnabled();
   *
   * // disable dash
   * shape.dashEnabled(false);
   *
   * // enable dash
   * shape.dashEnabled(true);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeScaleEnabled', true);

  /**
   * get/set strokeScale enabled flag
   * @name strokeScaleEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get stroke scale enabled flag
   * var strokeScaleEnabled = shape.strokeScaleEnabled();
   *
   * // disable stroke scale
   * shape.strokeScaleEnabled(false);
   *
   * // enable stroke scale
   * shape.strokeScaleEnabled(true);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPriority', 'color');

  /**
   * get/set fill priority.  can be color, pattern, linear-gradient, or radial-gradient.  The default is color.
   *   This is handy if you want to toggle between different fill types.
   * @name fillPriority
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} priority
   * @returns {String}
   * @example
   * // get fill priority
   * var fillPriority = shape.fillPriority();
   *
   * // set fill priority
   * shape.fillPriority('linear-gradient');
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternOffset', [
    'x',
    'y'
  ]);

  /**
   * get/set fill pattern offset
   * @name fillPatternOffset
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} offset
   * @param {Number} offset.x
   * @param {Number} offset.y
   * @returns {Object}
   * @example
   * // get fill pattern offset
   * var patternOffset = shape.fillPatternOffset();
   *
   * // set fill pattern offset
   * shape.fillPatternOffset({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillPatternOffsetX',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set fill pattern offset x
   * @name fillPatternOffsetX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill pattern offset x
   * var patternOffsetX = shape.fillPatternOffsetX();
   *
   * // set fill pattern offset x
   * shape.fillPatternOffsetX(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillPatternOffsetY',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set fill pattern offset y
   * @name fillPatternOffsetY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill pattern offset y
   * var patternOffsetY = shape.fillPatternOffsetY();
   *
   * // set fill pattern offset y
   * shape.fillPatternOffsetY(10);
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternScale', [
    'x',
    'y'
  ]);

  /**
   * get/set fill pattern scale
   * @name fillPatternScale
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} scale
   * @param {Number} scale.x
   * @param {Number} scale.y
   * @returns {Object}
   * @example
   * // get fill pattern scale
   * var patternScale = shape.fillPatternScale();
   *
   * // set fill pattern scale
   * shape.fillPatternScale({
   *   x: 2
   *   y: 2
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillPatternScaleX',
    1,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set fill pattern scale x
   * @name fillPatternScaleX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill pattern scale x
   * var patternScaleX = shape.fillPatternScaleX();
   *
   * // set fill pattern scale x
   * shape.fillPatternScaleX(2);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillPatternScaleY',
    1,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set fill pattern scale y
   * @name fillPatternScaleY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill pattern scale y
   * var patternScaleY = shape.fillPatternScaleY();
   *
   * // set fill pattern scale y
   * shape.fillPatternScaleY(2);
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillLinearGradientStartPoint',
    ['x', 'y']
  );

  /**
   * get/set fill linear gradient start point
   * @name fillLinearGradientStartPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} startPoint
   * @param {Number} startPoint.x
   * @param {Number} startPoint.y
   * @returns {Object}
   * @example
   * // get fill linear gradient start point
   * var startPoint = shape.fillLinearGradientStartPoint();
   *
   * // set fill linear gradient start point
   * shape.fillLinearGradientStartPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'strokeLinearGradientStartPoint',
    ['x', 'y']
  );

  /**
   * get/set stroke linear gradient start point
   * @name strokeLinearGradientStartPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} startPoint
   * @param {Number} startPoint.x
   * @param {Number} startPoint.y
   * @returns {Object}
   * @example
   * // get stroke linear gradient start point
   * var startPoint = shape.strokeLinearGradientStartPoint();
   *
   * // set stroke linear gradient start point
   * shape.strokeLinearGradientStartPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillLinearGradientStartPointX',
    0
  );

  /**
   * get/set fill linear gradient start point x
   * @name fillLinearGradientStartPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill linear gradient start point x
   * var startPointX = shape.fillLinearGradientStartPointX();
   *
   * // set fill linear gradient start point x
   * shape.fillLinearGradientStartPointX(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'strokeLinearGradientStartPointX',
    0
  );

  /**
   * get/set stroke linear gradient start point x
   * @name linearLinearGradientStartPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get stroke linear gradient start point x
   * var startPointX = shape.strokeLinearGradientStartPointX();
   *
   * // set stroke linear gradient start point x
   * shape.strokeLinearGradientStartPointX(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillLinearGradientStartPointY',
    0
  );

  /**
   * get/set fill linear gradient start point y
   * @name fillLinearGradientStartPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill linear gradient start point y
   * var startPointY = shape.fillLinearGradientStartPointY();
   *
   * // set fill linear gradient start point y
   * shape.fillLinearGradientStartPointY(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'strokeLinearGradientStartPointY',
    0
  );
  /**
   * get/set stroke linear gradient start point y
   * @name strokeLinearGradientStartPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get stroke linear gradient start point y
   * var startPointY = shape.strokeLinearGradientStartPointY();
   *
   * // set stroke linear gradient start point y
   * shape.strokeLinearGradientStartPointY(20);
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillLinearGradientEndPoint',
    ['x', 'y']
  );

  /**
   * get/set fill linear gradient end point
   * @name fillLinearGradientEndPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} endPoint
   * @param {Number} endPoint.x
   * @param {Number} endPoint.y
   * @returns {Object}
   * @example
   * // get fill linear gradient end point
   * var endPoint = shape.fillLinearGradientEndPoint();
   *
   * // set fill linear gradient end point
   * shape.fillLinearGradientEndPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'strokeLinearGradientEndPoint',
    ['x', 'y']
  );

  /**
   * get/set stroke linear gradient end point
   * @name strokeLinearGradientEndPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} endPoint
   * @param {Number} endPoint.x
   * @param {Number} endPoint.y
   * @returns {Object}
   * @example
   * // get stroke linear gradient end point
   * var endPoint = shape.strokeLinearGradientEndPoint();
   *
   * // set stroke linear gradient end point
   * shape.strokeLinearGradientEndPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointX', 0);
  /**
   * get/set fill linear gradient end point x
   * @name fillLinearGradientEndPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill linear gradient end point x
   * var endPointX = shape.fillLinearGradientEndPointX();
   *
   * // set fill linear gradient end point x
   * shape.fillLinearGradientEndPointX(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'strokeLinearGradientEndPointX',
    0
  );
  /**
   * get/set fill linear gradient end point x
   * @name strokeLinearGradientEndPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get stroke linear gradient end point x
   * var endPointX = shape.strokeLinearGradientEndPointX();
   *
   * // set stroke linear gradient end point x
   * shape.strokeLinearGradientEndPointX(20);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointY', 0);
  /**
   * get/set fill linear gradient end point y
   * @name fillLinearGradientEndPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill linear gradient end point y
   * var endPointY = shape.fillLinearGradientEndPointY();
   *
   * // set fill linear gradient end point y
   * shape.fillLinearGradientEndPointY(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'strokeLinearGradientEndPointY',
    0
  );
  /**
   * get/set stroke linear gradient end point y
   * @name strokeLinearGradientEndPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get stroke linear gradient end point y
   * var endPointY = shape.strokeLinearGradientEndPointY();
   *
   * // set stroke linear gradient end point y
   * shape.strokeLinearGradientEndPointY(20);
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartPoint',
    ['x', 'y']
  );

  /**
   * get/set fill radial gradient start point
   * @name fillRadialGradientStartPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} startPoint
   * @param {Number} startPoint.x
   * @param {Number} startPoint.y
   * @returns {Object}
   * @example
   * // get fill radial gradient start point
   * var startPoint = shape.fillRadialGradientStartPoint();
   *
   * // set fill radial gradient start point
   * shape.fillRadialGradientStartPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartPointX',
    0
  );
  /**
   * get/set fill radial gradient start point x
   * @name fillRadialGradientStartPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill radial gradient start point x
   * var startPointX = shape.fillRadialGradientStartPointX();
   *
   * // set fill radial gradient start point x
   * shape.fillRadialGradientStartPointX(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartPointY',
    0
  );
  /**
   * get/set fill radial gradient start point y
   * @name fillRadialGradientStartPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill radial gradient start point y
   * var startPointY = shape.fillRadialGradientStartPointY();
   *
   * // set fill radial gradient start point y
   * shape.fillRadialGradientStartPointY(20);
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillRadialGradientEndPoint',
    ['x', 'y']
  );

  /**
   * get/set fill radial gradient end point
   * @name fillRadialGradientEndPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} endPoint
   * @param {Number} endPoint.x
   * @param {Number} endPoint.y
   * @returns {Object}
   * @example
   * // get fill radial gradient end point
   * var endPoint = shape.fillRadialGradientEndPoint();
   *
   * // set fill radial gradient end point
   * shape.fillRadialGradientEndPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointX', 0);
  /**
   * get/set fill radial gradient end point x
   * @name fillRadialGradientEndPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill radial gradient end point x
   * var endPointX = shape.fillRadialGradientEndPointX();
   *
   * // set fill radial gradient end point x
   * shape.fillRadialGradientEndPointX(20);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointY', 0);
  /**
   * get/set fill radial gradient end point y
   * @name fillRadialGradientEndPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill radial gradient end point y
   * var endPointY = shape.fillRadialGradientEndPointY();
   *
   * // set fill radial gradient end point y
   * shape.fillRadialGradientEndPointY(20);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRotation', 0);

  /**
   * get/set fill pattern rotation in degrees
   * @name fillPatternRotation
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} rotation
   * @returns {Konva.Shape}
   * @example
   * // get fill pattern rotation
   * var patternRotation = shape.fillPatternRotation();
   *
   * // set fill pattern rotation
   * shape.fillPatternRotation(20);
   */

  Konva.Factory.backCompat(Konva.Shape, {
    dashArray: 'dash',
    getDashArray: 'getDash',
    setDashArray: 'getDash',

    drawFunc: 'sceneFunc',
    getDrawFunc: 'getSceneFunc',
    setDrawFunc: 'setSceneFunc',

    drawHitFunc: 'hitFunc',
    getDrawHitFunc: 'getHitFunc',
    setDrawHitFunc: 'setHitFunc'
  });

  Konva.Collection.mapMethods(Konva.Shape);
})(Konva);

(function() {
  'use strict';
  // CONSTANTS
  var STAGE = 'Stage',
    STRING = 'string',
    PX = 'px',
    MOUSEOUT = 'mouseout',
    MOUSELEAVE = 'mouseleave',
    MOUSEOVER = 'mouseover',
    MOUSEENTER = 'mouseenter',
    MOUSEMOVE = 'mousemove',
    MOUSEDOWN = 'mousedown',
    MOUSEUP = 'mouseup',
    CONTEXTMENU = 'contextmenu',
    CLICK = 'click',
    DBL_CLICK = 'dblclick',
    TOUCHSTART = 'touchstart',
    TOUCHEND = 'touchend',
    TAP = 'tap',
    DBL_TAP = 'dbltap',
    TOUCHMOVE = 'touchmove',
    WHEEL = 'wheel',
    CONTENT_MOUSEOUT = 'contentMouseout',
    CONTENT_MOUSEOVER = 'contentMouseover',
    CONTENT_MOUSEMOVE = 'contentMousemove',
    CONTENT_MOUSEDOWN = 'contentMousedown',
    CONTENT_MOUSEUP = 'contentMouseup',
    CONTENT_CONTEXTMENU = 'contentContextmenu',
    CONTENT_CLICK = 'contentClick',
    CONTENT_DBL_CLICK = 'contentDblclick',
    CONTENT_TOUCHSTART = 'contentTouchstart',
    CONTENT_TOUCHEND = 'contentTouchend',
    CONTENT_DBL_TAP = 'contentDbltap',
    CONTENT_TAP = 'contentTap',
    CONTENT_TOUCHMOVE = 'contentTouchmove',
    CONTENT_WHEEL = 'contentWheel',
    DIV = 'div',
    RELATIVE = 'relative',
    KONVA_CONTENT = 'konvajs-content',
    SPACE = ' ',
    UNDERSCORE = '_',
    CONTAINER = 'container',
    EMPTY_STRING = '',
    EVENTS = [
      MOUSEDOWN,
      MOUSEMOVE,
      MOUSEUP,
      MOUSEOUT,
      TOUCHSTART,
      TOUCHMOVE,
      TOUCHEND,
      MOUSEOVER,
      WHEEL,
      CONTEXTMENU
    ],
    // cached variables
    eventsLength = EVENTS.length;

  function addEvent(ctx, eventName) {
    ctx.content.addEventListener(
      eventName,
      function(evt) {
        ctx[UNDERSCORE + eventName](evt);
      },
      false
    );
  }

  /**
   * Stage constructor.  A stage is used to contain multiple layers
   * @constructor
   * @memberof Konva
   * @augments Konva.Container
   * @param {Object} config
   * @param {String|Element} config.container Container selector or DOM element
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var stage = new Konva.Stage({
   *   width: 500,
   *   height: 800,
   *   container: 'containerId' // or "#containerId" or ".containerClass"
   * });
   */
  Konva.Stage = function(config) {
    this.___init(config);
  };

  Konva.Util.addMethods(Konva.Stage, {
    ___init: function(config) {
      this.nodeType = STAGE;
      // call super constructor
      Konva.Container.call(this, config);
      this._id = Konva.idCounter++;
      this._buildDOM();
      this._bindContentEvents();
      this._enableNestedTransforms = false;
      Konva.stages.push(this);
    },
    _validateAdd: function(child) {
      if (child.getType() !== 'Layer') {
        Konva.Util.throw('You may only add layers to the stage.');
      }
    },
    /**
     * set container dom element which contains the stage wrapper div element
     * @method
     * @memberof Konva.Stage.prototype
     * @param {DomElement} container can pass in a dom element or id string
     */
    setContainer: function(container) {
      if (typeof container === STRING) {
        if (container.charAt(0) === '.') {
          var className = container.slice(1);
          container = Konva.document.getElementsByClassName(className)[0];
        } else {
          var id;
          if (container.charAt(0) !== '#') {
            id = container;
          } else {
            id = container.slice(1);
          }
          container = Konva.document.getElementById(id);
        }
        if (!container) {
          throw 'Can not find container in document with id ' + id;
        }
      }
      this._setAttr(CONTAINER, container);
      return this;
    },
    shouldDrawHit: function() {
      return true;
    },
    draw: function() {
      Konva.Node.prototype.draw.call(this);
      return this;
    },
    /**
     * draw layer scene graphs
     * @name draw
     * @method
     * @memberof Konva.Stage.prototype
     */

    /**
     * draw layer hit graphs
     * @name drawHit
     * @method
     * @memberof Konva.Stage.prototype
     */

    /**
     * set height
     * @method
     * @memberof Konva.Stage.prototype
     * @param {Number} height
     */
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      this._resizeDOM();
      return this;
    },
    /**
     * set width
     * @method
     * @memberof Konva.Stage.prototype
     * @param {Number} width
     */
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      this._resizeDOM();
      return this;
    },
    /**
     * clear all layers
     * @method
     * @memberof Konva.Stage.prototype
     */
    clear: function() {
      var layers = this.children,
        len = layers.length,
        n;

      for (n = 0; n < len; n++) {
        layers[n].clear();
      }
      return this;
    },
    clone: function(obj) {
      if (!obj) {
        obj = {};
      }
      obj.container = Konva.document.createElement(DIV);
      return Konva.Container.prototype.clone.call(this, obj);
    },
    /**
     * destroy stage
     * @method
     * @memberof Konva.Stage.prototype
     */
    destroy: function() {
      var content = this.content;
      Konva.Container.prototype.destroy.call(this);

      if (content && Konva.Util._isInDocument(content)) {
        this.getContainer().removeChild(content);
      }
      var index = Konva.stages.indexOf(this);
      if (index > -1) {
        Konva.stages.splice(index, 1);
      }
      return this;
    },
    /**
     * get pointer position which can be a touch position or mouse position
     * @method
     * @memberof Konva.Stage.prototype
     * @returns {Object}
     */
    getPointerPosition: function() {
      return this.pointerPos;
    },
    getStage: function() {
      return this;
    },
    /**
     * get stage content div element which has the
     *  the class name "konvajs-content"
     * @method
     * @memberof Konva.Stage.prototype
     */
    getContent: function() {
      return this.content;
    },
    _toKonvaCanvas: function(config) {
      config = config || {};

      var x = config.x || 0,
        y = config.y || 0,
        canvas = new Konva.SceneCanvas({
          width: config.width || this.getWidth(),
          height: config.height || this.getHeight(),
          pixelRatio: config.pixelRatio || 1
        }),
        _context = canvas.getContext()._context,
        layers = this.children;

      if (x || y) {
        _context.translate(-1 * x, -1 * y);
      }

      layers.each(function(layer) {
        if (!layer.isVisible()) {
          return;
        }
        var layerCanvas = layer._toKonvaCanvas(config);
        _context.drawImage(
          layerCanvas._canvas,
          x,
          y,
          layerCanvas.getWidth() / layerCanvas.getPixelRatio(),
          layerCanvas.getHeight() / layerCanvas.getPixelRatio()
        );
      });
      return canvas;
    },
    /**
     * converts stage into an image.
     * @method
     * @memberof Konva.Stage.prototype
     * @param {Object} config
     * @param {Function} config.callback function executed when the composite has completed
     * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
     *  "image/png" is the default
     * @param {Number} [config.x] x position of canvas section
     * @param {Number} [config.y] y position of canvas section
     * @param {Number} [config.width] width of canvas section
     * @param {Number} [config.height] height of canvas section
     * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
     *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
     *  is very high quality
     */
    toImage: function(config) {
      var cb = config.callback;

      config.callback = function(dataUrl) {
        Konva.Util._getImage(dataUrl, function(img) {
          cb(img);
        });
      };
      this.toDataURL(config);
    },
    /**
     * get visible intersection shape. This is the preferred
     *  method for determining if a point intersects a shape or not
     * @method
     * @memberof Konva.Stage.prototype
     * @param {Object} pos
     * @param {Number} pos.x
     * @param {Number} pos.y
     * @param {String} [selector]
     * @returns {Konva.Node}
     * @example
     * var shape = stage.getIntersection({x: 50, y: 50});
     * // or if you interested in shape parent:
     * var group = stage.getIntersection({x: 50, y: 50}, 'Group');
     */
    getIntersection: function(pos, selector) {
      var layers = this.getChildren(),
        len = layers.length,
        end = len - 1,
        n,
        shape;

      for (n = end; n >= 0; n--) {
        shape = layers[n].getIntersection(pos, selector);
        if (shape) {
          return shape;
        }
      }

      return null;
    },
    _resizeDOM: function() {
      if (this.content) {
        var width = this.getWidth(),
          height = this.getHeight(),
          layers = this.getChildren(),
          len = layers.length,
          n,
          layer;

        // set content dimensions
        this.content.style.width = width + PX;
        this.content.style.height = height + PX;

        this.bufferCanvas.setSize(width, height);
        this.bufferHitCanvas.setSize(width, height);

        // set layer dimensions
        for (n = 0; n < len; n++) {
          layer = layers[n];
          layer.setSize(width, height);
          layer.draw();
        }
      }
    },
    /**
     * add layer or layers to stage
     * @method
     * @memberof Konva.Stage.prototype
     * @param {...Konva.Layer} layer
     * @example
     * stage.add(layer1, layer2, layer3);
     */
    add: function(layer) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      Konva.Container.prototype.add.call(this, layer);
      layer._setCanvasSize(this.width(), this.height());

      // draw layer and append canvas to container
      layer.draw();

      if (Konva.isBrowser) {
        this.content.appendChild(layer.canvas._canvas);
      }

      // chainable
      return this;
    },
    getParent: function() {
      return null;
    },
    getLayer: function() {
      return null;
    },
    /**
     * returns a {@link Konva.Collection} of layers
     * @method
     * @memberof Konva.Stage.prototype
     */
    getLayers: function() {
      return this.getChildren();
    },
    _bindContentEvents: function() {
      if (!Konva.isBrowser) {
        return;
      }
      for (var n = 0; n < eventsLength; n++) {
        addEvent(this, EVENTS[n]);
      }
    },
    _mouseover: function(evt) {
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        this._fire(CONTENT_MOUSEOVER, { evt: evt });
      }
    },
    _mouseout: function(evt) {
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        var targetShape = this.targetShape;

        if (targetShape && !Konva.isDragging()) {
          targetShape._fireAndBubble(MOUSEOUT, { evt: evt });
          targetShape._fireAndBubble(MOUSELEAVE, { evt: evt });
          this.targetShape = null;
        }
        this.pointerPos = undefined;

        this._fire(CONTENT_MOUSEOUT, { evt: evt });
      }
    },
    _mousemove: function(evt) {
      // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
      if (Konva.UA.ieMobile) {
        return this._touchmove(evt);
      }
      // workaround fake mousemove event in chrome browser https://code.google.com/p/chromium/issues/detail?id=161464
      if (
        (typeof evt.movementX !== 'undefined' ||
          typeof evt.movementY !== 'undefined') &&
        evt.movementY === 0 &&
        evt.movementX === 0
      ) {
        return null;
      }
      if (Konva.UA.mobile) {
        return null;
      }
      this._setPointerPosition(evt);
      var shape;

      if (!Konva.isDragging()) {
        shape = this.getIntersection(this.getPointerPosition());
        if (shape && shape.isListening()) {
          if (
            !Konva.isDragging() &&
            (!this.targetShape || this.targetShape._id !== shape._id)
          ) {
            if (this.targetShape) {
              this.targetShape._fireAndBubble(MOUSEOUT, { evt: evt }, shape);
              this.targetShape._fireAndBubble(MOUSELEAVE, { evt: evt }, shape);
            }
            shape._fireAndBubble(MOUSEOVER, { evt: evt }, this.targetShape);
            shape._fireAndBubble(MOUSEENTER, { evt: evt }, this.targetShape);
            this.targetShape = shape;
          } else {
            shape._fireAndBubble(MOUSEMOVE, { evt: evt });
          }
        } else {
          /*
                 * if no shape was detected, clear target shape and try
                 * to run mouseout from previous target shape
                 */
          if (this.targetShape && !Konva.isDragging()) {
            this.targetShape._fireAndBubble(MOUSEOUT, { evt: evt });
            this.targetShape._fireAndBubble(MOUSELEAVE, { evt: evt });
            this.targetShape = null;
          }
          this._fire(MOUSEMOVE, {
            evt: evt,
            target: this,
            currentTarget: this
          });
        }

        // content event
        this._fire(CONTENT_MOUSEMOVE, { evt: evt });
      }

      // always call preventDefault for desktop events because some browsers
      // try to drag and drop the canvas element
      if (evt.cancelable) {
        evt.preventDefault();
      }
    },
    _mousedown: function(evt) {
      // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
      if (Konva.UA.ieMobile) {
        return this._touchstart(evt);
      }
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        var shape = this.getIntersection(this.getPointerPosition());

        Konva.listenClickTap = true;

        if (shape && shape.isListening()) {
          this.clickStartShape = shape;
          shape._fireAndBubble(MOUSEDOWN, { evt: evt });
        } else {
          this._fire(MOUSEDOWN, {
            evt: evt,
            target: this,
            currentTarget: this
          });
        }

        // content event
        this._fire(CONTENT_MOUSEDOWN, { evt: evt });
      }

      // always call preventDefault for desktop events because some browsers
      // try to drag and drop the canvas element
      // TODO: if we preventDefault() it will cancel event detection outside of window inside iframe
      // but we need it for better drag&drop
      // can we disable native drag&drop somehow differently?
      // if (evt.cancelable) {
      // evt.preventDefault();
      // }
    },
    _mouseup: function(evt) {
      // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
      if (Konva.UA.ieMobile) {
        return this._touchend(evt);
      }
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        var shape = this.getIntersection(this.getPointerPosition()),
          clickStartShape = this.clickStartShape,
          clickEndShape = this.clickEndShape,
          fireDblClick = false,
          dd = Konva.DD;

        if (Konva.inDblClickWindow) {
          fireDblClick = true;
          clearTimeout(this.dblTimeout);
          // Konva.inDblClickWindow = false;
        } else if (!dd || !dd.justDragged) {
          // don't set inDblClickWindow after dragging
          Konva.inDblClickWindow = true;
          clearTimeout(this.dblTimeout);
        } else if (dd) {
          dd.justDragged = false;
        }

        this.dblTimeout = setTimeout(function() {
          Konva.inDblClickWindow = false;
        }, Konva.dblClickWindow);

        if (shape && shape.isListening()) {
          this.clickEndShape = shape;
          shape._fireAndBubble(MOUSEUP, { evt: evt });

          // detect if click or double click occurred
          if (
            Konva.listenClickTap &&
            clickStartShape &&
            clickStartShape._id === shape._id
          ) {
            shape._fireAndBubble(CLICK, { evt: evt });

            if (
              fireDblClick &&
              clickEndShape &&
              clickEndShape._id === shape._id
            ) {
              shape._fireAndBubble(DBL_CLICK, { evt: evt });
            }
          }
        } else {
          this._fire(MOUSEUP, { evt: evt, target: this, currentTarget: this });
          if (Konva.listenClickTap) {
            this._fire(CLICK, { evt: evt, target: this, currentTarget: this });
          }

          if (fireDblClick) {
            this._fire(DBL_CLICK, {
              evt: evt,
              target: this,
              currentTarget: this
            });
          }
        }
        // content events
        this._fire(CONTENT_MOUSEUP, { evt: evt });
        if (Konva.listenClickTap) {
          this._fire(CONTENT_CLICK, { evt: evt });
          if (fireDblClick) {
            this._fire(CONTENT_DBL_CLICK, { evt: evt });
          }
        }

        Konva.listenClickTap = false;
      }

      // always call preventDefault for desktop events because some browsers
      // try to drag and drop the canvas element
      if (evt.cancelable) {
        evt.preventDefault();
      }
    },
    _contextmenu: function(evt) {
      this._setPointerPosition(evt);
      var shape = this.getIntersection(this.getPointerPosition());

      if (shape && shape.isListening()) {
        shape._fireAndBubble(CONTEXTMENU, { evt: evt });
      } else {
        this._fire(CONTEXTMENU, {
          evt: evt,
          target: this,
          currentTarget: this
        });
      }
      this._fire(CONTENT_CONTEXTMENU, { evt: evt });
    },
    _touchstart: function(evt) {
      this._setPointerPosition(evt);
      var shape = this.getIntersection(this.getPointerPosition());

      Konva.listenClickTap = true;

      if (shape && shape.isListening()) {
        this.tapStartShape = shape;
        shape._fireAndBubble(TOUCHSTART, { evt: evt });

        // only call preventDefault if the shape is listening for events
        if (shape.isListening() && shape.preventDefault() && evt.cancelable) {
          evt.preventDefault();
        }
      } else {
        this._fire(TOUCHSTART, {
          evt: evt,
          target: this,
          currentTarget: this
        });
      }
      // content event
      this._fire(CONTENT_TOUCHSTART, { evt: evt });
    },
    _touchend: function(evt) {
      this._setPointerPosition(evt);
      var shape = this.getIntersection(this.getPointerPosition()),
        fireDblClick = false;

      if (Konva.inDblClickWindow) {
        fireDblClick = true;
        clearTimeout(this.dblTimeout);
        // Konva.inDblClickWindow = false;
      } else {
        Konva.inDblClickWindow = true;
        clearTimeout(this.dblTimeout);
      }

      this.dblTimeout = setTimeout(function() {
        Konva.inDblClickWindow = false;
      }, Konva.dblClickWindow);

      if (shape && shape.isListening()) {
        shape._fireAndBubble(TOUCHEND, { evt: evt });

        // detect if tap or double tap occurred
        if (
          Konva.listenClickTap &&
          this.tapStartShape &&
          shape._id === this.tapStartShape._id
        ) {
          shape._fireAndBubble(TAP, { evt: evt });

          if (fireDblClick) {
            shape._fireAndBubble(DBL_TAP, { evt: evt });
          }
        }
        // only call preventDefault if the shape is listening for events
        if (shape.isListening() && shape.preventDefault() && evt.cancelable) {
          evt.preventDefault();
        }
      } else {
        this._fire(TOUCHEND, { evt: evt, target: this, currentTarget: this });
        if (Konva.listenClickTap) {
          this._fire(TAP, { evt: evt, target: this, currentTarget: this });
        }
        if (fireDblClick) {
          this._fire(DBL_TAP, {
            evt: evt,
            target: this,
            currentTarget: this
          });
        }
      }
      // content events
      this._fire(CONTENT_TOUCHEND, { evt: evt });
      if (Konva.listenClickTap) {
        this._fire(CONTENT_TAP, { evt: evt });
        if (fireDblClick) {
          this._fire(CONTENT_DBL_TAP, { evt: evt });
        }
      }

      Konva.listenClickTap = false;
    },
    _touchmove: function(evt) {
      this._setPointerPosition(evt);
      var dd = Konva.DD,
        shape;
      if (!Konva.isDragging()) {
        shape = this.getIntersection(this.getPointerPosition());
        if (shape && shape.isListening()) {
          shape._fireAndBubble(TOUCHMOVE, { evt: evt });
          // only call preventDefault if the shape is listening for events
          if (shape.isListening() && shape.preventDefault() && evt.cancelable) {
            evt.preventDefault();
          }
        } else {
          this._fire(TOUCHMOVE, {
            evt: evt,
            target: this,
            currentTarget: this
          });
        }
        this._fire(CONTENT_TOUCHMOVE, { evt: evt });
      }
      if (dd) {
        if (
          Konva.isDragging() &&
          Konva.DD.node.preventDefault() &&
          evt.cancelable
        ) {
          evt.preventDefault();
        }
      }
    },
    _wheel: function(evt) {
      this._setPointerPosition(evt);
      var shape = this.getIntersection(this.getPointerPosition());

      if (shape && shape.isListening()) {
        shape._fireAndBubble(WHEEL, { evt: evt });
      } else {
        this._fire(WHEEL, {
          evt: evt,
          target: this,
          currentTarget: this
        });
      }
      this._fire(CONTENT_WHEEL, { evt: evt });
    },
    _setPointerPosition: function(evt) {
      var contentPosition = this._getContentPosition(),
        x = null,
        y = null;
      evt = evt ? evt : window.event;

      // touch events
      if (evt.touches !== undefined) {
        // currently, only handle one finger
        if (evt.touches.length > 0) {
          var touch = evt.touches[0];
          // get the information for finger #1
          x = touch.clientX - contentPosition.left;
          y = touch.clientY - contentPosition.top;
        }
      } else {
        // mouse events
        x = evt.clientX - contentPosition.left;
        y = evt.clientY - contentPosition.top;
      }
      if (x !== null && y !== null) {
        this.pointerPos = {
          x: x,
          y: y
        };
      }
    },
    _getContentPosition: function() {
      var rect = this.content.getBoundingClientRect
        ? this.content.getBoundingClientRect()
        : { top: 0, left: 0 };
      return {
        top: rect.top,
        left: rect.left
      };
    },
    _buildDOM: function() {
      // the buffer canvas pixel ratio must be 1 because it is used as an
      // intermediate canvas before copying the result onto a scene canvas.
      // not setting it to 1 will result in an over compensation
      this.bufferCanvas = new Konva.SceneCanvas();
      this.bufferHitCanvas = new Konva.HitCanvas({ pixelRatio: 1 });

      if (!Konva.isBrowser) {
        return;
      }
      var container = this.getContainer();
      if (!container) {
        throw 'Stage has no container. A container is required.';
      }
      // clear content inside container
      container.innerHTML = EMPTY_STRING;

      // content
      this.content = Konva.document.createElement(DIV);
      this.content.style.position = RELATIVE;
      this.content.style.userSelect = 'none';
      this.content.className = KONVA_CONTENT;

      this.content.setAttribute('role', 'presentation');

      container.appendChild(this.content);

      this._resizeDOM();
    },
    _onContent: function(typesStr, handler) {
      var types = typesStr.split(SPACE),
        len = types.length,
        n,
        baseEvent;

      for (n = 0; n < len; n++) {
        baseEvent = types[n];
        this.content.addEventListener(baseEvent, handler, false);
      }
    },
    // currently cache function is now working for stage, because stage has no its own canvas element
    // TODO: may be it is better to cache all children layers?
    cache: function() {
      Konva.Util.warn(
        'Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.'
      );
    },
    clearCache: function() {}
  });
  Konva.Util.extend(Konva.Stage, Konva.Container);

  // add getters and setters
  Konva.Factory.addGetter(Konva.Stage, 'container');
  Konva.Factory.addOverloadedGetterSetter(Konva.Stage, 'container');

  /**
   * get container DOM element
   * @name container
   * @method
   * @memberof Konva.Stage.prototype
   * @returns {DomElement} container
   * @example
   * // get container
   * var container = stage.container();
   * // set container
   * var container = document.createElement('div');
   * body.appendChild(container);
   * stage.container(container);
   */
})();

(function(Konva) {
  'use strict';
  /**
   * BaseLayer constructor.
   * @constructor
   * @memberof Konva
   * @augments Konva.Container
   * @param {Object} config
   * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
   * to clear the canvas before each layer draw.  The default value is true.
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

   */
  Konva.BaseLayer = function(config) {
    this.___init(config);
  };

  Konva.Util.addMethods(Konva.BaseLayer, {
    ___init: function(config) {
      this.nodeType = 'Layer';
      Konva.Container.call(this, config);
    },
    createPNGStream: function() {
      return this.canvas._canvas.createPNGStream();
    },
    /**
     * get layer canvas
     * @method
     * @memberof Konva.BaseLayer.prototype
     */
    getCanvas: function() {
      return this.canvas;
    },
    /**
     * get layer hit canvas
     * @method
     * @memberof Konva.BaseLayer.prototype
     */
    getHitCanvas: function() {
      return this.hitCanvas;
    },
    /**
     * get layer canvas context
     * @method
     * @memberof Konva.BaseLayer.prototype
     */
    getContext: function() {
      return this.getCanvas().getContext();
    },
    /**
     * clear scene and hit canvas contexts tied to the layer
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @param {Object} [bounds]
     * @param {Number} [bounds.x]
     * @param {Number} [bounds.y]
     * @param {Number} [bounds.width]
     * @param {Number} [bounds.height]
     * @example
     * layer.clear();
     * layer.clear({
     *   x : 0,
     *   y : 0,
     *   width : 100,
     *   height : 100
     * });
     */
    clear: function(bounds) {
      this.getContext().clear(bounds);
      return this;
    },
    clearHitCache: function() {
      this._hitImageData = undefined;
    },
    // extend Node.prototype.setZIndex
    setZIndex: function(index) {
      Konva.Node.prototype.setZIndex.call(this, index);
      var stage = this.getStage();
      if (stage) {
        stage.content.removeChild(this.getCanvas()._canvas);

        if (index < stage.getChildren().length - 1) {
          stage.content.insertBefore(
            this.getCanvas()._canvas,
            stage.getChildren()[index + 1].getCanvas()._canvas
          );
        } else {
          stage.content.appendChild(this.getCanvas()._canvas);
        }
      }
      return this;
    },
    // extend Node.prototype.moveToTop
    moveToTop: function() {
      Konva.Node.prototype.moveToTop.call(this);
      var stage = this.getStage();
      if (stage) {
        stage.content.removeChild(this.getCanvas()._canvas);
        stage.content.appendChild(this.getCanvas()._canvas);
      }
      return this;
    },
    // extend Node.prototype.moveUp
    moveUp: function() {
      var moved = Konva.Node.prototype.moveUp.call(this);
      if (!moved) {
        return this;
      }
      var stage = this.getStage();
      if (!stage) {
        return this;
      }
      stage.content.removeChild(this.getCanvas()._canvas);

      if (this.index < stage.getChildren().length - 1) {
        stage.content.insertBefore(
          this.getCanvas()._canvas,
          stage.getChildren()[this.index + 1].getCanvas()._canvas
        );
      } else {
        stage.content.appendChild(this.getCanvas()._canvas);
      }
      return this;
    },
    // extend Node.prototype.moveDown
    moveDown: function() {
      if (Konva.Node.prototype.moveDown.call(this)) {
        var stage = this.getStage();
        if (stage) {
          var children = stage.getChildren();
          stage.content.removeChild(this.getCanvas()._canvas);
          stage.content.insertBefore(
            this.getCanvas()._canvas,
            children[this.index + 1].getCanvas()._canvas
          );
        }
      }
      return this;
    },
    // extend Node.prototype.moveToBottom
    moveToBottom: function() {
      if (Konva.Node.prototype.moveToBottom.call(this)) {
        var stage = this.getStage();
        if (stage) {
          var children = stage.getChildren();
          stage.content.removeChild(this.getCanvas()._canvas);
          stage.content.insertBefore(
            this.getCanvas()._canvas,
            children[1].getCanvas()._canvas
          );
        }
      }
      return this;
    },
    getLayer: function() {
      return this;
    },
    remove: function() {
      var _canvas = this.getCanvas()._canvas;

      Konva.Node.prototype.remove.call(this);

      if (_canvas && _canvas.parentNode && Konva.Util._isInDocument(_canvas)) {
        _canvas.parentNode.removeChild(_canvas);
      }
      return this;
    },
    getStage: function() {
      return this.parent;
    },
    setSize: function(width, height) {
      this.canvas.setSize(width, height);
      return this;
    },
    _toKonvaCanvas: function(config) {
      config = config || {};
      config.width = config.width || this.getWidth();
      config.height = config.height || this.getHeight();
      config.x = config.x !== undefined ? config.x : this.getX();
      config.y = config.y !== undefined ? config.y : this.getY();

      return Konva.Node.prototype._toKonvaCanvas.call(this, config);
    },
    /**
     * get/set width of layer.getter return width of stage. setter doing nothing.
     * if you want change width use `stage.width(value);`
     * @name width
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @returns {Number}
     * @example
     * var width = layer.width();
     */
    getWidth: function() {
      if (this.parent) {
        return this.parent.getWidth();
      }
    },
    setWidth: function() {
      Konva.Util.warn(
        'Can not change width of layer. Use "stage.width(value)" function instead.'
      );
    },
    /**
     * get/set height of layer.getter return height of stage. setter doing nothing.
     * if you want change height use `stage.height(value);`
     * @name height
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @returns {Number}
     * @example
     * var height = layer.height();
     */
    getHeight: function() {
      if (this.parent) {
        return this.parent.getHeight();
      }
    },
    setHeight: function() {
      Konva.Util.warn(
        'Can not change height of layer. Use "stage.height(value)" function instead.'
      );
    },
    // the apply transform method is handled by the Layer and FastLayer class
    // because it is up to the layer to decide if an absolute or relative transform
    // should be used
    _applyTransform: function(shape, context, top) {
      var m = shape.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    }
  });
  Konva.Util.extend(Konva.BaseLayer, Konva.Container);

  // add getters and setters
  Konva.Factory.addGetterSetter(Konva.BaseLayer, 'clearBeforeDraw', true);
  /**
   * get/set clearBeforeDraw flag which determines if the layer is cleared or not
   *  before drawing
   * @name clearBeforeDraw
   * @method
   * @memberof Konva.BaseLayer.prototype
   * @param {Boolean} clearBeforeDraw
   * @returns {Boolean}
   * @example
   * // get clearBeforeDraw flag
   * var clearBeforeDraw = layer.clearBeforeDraw();
   *
   * // disable clear before draw
   * layer.clearBeforeDraw(false);
   *
   * // enable clear before draw
   * layer.clearBeforeDraw(true);
   */

  Konva.Collection.mapMethods(Konva.BaseLayer);
})(Konva);

(function() {
  'use strict';
  // constants
  var HASH = '#',
    BEFORE_DRAW = 'beforeDraw',
    DRAW = 'draw',
    /*
         * 2 - 3 - 4
         * |       |
         * 1 - 0   5
         *         |
         * 8 - 7 - 6
         */
    INTERSECTION_OFFSETS = [
      { x: 0, y: 0 }, // 0
      { x: -1, y: -1 }, // 2
      { x: 1, y: -1 }, // 4
      { x: 1, y: 1 }, // 6
      { x: -1, y: 1 } // 8
    ],
    INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;

  /**
   * Layer constructor.  Layers are tied to their own canvas element and are used
   * to contain groups or shapes.
   * @constructor
   * @memberof Konva
   * @augments Konva.BaseLayer
   * @param {Object} config
   * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
   * to clear the canvas before each layer draw.  The default value is true.
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

   * @example
   * var layer = new Konva.Layer();
   */
  Konva.Layer = function(config) {
    this.____init(config);
  };

  Konva.Util.addMethods(Konva.Layer, {
    ____init: function(config) {
      this.nodeType = 'Layer';
      this.canvas = new Konva.SceneCanvas();
      this.hitCanvas = new Konva.HitCanvas({
        pixelRatio: 1
      });
      // call super constructor
      Konva.BaseLayer.call(this, config);
    },
    _setCanvasSize: function(width, height) {
      this.canvas.setSize(width, height);
      this.hitCanvas.setSize(width, height);
    },
    _validateAdd: function(child) {
      var type = child.getType();
      if (type !== 'Group' && type !== 'Shape') {
        Konva.Util.throw('You may only add groups and shapes to a layer.');
      }
    },
    /**
     * get visible intersection shape. This is the preferred
     * method for determining if a point intersects a shape or not
     * also you may pass optional selector parametr to return ancestor of intersected shape
     * @method
     * @memberof Konva.Layer.prototype
     * @param {Object} pos
     * @param {Number} pos.x
     * @param {Number} pos.y
     * @param {String} [selector]
     * @returns {Konva.Node}
     * @example
     * var shape = layer.getIntersection({x: 50, y: 50});
     * // or if you interested in shape parent:
     * var group = layer.getIntersection({x: 50, y: 50}, 'Group');
     */
    getIntersection: function(pos, selector) {
      var obj, i, intersectionOffset, shape;

      if (!this.hitGraphEnabled() || !this.isVisible()) {
        return null;
      }
      // in some cases antialiased area may be bigger than 1px
      // it is possible if we will cache node, then scale it a lot
      // TODO: check { 0; 0 } point before loop, and remove it from INTERSECTION_OFFSETS.
      var spiralSearchDistance = 1;
      var continueSearch = false;
      while (true) {
        for (i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
          intersectionOffset = INTERSECTION_OFFSETS[i];
          obj = this._getIntersection({
            x: pos.x + intersectionOffset.x * spiralSearchDistance,
            y: pos.y + intersectionOffset.y * spiralSearchDistance
          });
          shape = obj.shape;
          if (shape && selector) {
            return shape.findAncestor(selector, true);
          } else if (shape) {
            return shape;
          }
          // we should continue search if we found antialiased pixel
          // that means our node somewhere very close
          continueSearch = !!obj.antialiased;
          // stop search if found empty pixel
          if (!obj.antialiased) {
            break;
          }
        }
        // if no shape, and no antialiased pixel, we should end searching
        if (continueSearch) {
          spiralSearchDistance += 1;
        } else {
          return null;
        }
      }
    },
    _getImageData: function(x, y) {
      var width = this.hitCanvas.width || 1,
        height = this.hitCanvas.height || 1,
        index = Math.round(y) * width + Math.round(x);

      if (!this._hitImageData) {
        this._hitImageData = this.hitCanvas.context.getImageData(
          0,
          0,
          width,
          height
        );
      }

      return [
        this._hitImageData.data[4 * index + 0], // Red
        this._hitImageData.data[4 * index + 1], // Green
        this._hitImageData.data[4 * index + 2], // Blue
        this._hitImageData.data[4 * index + 3] // Alpha
      ];
    },
    _getIntersection: function(pos) {
      var ratio = this.hitCanvas.pixelRatio;
      var p = this.hitCanvas.context.getImageData(
          Math.round(pos.x * ratio),
          Math.round(pos.y * ratio),
          1,
          1
        ).data,
        p3 = p[3],
        colorKey,
        shape;
      // fully opaque pixel
      if (p3 === 255) {
        colorKey = Konva.Util._rgbToHex(p[0], p[1], p[2]);
        shape = Konva.shapes[HASH + colorKey];
        if (shape) {
          return {
            shape: shape
          };
        }
        return {
          antialiased: true
        };
      } else if (p3 > 0) {
        // antialiased pixel
        return {
          antialiased: true
        };
      }
      // empty pixel
      return {};
    },
    drawScene: function(can, top) {
      var layer = this.getLayer(),
        canvas = can || (layer && layer.getCanvas());

      this._fire(BEFORE_DRAW, {
        node: this
      });

      if (this.getClearBeforeDraw()) {
        canvas.getContext().clear();
      }

      Konva.Container.prototype.drawScene.call(this, canvas, top);

      this._fire(DRAW, {
        node: this
      });

      return this;
    },
    drawHit: function(can, top) {
      var layer = this.getLayer(),
        canvas = can || (layer && layer.hitCanvas);

      if (layer && layer.getClearBeforeDraw()) {
        layer
          .getHitCanvas()
          .getContext()
          .clear();
      }

      Konva.Container.prototype.drawHit.call(this, canvas, top);
      this.imageData = null; // Clear imageData cache
      return this;
    },
    clear: function(bounds) {
      Konva.BaseLayer.prototype.clear.call(this, bounds);
      this.getHitCanvas()
        .getContext()
        .clear(bounds);
      this.imageData = null; // Clear getImageData cache
      return this;
    },
    // extend Node.prototype.setVisible
    setVisible: function(visible) {
      Konva.Node.prototype.setVisible.call(this, visible);
      if (visible) {
        this.getCanvas()._canvas.style.display = 'block';
        this.hitCanvas._canvas.style.display = 'block';
      } else {
        this.getCanvas()._canvas.style.display = 'none';
        this.hitCanvas._canvas.style.display = 'none';
      }
      return this;
    },
    /**
     * enable hit graph
     * @name enableHitGraph
     * @method
     * @memberof Konva.Layer.prototype
     * @returns {Layer}
     */
    enableHitGraph: function() {
      this.setHitGraphEnabled(true);
      return this;
    },
    /**
     * disable hit graph
     * @name disableHitGraph
     * @method
     * @memberof Konva.Layer.prototype
     * @returns {Layer}
     */
    disableHitGraph: function() {
      this.setHitGraphEnabled(false);
      return this;
    },
    setSize: function(width, height) {
      Konva.BaseLayer.prototype.setSize.call(this, width, height);
      this.hitCanvas.setSize(width, height);
      return this;
    }
  });
  Konva.Util.extend(Konva.Layer, Konva.BaseLayer);

  Konva.Factory.addGetterSetter(Konva.Layer, 'hitGraphEnabled', true);
  /**
   * get/set hitGraphEnabled flag.  Disabling the hit graph will greatly increase
   *  draw performance because the hit graph will not be redrawn each time the layer is
   *  drawn.  This, however, also disables mouse/touch event detection
   * @name hitGraphEnabled
   * @method
   * @memberof Konva.Layer.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get hitGraphEnabled flag
   * var hitGraphEnabled = layer.hitGraphEnabled();
   *
   * // disable hit graph
   * layer.hitGraphEnabled(false);
   *
   * // enable hit graph
   * layer.hitGraphEnabled(true);
   */
  Konva.Collection.mapMethods(Konva.Layer);
})();

(function() {
  'use strict';
  /**
   * FastLayer constructor. Layers are tied to their own canvas element and are used
   * to contain shapes only.  If you don't need node nesting, mouse and touch interactions,
   * or event pub/sub, you should use FastLayer instead of Layer to create your layers.
   * It renders about 2x faster than normal layers.
   * @constructor
   * @memberof Konva
   * @augments Konva.BaseLayer
   * @param {Object} config
   * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
   * to clear the canvas before each layer draw.  The default value is true.
   * @param {Boolean} [config.visible]
   * @param {String} [config.id] unique id
   * @param {String} [config.name] non-unique name
   * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
   * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

   * @example
   * var layer = new Konva.FastLayer();
   */
  Konva.FastLayer = function(config) {
    this.____init(config);
  };

  Konva.Util.addMethods(Konva.FastLayer, {
    ____init: function(config) {
      this.nodeType = 'Layer';
      this.canvas = new Konva.SceneCanvas();
      // call super constructor
      Konva.BaseLayer.call(this, config);
    },
    _validateAdd: function(child) {
      var type = child.getType();
      if (type !== 'Shape') {
        Konva.Util.throw('You may only add shapes to a fast layer.');
      }
    },
    _setCanvasSize: function(width, height) {
      this.canvas.setSize(width, height);
    },
    hitGraphEnabled: function() {
      return false;
    },
    getIntersection: function() {
      return null;
    },
    drawScene: function(can) {
      var layer = this.getLayer(),
        canvas = can || (layer && layer.getCanvas());

      if (this.getClearBeforeDraw()) {
        canvas.getContext().clear();
      }

      Konva.Container.prototype.drawScene.call(this, canvas);

      return this;
    },
    draw: function() {
      this.drawScene();
      return this;
    },
    // extend Node.prototype.setVisible
    setVisible: function(visible) {
      Konva.Node.prototype.setVisible.call(this, visible);
      if (visible) {
        this.getCanvas()._canvas.style.display = 'block';
      } else {
        this.getCanvas()._canvas.style.display = 'none';
      }
      return this;
    }
  });
  Konva.Util.extend(Konva.FastLayer, Konva.BaseLayer);

  Konva.Collection.mapMethods(Konva.FastLayer);
})();

(function() {
  'use strict';
  /**
   * Group constructor.  Groups are used to contain shapes or other groups.
   * @constructor
   * @memberof Konva
   * @augments Konva.Container
   * @param {Object} config
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

   * @example
   * var group = new Konva.Group();
   */
  Konva.Group = function(config) {
    this.___init(config);
  };

  Konva.Util.addMethods(Konva.Group, {
    ___init: function(config) {
      this.nodeType = 'Group';
      // call super constructor
      Konva.Container.call(this, config);
    },
    _validateAdd: function(child) {
      var type = child.getType();
      if (type !== 'Group' && type !== 'Shape') {
        Konva.Util.throw('You may only add groups and shapes to groups.');
      }
    }
  });
  Konva.Util.extend(Konva.Group, Konva.Container);

  Konva.Collection.mapMethods(Konva.Group);
})();

(function(Konva) {
  'use strict';
  var now = (function() {
    if (Konva.global.performance && Konva.global.performance.now) {
      return function() {
        return Konva.global.performance.now();
      };
    }

    return function() {
      return new Date().getTime();
    };
  })();

  function FRAF(callback) {
    setTimeout(callback, 1000 / 60);
  }

  var RAF = (function() {
    return (
      Konva.global.requestAnimationFrame ||
      Konva.global.webkitRequestAnimationFrame ||
      Konva.global.mozRequestAnimationFrame ||
      Konva.global.oRequestAnimationFrame ||
      Konva.global.msRequestAnimationFrame ||
      FRAF
    );
  })();

  function requestAnimFrame() {
    return RAF.apply(Konva.global, arguments);
  }

  /**
   * Animation constructor.  A stage is used to contain multiple layers and handle
   * @constructor
   * @memberof Konva
   * @param {Function} func function executed on each animation frame.  The function is passed a frame object, which contains
   *  timeDiff, lastTime, time, and frameRate properties.  The timeDiff property is the number of milliseconds that have passed
   *  since the last animation frame.  The lastTime property is time in milliseconds that elapsed from the moment the animation started
   *  to the last animation frame.  The time property is the time in milliseconds that ellapsed from the moment the animation started
   *  to the current animation frame.  The frameRate property is the current frame rate in frames / second. Return false from function,
   *  if you don't need to redraw layer/layers on some frames.
   * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn on each animation frame. Can be a layer, an array of layers, or null.
   *  Not specifying a node will result in no redraw.
   * @example
   * // move a node to the right at 50 pixels / second
   * var velocity = 50;
   *
   * var anim = new Konva.Animation(function(frame) {
   *   var dist = velocity * (frame.timeDiff / 1000);
   *   node.move(dist, 0);
   * }, layer);
   *
   * anim.start();
   */
  Konva.Animation = function(func, layers) {
    var Anim = Konva.Animation;
    this.func = func;
    this.setLayers(layers);
    this.id = Anim.animIdCounter++;
    this.frame = {
      time: 0,
      timeDiff: 0,
      lastTime: now()
    };
  };
  /*
     * Animation methods
     */
  Konva.Animation.prototype = {
    /**
     * set layers to be redrawn on each animation frame
     * @method
     * @memberof Konva.Animation.prototype
     * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn.&nbsp; Can be a layer, an array of layers, or null.  Not specifying a node will result in no redraw.
     * @return {Konva.Animation} this
     */
    setLayers: function(layers) {
      var lays = [];
      // if passing in no layers
      if (!layers) {
        lays = [];
      } else if (layers.length > 0) {
        // if passing in an array of Layers
        // NOTE: layers could be an array or Konva.Collection.  for simplicity, I'm just inspecting
        // the length property to check for both cases
        lays = layers;
      } else {
        // if passing in a Layer
        lays = [layers];
      }

      this.layers = lays;
      return this;
    },
    /**
     * get layers
     * @method
     * @memberof Konva.Animation.prototype
     * @return {Array} Array of Konva.Layer
     */
    getLayers: function() {
      return this.layers;
    },
    /**
     * add layer.  Returns true if the layer was added, and false if it was not
     * @method
     * @memberof Konva.Animation.prototype
     * @param {Konva.Layer} layer to add
     * @return {Bool} true if layer is added to animation, otherwise false
     */
    addLayer: function(layer) {
      var layers = this.layers,
        len = layers.length,
        n;

      // don't add the layer if it already exists
      for (n = 0; n < len; n++) {
        if (layers[n]._id === layer._id) {
          return false;
        }
      }

      this.layers.push(layer);
      return true;
    },
    /**
     * determine if animation is running or not.  returns true or false
     * @method
     * @memberof Konva.Animation.prototype
     * @return {Bool} is animation running?
     */
    isRunning: function() {
      var a = Konva.Animation,
        animations = a.animations,
        len = animations.length,
        n;

      for (n = 0; n < len; n++) {
        if (animations[n].id === this.id) {
          return true;
        }
      }
      return false;
    },
    /**
     * start animation
     * @method
     * @memberof Konva.Animation.prototype
     * @return {Konva.Animation} this
     */
    start: function() {
      var Anim = Konva.Animation;
      this.stop();
      this.frame.timeDiff = 0;
      this.frame.lastTime = now();
      Anim._addAnimation(this);
      return this;
    },
    /**
     * stop animation
     * @method
     * @memberof Konva.Animation.prototype
     * @return {Konva.Animation} this
     */
    stop: function() {
      Konva.Animation._removeAnimation(this);
      return this;
    },
    _updateFrameObject: function(time) {
      this.frame.timeDiff = time - this.frame.lastTime;
      this.frame.lastTime = time;
      this.frame.time += this.frame.timeDiff;
      this.frame.frameRate = 1000 / this.frame.timeDiff;
    }
  };
  Konva.Animation.animations = [];
  Konva.Animation.animIdCounter = 0;
  Konva.Animation.animRunning = false;

  Konva.Animation._addAnimation = function(anim) {
    this.animations.push(anim);
    this._handleAnimation();
  };
  Konva.Animation._removeAnimation = function(anim) {
    var id = anim.id,
      animations = this.animations,
      len = animations.length,
      n;

    for (n = 0; n < len; n++) {
      if (animations[n].id === id) {
        this.animations.splice(n, 1);
        break;
      }
    }
  };

  Konva.Animation._runFrames = function() {
    var layerHash = {},
      animations = this.animations,
      anim,
      layers,
      func,
      n,
      i,
      layersLen,
      layer,
      key,
      needRedraw;
    /*
         * loop through all animations and execute animation
         *  function.  if the animation object has specified node,
         *  we can add the node to the nodes hash to eliminate
         *  drawing the same node multiple times.  The node property
         *  can be the stage itself or a layer
         */
    /*
         * WARNING: don't cache animations.length because it could change while
         * the for loop is running, causing a JS error
         */

    for (n = 0; n < animations.length; n++) {
      anim = animations[n];
      layers = anim.layers;
      func = anim.func;

      anim._updateFrameObject(now());
      layersLen = layers.length;

      // if animation object has a function, execute it
      if (func) {
        // allow anim bypassing drawing
        needRedraw = func.call(anim, anim.frame) !== false;
      } else {
        needRedraw = true;
      }
      if (!needRedraw) {
        continue;
      }
      for (i = 0; i < layersLen; i++) {
        layer = layers[i];

        if (layer._id !== undefined) {
          layerHash[layer._id] = layer;
        }
      }
    }

    for (key in layerHash) {
      if (!layerHash.hasOwnProperty(key)) {
        continue;
      }
      layerHash[key].draw();
    }
  };
  Konva.Animation._animationLoop = function() {
    var Anim = Konva.Animation;
    if (Anim.animations.length) {
      Anim._runFrames();
      requestAnimFrame(Anim._animationLoop);
    } else {
      Anim.animRunning = false;
    }
  };
  Konva.Animation._handleAnimation = function() {
    if (!this.animRunning) {
      this.animRunning = true;
      requestAnimFrame(this._animationLoop);
    }
  };

  /**
   * batch draw. this function will not do immediate draw
   * but it will schedule drawing to next tick (requestAnimFrame)
   * @method
   * @return {Konva.Layer} this
   * @memberof Konva.Base.prototype
   */
  Konva.BaseLayer.prototype.batchDraw = function() {
    var that = this,
      Anim = Konva.Animation;

    if (!this.batchAnim) {
      this.batchAnim = new Anim(function() {
        // stop animation after first tick
        that.batchAnim.stop();
      }, this);
    }

    if (!this.batchAnim.isRunning()) {
      this.batchAnim.start();
    }
    return this;
  };

  /**
   * batch draw
   * @method
   * @return {Konva.Stage} this
   * @memberof Konva.Stage.prototype
   */
  Konva.Stage.prototype.batchDraw = function() {
    this.getChildren().each(function(layer) {
      layer.batchDraw();
    });
    return this;
  };
})(Konva);

(function() {
  'use strict';
  var blacklist = {
      node: 1,
      duration: 1,
      easing: 1,
      onFinish: 1,
      yoyo: 1
    },
    PAUSED = 1,
    PLAYING = 2,
    REVERSING = 3,
    idCounter = 0,
    colorAttrs = ['fill', 'stroke', 'shadowColor'];

  var Tween = function(prop, propFunc, func, begin, finish, duration, yoyo) {
    this.prop = prop;
    this.propFunc = propFunc;
    this.begin = begin;
    this._pos = begin;
    this.duration = duration;
    this._change = 0;
    this.prevPos = 0;
    this.yoyo = yoyo;
    this._time = 0;
    this._position = 0;
    this._startTime = 0;
    this._finish = 0;
    this.func = func;
    this._change = finish - this.begin;
    this.pause();
  };
  /*
     * Tween methods
     */
  Tween.prototype = {
    fire: function(str) {
      var handler = this[str];
      if (handler) {
        handler();
      }
    },
    setTime: function(t) {
      if (t > this.duration) {
        if (this.yoyo) {
          this._time = this.duration;
          this.reverse();
        } else {
          this.finish();
        }
      } else if (t < 0) {
        if (this.yoyo) {
          this._time = 0;
          this.play();
        } else {
          this.reset();
        }
      } else {
        this._time = t;
        this.update();
      }
    },
    getTime: function() {
      return this._time;
    },
    setPosition: function(p) {
      this.prevPos = this._pos;
      this.propFunc(p);
      this._pos = p;
    },
    getPosition: function(t) {
      if (t === undefined) {
        t = this._time;
      }
      return this.func(t, this.begin, this._change, this.duration);
    },
    play: function() {
      this.state = PLAYING;
      this._startTime = this.getTimer() - this._time;
      this.onEnterFrame();
      this.fire('onPlay');
    },
    reverse: function() {
      this.state = REVERSING;
      this._time = this.duration - this._time;
      this._startTime = this.getTimer() - this._time;
      this.onEnterFrame();
      this.fire('onReverse');
    },
    seek: function(t) {
      this.pause();
      this._time = t;
      this.update();
      this.fire('onSeek');
    },
    reset: function() {
      this.pause();
      this._time = 0;
      this.update();
      this.fire('onReset');
    },
    finish: function() {
      this.pause();
      this._time = this.duration;
      this.update();
      this.fire('onFinish');
    },
    update: function() {
      this.setPosition(this.getPosition(this._time));
    },
    onEnterFrame: function() {
      var t = this.getTimer() - this._startTime;
      if (this.state === PLAYING) {
        this.setTime(t);
      } else if (this.state === REVERSING) {
        this.setTime(this.duration - t);
      }
    },
    pause: function() {
      this.state = PAUSED;
      this.fire('onPause');
    },
    getTimer: function() {
      return new Date().getTime();
    }
  };

  /**
   * Tween constructor.  Tweens enable you to animate a node between the current state and a new state.
   *  You can play, pause, reverse, seek, reset, and finish tweens.  By default, tweens are animated using
   *  a linear easing.  For more tweening options, check out {@link Konva.Easings}
   * @constructor
   * @memberof Konva
   * @example
   * // instantiate new tween which fully rotates a node in 1 second
   * var tween = new Konva.Tween({
   *   node: node,
   *   rotationDeg: 360,
   *   duration: 1,
   *   easing: Konva.Easings.EaseInOut
   * });
   *
   * // play tween
   * tween.play();
   *
   * // pause tween
   * tween.pause();
   */
  Konva.Tween = function(config) {
    var that = this,
      node = config.node,
      nodeId = node._id,
      duration,
      easing = config.easing || Konva.Easings.Linear,
      yoyo = !!config.yoyo,
      key;

    if (typeof config.duration === 'undefined') {
      duration = 0.3;
    } else if (config.duration === 0) {
      // zero is bad value for duration
      duration = 0.001;
    } else {
      duration = config.duration;
    }
    this.node = node;
    this._id = idCounter++;

    var layers =
      node.getLayer() ||
      (node instanceof Konva.Stage ? node.getLayers() : null);
    if (!layers) {
      Konva.Util.error(
        'Tween constructor have `node` that is not in a layer. Please add node into layer first.'
      );
    }
    this.anim = new Konva.Animation(function() {
      that.tween.onEnterFrame();
    }, layers);

    this.tween = new Tween(
      key,
      function(i) {
        that._tweenFunc(i);
      },
      easing,
      0,
      1,
      duration * 1000,
      yoyo
    );

    this._addListeners();

    // init attrs map
    if (!Konva.Tween.attrs[nodeId]) {
      Konva.Tween.attrs[nodeId] = {};
    }
    if (!Konva.Tween.attrs[nodeId][this._id]) {
      Konva.Tween.attrs[nodeId][this._id] = {};
    }
    // init tweens map
    if (!Konva.Tween.tweens[nodeId]) {
      Konva.Tween.tweens[nodeId] = {};
    }

    for (key in config) {
      if (blacklist[key] === undefined) {
        this._addAttr(key, config[key]);
      }
    }

    this.reset();

    // callbacks
    this.onFinish = config.onFinish;
    this.onReset = config.onReset;
  };

  // start/diff object = attrs.nodeId.tweenId.attr
  Konva.Tween.attrs = {};
  // tweenId = tweens.nodeId.attr
  Konva.Tween.tweens = {};

  Konva.Tween.prototype = {
    _addAttr: function(key, end) {
      var node = this.node,
        nodeId = node._id,
        start,
        diff,
        tweenId,
        n,
        len,
        trueEnd,
        trueStart,
        endRGBA;

      // remove conflict from tween map if it exists
      tweenId = Konva.Tween.tweens[nodeId][key];

      if (tweenId) {
        delete Konva.Tween.attrs[nodeId][tweenId][key];
      }

      // add to tween map
      start = node.getAttr(key);

      if (Konva.Util._isArray(end)) {
        diff = [];
        len = Math.max(end.length, start.length);

        if (key === 'points' && end.length !== start.length) {
          // before tweening points we need to make sure that start.length === end.length
          // Konva.Util._prepareArrayForTween thinking that end.length > start.length

          if (end.length > start.length) {
            // so in this case we will increase number of starting points
            trueStart = start;
            start = Konva.Util._prepareArrayForTween(start, end, node.closed());
          } else {
            // in this case we will increase number of eding points
            trueEnd = end;
            end = Konva.Util._prepareArrayForTween(end, start, node.closed());
          }
        }

        if (key.indexOf('fill') === 0) {
          for (n = 0; n < len; n++) {
            if (n % 2 === 0) {
              diff.push(end[n] - start[n]);
            } else {
              var startRGBA = Konva.Util.colorToRGBA(start[n]);
              endRGBA = Konva.Util.colorToRGBA(end[n]);
              start[n] = startRGBA;
              diff.push({
                r: endRGBA.r - startRGBA.r,
                g: endRGBA.g - startRGBA.g,
                b: endRGBA.b - startRGBA.b,
                a: endRGBA.a - startRGBA.a
              });
            }
          }
        } else {
          for (n = 0; n < len; n++) {
            diff.push(end[n] - start[n]);
          }
        }
      } else if (colorAttrs.indexOf(key) !== -1) {
        start = Konva.Util.colorToRGBA(start);
        endRGBA = Konva.Util.colorToRGBA(end);
        diff = {
          r: endRGBA.r - start.r,
          g: endRGBA.g - start.g,
          b: endRGBA.b - start.b,
          a: endRGBA.a - start.a
        };
      } else {
        diff = end - start;
      }

      Konva.Tween.attrs[nodeId][this._id][key] = {
        start: start,
        diff: diff,
        end: end,
        trueEnd: trueEnd,
        trueStart: trueStart
      };
      Konva.Tween.tweens[nodeId][key] = this._id;
    },
    _tweenFunc: function(i) {
      var node = this.node,
        attrs = Konva.Tween.attrs[node._id][this._id],
        key,
        attr,
        start,
        diff,
        newVal,
        n,
        len,
        end;

      for (key in attrs) {
        attr = attrs[key];
        start = attr.start;
        diff = attr.diff;
        end = attr.end;

        if (Konva.Util._isArray(start)) {
          newVal = [];
          len = Math.max(start.length, end.length);
          if (key.indexOf('fill') === 0) {
            for (n = 0; n < len; n++) {
              if (n % 2 === 0) {
                newVal.push((start[n] || 0) + diff[n] * i);
              } else {
                newVal.push(
                  'rgba(' +
                    Math.round(start[n].r + diff[n].r * i) +
                    ',' +
                    Math.round(start[n].g + diff[n].g * i) +
                    ',' +
                    Math.round(start[n].b + diff[n].b * i) +
                    ',' +
                    (start[n].a + diff[n].a * i) +
                    ')'
                );
              }
            }
          } else {
            for (n = 0; n < len; n++) {
              newVal.push((start[n] || 0) + diff[n] * i);
            }
          }
        } else if (colorAttrs.indexOf(key) !== -1) {
          newVal =
            'rgba(' +
            Math.round(start.r + diff.r * i) +
            ',' +
            Math.round(start.g + diff.g * i) +
            ',' +
            Math.round(start.b + diff.b * i) +
            ',' +
            (start.a + diff.a * i) +
            ')';
        } else {
          newVal = start + diff * i;
        }

        node.setAttr(key, newVal);
      }
    },
    _addListeners: function() {
      var that = this;

      // start listeners
      this.tween.onPlay = function() {
        that.anim.start();
      };
      this.tween.onReverse = function() {
        that.anim.start();
      };

      // stop listeners
      this.tween.onPause = function() {
        that.anim.stop();
      };
      this.tween.onFinish = function() {
        var node = that.node;

        // after tweening  points of line we need to set original end
        var attrs = Konva.Tween.attrs[node._id][that._id];
        if (attrs.points && attrs.points.trueEnd) {
          node.points(attrs.points.trueEnd);
        }

        if (that.onFinish) {
          that.onFinish.call(that);
        }
      };
      this.tween.onReset = function() {
        var node = that.node;
        // after tweening  points of line we need to set original start
        var attrs = Konva.Tween.attrs[node._id][that._id];
        if (attrs.points && attrs.points.trueStart) {
          node.points(attrs.points.trueStart);
        }

        if (that.onReset) {
          that.onReset();
        }
      };
    },
    /**
     * play
     * @method
     * @memberof Konva.Tween.prototype
     * @returns {Tween}
     */
    play: function() {
      this.tween.play();
      return this;
    },
    /**
     * reverse
     * @method
     * @memberof Konva.Tween.prototype
     * @returns {Tween}
     */
    reverse: function() {
      this.tween.reverse();
      return this;
    },
    /**
     * reset
     * @method
     * @memberof Konva.Tween.prototype
     * @returns {Tween}
     */
    reset: function() {
      this.tween.reset();
      return this;
    },
    /**
     * seek
     * @method
     * @memberof Konva.Tween.prototype
     * @param {Integer} t time in seconds between 0 and the duration
     * @returns {Tween}
     */
    seek: function(t) {
      this.tween.seek(t * 1000);
      return this;
    },
    /**
     * pause
     * @method
     * @memberof Konva.Tween.prototype
     * @returns {Tween}
     */
    pause: function() {
      this.tween.pause();
      return this;
    },
    /**
     * finish
     * @method
     * @memberof Konva.Tween.prototype
     * @returns {Tween}
     */
    finish: function() {
      this.tween.finish();
      return this;
    },
    /**
     * destroy
     * @method
     * @memberof Konva.Tween.prototype
     */
    destroy: function() {
      var nodeId = this.node._id,
        thisId = this._id,
        attrs = Konva.Tween.tweens[nodeId],
        key;

      this.pause();

      for (key in attrs) {
        delete Konva.Tween.tweens[nodeId][key];
      }

      delete Konva.Tween.attrs[nodeId][thisId];
    }
  };

  /**
   * Tween node properties. Shorter usage of {@link Konva.Tween} object.
   *
   * @method Konva.Node#to
   * @memberof Konva.Node
   * @param {Object} [params] tween params
   * @example
   *
   * circle.to({
   *  x : 50,
   *  duration : 0.5
   * });
   */
  Konva.Node.prototype.to = function(params) {
    var onFinish = params.onFinish;
    params.node = this;
    params.onFinish = function() {
      this.destroy();
      if (onFinish) {
        onFinish();
      }
    };
    var tween = new Konva.Tween(params);
    tween.play();
  };

  /*
    * These eases were ported from an Adobe Flash tweening library to JavaScript
    * by Xaric
    */

  /**
   * @namespace Easings
   * @memberof Konva
   */
  Konva.Easings = {
    /**
     * back ease in
     * @function
     * @memberof Konva.Easings
     */
    BackEaseIn: function(t, b, c, d) {
      var s = 1.70158;
      return c * (t /= d) * t * ((s + 1) * t - s) + b;
    },
    /**
     * back ease out
     * @function
     * @memberof Konva.Easings
     */
    BackEaseOut: function(t, b, c, d) {
      var s = 1.70158;
      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },
    /**
     * back ease in out
     * @function
     * @memberof Konva.Easings
     */
    BackEaseInOut: function(t, b, c, d) {
      var s = 1.70158;
      if ((t /= d / 2) < 1) {
        return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
      }
      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
    },
    /**
     * elastic ease in
     * @function
     * @memberof Konva.Easings
     */
    ElasticEaseIn: function(t, b, c, d, a, p) {
      // added s = 0
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      if (!a || a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      return (
        -(
          a *
          Math.pow(2, 10 * (t -= 1)) *
          Math.sin((t * d - s) * (2 * Math.PI) / p)
        ) + b
      );
    },
    /**
     * elastic ease out
     * @function
     * @memberof Konva.Easings
     */
    ElasticEaseOut: function(t, b, c, d, a, p) {
      // added s = 0
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      if (!a || a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      return (
        a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) +
        c +
        b
      );
    },
    /**
     * elastic ease in out
     * @function
     * @memberof Konva.Easings
     */
    ElasticEaseInOut: function(t, b, c, d, a, p) {
      // added s = 0
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d / 2) === 2) {
        return b + c;
      }
      if (!p) {
        p = d * (0.3 * 1.5);
      }
      if (!a || a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      if (t < 1) {
        return (
          -0.5 *
            (a *
              Math.pow(2, 10 * (t -= 1)) *
              Math.sin((t * d - s) * (2 * Math.PI) / p)) +
          b
        );
      }
      return (
        a *
          Math.pow(2, -10 * (t -= 1)) *
          Math.sin((t * d - s) * (2 * Math.PI) / p) *
          0.5 +
        c +
        b
      );
    },
    /**
     * bounce ease out
     * @function
     * @memberof Konva.Easings
     */
    BounceEaseOut: function(t, b, c, d) {
      if ((t /= d) < 1 / 2.75) {
        return c * (7.5625 * t * t) + b;
      } else if (t < 2 / 2.75) {
        return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
      } else if (t < 2.5 / 2.75) {
        return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
      } else {
        return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
      }
    },
    /**
     * bounce ease in
     * @function
     * @memberof Konva.Easings
     */
    BounceEaseIn: function(t, b, c, d) {
      return c - Konva.Easings.BounceEaseOut(d - t, 0, c, d) + b;
    },
    /**
     * bounce ease in out
     * @function
     * @memberof Konva.Easings
     */
    BounceEaseInOut: function(t, b, c, d) {
      if (t < d / 2) {
        return Konva.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
      } else {
        return (
          Konva.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b
        );
      }
    },
    /**
     * ease in
     * @function
     * @memberof Konva.Easings
     */
    EaseIn: function(t, b, c, d) {
      return c * (t /= d) * t + b;
    },
    /**
     * ease out
     * @function
     * @memberof Konva.Easings
     */
    EaseOut: function(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    },
    /**
     * ease in out
     * @function
     * @memberof Konva.Easings
     */
    EaseInOut: function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t + b;
      }
      return -c / 2 * (--t * (t - 2) - 1) + b;
    },
    /**
     * strong ease in
     * @function
     * @memberof Konva.Easings
     */
    StrongEaseIn: function(t, b, c, d) {
      return c * (t /= d) * t * t * t * t + b;
    },
    /**
     * strong ease out
     * @function
     * @memberof Konva.Easings
     */
    StrongEaseOut: function(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    },
    /**
     * strong ease in out
     * @function
     * @memberof Konva.Easings
     */
    StrongEaseInOut: function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    },
    /**
     * linear
     * @function
     * @memberof Konva.Easings
     */
    Linear: function(t, b, c, d) {
      return c * t / d + b;
    }
  };
})();

(function() {
  'use strict';
  Konva.DD = {
    // properties
    anim: new Konva.Animation(function() {
      var b = this.dirty;
      this.dirty = false;
      return b;
    }),
    isDragging: false,
    justDragged: false,
    offset: {
      x: 0,
      y: 0
    },
    node: null,

    // methods
    _drag: function(evt) {
      var dd = Konva.DD,
        node = dd.node;
      if (node) {
        if (!dd.isDragging) {
          var pos = node.getStage().getPointerPosition();
          // it is possible that pos is undefined
          // reattach it
          if (!pos) {
            node.getStage()._setPointerPosition(evt);
            pos = node.getStage().getPointerPosition();
          }
          var dragDistance = node.dragDistance();
          var distance = Math.max(
            Math.abs(pos.x - dd.startPointerPos.x),
            Math.abs(pos.y - dd.startPointerPos.y)
          );
          if (distance < dragDistance) {
            return;
          }
        }

        node.getStage()._setPointerPosition(evt);
        if (!dd.isDragging) {
          dd.isDragging = true;
          node.fire(
            'dragstart',
            {
              type: 'dragstart',
              target: node,
              evt: evt
            },
            true
          );
          // a user can stop dragging inside `dragstart`
          if (!node.isDragging()) {
            return;
          }
        }
        node._setDragPosition(evt);

        // execute ondragmove if defined
        node.fire(
          'dragmove',
          {
            type: 'dragmove',
            target: node,
            evt: evt
          },
          true
        );
      }
    },
    _endDragBefore: function(evt) {
      var dd = Konva.DD,
        node = dd.node,
        layer;

      if (node) {
        layer = node.getLayer();
        dd.anim.stop();

        // only fire dragend event if the drag and drop
        // operation actually started.
        if (dd.isDragging) {
          dd.isDragging = false;
          dd.justDragged = true;
          Konva.listenClickTap = false;

          if (evt) {
            evt.dragEndNode = node;
          }
        }

        delete dd.node;

        if (node.getLayer() || layer || node instanceof Konva.Stage) {
          (layer || node).draw();
        }
      }
    },
    _endDragAfter: function(evt) {
      evt = evt || {};
      var dragEndNode = evt.dragEndNode;

      if (evt && dragEndNode) {
        dragEndNode.fire(
          'dragend',
          {
            type: 'dragend',
            target: dragEndNode,
            evt: evt
          },
          true
        );
      }
    }
  };

  // Node extenders

  /**
   * initiate drag and drop
   * @method
   * @memberof Konva.Node.prototype
   */
  Konva.Node.prototype.startDrag = function() {
    var dd = Konva.DD,
      stage = this.getStage(),
      layer = this.getLayer(),
      pos = stage.getPointerPosition(),
      ap = this.getAbsolutePosition();

    if (pos) {
      if (dd.node) {
        dd.node.stopDrag();
      }

      dd.node = this;
      dd.startPointerPos = pos;
      dd.offset.x = pos.x - ap.x;
      dd.offset.y = pos.y - ap.y;
      dd.anim.setLayers(layer || this.getLayers());
      dd.anim.start();

      this._setDragPosition();
    }
  };

  Konva.Node.prototype._setDragPosition = function(evt) {
    var dd = Konva.DD,
      pos = this.getStage().getPointerPosition(),
      dbf = this.getDragBoundFunc();
    if (!pos) {
      return;
    }
    var newNodePos = {
      x: pos.x - dd.offset.x,
      y: pos.y - dd.offset.y
    };

    if (dbf !== undefined) {
      newNodePos = dbf.call(this, newNodePos, evt);
    }
    this.setAbsolutePosition(newNodePos);

    if (
      !this._lastPos ||
      this._lastPos.x !== newNodePos.x ||
      this._lastPos.y !== newNodePos.y
    ) {
      dd.anim.dirty = true;
    }

    this._lastPos = newNodePos;
  };

  /**
   * stop drag and drop
   * @method
   * @memberof Konva.Node.prototype
   */
  Konva.Node.prototype.stopDrag = function() {
    var dd = Konva.DD,
      evt = {};
    dd._endDragBefore(evt);
    dd._endDragAfter(evt);
  };

  Konva.Node.prototype.setDraggable = function(draggable) {
    this._setAttr('draggable', draggable);
    this._dragChange();
  };

  var origRemove = Konva.Node.prototype.remove;

  Konva.Node.prototype.__originalRemove = origRemove;
  Konva.Node.prototype.remove = function() {
    var dd = Konva.DD;

    // stop DD
    if (dd.node && dd.node._id === this._id) {
      this.stopDrag();
    }

    origRemove.call(this);
  };

  /**
   * determine if node is currently in drag and drop mode
   * @method
   * @memberof Konva.Node.prototype
   */
  Konva.Node.prototype.isDragging = function() {
    var dd = Konva.DD;
    return !!(dd.node && dd.node._id === this._id && dd.isDragging);
  };

  Konva.Node.prototype._listenDrag = function() {
    var that = this;

    this._dragCleanup();

    if (this.getClassName() === 'Stage') {
      this.on('contentMousedown.konva contentTouchstart.konva', function(evt) {
        if (!Konva.DD.node) {
          that.startDrag(evt);
        }
      });
    } else {
      this.on('mousedown.konva touchstart.konva', function(evt) {
        // ignore right and middle buttons
        if (evt.evt.button === 1 || evt.evt.button === 2) {
          return;
        }
        if (!Konva.DD.node) {
          that.startDrag(evt);
        }
      });
    }

    // listening is required for drag and drop
    /*
        this._listeningEnabled = true;
        this._clearSelfAndAncestorCache('listeningEnabled');
        */
  };

  Konva.Node.prototype._dragChange = function() {
    if (this.attrs.draggable) {
      this._listenDrag();
    } else {
      // remove event listeners
      this._dragCleanup();

      /*
             * force drag and drop to end
             * if this node is currently in
             * drag and drop mode
             */
      var stage = this.getStage();
      var dd = Konva.DD;
      if (stage && dd.node && dd.node._id === this._id) {
        dd.node.stopDrag();
      }
    }
  };

  Konva.Node.prototype._dragCleanup = function() {
    if (this.getClassName() === 'Stage') {
      this.off('contentMousedown.konva');
      this.off('contentTouchstart.konva');
    } else {
      this.off('mousedown.konva');
      this.off('touchstart.konva');
    }
  };

  Konva.Factory.addGetterSetter(Konva.Node, 'dragBoundFunc');

  /**
   * get/set drag bound function.  This is used to override the default
   *  drag and drop position.
   * @name dragBoundFunc
   * @method
   * @memberof Konva.Node.prototype
   * @param {Function} dragBoundFunc
   * @returns {Function}
   * @example
   * // get drag bound function
   * var dragBoundFunc = node.dragBoundFunc();
   *
   * // create vertical drag and drop
   * node.dragBoundFunc(function(pos){
   *   // important pos - is absolute position of the node
   *   // you should return absolute position too
   *   return {
   *     x: this.getAbsolutePosition().x,
   *     y: pos.y
   *   };
   * });
   */

  Konva.Factory.addGetter(Konva.Node, 'draggable', false);
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'draggable');

  /**
   * get/set draggable flag
   * @name draggable
   * @method
   * @memberof Konva.Node.prototype
   * @param {Boolean} draggable
   * @returns {Boolean}
   * @example
   * // get draggable flag
   * var draggable = node.draggable();
   *
   * // enable drag and drop
   * node.draggable(true);
   *
   * // disable drag and drop
   * node.draggable(false);
   */

  if (Konva.isBrowser) {
    window.addEventListener('mouseup', Konva.DD._endDragBefore, true);
    window.addEventListener('touchend', Konva.DD._endDragBefore, true);

    window.addEventListener('mousemove', Konva.DD._drag);
    window.addEventListener('touchmove', Konva.DD._drag);

    window.addEventListener('mouseup', Konva.DD._endDragAfter, false);
    window.addEventListener('touchend', Konva.DD._endDragAfter, false);
  }
})();

(function() {
  'use strict';
  /**
   * Rect constructor
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Number} [config.cornerRadius]
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var rect = new Konva.Rect({
   *   width: 100,
   *   height: 50,
   *   fill: 'red',
   *   stroke: 'black',
   *   strokeWidth: 5
   * });
   */
  Konva.Rect = function(config) {
    this.___init(config);
  };

  Konva.Rect.prototype = {
    ___init: function(config) {
      Konva.Shape.call(this, config);
      this.className = 'Rect';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var cornerRadius = this.getCornerRadius(),
        width = this.getWidth(),
        height = this.getHeight();

      context.beginPath();

      if (!cornerRadius) {
        // simple rect - don't bother doing all that complicated maths stuff.
        context.rect(0, 0, width, height);
      } else {
        // arcTo would be nicer, but browser support is patchy (Opera)
        cornerRadius = Math.min(cornerRadius, width / 2, height / 2);
        context.moveTo(cornerRadius, 0);
        context.lineTo(width - cornerRadius, 0);
        context.arc(
          width - cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI * 3 / 2,
          0,
          false
        );
        context.lineTo(width, height - cornerRadius);
        context.arc(
          width - cornerRadius,
          height - cornerRadius,
          cornerRadius,
          0,
          Math.PI / 2,
          false
        );
        context.lineTo(cornerRadius, height);
        context.arc(
          cornerRadius,
          height - cornerRadius,
          cornerRadius,
          Math.PI / 2,
          Math.PI,
          false
        );
        context.lineTo(0, cornerRadius);
        context.arc(
          cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI,
          Math.PI * 3 / 2,
          false
        );
      }
      context.closePath();
      context.fillStrokeShape(this);
    }
  };

  Konva.Util.extend(Konva.Rect, Konva.Shape);

  Konva.Factory.addGetterSetter(
    Konva.Rect,
    'cornerRadius',
    0,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set corner radius
   * @name cornerRadius
   * @method
   * @memberof Konva.Rect.prototype
   * @param {Number} cornerRadius
   * @returns {Number}
   * @example
   * // get corner radius
   * var cornerRadius = rect.cornerRadius();
   *
   * // set corner radius
   * rect.cornerRadius(10);
   */

  Konva.Collection.mapMethods(Konva.Rect);
})();

(function(Konva) {
  'use strict';
  // the 0.0001 offset fixes a bug in Chrome 27
  var PIx2 = Math.PI * 2 - 0.0001,
    CIRCLE = 'Circle';

  /**
   * Circle constructor
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Number} config.radius
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * // create circle
   * var circle = new Konva.Circle({
   *   radius: 40,
   *   fill: 'red',
   *   stroke: 'black'
   *   strokeWidth: 5
   * });
   */
  Konva.Circle = function(config) {
    this.___init(config);
  };

  Konva.Circle.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = CIRCLE;
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      context.beginPath();
      context.arc(0, 0, this.getRadius(), 0, PIx2, false);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.radius() !== width / 2) {
        this.setRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.radius() !== height / 2) {
        this.setRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Circle, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(
    Konva.Circle,
    'radius',
    0,
    Konva.Validators.getNumberValidator()
  );
  Konva.Factory.addOverloadedGetterSetter(Konva.Circle, 'radius');

  /**
   * get/set radius
   * @name radius
   * @method
   * @memberof Konva.Circle.prototype
   * @param {Number} radius
   * @returns {Number}
   * @example
   * // get radius
   * var radius = circle.radius();
   *
   * // set radius
   * circle.radius(10);
   */

  Konva.Collection.mapMethods(Konva.Circle);
})(Konva);

(function() {
  'use strict';
  // the 0.0001 offset fixes a bug in Chrome 27
  var PIx2 = Math.PI * 2 - 0.0001,
    ELLIPSE = 'Ellipse';

  /**
   * Ellipse constructor
   * @constructor
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Object} config.radius defines x and y radius
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var ellipse = new Konva.Ellipse({
   *   radius : {
   *     x : 50,
   *     y : 50
   *   },
   *   fill: 'red'
   * });
   */
  Konva.Ellipse = function(config) {
    this.___init(config);
  };

  Konva.Ellipse.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = ELLIPSE;
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var rx = this.getRadiusX(),
        ry = this.getRadiusY();

      context.beginPath();
      context.save();
      if (rx !== ry) {
        context.scale(1, ry / rx);
      }
      context.arc(0, 0, rx, 0, PIx2, false);
      context.restore();
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getRadiusX() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadiusY() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      this.setRadius({
        x: width / 2
      });
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      this.setRadius({
        y: height / 2
      });
    }
  };
  Konva.Util.extend(Konva.Ellipse, Konva.Shape);

  // add getters setters
  Konva.Factory.addComponentsGetterSetter(Konva.Ellipse, 'radius', ['x', 'y']);

  /**
   * get/set radius
   * @name radius
   * @method
   * @memberof Konva.Ellipse.prototype
   * @param {Object} radius
   * @param {Number} radius.x
   * @param {Number} radius.y
   * @returns {Object}
   * @example
   * // get radius
   * var radius = ellipse.radius();
   *
   * // set radius
   * ellipse.radius({
   *   x: 200,
   *   y: 100
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Ellipse,
    'radiusX',
    0,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set radius x
   * @name radiusX
   * @method
   * @memberof Konva.Ellipse.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get radius x
   * var radiusX = ellipse.radiusX();
   *
   * // set radius x
   * ellipse.radiusX(200);
   */

  Konva.Factory.addGetterSetter(
    Konva.Ellipse,
    'radiusY',
    0,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set radius y
   * @name radiusY
   * @method
   * @memberof Konva.Ellipse.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get radius y
   * var radiusY = ellipse.radiusY();
   *
   * // set radius y
   * ellipse.radiusY(200);
   */

  Konva.Collection.mapMethods(Konva.Ellipse);
})();

(function() {
  'use strict';
  // the 0.0001 offset fixes a bug in Chrome 27
  var PIx2 = Math.PI * 2 - 0.0001;
  /**
   * Ring constructor
   * @constructor
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Number} config.innerRadius
   * @param {Number} config.outerRadius
   * @param {Boolean} [config.clockwise]
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var ring = new Konva.Ring({
   *   innerRadius: 40,
   *   outerRadius: 80,
   *   fill: 'red',
   *   stroke: 'black',
   *   strokeWidth: 5
   * });
   */
  Konva.Ring = function(config) {
    this.___init(config);
  };

  Konva.Ring.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Ring';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      context.beginPath();
      context.arc(0, 0, this.getInnerRadius(), 0, PIx2, false);
      context.moveTo(this.getOuterRadius(), 0);
      context.arc(0, 0, this.getOuterRadius(), PIx2, 0, true);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.outerRadius() !== width / 2) {
        this.setOuterRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.outerRadius() !== height / 2) {
        this.setOuterRadius(height / 2);
      }
    },
    setOuterRadius: function(val) {
      this._setAttr('outerRadius', val);
      this.setWidth(val * 2);
      this.setHeight(val * 2);
    }
  };
  Konva.Util.extend(Konva.Ring, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(
    Konva.Ring,
    'innerRadius',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set innerRadius
   * @name innerRadius
   * @method
   * @memberof Konva.Ring.prototype
   * @param {Number} innerRadius
   * @returns {Number}
   * @example
   * // get inner radius
   * var innerRadius = ring.innerRadius();
   *
   * // set inner radius
   * ring.innerRadius(20);
   */
  Konva.Factory.addGetter(
    Konva.Ring,
    'outerRadius',
    0,
    Konva.Validators.getNumberValidator()
  );
  Konva.Factory.addOverloadedGetterSetter(Konva.Ring, 'outerRadius');

  /**
   * get/set outerRadius
   * @name outerRadius
   * @method
   * @memberof Konva.Ring.prototype
   * @param {Number} outerRadius
   * @returns {Number}
   * @example
   * // get outer radius
   * var outerRadius = ring.outerRadius();
   *
   * // set outer radius
   * ring.outerRadius(20);
   */

  Konva.Collection.mapMethods(Konva.Ring);
})();

(function() {
  'use strict';
  /**
   * Wedge constructor
   * @constructor
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Number} config.angle in degrees
   * @param {Number} config.radius
   * @param {Boolean} [config.clockwise]
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * // draw a wedge that's pointing downwards
   * var wedge = new Konva.Wedge({
   *   radius: 40,
   *   fill: 'red',
   *   stroke: 'black'
   *   strokeWidth: 5,
   *   angleDeg: 60,
   *   rotationDeg: -120
   * });
   */
  Konva.Wedge = function(config) {
    this.___init(config);
  };

  Konva.Wedge.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Wedge';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      context.beginPath();
      context.arc(
        0,
        0,
        this.getRadius(),
        0,
        Konva.getAngle(this.getAngle()),
        this.getClockwise()
      );
      context.lineTo(0, 0);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.radius() !== width / 2) {
        this.setRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.radius() !== height / 2) {
        this.setRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Wedge, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(
    Konva.Wedge,
    'radius',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set radius
   * @name radius
   * @method
   * @memberof Konva.Wedge.prototype
   * @param {Number} radius
   * @returns {Number}
   * @example
   * // get radius
   * var radius = wedge.radius();
   *
   * // set radius
   * wedge.radius(10);
   */

  Konva.Factory.addGetterSetter(
    Konva.Wedge,
    'angle',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set angle in degrees
   * @name angle
   * @method
   * @memberof Konva.Wedge.prototype
   * @param {Number} angle
   * @returns {Number}
   * @example
   * // get angle
   * var angle = wedge.angle();
   *
   * // set angle
   * wedge.angle(20);
   */

  Konva.Factory.addGetterSetter(Konva.Wedge, 'clockwise', false);

  /**
   * get/set clockwise flag
   * @name clockwise
   * @method
   * @memberof Konva.Wedge.prototype
   * @param {Number} clockwise
   * @returns {Number}
   * @example
   * // get clockwise flag
   * var clockwise = wedge.clockwise();
   *
   * // draw wedge counter-clockwise
   * wedge.clockwise(false);
   *
   * // draw wedge clockwise
   * wedge.clockwise(true);
   */

  Konva.Factory.backCompat(Konva.Wedge, {
    angleDeg: 'angle',
    getAngleDeg: 'getAngle',
    setAngleDeg: 'setAngle'
  });

  Konva.Collection.mapMethods(Konva.Wedge);
})();

(function(Konva) {
  'use strict';
  /**
   * Arc constructor
   * @constructor
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Number} config.angle in degrees
   * @param {Number} config.innerRadius
   * @param {Number} config.outerRadius
   * @param {Boolean} [config.clockwise]
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * // draw a Arc that's pointing downwards
   * var arc = new Konva.Arc({
   *   innerRadius: 40,
   *   outerRadius: 80,
   *   fill: 'red',
   *   stroke: 'black'
   *   strokeWidth: 5,
   *   angle: 60,
   *   rotationDeg: -120
   * });
   */
  Konva.Arc = function(config) {
    this.___init(config);
  };

  Konva.Arc.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Arc';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var angle = Konva.getAngle(this.angle()),
        clockwise = this.clockwise();

      context.beginPath();
      context.arc(0, 0, this.getOuterRadius(), 0, angle, clockwise);
      context.arc(0, 0, this.getInnerRadius(), angle, 0, !clockwise);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.getOuterRadius() !== width / 2) {
        this.setOuterRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.getOuterRadius() !== height / 2) {
        this.setOuterRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Arc, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(
    Konva.Arc,
    'innerRadius',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set innerRadius
   * @name innerRadius
   * @method
   * @memberof Konva.Arc.prototype
   * @param {Number} innerRadius
   * @returns {Number}
   * @example
   * // get inner radius
   * var innerRadius = arc.innerRadius();
   *
   * // set inner radius
   * arc.innerRadius(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Arc,
    'outerRadius',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set outerRadius
   * @name outerRadius
   * @method
   * @memberof Konva.Arc.prototype
   * @param {Number} outerRadius
   * @returns {Number}
   * @example
   * // get outer radius
   * var outerRadius = arc.outerRadius();
   *
   * // set outer radius
   * arc.outerRadius(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Arc,
    'angle',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set angle in degrees
   * @name angle
   * @method
   * @memberof Konva.Arc.prototype
   * @param {Number} angle
   * @returns {Number}
   * @example
   * // get angle
   * var angle = arc.angle();
   *
   * // set angle
   * arc.angle(20);
   */

  Konva.Factory.addGetterSetter(Konva.Arc, 'clockwise', false);

  /**
   * get/set clockwise flag
   * @name clockwise
   * @method
   * @memberof Konva.Arc.prototype
   * @param {Boolean} clockwise
   * @returns {Boolean}
   * @example
   * // get clockwise flag
   * var clockwise = arc.clockwise();
   *
   * // draw arc counter-clockwise
   * arc.clockwise(false);
   *
   * // draw arc clockwise
   * arc.clockwise(true);
   */

  Konva.Collection.mapMethods(Konva.Arc);
})(Konva);

(function() {
  'use strict';
  // CONSTANTS
  var IMAGE = 'Image';

  /**
   * Image constructor
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Image} config.image
   * @param {Object} [config.crop]
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var imageObj = new Image();
   * imageObj.onload = function() {
   *   var image = new Konva.Image({
   *     x: 200,
   *     y: 50,
   *     image: imageObj,
   *     width: 100,
   *     height: 100
   *   });
   * };
   * imageObj.src = '/path/to/image.jpg'
   */
  Konva.Image = function(config) {
    this.___init(config);
  };

  Konva.Image.prototype = {
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = IMAGE;
      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _useBufferCanvas: function() {
      return (
        (this.hasShadow() || this.getAbsoluteOpacity() !== 1) &&
        this.hasStroke() &&
        this.getStage()
      );
    },
    _sceneFunc: function(context) {
      var width = this.getWidth(),
        height = this.getHeight(),
        image = this.getImage(),
        cropWidth,
        cropHeight,
        params;

      if (image) {
        cropWidth = this.getCropWidth();
        cropHeight = this.getCropHeight();
        if (cropWidth && cropHeight) {
          params = [
            image,
            this.getCropX(),
            this.getCropY(),
            cropWidth,
            cropHeight,
            0,
            0,
            width,
            height
          ];
        } else {
          params = [image, 0, 0, width, height];
        }
      }

      if (this.hasFill() || this.hasStroke()) {
        context.beginPath();
        context.rect(0, 0, width, height);
        context.closePath();
        context.fillStrokeShape(this);
      }

      if (image) {
        context.drawImage.apply(context, params);
      }
    },
    _hitFunc: function(context) {
      var width = this.getWidth(),
        height = this.getHeight();

      context.beginPath();
      context.rect(0, 0, width, height);
      context.closePath();
      context.fillStrokeShape(this);
    },
    getWidth: function() {
      var image = this.getImage();
      return this.attrs.width || (image ? image.width : 0);
    },
    getHeight: function() {
      var image = this.getImage();
      return this.attrs.height || (image ? image.height : 0);
    }
  };
  Konva.Util.extend(Konva.Image, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Image, 'image');

  /**
   * set image
   * @name setImage
   * @method
   * @memberof Konva.Image.prototype
   * @param {Image} image
   */

  /**
   * get image
   * @name getImage
   * @method
   * @memberof Konva.Image.prototype
   * @returns {Image}
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Image, 'crop', [
    'x',
    'y',
    'width',
    'height'
  ]);
  /**
   * get/set crop
   * @method
   * @name crop
   * @memberof Konva.Image.prototype
   * @param {Object} crop
   * @param {Number} crop.x
   * @param {Number} crop.y
   * @param {Number} crop.width
   * @param {Number} crop.height
   * @returns {Object}
   * @example
   * // get crop
   * var crop = image.crop();
   *
   * // set crop
   * image.crop({
   *   x: 20,
   *   y: 20,
   *   width: 20,
   *   height: 20
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Image,
    'cropX',
    0,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set crop x
   * @method
   * @name cropX
   * @memberof Konva.Image.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get crop x
   * var cropX = image.cropX();
   *
   * // set crop x
   * image.cropX(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Image,
    'cropY',
    0,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set crop y
   * @name cropY
   * @method
   * @memberof Konva.Image.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get crop y
   * var cropY = image.cropY();
   *
   * // set crop y
   * image.cropY(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Image,
    'cropWidth',
    0,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set crop width
   * @name cropWidth
   * @method
   * @memberof Konva.Image.prototype
   * @param {Number} width
   * @returns {Number}
   * @example
   * // get crop width
   * var cropWidth = image.cropWidth();
   *
   * // set crop width
   * image.cropWidth(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Image,
    'cropHeight',
    0,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set crop height
   * @name cropHeight
   * @method
   * @memberof Konva.Image.prototype
   * @param {Number} height
   * @returns {Number}
   * @example
   * // get crop height
   * var cropHeight = image.cropHeight();
   *
   * // set crop height
   * image.cropHeight(20);
   */

  Konva.Collection.mapMethods(Konva.Image);

  /**
   * load image from given url and create `Konva.Image` instance
   * @method
   * @memberof Konva.Image
   * @param {String} url image source
   * @param {Function} callback with Konva.Image instance as first argument
   * @example
   *  Konva.Image.fromURL(imageURL, function(image){
   *    // image is Konva.Image instance
   *    layer.add(image);
   *    layer.draw();
   *  });
   */
  Konva.Image.fromURL = function(url, callback) {
    var img = new Image();
    img.onload = function() {
      var image = new Konva.Image({
        image: img
      });
      callback(image);
    };
    img.crossOrigin = 'Anonymous';
    img.src = url;
  };
})();

/*eslint-disable max-depth */
(function() {
  'use strict';
  // var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
  // constants
  var AUTO = 'auto',
    //CANVAS = 'canvas',
    CENTER = 'center',
    JUSTIFY = 'justify',
    CHANGE_KONVA = 'Change.konva',
    CONTEXT_2D = '2d',
    DASH = '-',
    EMPTY_STRING = '',
    LEFT = 'left',
    TEXT = 'text',
    TEXT_UPPER = 'Text',
    TOP = 'top',
    BOTTOM = 'bottom',
    MIDDLE = 'middle',
    NORMAL = 'normal',
    PX_SPACE = 'px ',
    SPACE = ' ',
    RIGHT = 'right',
    WORD = 'word',
    CHAR = 'char',
    NONE = 'none',
    ELLIPSIS = '…',
    ATTR_CHANGE_LIST = [
      'fontFamily',
      'fontSize',
      'fontStyle',
      'fontVariant',
      'padding',
      'align',
      'verticalAlign',
      'lineHeight',
      'text',
      'width',
      'height',
      'wrap',
      'ellipsis',
      'letterSpacing'
    ],
    // cached variables
    attrChangeListLen = ATTR_CHANGE_LIST.length;
  var dummyContext;
  function getDummyContext() {
    if (dummyContext) {
      return dummyContext;
    }
    dummyContext = Konva.Util.createCanvasElement().getContext(CONTEXT_2D);
    return dummyContext;
  }

  /**
   * Text constructor
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {String} [config.fontFamily] default is Arial
   * @param {Number} [config.fontSize] in pixels.  Default is 12
   * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
   * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
   * @param {String} config.text
   * @param {String} [config.align] can be left, center, or right
   * @param {String} [config.verticalAlign] can be top, middle or bottom
   * @param {Number} [config.padding]
   * @param {Number} [config.lineHeight] default is 1
   * @param {String} [config.wrap] can be word, char, or none. Default is word
   * @param {Boolean} [config.ellipsis] can be true or false. Default is false. if Konva.Text config is set to wrap="none" and ellipsis=true, then it will add "..." to the end
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var text = new Konva.Text({
   *   x: 10,
   *   y: 15,
   *   text: 'Simple Text',
   *   fontSize: 30,
   *   fontFamily: 'Calibri',
   *   fill: 'green'
   * });
   */
  Konva.Text = function(config) {
    this.___init(config);
  };
  function _fillFunc(context) {
    context.fillText(this.partialText, 0, 0);
  }
  function _strokeFunc(context) {
    context.strokeText(this.partialText, 0, 0);
  }

  Konva.Text.prototype = {
    ___init: function(config) {
      config = config || {};

      // set default color to black
      if (
        !config.fillLinearGradientColorStops &&
        !config.fillRadialGradientColorStops
      ) {
        config.fill = config.fill || 'black';
      }
      //
      // if (config.width === undefined) {
      //     config.width = AUTO;
      // }
      // if (config.height === undefined) {
      //     config.height = AUTO;
      // }

      // call super constructor
      Konva.Shape.call(this, config);

      this._fillFunc = _fillFunc;
      this._strokeFunc = _strokeFunc;
      this.className = TEXT_UPPER;

      // update text data for certain attr changes
      for (var n = 0; n < attrChangeListLen; n++) {
        this.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, this._setTextData);
      }

      this._setTextData();
      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _sceneFunc: function(context) {
      var padding = this.getPadding(),
        textHeight = this.getTextHeight(),
        lineHeightPx = this.getLineHeight() * textHeight,
        textArr = this.textArr,
        textArrLen = textArr.length,
        verticalAlign = this.getVerticalAlign(),
        alignY = 0,
        align = this.getAlign(),
        totalWidth = this.getWidth(),
        letterSpacing = this.getLetterSpacing(),
        textDecoration = this.textDecoration(),
        fill = this.fill(),
        fontSize = this.fontSize(),
        n;

      context.setAttr('font', this._getContextFont());

      context.setAttr('textBaseline', MIDDLE);
      context.setAttr('textAlign', LEFT);

      // handle vertical alignment
      if (verticalAlign === MIDDLE) {
        alignY =
          (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2;
      } else if (verticalAlign === BOTTOM) {
        alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2;
      }

      if (padding) {
        context.translate(padding, 0);
        context.translate(0, alignY + padding + lineHeightPx / 2);
      } else {
        context.translate(0, alignY + lineHeightPx / 2);
      }

      // draw text lines
      for (n = 0; n < textArrLen; n++) {
        var obj = textArr[n],
          text = obj.text,
          width = obj.width,
          lastLine = n !== textArrLen - 1,
          spacesNumber,
          oneWord,
          lineWidth;

        // horizontal alignment
        context.save();
        if (align === RIGHT) {
          context.translate(totalWidth - width - padding * 2, 0);
        } else if (align === CENTER) {
          context.translate((totalWidth - width - padding * 2) / 2, 0);
        }

        if (textDecoration.indexOf('underline') !== -1) {
          context.save();
          context.beginPath();

          context.moveTo(0, Math.round(lineHeightPx / 2));
          spacesNumber = text.split(' ').length - 1;
          oneWord = spacesNumber === 0;
          lineWidth =
            align === JUSTIFY && lastLine && !oneWord
              ? totalWidth - padding * 2
              : width;
          context.lineTo(Math.round(lineWidth), Math.round(lineHeightPx / 2));
          // TODO: I have no idea what is real ratio
          // just /15 looks good enough
          context.lineWidth = fontSize / 15;
          context.strokeStyle = fill;
          context.stroke();
          context.restore();
        }
        if (textDecoration.indexOf('line-through') !== -1) {
          context.save();
          context.beginPath();
          context.moveTo(0, 0);
          spacesNumber = text.split(' ').length - 1;
          oneWord = spacesNumber === 0;
          lineWidth =
            align === JUSTIFY && lastLine && !oneWord
              ? totalWidth - padding * 2
              : width;
          context.lineTo(Math.round(lineWidth), 0);
          context.lineWidth = fontSize / 15;
          context.strokeStyle = fill;
          context.stroke();
          context.restore();
        }
        if (letterSpacing !== 0 || align === JUSTIFY) {
          //   var words = text.split(' ');
          spacesNumber = text.split(' ').length - 1;
          for (var li = 0; li < text.length; li++) {
            var letter = text[li];
            // skip justify for the last line
            if (letter === ' ' && n !== textArrLen - 1 && align === JUSTIFY) {
              context.translate(
                Math.floor((totalWidth - padding * 2 - width) / spacesNumber),
                0
              );
            }
            this.partialText = letter;
            context.fillStrokeShape(this);
            context.translate(
              Math.round(this._getTextSize(letter).width) + letterSpacing,
              0
            );
          }
        } else {
          this.partialText = text;

          context.fillStrokeShape(this);
        }
        context.restore();
        if (textArrLen > 1) {
          context.translate(0, lineHeightPx);
        }
      }
    },
    _hitFunc: function(context) {
      var width = this.getWidth(),
        height = this.getHeight();

      context.beginPath();
      context.rect(0, 0, width, height);
      context.closePath();
      context.fillStrokeShape(this);
    },
    setText: function(text) {
      var str = Konva.Util._isString(text) ? text : (text || '').toString();
      this._setAttr(TEXT, str);
      return this;
    },
    /**
     * get width of text area, which includes padding
     * @method
     * @memberof Konva.Text.prototype
     * @returns {Number}
     */
    getWidth: function() {
      var isAuto = this.attrs.width === AUTO || this.attrs.width === undefined;
      return isAuto
        ? this.getTextWidth() + this.getPadding() * 2
        : this.attrs.width;
    },
    /**
     * get the height of the text area, which takes into account multi-line text, line heights, and padding
     * @method
     * @memberof Konva.Text.prototype
     * @returns {Number}
     */
    getHeight: function() {
      var isAuto =
        this.attrs.height === AUTO || this.attrs.height === undefined;
      return isAuto
        ? this.getTextHeight() * this.textArr.length * this.getLineHeight() +
            this.getPadding() * 2
        : this.attrs.height;
    },
    /**
     * get text width
     * @method
     * @memberof Konva.Text.prototype
     * @returns {Number}
     */
    getTextWidth: function() {
      return this.textWidth;
    },
    /**
     * get height of one line text
     * @method
     * @memberof Konva.Text.prototype
     * @returns {Number}
     */
    getTextHeight: function() {
      return this.textHeight;
    },
    _getTextSize: function(text) {
      var _context = getDummyContext(),
        fontSize = this.getFontSize(),
        metrics;

      _context.save();
      _context.font = this._getContextFont();

      metrics = _context.measureText(text);
      _context.restore();
      return {
        width: metrics.width,
        height: parseInt(fontSize, 10)
      };
    },
    _getContextFont: function() {
      // IE don't want to work with usual font style
      // bold was not working
      // removing font variant will solve
      // fix for: https://github.com/konvajs/konva/issues/94
      if (Konva.UA.isIE) {
        return (
          this.getFontStyle() +
          SPACE +
          this.getFontSize() +
          PX_SPACE +
          this.getFontFamily()
        );
      }
      return (
        this.getFontStyle() +
        SPACE +
        this.getFontVariant() +
        SPACE +
        this.getFontSize() +
        PX_SPACE +
        this.getFontFamily()
      );
    },
    _addTextLine: function(line) {
      if (this.align() === JUSTIFY) {
        line = line.trim();
      }
      var width = this._getTextWidth(line);
      return this.textArr.push({ text: line, width: width });
    },
    _getTextWidth: function(text) {
      var latterSpacing = this.getLetterSpacing();
      var length = text.length;
      return (
        getDummyContext().measureText(text).width +
        (length ? latterSpacing * (length - 1) : 0)
      );
    },
    _setTextData: function() {
      var lines = this.getText().split('\n'),
        fontSize = +this.getFontSize(),
        textWidth = 0,
        lineHeightPx = this.getLineHeight() * fontSize,
        width = this.attrs.width,
        height = this.attrs.height,
        fixedWidth = width !== AUTO,
        fixedHeight = height !== AUTO,
        padding = this.getPadding(),
        maxWidth = width - padding * 2,
        maxHeightPx = height - padding * 2,
        currentHeightPx = 0,
        wrap = this.getWrap(),
        // align = this.getAlign(),
        shouldWrap = wrap !== NONE,
        wrapAtWord = wrap !== CHAR && shouldWrap,
        shouldAddEllipsis = this.getEllipsis() && !shouldWrap;

      this.textArr = [];
      getDummyContext().font = this._getContextFont();
      for (var i = 0, max = lines.length; i < max; ++i) {
        var line = lines[i];
        var additionalWidth = shouldAddEllipsis
          ? this._getTextWidth(ELLIPSIS)
          : 0;

        var lineWidth = this._getTextWidth(line);
        if (fixedWidth && lineWidth > maxWidth) {
          /*
          * if width is fixed and line does not fit entirely
          * break the line into multiple fitting lines
          */
          while (line.length > 0) {
            /*
            * use binary search to find the longest substring that
            * that would fit in the specified width
            */
            var low = 0,
              high = line.length,
              match = '',
              matchWidth = 0;
            while (low < high) {
              var mid = (low + high) >>> 1,
                substr = line.slice(0, mid + 1),
                substrWidth = this._getTextWidth(substr) + additionalWidth;
              if (substrWidth <= maxWidth) {
                low = mid + 1;
                match = substr + (shouldAddEllipsis ? ELLIPSIS : '');
                matchWidth = substrWidth;
              } else {
                high = mid;
              }
            }
            /*
            * 'low' is now the index of the substring end
            * 'match' is the substring
            * 'matchWidth' is the substring width in px
            */
            if (match) {
              // a fitting substring was found
              if (wrapAtWord) {
                // try to find a space or dash where wrapping could be done
                var wrapIndex;
                var nextChar = line[match.length];
                var nextIsSpaceOrDash = nextChar === SPACE || nextChar === DASH;
                if (nextIsSpaceOrDash && matchWidth <= maxWidth) {
                  wrapIndex = match.length;
                } else {
                  wrapIndex =
                    Math.max(
                      match.lastIndexOf(SPACE),
                      match.lastIndexOf(DASH)
                    ) + 1;
                }
                if (wrapIndex > 0) {
                  // re-cut the substring found at the space/dash position
                  low = wrapIndex;
                  match = match.slice(0, low);
                  matchWidth = this._getTextWidth(match);
                }
              }
              // if (align === 'right') {
              match = Konva.Util.trimRight(match);
              // }
              this._addTextLine(match);
              textWidth = Math.max(textWidth, matchWidth);
              currentHeightPx += lineHeightPx;
              if (
                !shouldWrap ||
                (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)
              ) {
                /*
                * stop wrapping if wrapping is disabled or if adding
                * one more line would overflow the fixed height
                */
                break;
              }
              line = line.slice(low);
              line = Konva.Util.trimLeft(line);
              if (line.length > 0) {
                // Check if the remaining text would fit on one line
                lineWidth = this._getTextWidth(line);
                if (lineWidth <= maxWidth) {
                  // if it does, add the line and break out of the loop
                  this._addTextLine(line);
                  currentHeightPx += lineHeightPx;
                  textWidth = Math.max(textWidth, lineWidth);
                  break;
                }
              }
            } else {
              // not even one character could fit in the element, abort
              break;
            }
          }
        } else {
          // element width is automatically adjusted to max line width
          this._addTextLine(line);
          currentHeightPx += lineHeightPx;
          textWidth = Math.max(textWidth, lineWidth);
        }
        // if element height is fixed, abort if adding one more line would overflow
        if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
          break;
        }
      }
      this.textHeight = fontSize;
      // var maxTextWidth = 0;
      // for(var j = 0; j < this.textArr.length; j++) {
      //     maxTextWidth = Math.max(maxTextWidth, this.textArr[j].width);
      // }
      this.textWidth = textWidth;
    }
  };
  Konva.Util.extend(Konva.Text, Konva.Shape);

  Konva.Factory.addSetter(
    Konva.Node,
    'width',
    Konva.Validators.getNumberOrAutoValidator()
  );

  Konva.Factory.addSetter(
    Konva.Node,
    'height',
    Konva.Validators.getNumberOrAutoValidator()
  );

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Text, 'fontFamily', 'Arial');

  /**
   * get/set font family
   * @name fontFamily
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} fontFamily
   * @returns {String}
   * @example
   * // get font family
   * var fontFamily = text.fontFamily();
   *
   * // set font family
   * text.fontFamily('Arial');
   */

  Konva.Factory.addGetterSetter(
    Konva.Text,
    'fontSize',
    12,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set font size in pixels
   * @name fontSize
   * @method
   * @memberof Konva.Text.prototype
   * @param {Number} fontSize
   * @returns {Number}
   * @example
   * // get font size
   * var fontSize = text.fontSize();
   *
   * // set font size to 22px
   * text.fontSize(22);
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'fontStyle', NORMAL);

  /**
   * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
   * @name fontStyle
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} fontStyle
   * @returns {String}
   * @example
   * // get font style
   * var fontStyle = text.fontStyle();
   *
   * // set font style
   * text.fontStyle('bold');
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'fontVariant', NORMAL);

  /**
   * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
   * @name fontVariant
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} fontVariant
   * @returns {String}
   * @example
   * // get font variant
   * var fontVariant = text.fontVariant();
   *
   * // set font variant
   * text.fontVariant('small-caps');
   */

  Konva.Factory.addGetterSetter(
    Konva.Text,
    'padding',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set padding
   * @name padding
   * @method
   * @memberof Konva.Text.prototype
   * @param {Number} padding
   * @returns {Number}
   * @example
   * // get padding
   * var padding = text.padding();
   *
   * // set padding to 10 pixels
   * text.padding(10);
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'align', LEFT);

  /**
   * get/set horizontal align of text.  Can be 'left', 'center', 'right' or 'justify'
   * @name align
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} align
   * @returns {String}
   * @example
   * // get text align
   * var align = text.align();
   *
   * // center text
   * text.align('center');
   *
   * // align text to right
   * text.align('right');
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'verticalAlign', TOP);

  /**
   * get/set vertical align of text.  Can be 'top', 'middle', 'bottom'.
   * @name verticalAlign
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} verticalAlign
   * @returns {String}
   * @example
   * // get text vertical align
   * var verticalAlign = text.verticalAlign();
   *
   * // center text
   * text.verticalAlign('middle');
   */

  Konva.Factory.addGetterSetter(
    Konva.Text,
    'lineHeight',
    1,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set line height.  The default is 1.
   * @name lineHeight
   * @method
   * @memberof Konva.Text.prototype
   * @param {Number} lineHeight
   * @returns {Number}
   * @example
   * // get line height
   * var lineHeight = text.lineHeight();
   *
   * // set the line height
   * text.lineHeight(2);
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'wrap', WORD);

  /**
   * get/set wrap.  Can be word, char, or none. Default is word.
   * @name wrap
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} wrap
   * @returns {String}
   * @example
   * // get wrap
   * var wrap = text.wrap();
   *
   * // set wrap
   * text.wrap('word');
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'ellipsis', false);

  /**
   * get/set ellipsis.  Can be true or false. Default is false.
   * if Konva.Text config is set to wrap="none" and ellipsis=true, then it will add "..." to the end
   * @name ellipsis
   * @method
   * @memberof Konva.Text.prototype
   * @param {Boolean} ellipsis
   * @returns {Boolean}
   * @example
   * // get ellipsis
   * var ellipsis = text.ellipsis();
   *
   * // set ellipsis
   * text.ellipsis(true);
   */

  Konva.Factory.addGetterSetter(
    Konva.Text,
    'letterSpacing',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set letter spacing property. Default value is 0.
   * @name letterSpacing
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {Number} letterSpacing
   */

  Konva.Factory.addGetter(Konva.Text, 'text', EMPTY_STRING);
  Konva.Factory.addOverloadedGetterSetter(Konva.Text, 'text');

  /**
   * get/set text
   * @name getText
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} text
   * @returns {String}
   * @example
   * // get text
   * var text = text.text();
   *
   * // set text
   * text.text('Hello world!');
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'textDecoration', EMPTY_STRING);

  /**
   * get/set text decoration of a text.  Possible values are 'underline', 'line-through' or combination of these values separated by space
   * @name textDecoration
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} textDecoration
   * @returns {String}
   * @example
   * // get text decoration
   * var textDecoration = text.textDecoration();
   *
   * // underline text
   * text.textDecoration('underline');
   *
   * // strike text
   * text.textDecoration('line-through');
   *
   * // underline and strike text
   * text.textDecoration('underline line-through');
   */

  Konva.Collection.mapMethods(Konva.Text);
})();

(function() {
  'use strict';
  /**
   * Line constructor.&nbsp; Lines are defined by an array of points and
   *  a tension
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Array} config.points Flat array of points coordinates. You should define them as [x1, y1, x2, y2, x3, y3].
   * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
   *   The default is 0
   * @param {Boolean} [config.closed] defines whether or not the line shape is closed, creating a polygon or blob
   * @param {Boolean} [config.bezier] if no tension is provided but bezier=true, we draw the line as a bezier using the passed points
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var line = new Konva.Line({
   *   x: 100,
   *   y: 50,
   *   points: [73, 70, 340, 23, 450, 60, 500, 20],
   *   stroke: 'red',
   *   tension: 1
   * });
   */
  Konva.Line = function(config) {
    this.___init(config);
  };

  Konva.Line.prototype = {
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Line';

      this.on(
        'pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva',
        function() {
          this._clearCache('tensionPoints');
        }
      );

      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var points = this.getPoints(),
        length = points.length,
        tension = this.getTension(),
        closed = this.getClosed(),
        bezier = this.getBezier(),
        tp,
        len,
        n;

      if (!length) {
        return;
      }

      context.beginPath();
      context.moveTo(points[0], points[1]);

      // tension
      if (tension !== 0 && length > 4) {
        tp = this.getTensionPoints();
        len = tp.length;
        n = closed ? 0 : 4;

        if (!closed) {
          context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
        }

        while (n < len - 2) {
          context.bezierCurveTo(
            tp[n++],
            tp[n++],
            tp[n++],
            tp[n++],
            tp[n++],
            tp[n++]
          );
        }

        if (!closed) {
          context.quadraticCurveTo(
            tp[len - 2],
            tp[len - 1],
            points[length - 2],
            points[length - 1]
          );
        }
      } else if (bezier) {
        // no tension but bezier
        n = 2;

        while (n < length) {
          context.bezierCurveTo(
            points[n++],
            points[n++],
            points[n++],
            points[n++],
            points[n++],
            points[n++]
          );
        }
      } else {
        // no tension
        for (n = 2; n < length; n += 2) {
          context.lineTo(points[n], points[n + 1]);
        }
      }

      // closed e.g. polygons and blobs
      if (closed) {
        context.closePath();
        context.fillStrokeShape(this);
      } else {
        // open e.g. lines and splines
        context.strokeShape(this);
      }
    },
    getTensionPoints: function() {
      return this._getCache('tensionPoints', this._getTensionPoints);
    },
    _getTensionPoints: function() {
      if (this.getClosed()) {
        return this._getTensionPointsClosed();
      } else {
        return Konva.Util._expandPoints(this.getPoints(), this.getTension());
      }
    },
    _getTensionPointsClosed: function() {
      var p = this.getPoints(),
        len = p.length,
        tension = this.getTension(),
        util = Konva.Util,
        firstControlPoints = util._getControlPoints(
          p[len - 2],
          p[len - 1],
          p[0],
          p[1],
          p[2],
          p[3],
          tension
        ),
        lastControlPoints = util._getControlPoints(
          p[len - 4],
          p[len - 3],
          p[len - 2],
          p[len - 1],
          p[0],
          p[1],
          tension
        ),
        middle = Konva.Util._expandPoints(p, tension),
        tp = [firstControlPoints[2], firstControlPoints[3]]
          .concat(middle)
          .concat([
            lastControlPoints[0],
            lastControlPoints[1],
            p[len - 2],
            p[len - 1],
            lastControlPoints[2],
            lastControlPoints[3],
            firstControlPoints[0],
            firstControlPoints[1],
            p[0],
            p[1]
          ]);

      return tp;
    },
    getWidth: function() {
      return this.getSelfRect().width;
    },
    getHeight: function() {
      return this.getSelfRect().height;
    },
    // overload size detection
    getSelfRect: function() {
      var points;
      if (this.getTension() !== 0) {
        points = this._getTensionPoints();
      } else {
        points = this.getPoints();
      }
      var minX = points[0];
      var maxX = points[0];
      var minY = points[1];
      var maxY = points[1];
      var x, y;
      for (var i = 0; i < points.length / 2; i++) {
        x = points[i * 2];
        y = points[i * 2 + 1];
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
      return {
        x: Math.round(minX),
        y: Math.round(minY),
        width: Math.round(maxX - minX),
        height: Math.round(maxY - minY)
      };
    }
  };
  Konva.Util.extend(Konva.Line, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Line, 'closed', false);

  /**
   * get/set closed flag.  The default is false
   * @name closed
   * @method
   * @memberof Konva.Line.prototype
   * @param {Boolean} closed
   * @returns {Boolean}
   * @example
   * // get closed flag
   * var closed = line.closed();
   *
   * // close the shape
   * line.closed(true);
   *
   * // open the shape
   * line.closed(false);
   */

  Konva.Factory.addGetterSetter(Konva.Line, 'bezier', false);

  /**
   * get/set bezier flag.  The default is false
   * @name bezier
   * @method
   * @memberof Konva.Line.prototype
   * @param {Boolean} bezier
   * @returns {Boolean}
   * @example
   * // get whether the line is a bezier
   * var isBezier = line.bezier();
   *
   * // set whether the line is a bezier
   * line.bezier(true);
   */

  Konva.Factory.addGetterSetter(
    Konva.Line,
    'tension',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set tension
   * @name tension
   * @method
   * @memberof Konva.Line.prototype
   * @param {Number} Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
   *   The default is 0
   * @returns {Number}
   * @example
   * // get tension
   * var tension = line.tension();
   *
   * // set tension
   * line.tension(3);
   */

  Konva.Factory.addGetterSetter(
    Konva.Line,
    'points',
    [],
    Konva.Validators.getNumberArrayValidator()
  );
  /**
   * get/set points array
   * @name points
   * @method
   * @memberof Konva.Line.prototype
   * @param {Array} points
   * @returns {Array}
   * @example
   * // get points
   * var points = line.points();
   *
   * // set points
   * line.points([10, 20, 30, 40, 50, 60]);
   *
   * // push a new point
   * line.points(line.points().concat([70, 80]));
   */

  Konva.Collection.mapMethods(Konva.Line);
})();

(function() {
  'use strict';
  /**
   * Sprite constructor
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {String} config.animation animation key
   * @param {Object} config.animations animation map
   * @param {Integer} [config.frameIndex] animation frame index
   * @param {Image} config.image image object
   * @param {Integer} [config.frameRate] animation frame rate
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var imageObj = new Image();
   * imageObj.onload = function() {
   *   var sprite = new Konva.Sprite({
   *     x: 200,
   *     y: 100,
   *     image: imageObj,
   *     animation: 'standing',
   *     animations: {
   *       standing: [
   *         // x, y, width, height (6 frames)
   *         0, 0, 49, 109,
   *         52, 0, 49, 109,
   *         105, 0, 49, 109,
   *         158, 0, 49, 109,
   *         210, 0, 49, 109,
   *         262, 0, 49, 109
   *       ],
   *       kicking: [
   *         // x, y, width, height (6 frames)
   *         0, 109, 45, 98,
   *         45, 109, 45, 98,
   *         95, 109, 63, 98,
   *         156, 109, 70, 98,
   *         229, 109, 60, 98,
   *         287, 109, 41, 98
   *       ]
   *     },
   *     frameRate: 7,
   *     frameIndex: 0
   *   });
   * };
   * imageObj.src = '/path/to/image.jpg'
   */
  Konva.Sprite = function(config) {
    this.___init(config);
  };

  Konva.Sprite.prototype = {
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Sprite';

      this._updated = true;
      var that = this;
      this.anim = new Konva.Animation(function() {
        // if we don't need to redraw layer we should return false
        var updated = that._updated;
        that._updated = false;
        return updated;
      });
      this.on('animationChange.konva', function() {
        // reset index when animation changes
        this.frameIndex(0);
      });
      this.on('frameIndexChange.konva', function() {
        this._updated = true;
      });
      // smooth change for frameRate
      this.on('frameRateChange.konva', function() {
        if (!this.anim.isRunning()) {
          return;
        }
        clearInterval(this.interval);
        this._setInterval();
      });

      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _sceneFunc: function(context) {
      var anim = this.getAnimation(),
        index = this.frameIndex(),
        ix4 = index * 4,
        set = this.getAnimations()[anim],
        offsets = this.frameOffsets(),
        x = set[ix4 + 0],
        y = set[ix4 + 1],
        width = set[ix4 + 2],
        height = set[ix4 + 3],
        image = this.getImage();

      if (this.hasFill() || this.hasStroke()) {
        context.beginPath();
        context.rect(0, 0, width, height);
        context.closePath();
        context.fillStrokeShape(this);
      }

      if (image) {
        if (offsets) {
          var offset = offsets[anim],
            ix2 = index * 2;
          context.drawImage(
            image,
            x,
            y,
            width,
            height,
            offset[ix2 + 0],
            offset[ix2 + 1],
            width,
            height
          );
        } else {
          context.drawImage(image, x, y, width, height, 0, 0, width, height);
        }
      }
    },
    _hitFunc: function(context) {
      var anim = this.getAnimation(),
        index = this.frameIndex(),
        ix4 = index * 4,
        set = this.getAnimations()[anim],
        offsets = this.frameOffsets(),
        width = set[ix4 + 2],
        height = set[ix4 + 3];

      context.beginPath();
      if (offsets) {
        var offset = offsets[anim];
        var ix2 = index * 2;
        context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
      } else {
        context.rect(0, 0, width, height);
      }
      context.closePath();
      context.fillShape(this);
    },
    _useBufferCanvas: function() {
      return (
        (this.hasShadow() || this.getAbsoluteOpacity() !== 1) &&
        this.hasStroke()
      );
    },
    _setInterval: function() {
      var that = this;
      this.interval = setInterval(function() {
        that._updateIndex();
      }, 1000 / this.getFrameRate());
    },
    /**
     * start sprite animation
     * @method
     * @memberof Konva.Sprite.prototype
     */
    start: function() {
      if (this.isRunning()) {
        return;
      }
      var layer = this.getLayer();

      /*
             * animation object has no executable function because
             *  the updates are done with a fixed FPS with the setInterval
             *  below.  The anim object only needs the layer reference for
             *  redraw
             */
      this.anim.setLayers(layer);
      this._setInterval();
      this.anim.start();
    },
    /**
     * stop sprite animation
     * @method
     * @memberof Konva.Sprite.prototype
     */
    stop: function() {
      this.anim.stop();
      clearInterval(this.interval);
    },
    /**
     * determine if animation of sprite is running or not.  returns true or false
     * @method
     * @memberof Konva.Animation.prototype
     * @returns {Boolean}
     */
    isRunning: function() {
      return this.anim.isRunning();
    },
    _updateIndex: function() {
      var index = this.frameIndex(),
        animation = this.getAnimation(),
        animations = this.getAnimations(),
        anim = animations[animation],
        len = anim.length / 4;

      if (index < len - 1) {
        this.frameIndex(index + 1);
      } else {
        this.frameIndex(0);
      }
    }
  };
  Konva.Util.extend(Konva.Sprite, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Sprite, 'animation');

  /**
   * get/set animation key
   * @name animation
   * @method
   * @memberof Konva.Sprite.prototype
   * @param {String} anim animation key
   * @returns {String}
   * @example
   * // get animation key
   * var animation = sprite.animation();
   *
   * // set animation key
   * sprite.animation('kicking');
   */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'animations');

  /**
   * get/set animations map
   * @name animations
   * @method
   * @memberof Konva.Sprite.prototype
   * @param {Object} animations
   * @returns {Object}
   * @example
   * // get animations map
   * var animations = sprite.animations();
   *
   * // set animations map
   * sprite.animations({
   *   standing: [
   *     // x, y, width, height (6 frames)
   *     0, 0, 49, 109,
   *     52, 0, 49, 109,
   *     105, 0, 49, 109,
   *     158, 0, 49, 109,
   *     210, 0, 49, 109,
   *     262, 0, 49, 109
   *   ],
   *   kicking: [
   *     // x, y, width, height (6 frames)
   *     0, 109, 45, 98,
   *     45, 109, 45, 98,
   *     95, 109, 63, 98,
   *     156, 109, 70, 98,
   *     229, 109, 60, 98,
   *     287, 109, 41, 98
   *   ]
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'frameOffsets');

  /**
   * get/set offsets map
   * @name offsets
   * @method
   * @memberof Konva.Sprite.prototype
   * @param {Object} offsets
   * @returns {Object}
   * @example
   * // get offsets map
   * var offsets = sprite.offsets();
   *
   * // set offsets map
   * sprite.offsets({
   *   standing: [
   *     // x, y (6 frames)
   *     0, 0,
   *     0, 0,
   *     5, 0,
   *     0, 0,
   *     0, 3,
   *     2, 0
   *   ],
   *   kicking: [
   *     // x, y (6 frames)
   *     0, 5,
   *     5, 0,
   *     10, 0,
   *     0, 0,
   *     2, 1,
   *     0, 0
   *   ]
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'image');

  /**
   * get/set image
   * @name image
   * @method
   * @memberof Konva.Sprite.prototype
   * @param {Image} image
   * @returns {Image}
   * @example
   * // get image
   * var image = sprite.image();
   *
   * // set image
   * sprite.image(imageObj);
   */

  Konva.Factory.addGetterSetter(
    Konva.Sprite,
    'frameIndex',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set/set animation frame index
   * @name frameIndex
   * @method
   * @memberof Konva.Sprite.prototype
   * @param {Integer} frameIndex
   * @returns {Integer}
   * @example
   * // get animation frame index
   * var frameIndex = sprite.frameIndex();
   *
   * // set animation frame index
   * sprite.frameIndex(3);
   */

  Konva.Factory.addGetterSetter(
    Konva.Sprite,
    'frameRate',
    17,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set frame rate in frames per second.  Increase this number to make the sprite
   *  animation run faster, and decrease the number to make the sprite animation run slower
   *  The default is 17 frames per second
   * @name frameRate
   * @method
   * @memberof Konva.Sprite.prototype
   * @param {Integer} frameRate
   * @returns {Integer}
   * @example
   * // get frame rate
   * var frameRate = sprite.frameRate();
   *
   * // set frame rate to 2 frames per second
   * sprite.frameRate(2);
   */

  Konva.Factory.backCompat(Konva.Sprite, {
    index: 'frameIndex',
    getIndex: 'getFrameIndex',
    setIndex: 'setFrameIndex'
  });

  Konva.Collection.mapMethods(Konva.Sprite);
})();

/*eslint-disable  no-shadow, max-len, max-depth */
(function() {
  'use strict';
  /**
   * Path constructor.
   * @author Jason Follas
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {String} config.data SVG data string
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var path = new Konva.Path({
   *   x: 240,
   *   y: 40,
   *   data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',
   *   fill: 'green',
   *   scale: 2
   * });
   */
  Konva.Path = function(config) {
    this.___init(config);
  };

  Konva.Path.prototype = {
    ___init: function(config) {
      this.dataArray = [];
      var that = this;

      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Path';

      this.dataArray = Konva.Path.parsePathData(this.getData());
      this.pathLength = 0;
      for (var i = 0; i < this.dataArray.length; ++i) {
        this.pathLength += this.dataArray[i].pathLength;
      }
      this.on('dataChange.konva', function() {
        that.dataArray = Konva.Path.parsePathData(this.getData());
        this.pathLength = 0;
        for (var i = 0; i < this.dataArray.length; ++i) {
          this.pathLength += this.dataArray[i].pathLength;
        }
      });

      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var ca = this.dataArray;

      // context position
      context.beginPath();
      for (var n = 0; n < ca.length; n++) {
        var c = ca[n].command;
        var p = ca[n].points;
        switch (c) {
          case 'L':
            context.lineTo(p[0], p[1]);
            break;
          case 'M':
            context.moveTo(p[0], p[1]);
            break;
          case 'C':
            context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
            break;
          case 'Q':
            context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
            break;
          case 'A':
            var cx = p[0],
              cy = p[1],
              rx = p[2],
              ry = p[3],
              theta = p[4],
              dTheta = p[5],
              psi = p[6],
              fs = p[7];

            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;

            context.translate(cx, cy);
            context.rotate(psi);
            context.scale(scaleX, scaleY);
            context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
            context.scale(1 / scaleX, 1 / scaleY);
            context.rotate(-psi);
            context.translate(-cx, -cy);

            break;
          case 'z':
            context.closePath();
            break;
        }
      }

      context.fillStrokeShape(this);
    },
    getSelfRect: function() {
      var points = [];
      this.dataArray.forEach(function(data) {
        points = points.concat(data.points);
      });
      var minX = points[0];
      var maxX = points[0];
      var minY = points[1];
      var maxY = points[1];
      var x, y;
      for (var i = 0; i < points.length / 2; i++) {
        x = points[i * 2];
        y = points[i * 2 + 1];

        // skip bad values
        // TODO: prevent them from parsing function
        if (!isNaN(x)) {
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
        }
        if (!isNaN(y)) {
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }
      }
      return {
        x: Math.round(minX),
        y: Math.round(minY),
        width: Math.round(maxX - minX),
        height: Math.round(maxY - minY)
      };
    },
    /**
     * Return length of the path.
     * @method
     * @memberof Konva.Path.prototype
     * @returns {Number} length
     * @example
     * var length = path.getLength();
     */
    getLength: function() {
      return this.pathLength;
    },
    /**
     * Get point on path at specific length of the path
     * @method
     * @memberof Konva.Path.prototype
     * @param {Number} length length
     * @returns {Object} point {x,y} point
     * @example
     * var point = path.getPointAtLength(10);
     */
    getPointAtLength: function(length) {
      var point,
        i = 0,
        ii = this.dataArray.length;

      if (!ii) {
        return null;
      }

      while (i < ii && length > this.dataArray[i].pathLength) {
        length -= this.dataArray[i].pathLength;
        ++i;
      }

      if (i === ii) {
        point = this.dataArray[i - 1].points.slice(-2);
        return {
          x: point[0],
          y: point[1]
        };
      }

      if (length < 0.01) {
        point = this.dataArray[i].points.slice(0, 2);
        return {
          x: point[0],
          y: point[1]
        };
      }

      var cp = this.dataArray[i];
      var p = cp.points;
      switch (cp.command) {
        case 'L':
          return Konva.Path.getPointOnLine(
            length,
            cp.start.x,
            cp.start.y,
            p[0],
            p[1]
          );
        case 'C':
          return Konva.Path.getPointOnCubicBezier(
            length / cp.pathLength,
            cp.start.x,
            cp.start.y,
            p[0],
            p[1],
            p[2],
            p[3],
            p[4],
            p[5]
          );
        case 'Q':
          return Konva.Path.getPointOnQuadraticBezier(
            length / cp.pathLength,
            cp.start.x,
            cp.start.y,
            p[0],
            p[1],
            p[2],
            p[3]
          );
        case 'A':
          var cx = p[0],
            cy = p[1],
            rx = p[2],
            ry = p[3],
            theta = p[4],
            dTheta = p[5],
            psi = p[6];
          theta += dTheta * length / cp.pathLength;
          return Konva.Path.getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi);
      }

      return null;
    }
  };
  Konva.Util.extend(Konva.Path, Konva.Shape);

  Konva.Path.getLineLength = function(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  };
  Konva.Path.getPointOnLine = function(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
    if (fromX === undefined) {
      fromX = P1x;
    }
    if (fromY === undefined) {
      fromY = P1y;
    }

    var m = (P2y - P1y) / (P2x - P1x + 0.00000001);
    var run = Math.sqrt(dist * dist / (1 + m * m));
    if (P2x < P1x) {
      run *= -1;
    }
    var rise = m * run;
    var pt;

    if (P2x === P1x) {
      // vertical line
      pt = {
        x: fromX,
        y: fromY + rise
      };
    } else if ((fromY - P1y) / (fromX - P1x + 0.00000001) === m) {
      pt = {
        x: fromX + run,
        y: fromY + rise
      };
    } else {
      var ix, iy;

      var len = this.getLineLength(P1x, P1y, P2x, P2y);
      if (len < 0.00000001) {
        return undefined;
      }
      var u = (fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y);
      u = u / (len * len);
      ix = P1x + u * (P2x - P1x);
      iy = P1y + u * (P2y - P1y);

      var pRise = this.getLineLength(fromX, fromY, ix, iy);
      var pRun = Math.sqrt(dist * dist - pRise * pRise);
      run = Math.sqrt(pRun * pRun / (1 + m * m));
      if (P2x < P1x) {
        run *= -1;
      }
      rise = m * run;
      pt = {
        x: ix + run,
        y: iy + rise
      };
    }

    return pt;
  };

  Konva.Path.getPointOnCubicBezier = function(
    pct,
    P1x,
    P1y,
    P2x,
    P2y,
    P3x,
    P3y,
    P4x,
    P4y
  ) {
    function CB1(t) {
      return t * t * t;
    }
    function CB2(t) {
      return 3 * t * t * (1 - t);
    }
    function CB3(t) {
      return 3 * t * (1 - t) * (1 - t);
    }
    function CB4(t) {
      return (1 - t) * (1 - t) * (1 - t);
    }
    var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
    var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);

    return {
      x: x,
      y: y
    };
  };
  Konva.Path.getPointOnQuadraticBezier = function(
    pct,
    P1x,
    P1y,
    P2x,
    P2y,
    P3x,
    P3y
  ) {
    function QB1(t) {
      return t * t;
    }
    function QB2(t) {
      return 2 * t * (1 - t);
    }
    function QB3(t) {
      return (1 - t) * (1 - t);
    }
    var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
    var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);

    return {
      x: x,
      y: y
    };
  };
  Konva.Path.getPointOnEllipticalArc = function(cx, cy, rx, ry, theta, psi) {
    var cosPsi = Math.cos(psi),
      sinPsi = Math.sin(psi);
    var pt = {
      x: rx * Math.cos(theta),
      y: ry * Math.sin(theta)
    };
    return {
      x: cx + (pt.x * cosPsi - pt.y * sinPsi),
      y: cy + (pt.x * sinPsi + pt.y * cosPsi)
    };
  };
  /*
     * get parsed data array from the data
     *  string.  V, v, H, h, and l data are converted to
     *  L data for the purpose of high performance Path
     *  rendering
     */
  Konva.Path.parsePathData = function(data) {
    // Path Data Segment must begin with a moveTo
    //m (x y)+  Relative moveTo (subsequent points are treated as lineTo)
    //M (x y)+  Absolute moveTo (subsequent points are treated as lineTo)
    //l (x y)+  Relative lineTo
    //L (x y)+  Absolute LineTo
    //h (x)+    Relative horizontal lineTo
    //H (x)+    Absolute horizontal lineTo
    //v (y)+    Relative vertical lineTo
    //V (y)+    Absolute vertical lineTo
    //z (closepath)
    //Z (closepath)
    //c (x1 y1 x2 y2 x y)+ Relative Bezier curve
    //C (x1 y1 x2 y2 x y)+ Absolute Bezier curve
    //q (x1 y1 x y)+       Relative Quadratic Bezier
    //Q (x1 y1 x y)+       Absolute Quadratic Bezier
    //t (x y)+    Shorthand/Smooth Relative Quadratic Bezier
    //T (x y)+    Shorthand/Smooth Absolute Quadratic Bezier
    //s (x2 y2 x y)+       Shorthand/Smooth Relative Bezier curve
    //S (x2 y2 x y)+       Shorthand/Smooth Absolute Bezier curve
    //a (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+     Relative Elliptical Arc
    //A (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+  Absolute Elliptical Arc

    // return early if data is not defined
    if (!data) {
      return [];
    }

    // command string
    var cs = data;

    // command chars
    var cc = [
      'm',
      'M',
      'l',
      'L',
      'v',
      'V',
      'h',
      'H',
      'z',
      'Z',
      'c',
      'C',
      'q',
      'Q',
      't',
      'T',
      's',
      'S',
      'a',
      'A'
    ];
    // convert white spaces to commas
    cs = cs.replace(new RegExp(' ', 'g'), ',');
    // create pipes so that we can split the data
    for (var n = 0; n < cc.length; n++) {
      cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
    }
    // create array
    var arr = cs.split('|');
    var ca = [];
    var coords = [];
    // init context point
    var cpx = 0;
    var cpy = 0;

    var re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
    var match;
    for (n = 1; n < arr.length; n++) {
      var str = arr[n];
      var c = str.charAt(0);
      str = str.slice(1);

      coords.length = 0;
      while ((match = re.exec(str))) {
        coords.push(match[0]);
      }

      // while ((match = re.exec(str))) {
      //   coords.push(match[0]);
      // }
      var p = [];

      for (var j = 0, jlen = coords.length; j < jlen; j++) {
        var parsed = parseFloat(coords[j]);
        if (!isNaN(parsed)) {
          p.push(parsed);
        } else {
          p.push(0);
        }
      }

      while (p.length > 0) {
        if (isNaN(p[0])) {
          // case for a trailing comma before next command
          break;
        }

        var cmd = null;
        var points = [];
        var startX = cpx,
          startY = cpy;
        // Move var from within the switch to up here (jshint)
        var prevCmd, ctlPtx, ctlPty; // Ss, Tt
        var rx, ry, psi, fa, fs, x1, y1; // Aa

        // convert l, H, h, V, and v to L
        switch (c) {
          // Note: Keep the lineTo's above the moveTo's in this switch
          case 'l':
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'L':
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          // Note: lineTo handlers need to be above this point
          case 'm':
            var dx = p.shift();
            var dy = p.shift();
            cpx += dx;
            cpy += dy;
            cmd = 'M';
            // After closing the path move the current position
            // to the the first point of the path (if any).
            if (ca.length > 2 && ca[ca.length - 1].command === 'z') {
              for (var idx = ca.length - 2; idx >= 0; idx--) {
                if (ca[idx].command === 'M') {
                  cpx = ca[idx].points[0] + dx;
                  cpy = ca[idx].points[1] + dy;
                  break;
                }
              }
            }
            points.push(cpx, cpy);
            c = 'l';
            // subsequent points are treated as relative lineTo
            break;
          case 'M':
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'M';
            points.push(cpx, cpy);
            c = 'L';
            // subsequent points are treated as absolute lineTo
            break;

          case 'h':
            cpx += p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'H':
            cpx = p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'v':
            cpy += p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'V':
            cpy = p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'C':
            points.push(p.shift(), p.shift(), p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          case 'c':
            points.push(
              cpx + p.shift(),
              cpy + p.shift(),
              cpx + p.shift(),
              cpy + p.shift()
            );
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'C';
            points.push(cpx, cpy);
            break;
          case 'S':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'C') {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'C';
            points.push(cpx, cpy);
            break;
          case 's':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'C') {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'C';
            points.push(cpx, cpy);
            break;
          case 'Q':
            points.push(p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          case 'q':
            points.push(cpx + p.shift(), cpy + p.shift());
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'Q';
            points.push(cpx, cpy);
            break;
          case 'T':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'Q') {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'Q';
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case 't':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'Q') {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'Q';
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case 'A':
            rx = p.shift();
            ry = p.shift();
            psi = p.shift();
            fa = p.shift();
            fs = p.shift();
            x1 = cpx;
            y1 = cpy;
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'A';
            points = this.convertEndpointToCenterParameterization(
              x1,
              y1,
              cpx,
              cpy,
              fa,
              fs,
              rx,
              ry,
              psi
            );
            break;
          case 'a':
            rx = p.shift();
            ry = p.shift();
            psi = p.shift();
            fa = p.shift();
            fs = p.shift();
            x1 = cpx;
            y1 = cpy;
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'A';
            points = this.convertEndpointToCenterParameterization(
              x1,
              y1,
              cpx,
              cpy,
              fa,
              fs,
              rx,
              ry,
              psi
            );
            break;
        }

        ca.push({
          command: cmd || c,
          points: points,
          start: {
            x: startX,
            y: startY
          },
          pathLength: this.calcLength(startX, startY, cmd || c, points)
        });
      }

      if (c === 'z' || c === 'Z') {
        ca.push({
          command: 'z',
          points: [],
          start: undefined,
          pathLength: 0
        });
      }
    }

    return ca;
  };
  Konva.Path.calcLength = function(x, y, cmd, points) {
    var len, p1, p2, t;
    var path = Konva.Path;

    switch (cmd) {
      case 'L':
        return path.getLineLength(x, y, points[0], points[1]);
      case 'C':
        // Approximates by breaking curve into 100 line segments
        len = 0.0;
        p1 = path.getPointOnCubicBezier(
          0,
          x,
          y,
          points[0],
          points[1],
          points[2],
          points[3],
          points[4],
          points[5]
        );
        for (t = 0.01; t <= 1; t += 0.01) {
          p2 = path.getPointOnCubicBezier(
            t,
            x,
            y,
            points[0],
            points[1],
            points[2],
            points[3],
            points[4],
            points[5]
          );
          len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }
        return len;
      case 'Q':
        // Approximates by breaking curve into 100 line segments
        len = 0.0;
        p1 = path.getPointOnQuadraticBezier(
          0,
          x,
          y,
          points[0],
          points[1],
          points[2],
          points[3]
        );
        for (t = 0.01; t <= 1; t += 0.01) {
          p2 = path.getPointOnQuadraticBezier(
            t,
            x,
            y,
            points[0],
            points[1],
            points[2],
            points[3]
          );
          len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }
        return len;
      case 'A':
        // Approximates by breaking curve into line segments
        len = 0.0;
        var start = points[4];
        // 4 = theta
        var dTheta = points[5];
        // 5 = dTheta
        var end = points[4] + dTheta;
        var inc = Math.PI / 180.0;
        // 1 degree resolution
        if (Math.abs(start - end) < inc) {
          inc = Math.abs(start - end);
        }
        // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi
        p1 = path.getPointOnEllipticalArc(
          points[0],
          points[1],
          points[2],
          points[3],
          start,
          0
        );
        if (dTheta < 0) {
          // clockwise
          for (t = start - inc; t > end; t -= inc) {
            p2 = path.getPointOnEllipticalArc(
              points[0],
              points[1],
              points[2],
              points[3],
              t,
              0
            );
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        } else {
          // counter-clockwise
          for (t = start + inc; t < end; t += inc) {
            p2 = path.getPointOnEllipticalArc(
              points[0],
              points[1],
              points[2],
              points[3],
              t,
              0
            );
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        }
        p2 = path.getPointOnEllipticalArc(
          points[0],
          points[1],
          points[2],
          points[3],
          end,
          0
        );
        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);

        return len;
    }

    return 0;
  };
  Konva.Path.convertEndpointToCenterParameterization = function(
    x1,
    y1,
    x2,
    y2,
    fa,
    fs,
    rx,
    ry,
    psiDeg
  ) {
    // Derived from: http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
    var psi = psiDeg * (Math.PI / 180.0);
    var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
    var yp =
      -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;

    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }

    var f = Math.sqrt(
      (rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) /
        (rx * rx * (yp * yp) + ry * ry * (xp * xp))
    );

    if (fa === fs) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }

    var cxp = f * rx * yp / ry;
    var cyp = f * -ry * xp / rx;

    var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
    var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;

    var vMag = function(v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };
    var vRatio = function(u, v) {
      return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
    };
    var vAngle = function(u, v) {
      return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
    };
    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var dTheta = vAngle(u, v);

    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (fs === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * Math.PI;
    }
    if (fs === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * Math.PI;
    }
    return [cx, cy, rx, ry, theta, dTheta, psi, fs];
  };
  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Path, 'data');

  /**
   * set SVG path data string.  This method
   *  also automatically parses the data string
   *  into a data array.  Currently supported SVG data:
   *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z
   * @name setData
   * @method
   * @memberof Konva.Path.prototype
   * @param {String} SVG path command string
   */

  /**
   * get SVG path data string
   * @name getData
   * @method
   * @memberof Konva.Path.prototype
   */

  Konva.Collection.mapMethods(Konva.Path);
})();

(function() {
  'use strict';
  var EMPTY_STRING = '',
    //CALIBRI = 'Calibri',
    NORMAL = 'normal';

  /**
   * Path constructor.
   * @author Jason Follas
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {String} [config.fontFamily] default is Calibri
   * @param {Number} [config.fontSize] default is 12
   * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
   * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
   * @param {String} config.text
   * @param {String} config.data SVG data string
   * @param {Function} config.getKerning a getter for kerning values for the specified characters
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var kerningPairs = {
   *   'A': {
   *     ' ': -0.05517578125,
   *     'T': -0.07421875,
   *     'V': -0.07421875,
   *   },
   *   'V': {
   *     ',': -0.091796875,
   *     ":": -0.037109375,
   *     ";": -0.037109375,
   *     "A": -0.07421875,
   *   }
   * }
   * var textpath = new Konva.TextPath({
   *   x: 100,
   *   y: 50,
   *   fill: '#333',
   *   fontSize: '24',
   *   fontFamily: 'Arial',
   *   text: 'All the world\'s a stage, and all the men and women merely players.',
   *   data: 'M10,10 C0,0 10,150 100,100 S300,150 400,50',
   *   getKerning: function(leftChar, rightChar) {
   *     return kerningPairs.hasOwnProperty(leftChar) ? pairs[leftChar][rightChar] || 0 : 0
   *   }
   * });
   */
  Konva.TextPath = function(config) {
    this.___init(config);
  };

  function _fillFunc(context) {
    context.fillText(this.partialText, 0, 0);
  }
  function _strokeFunc(context) {
    context.strokeText(this.partialText, 0, 0);
  }

  Konva.TextPath.prototype = {
    ___init: function(config) {
      var that = this;
      this.dummyCanvas = Konva.Util.createCanvasElement();
      this.dataArray = [];
      this.getKerning = config && config.getKerning;

      // call super constructor
      Konva.Shape.call(this, config);

      // overrides
      // TODO: shouldn't this be on the prototype?
      this._fillFunc = _fillFunc;
      this._strokeFunc = _strokeFunc;
      this._fillFuncHit = _fillFunc;
      this._strokeFuncHit = _strokeFunc;

      this.className = 'TextPath';

      this.dataArray = Konva.Path.parsePathData(this.attrs.data);
      this.on('dataChange.konva', function() {
        that.dataArray = Konva.Path.parsePathData(this.attrs.data);
        that._setTextData();
      });

      // update text data for certain attr changes
      this.on(
        'textChange.konva alignChange.konva letterSpacingChange.konva',
        that._setTextData
      );
      that._setTextData();
      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _sceneFunc: function(context) {
      context.setAttr('font', this._getContextFont());
      context.setAttr('textBaseline', this.getTextBaseline());
      context.setAttr('textAlign', 'left');
      context.save();

      var textDecoration = this.textDecoration();
      var fill = this.fill();
      var fontSize = this.fontSize();

      var glyphInfo = this.glyphInfo;
      if (textDecoration === 'underline') {
        context.beginPath();
      }
      for (var i = 0; i < glyphInfo.length; i++) {
        context.save();

        var p0 = glyphInfo[i].p0;

        context.translate(p0.x, p0.y);
        context.rotate(glyphInfo[i].rotation);
        this.partialText = glyphInfo[i].text;

        context.fillStrokeShape(this);
        if (textDecoration === 'underline') {
          if (i === 0) {
            context.moveTo(0, fontSize / 2 + 1);
          }

          context.lineTo(fontSize, fontSize / 2 + 1);
        }
        context.restore();

        //// To assist with debugging visually, uncomment following
        //
        // if (i % 2)
        // context.strokeStyle = 'cyan';
        // else
        // context.strokeStyle = 'green';
        // var p1 = glyphInfo[i].p1;
        // context.moveTo(p0.x, p0.y);
        // context.lineTo(p1.x, p1.y);
        // context.stroke();
      }
      if (textDecoration === 'underline') {
        context.strokeStyle = fill;
        context.lineWidth = fontSize / 20;
        context.stroke();
      }

      context.restore();
    },
    _hitFunc: function(context) {
      context.beginPath();

      var glyphInfo = this.glyphInfo;
      if (glyphInfo.length >= 1) {
        var p0 = glyphInfo[0].p0;
        context.moveTo(p0.x, p0.y);
      }
      for (var i = 0; i < glyphInfo.length; i++) {
        var p1 = glyphInfo[i].p1;
        context.lineTo(p1.x, p1.y);
      }
      context.setAttr('lineWidth', this.getFontSize());
      context.setAttr('strokeStyle', this.colorKey);
      context.stroke();
    },
    /**
     * get text width in pixels
     * @method
     * @memberof Konva.TextPath.prototype
     */
    getTextWidth: function() {
      return this.textWidth;
    },
    /**
     * get text height in pixels
     * @method
     * @memberof Konva.TextPath.prototype
     */
    getTextHeight: function() {
      return this.textHeight;
    },
    /**
     * set text
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} text
     */
    setText: function(text) {
      Konva.Text.prototype.setText.call(this, text);
    },
    _getTextSize: function(text) {
      var dummyCanvas = this.dummyCanvas;
      var _context = dummyCanvas.getContext('2d');

      _context.save();

      _context.font = this._getContextFont();
      var metrics = _context.measureText(text);

      _context.restore();

      return {
        width: metrics.width,
        height: parseInt(this.attrs.fontSize, 10)
      };
    },
    _setTextData: function() {
      var that = this;
      var size = this._getTextSize(this.attrs.text);
      var letterSpacing = this.getLetterSpacing();
      var align = this.align();

      this.textWidth = size.width;
      this.textHeight = size.height;

      var textFullWidth = Math.max(
        this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing,
        0
      );

      this.glyphInfo = [];

      var fullPathWidth = 0;
      for (var l = 0; l < that.dataArray.length; l++) {
        if (that.dataArray[l].pathLength > 0) {
          fullPathWidth += that.dataArray[l].pathLength;
        }
      }

      var offset = 0;
      if (align === 'center') {
        offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);
      }
      if (align === 'right') {
        offset = Math.max(0, fullPathWidth - textFullWidth);
      }

      var charArr = this.getText().split('');
      var spacesNumber = this.getText().split(' ').length - 1;

      var p0, p1, pathCmd;

      var pIndex = -1;
      var currentT = 0;
      // var sumLength = 0;
      // for(var j = 0; j < that.dataArray.length; j++) {
      //   if(that.dataArray[j].pathLength > 0) {
      //
      //     if (sumLength + that.dataArray[j].pathLength > offset) {}
      //       fullPathWidth += that.dataArray[j].pathLength;
      //   }
      // }

      var getNextPathSegment = function() {
        currentT = 0;
        var pathData = that.dataArray;

        for (var j = pIndex + 1; j < pathData.length; j++) {
          if (pathData[j].pathLength > 0) {
            pIndex = j;

            return pathData[j];
          } else if (pathData[j].command === 'M') {
            p0 = {
              x: pathData[j].points[0],
              y: pathData[j].points[1]
            };
          }
        }

        return {};
      };

      var findSegmentToFitCharacter = function(c) {
        var glyphWidth = that._getTextSize(c).width + letterSpacing;

        if (c === ' ' && align === 'justify') {
          glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
        }

        var currLen = 0;
        var attempts = 0;

        p1 = undefined;
        while (
          Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&
          attempts < 25
        ) {
          attempts++;
          var cumulativePathLength = currLen;
          while (pathCmd === undefined) {
            pathCmd = getNextPathSegment();

            if (
              pathCmd &&
              cumulativePathLength + pathCmd.pathLength < glyphWidth
            ) {
              cumulativePathLength += pathCmd.pathLength;
              pathCmd = undefined;
            }
          }

          if (pathCmd === {} || p0 === undefined) {
            return undefined;
          }

          var needNewSegment = false;

          switch (pathCmd.command) {
            case 'L':
              if (
                Konva.Path.getLineLength(
                  p0.x,
                  p0.y,
                  pathCmd.points[0],
                  pathCmd.points[1]
                ) > glyphWidth
              ) {
                p1 = Konva.Path.getPointOnLine(
                  glyphWidth,
                  p0.x,
                  p0.y,
                  pathCmd.points[0],
                  pathCmd.points[1],
                  p0.x,
                  p0.y
                );
              } else {
                pathCmd = undefined;
              }
              break;
            case 'A':
              var start = pathCmd.points[4];
              // 4 = theta
              var dTheta = pathCmd.points[5];
              // 5 = dTheta
              var end = pathCmd.points[4] + dTheta;

              if (currentT === 0) {
                currentT = start + 0.00000001;
              } else if (glyphWidth > currLen) {
                // Just in case start is 0
                currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);
              } else {
                currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);
              }

              // Credit for bug fix: @therth https://github.com/ericdrowell/KonvaJS/issues/249
              // Old code failed to render text along arc of this path: "M 50 50 a 150 50 0 0 1 250 50 l 50 0"
              if (
                (dTheta < 0 && currentT < end) ||
                (dTheta >= 0 && currentT > end)
              ) {
                currentT = end;
                needNewSegment = true;
              }
              p1 = Konva.Path.getPointOnEllipticalArc(
                pathCmd.points[0],
                pathCmd.points[1],
                pathCmd.points[2],
                pathCmd.points[3],
                currentT,
                pathCmd.points[6]
              );
              break;
            case 'C':
              if (currentT === 0) {
                if (glyphWidth > pathCmd.pathLength) {
                  currentT = 0.00000001;
                } else {
                  currentT = glyphWidth / pathCmd.pathLength;
                }
              } else if (glyphWidth > currLen) {
                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
              } else {
                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
              }

              if (currentT > 1.0) {
                currentT = 1.0;
                needNewSegment = true;
              }
              p1 = Konva.Path.getPointOnCubicBezier(
                currentT,
                pathCmd.start.x,
                pathCmd.start.y,
                pathCmd.points[0],
                pathCmd.points[1],
                pathCmd.points[2],
                pathCmd.points[3],
                pathCmd.points[4],
                pathCmd.points[5]
              );
              break;
            case 'Q':
              if (currentT === 0) {
                currentT = glyphWidth / pathCmd.pathLength;
              } else if (glyphWidth > currLen) {
                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
              } else {
                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
              }

              if (currentT > 1.0) {
                currentT = 1.0;
                needNewSegment = true;
              }
              p1 = Konva.Path.getPointOnQuadraticBezier(
                currentT,
                pathCmd.start.x,
                pathCmd.start.y,
                pathCmd.points[0],
                pathCmd.points[1],
                pathCmd.points[2],
                pathCmd.points[3]
              );
              break;
          }

          if (p1 !== undefined) {
            currLen = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
          }

          if (needNewSegment) {
            needNewSegment = false;
            pathCmd = undefined;
          }
        }
      };

      // fake search for offset, this is very bad approach
      // TODO: find other way to add offset from start (for align)
      var testChar = 'C';
      var glyphWidth = that._getTextSize(testChar).width + letterSpacing;
      for (var k = 0; k < offset / glyphWidth; k++) {
        findSegmentToFitCharacter(testChar);
        if (p0 === undefined || p1 === undefined) {
          break;
        }
        p0 = p1;
      }

      for (var i = 0; i < charArr.length; i++) {
        // Find p1 such that line segment between p0 and p1 is approx. width of glyph
        findSegmentToFitCharacter(charArr[i]);

        if (p0 === undefined || p1 === undefined) {
          break;
        }

        var width = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);

        var kern = 0;
        if (this.getKerning) {
          try {
            // getKerning is a user provided getter. Make sure it never breaks our logic
            kern =
              this.getKerning(charArr[i - 1], charArr[i]) * this.fontSize();
          } catch (e) {
            kern = 0;
          }
        }

        p0.x += kern;
        p1.x += kern;
        this.textWidth += kern;

        var midpoint = Konva.Path.getPointOnLine(
          kern + width / 2.0,
          p0.x,
          p0.y,
          p1.x,
          p1.y
        );

        var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);
        this.glyphInfo.push({
          transposeX: midpoint.x,
          transposeY: midpoint.y,
          text: charArr[i],
          rotation: rotation,
          p0: p0,
          p1: p1
        });
        p0 = p1;
      }
    },
    getSelfRect: function() {
      var points = [];

      this.glyphInfo.forEach(function(info) {
        points.push(info.p0.x);
        points.push(info.p0.y);
        points.push(info.p1.x);
        points.push(info.p1.y);
      });
      var minX = points[0];
      var maxX = points[0];
      var minY = points[0];
      var maxY = points[0];
      var x, y;
      for (var i = 0; i < points.length / 2; i++) {
        x = points[i * 2];
        y = points[i * 2 + 1];
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
      var fontSize = this.fontSize();
      return {
        x: Math.round(minX) - fontSize / 2,
        y: Math.round(minY) - fontSize / 2,
        width: Math.round(maxX - minX) + fontSize,
        height: Math.round(maxY - minY) + fontSize
      };
    }
  };

  // map TextPath methods to Text
  Konva.TextPath.prototype._getContextFont =
    Konva.Text.prototype._getContextFont;

  Konva.Util.extend(Konva.TextPath, Konva.Shape);

  // add setters and getters
  Konva.Factory.addGetterSetter(Konva.TextPath, 'data');

  /**
   * set SVG path data string.  This method
   *  also automatically parses the data string
   *  into a data array.  Currently supported SVG data:
   *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z
   * @name setData
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {String} SVG path command string
   */

  /**
   * get SVG path data string
   * @name getData
   * @method
   * @memberof Konva.TextPath.prototype
   */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'fontFamily', 'Arial');

  /**
   * set font family
   * @name setFontFamily
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {String} fontFamily
   */

  /**
   * get font family
   * @name getFontFamily
   * @method
   * @memberof Konva.TextPath.prototype
   */

  Konva.Factory.addGetterSetter(
    Konva.TextPath,
    'fontSize',
    12,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set font size
   * @name setFontSize
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {int} fontSize
   */

  /**
   * get font size
   * @name getFontSize
   * @method
   * @memberof Konva.TextPath.prototype
   */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'fontStyle', NORMAL);

  /**
   * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
   * @name setFontStyle
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {String} fontStyle
   */
  Konva.Factory.addGetterSetter(Konva.TextPath, 'align', 'left');

  /**
   * get/set horizontal align of text.  Can be 'left', 'center', 'right' or 'justify'
   * @name align
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} align
   * @returns {String}
   * @example
   * // get text align
   * var align = text.align();
   *
   * // center text
   * text.align('center');
   *
   * // align text to right
   * text.align('right');
   */

  Konva.Factory.addGetterSetter(
    Konva.TextPath,
    'letterSpacing',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set letter spacing property. Default value is 0.
   * @name letterSpacing
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {Number} letterSpacing
   */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'textBaseline', 'middle');

  /**
   * set textBaseline property. Default value is 'middle'.
   * Can be 'top', 'bottom', 'middle', 'alphabetic', 'hanging'
   * @name textBaseline
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {Number} textBaseline
   */

  /**
   * get font style
   * @name getFontStyle
   * @method
   * @memberof Konva.TextPath.prototype
   */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'fontVariant', NORMAL);

  /**
   * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
   * @name setFontVariant
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {String} fontVariant
   */

  /**
   * @get font variant
   * @name getFontVariant
   * @method
   * @memberof Konva.TextPath.prototype
   */

  Konva.Factory.addGetter(Konva.TextPath, 'text', EMPTY_STRING);

  /**
   * get text
   * @name getText
   * @method
   * @memberof Konva.TextPath.prototype
   */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'textDecoration', null);

  /**
   * get/set text decoration of a text.  Can be '' or 'underline'
   * @name textDecoration
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} textDecoration
   * @returns {String}
   * @example
   * // get text decoration
   * var textDecoration = text.textDecoration();
   *
   * // center text
   * text.textDecoration('underline');
   */

  Konva.Collection.mapMethods(Konva.TextPath);
})();

(function() {
  'use strict';
  /**
   * RegularPolygon constructor.&nbsp; Examples include triangles, squares, pentagons, hexagons, etc.
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Number} config.sides
   * @param {Number} config.radius
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var hexagon = new Konva.RegularPolygon({
   *   x: 100,
   *   y: 200,
   *   sides: 6,
   *   radius: 70,
   *   fill: 'red',
   *   stroke: 'black',
   *   strokeWidth: 4
   * });
   */
  Konva.RegularPolygon = function(config) {
    this.___init(config);
  };

  Konva.RegularPolygon.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'RegularPolygon';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var sides = this.attrs.sides,
        radius = this.attrs.radius,
        n,
        x,
        y;

      context.beginPath();
      context.moveTo(0, 0 - radius);

      for (n = 1; n < sides; n++) {
        x = radius * Math.sin(n * 2 * Math.PI / sides);
        y = -1 * radius * Math.cos(n * 2 * Math.PI / sides);
        context.lineTo(x, y);
      }
      context.closePath();
      context.fillStrokeShape(this);
    },
    getWidth: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.radius() !== width / 2) {
        this.setRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.radius() !== height / 2) {
        this.setRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.RegularPolygon, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(
    Konva.RegularPolygon,
    'radius',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set radius
   * @name setRadius
   * @method
   * @memberof Konva.RegularPolygon.prototype
   * @param {Number} radius
   */

  /**
   * get radius
   * @name getRadius
   * @method
   * @memberof Konva.RegularPolygon.prototype
   */

  Konva.Factory.addGetterSetter(
    Konva.RegularPolygon,
    'sides',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set number of sides
   * @name setSides
   * @method
   * @memberof Konva.RegularPolygon.prototype
   * @param {int} sides
   */

  /**
   * get number of sides
   * @name getSides
   * @method
   * @memberof Konva.RegularPolygon.prototype
   */

  Konva.Collection.mapMethods(Konva.RegularPolygon);
})();

(function() {
  'use strict';
  /**
   * Star constructor
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Integer} config.numPoints
   * @param {Number} config.innerRadius
   * @param {Number} config.outerRadius
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var star = new Konva.Star({
   *   x: 100,
   *   y: 200,
   *   numPoints: 5,
   *   innerRadius: 70,
   *   outerRadius: 70,
   *   fill: 'red',
   *   stroke: 'black',
   *   strokeWidth: 4
   * });
   */
  Konva.Star = function(config) {
    this.___init(config);
  };

  Konva.Star.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Star';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var innerRadius = this.innerRadius(),
        outerRadius = this.outerRadius(),
        numPoints = this.numPoints();

      context.beginPath();
      context.moveTo(0, 0 - outerRadius);

      for (var n = 1; n < numPoints * 2; n++) {
        var radius = n % 2 === 0 ? outerRadius : innerRadius;
        var x = radius * Math.sin(n * Math.PI / numPoints);
        var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
        context.lineTo(x, y);
      }
      context.closePath();

      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.outerRadius() !== width / 2) {
        this.setOuterRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.outerRadius() !== height / 2) {
        this.setOuterRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Star, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(
    Konva.Star,
    'numPoints',
    5,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set number of points
   * @name setNumPoints
   * @method
   * @memberof Konva.Star.prototype
   * @param {Integer} points
   */

  /**
   * get number of points
   * @name getNumPoints
   * @method
   * @memberof Konva.Star.prototype
   */

  Konva.Factory.addGetterSetter(
    Konva.Star,
    'innerRadius',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set inner radius
   * @name setInnerRadius
   * @method
   * @memberof Konva.Star.prototype
   * @param {Number} radius
   */

  /**
   * get inner radius
   * @name getInnerRadius
   * @method
   * @memberof Konva.Star.prototype
   */

  Konva.Factory.addGetterSetter(
    Konva.Star,
    'outerRadius',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set outer radius
   * @name setOuterRadius
   * @method
   * @memberof Konva.Star.prototype
   * @param {Number} radius
   */

  /**
   * get outer radius
   * @name getOuterRadius
   * @method
   * @memberof Konva.Star.prototype
   */

  Konva.Collection.mapMethods(Konva.Star);
})();

(function() {
  'use strict';
  // constants
  var ATTR_CHANGE_LIST = [
      'fontFamily',
      'fontSize',
      'fontStyle',
      'padding',
      'lineHeight',
      'text',
      'width'
    ],
    CHANGE_KONVA = 'Change.konva',
    NONE = 'none',
    UP = 'up',
    RIGHT = 'right',
    DOWN = 'down',
    LEFT = 'left',
    LABEL = 'Label',
    // cached variables
    attrChangeListLen = ATTR_CHANGE_LIST.length;

  /**
   * Label constructor.&nbsp; Labels are groups that contain a Text and Tag shape
   * @constructor
   * @memberof Konva
   * @param {Object} config
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * // create label
   * var label = new Konva.Label({
   *   x: 100,
   *   y: 100,
   *   draggable: true
   * });
   *
   * // add a tag to the label
   * label.add(new Konva.Tag({
   *   fill: '#bbb',
   *   stroke: '#333',
   *   shadowColor: 'black',
   *   shadowBlur: 10,
   *   shadowOffset: [10, 10],
   *   shadowOpacity: 0.2,
   *   lineJoin: 'round',
   *   pointerDirection: 'up',
   *   pointerWidth: 20,
   *   pointerHeight: 20,
   *   cornerRadius: 5
   * }));
   *
   * // add text to the label
   * label.add(new Konva.Text({
   *   text: 'Hello World!',
   *   fontSize: 50,
   *   lineHeight: 1.2,
   *   padding: 10,
   *   fill: 'green'
   *  }));
   */
  Konva.Label = function(config) {
    this.____init(config);
  };

  Konva.Label.prototype = {
    ____init: function(config) {
      var that = this;

      Konva.Group.call(this, config);
      this.className = LABEL;

      this.on('add.konva', function(evt) {
        that._addListeners(evt.child);
        that._sync();
      });
    },
    /**
     * get Text shape for the label.  You need to access the Text shape in order to update
     * the text properties
     * @name getText
     * @method
     * @memberof Konva.Label.prototype
     */
    getText: function() {
      return this.find('Text')[0];
    },
    /**
     * get Tag shape for the label.  You need to access the Tag shape in order to update
     * the pointer properties and the corner radius
     * @name getTag
     * @method
     * @memberof Konva.Label.prototype
     */
    getTag: function() {
      return this.find('Tag')[0];
    },
    _addListeners: function(text) {
      var that = this,
        n;
      var func = function() {
        that._sync();
      };

      // update text data for certain attr changes
      for (n = 0; n < attrChangeListLen; n++) {
        text.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, func);
      }
    },
    getWidth: function() {
      return this.getText().getWidth();
    },
    getHeight: function() {
      return this.getText().getHeight();
    },
    _sync: function() {
      var text = this.getText(),
        tag = this.getTag(),
        width,
        height,
        pointerDirection,
        pointerWidth,
        x,
        y,
        pointerHeight;

      if (text && tag) {
        width = text.getWidth();
        height = text.getHeight();
        pointerDirection = tag.getPointerDirection();
        pointerWidth = tag.getPointerWidth();
        pointerHeight = tag.getPointerHeight();
        x = 0;
        y = 0;

        switch (pointerDirection) {
          case UP:
            x = width / 2;
            y = -1 * pointerHeight;
            break;
          case RIGHT:
            x = width + pointerWidth;
            y = height / 2;
            break;
          case DOWN:
            x = width / 2;
            y = height + pointerHeight;
            break;
          case LEFT:
            x = -1 * pointerWidth;
            y = height / 2;
            break;
        }

        tag.setAttrs({
          x: -1 * x,
          y: -1 * y,
          width: width,
          height: height
        });

        text.setAttrs({
          x: -1 * x,
          y: -1 * y
        });
      }
    }
  };

  Konva.Util.extend(Konva.Label, Konva.Group);

  Konva.Collection.mapMethods(Konva.Label);

  /**
   * Tag constructor.&nbsp; A Tag can be configured
   *  to have a pointer element that points up, right, down, or left
   * @constructor
   * @memberof Konva
   * @param {Object} config
   * @param {String} [config.pointerDirection] can be up, right, down, left, or none; the default
   *  is none.  When a pointer is present, the positioning of the label is relative to the tip of the pointer.
   * @param {Number} [config.pointerWidth]
   * @param {Number} [config.pointerHeight]
   * @param {Number} [config.cornerRadius]
   */
  Konva.Tag = function(config) {
    this.___init(config);
  };

  Konva.Tag.prototype = {
    ___init: function(config) {
      Konva.Shape.call(this, config);
      this.className = 'Tag';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var width = this.getWidth(),
        height = this.getHeight(),
        pointerDirection = this.getPointerDirection(),
        pointerWidth = this.getPointerWidth(),
        pointerHeight = this.getPointerHeight(),
        cornerRadius = Math.min(this.getCornerRadius(), width / 2, height / 2);

      context.beginPath();
      if (!cornerRadius) {
        context.moveTo(0, 0);
      } else {
        context.moveTo(cornerRadius, 0);
      }

      if (pointerDirection === UP) {
        context.lineTo((width - pointerWidth) / 2, 0);
        context.lineTo(width / 2, -1 * pointerHeight);
        context.lineTo((width + pointerWidth) / 2, 0);
      }

      if (!cornerRadius) {
        context.lineTo(width, 0);
      } else {
        context.lineTo(width - cornerRadius, 0);
        context.arc(
          width - cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI * 3 / 2,
          0,
          false
        );
      }

      if (pointerDirection === RIGHT) {
        context.lineTo(width, (height - pointerHeight) / 2);
        context.lineTo(width + pointerWidth, height / 2);
        context.lineTo(width, (height + pointerHeight) / 2);
      }

      if (!cornerRadius) {
        context.lineTo(width, height);
      } else {
        context.lineTo(width, height - cornerRadius);
        context.arc(
          width - cornerRadius,
          height - cornerRadius,
          cornerRadius,
          0,
          Math.PI / 2,
          false
        );
      }

      if (pointerDirection === DOWN) {
        context.lineTo((width + pointerWidth) / 2, height);
        context.lineTo(width / 2, height + pointerHeight);
        context.lineTo((width - pointerWidth) / 2, height);
      }

      if (!cornerRadius) {
        context.lineTo(0, height);
      } else {
        context.lineTo(cornerRadius, height);
        context.arc(
          cornerRadius,
          height - cornerRadius,
          cornerRadius,
          Math.PI / 2,
          Math.PI,
          false
        );
      }

      if (pointerDirection === LEFT) {
        context.lineTo(0, (height + pointerHeight) / 2);
        context.lineTo(-1 * pointerWidth, height / 2);
        context.lineTo(0, (height - pointerHeight) / 2);
      }

      if (cornerRadius) {
        context.lineTo(0, cornerRadius);
        context.arc(
          cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI,
          Math.PI * 3 / 2,
          false
        );
      }

      context.closePath();
      context.fillStrokeShape(this);
    },
    getSelfRect: function() {
      var x = 0,
        y = 0,
        pointerWidth = this.getPointerWidth(),
        pointerHeight = this.getPointerHeight(),
        direction = this.pointerDirection(),
        width = this.getWidth(),
        height = this.getHeight();

      if (direction === UP) {
        y -= pointerHeight;
        height += pointerHeight;
      } else if (direction === DOWN) {
        height += pointerHeight;
      } else if (direction === LEFT) {
        // ARGH!!! I have no idea why should I used magic 1.5!!!!!!!!!
        x -= pointerWidth * 1.5;
        width += pointerWidth;
      } else if (direction === RIGHT) {
        width += pointerWidth * 1.5;
      }
      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    }
  };

  Konva.Util.extend(Konva.Tag, Konva.Shape);
  Konva.Factory.addGetterSetter(Konva.Tag, 'pointerDirection', NONE);

  /**
   * set pointer Direction
   * @name setPointerDirection
   * @method
   * @memberof Konva.Tag.prototype
   * @param {String} pointerDirection can be up, right, down, left, or none.  The
   *  default is none
   */

  /**
   * get pointer Direction
   * @name getPointerDirection
   * @method
   * @memberof Konva.Tag.prototype
   */

  Konva.Factory.addGetterSetter(
    Konva.Tag,
    'pointerWidth',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set pointer width
   * @name setPointerWidth
   * @method
   * @memberof Konva.Tag.prototype
   * @param {Number} pointerWidth
   */

  /**
   * get pointer width
   * @name getPointerWidth
   * @method
   * @memberof Konva.Tag.prototype
   */

  Konva.Factory.addGetterSetter(
    Konva.Tag,
    'pointerHeight',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set pointer height
   * @name setPointerHeight
   * @method
   * @memberof Konva.Tag.prototype
   * @param {Number} pointerHeight
   */

  /**
   * get pointer height
   * @name getPointerHeight
   * @method
   * @memberof Konva.Tag.prototype
   */

  Konva.Factory.addGetterSetter(
    Konva.Tag,
    'cornerRadius',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * set corner radius
   * @name setCornerRadius
   * @method
   * @memberof Konva.Tag.prototype
   * @param {Number} corner radius
   */

  /**
   * get corner radius
   * @name getCornerRadius
   * @method
   * @memberof Konva.Tag.prototype
   */

  Konva.Collection.mapMethods(Konva.Tag);
})();

(function(Konva) {
  'use strict';
  /**
   * Arrow constructor
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Array} config.points Flat array of points coordinates. You should define them as [x1, y1, x2, y2, x3, y3].
   * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
   *   The default is 0
   * @param {Number} config.pointerLength Arrow pointer length. Default value is 10.
   * @param {Number} config.pointerWidth Arrow pointer width. Default value is 10.
   * @param {Boolean} config.pointerAtBeginning Do we need to draw pointer on both sides?. Default false.
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var line = new Konva.Line({
   *   points: [73, 70, 340, 23, 450, 60, 500, 20],
   *   stroke: 'red',
   *   tension: 1,
   *   pointerLength : 10,
   *   pointerWidth : 12
   * });
   */
  Konva.Arrow = function(config) {
    this.____init(config);
  };

  Konva.Arrow.prototype = {
    ____init: function(config) {
      // call super constructor
      Konva.Line.call(this, config);
      this.className = 'Arrow';
    },
    _sceneFunc: function(ctx) {
      Konva.Line.prototype._sceneFunc.apply(this, arguments);
      var PI2 = Math.PI * 2;
      var points = this.points();

      var tp = points;
      var fromTension = this.getTension() !== 0 && points.length > 4;
      if (fromTension) {
        tp = this.getTensionPoints();
      }

      var n = points.length;

      var dx, dy;
      if (fromTension) {
        dx = points[n - 2] - tp[n - 2];
        dy = points[n - 1] - tp[n - 1];
      } else {
        dx = points[n - 2] - points[n - 4];
        dy = points[n - 1] - points[n - 3];
      }

      var radians = (Math.atan2(dy, dx) + PI2) % PI2;
      var length = this.pointerLength();
      var width = this.pointerWidth();

      ctx.save();
      ctx.beginPath();
      ctx.translate(points[n - 2], points[n - 1]);
      ctx.rotate(radians);
      ctx.moveTo(0, 0);
      ctx.lineTo(-length, width / 2);
      ctx.lineTo(-length, -width / 2);
      ctx.closePath();
      ctx.restore();

      if (this.pointerAtBeginning()) {
        ctx.save();
        ctx.translate(points[0], points[1]);
        if (fromTension) {
          dx = tp[0] - points[0];
          dy = tp[1] - points[1];
        } else {
          dx = points[2] - points[0];
          dy = points[3] - points[1];
        }

        ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
        ctx.moveTo(0, 0);
        ctx.lineTo(-length, width / 2);
        ctx.lineTo(-length, -width / 2);
        ctx.closePath();
        ctx.restore();
      }

      // here is a tricky part
      // we need to disable dash for arrow pointers
      var isDashEnabled = this.dashEnabled();
      if (isDashEnabled) {
        // manually disable dash for head
        // it is better not to use setter here,
        // because it will trigger attr change event
        this.attrs.dashEnabled = false;
        ctx.setLineDash([]);
      }

      ctx.fillStrokeShape(this);

      // restore old value
      if (isDashEnabled) {
        this.attrs.dashEnabled = true;
      }
    }
  };

  Konva.Util.extend(Konva.Arrow, Konva.Line);
  /**
   * get/set pointerLength
   * @name pointerLength
   * @method
   * @memberof Konva.Arrow.prototype
   * @param {Number} Length of pointer of arrow.
   *   The default is 10.
   * @returns {Number}
   * @example
   * // get tension
   * var pointerLength = line.pointerLength();
   *
   * // set tension
   * line.pointerLength(15);
   */

  Konva.Factory.addGetterSetter(
    Konva.Arrow,
    'pointerLength',
    10,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set pointerWidth
   * @name pointerWidth
   * @method
   * @memberof Konva.Arrow.prototype
   * @param {Number} Width of pointer of arrow.
   *   The default is 10.
   * @returns {Number}
   * @example
   * // get tension
   * var pointerWidth = line.pointerWidth();
   *
   * // set tension
   * line.pointerWidth(15);
   */

  Konva.Factory.addGetterSetter(
    Konva.Arrow,
    'pointerWidth',
    10,
    Konva.Validators.getNumberValidator()
  );
  /**
   * get/set pointerAtBeginning
   * @name pointerAtBeginning
   * @method
   * @memberof Konva.Arrow.prototype
   * @param {Number} Should pointer displayed at beginning of arrow.
   *   The default is false.
   * @returns {Boolean}
   * @example
   * // get tension
   * var pointerAtBeginning = line.pointerAtBeginning();
   *
   * // set tension
   * line.pointerAtBeginning(true);
   */

  Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerAtBeginning', false);
  Konva.Collection.mapMethods(Konva.Arrow);
})(Konva);

(function(Konva) {
  'use strict';

  var ATTR_CHANGE_LIST = [
    'resizeEnabledChange',
    'rotateAnchorOffsetChange',
    'rotateEnabledChange',
    'enabledAnchorsChange',
    'anchorSizeChange',
    'borderEnabledChange',
    'borderStrokeChange',
    'borderStrokeWidthChange',
    'anchorStrokeChange',
    'anchorStrokeWidthChange',
    'anchorFillChange',
    'anchorCornerRadiusChange'
  ].join(' ');

  var NODE_RECT = 'nodeRect';

  var TRANSFORM_CHANGE_STR = [
    'xChange.resizer',
    'yChange.resizer',
    'widthChange.resizer',
    'heightChange.resizer',
    'scaleXChange.resizer',
    'scaleYChange.resizer',
    'skewXChange.resizer',
    'skewYChange.resizer',
    'rotationChange.resizer',
    'offsetXChange.resizer',
    'offsetYChange.resizer',
    'transformsEnabledChange.resizer'
  ].join(' ');

  var REDRAW_CHANGE_STR = [
    'widthChange.resizer',
    'heightChange.resizer',
    'scaleXChange.resizer',
    'scaleYChange.resizer',
    'skewXChange.resizer',
    'skewYChange.resizer',
    'rotationChange.resizer',
    'offsetXChange.resizer',
    'offsetYChange.resizer'
  ].join(' ');

  var ANGLES = {
    'top-left': -45,
    'top-center': 0,
    'top-right': 45,
    'middle-right': -90,
    'middle-left': 90,
    'bottom-left': -135,
    'bottom-center': 180,
    'bottom-right': 135
  };

  function getCursor(anchorName, rad, isMirrored) {
    if (anchorName === 'rotater') {
      return 'crosshair';
    }

    rad += Konva.Util._degToRad(ANGLES[anchorName] || 0);
    // If we are mirrored, we need to mirror the angle (this is not the same as
    // rotate).
    if (isMirrored) {
      rad *= -1;
    }
    var angle = (Konva.Util._radToDeg(rad) % 360 + 360) % 360;

    if (
      Konva.Util._inRange(angle, 315 + 22.5, 360) ||
      Konva.Util._inRange(angle, 0, 22.5)
    ) {
      // TOP
      return 'ns-resize';
    } else if (Konva.Util._inRange(angle, 45 - 22.5, 45 + 22.5)) {
      // TOP - RIGHT
      return 'nesw-resize';
    } else if (Konva.Util._inRange(angle, 90 - 22.5, 90 + 22.5)) {
      // RIGHT
      return 'ew-resize';
    } else if (Konva.Util._inRange(angle, 135 - 22.5, 135 + 22.5)) {
      // BOTTOM - RIGHT
      return 'nwse-resize';
    } else if (Konva.Util._inRange(angle, 180 - 22.5, 180 + 22.5)) {
      // BOTTOM
      return 'ns-resize';
    } else if (Konva.Util._inRange(angle, 225 - 22.5, 225 + 22.5)) {
      // BOTTOM - LEFT
      return 'nesw-resize';
    } else if (Konva.Util._inRange(angle, 270 - 22.5, 270 + 22.5)) {
      // RIGHT
      return 'ew-resize';
    } else if (Konva.Util._inRange(angle, 315 - 22.5, 315 + 22.5)) {
      // BOTTOM - RIGHT
      return 'nwse-resize';
    } else {
      // how can we can there?
      // TODO: throw error
      Konva.Util.error(
        'Transformer has unknown angle for cursor detection: ' + angle
      );
      return 'pointer';
    }
  }

  /**
   * Transformer constructor.  Transformer is a special type of group that allow you transform Konva
   * primitives and shapes. Transforming tool is not changing `width` and `height` properties of nodes
   * when you resize them. Instead it changes `scaleX` and `scaleY` properties.
   * @constructor
   * @memberof Konva
   * @param {Object} config
   * @param {Boolean} [config.resizeEnabled] Default is true
   * @param {Boolean} [config.rotateEnabled] Default is true
   * @param {Array} [config.rotationSnaps] Array of angles for rotation snaps. Default is []
   * @param {Number} [config.rotateAnchorOffset] Default is 50
   * @param {Number} [config.padding] Default is 0
   * @param {Boolean} [config.borderEnabled] Should we draw border? Default is true
   * @param {String} [config.borderStroke] Border stroke color
   * @param {Number} [config.borderStrokeWidth] Border stroke size
   * @param {Array} [config.borderDash] Array for border dash.
   * @param {String} [config.anchorFill] Anchor fill color
   * @param {String} [config.anchorStroke] Anchor stroke color
   * @param {String} [config.anchorCornerRadius] Anchor corner radius
   * @param {Number} [config.anchorStrokeWidth] Anchor stroke size
   * @param {Number} [config.anchorSize] Default is 10
   * @param {Boolean} [config.keepRatio] Should we keep ratio when we are moving edges? Default is true
   * @param {Boolean} [config.centeredScaling] Should we resize relative to node's center? Default is false
   * @param {Array} [config.enabledAnchors] Array of names of enabled handles
   * @param {Function} [config.boundBoxFunc] Bounding box function
   * @example
   * var transformer = new Konva.Transformer({
   *   node: rectangle,
   *   rotateAnchorOffset: 60,
   *   enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right']
   * });
   * layer.add(transformer);
   */

  Konva.Transformer = function(config) {
    this.____init(config);
  };

  var ANCHORS_NAMES = [
    'top-left',
    'top-center',
    'top-right',
    'middle-right',
    'middle-left',
    'bottom-left',
    'bottom-center',
    'bottom-right'
  ];

  Konva.Transformer.prototype = {
    _centroid: false,
    ____init: function(config) {
      // call super constructor
      Konva.Group.call(this, config);
      this.className = 'Transformer';
      this._createElements();

      // bindings
      this._handleMouseMove = this._handleMouseMove.bind(this);
      this._handleMouseUp = this._handleMouseUp.bind(this);
      this.update = this.update.bind(this);

      // update transformer data for certain attr changes
      this.on(ATTR_CHANGE_LIST, this.update);

      if (this.getNode()) {
        this.update();
      }
    },

    /**
     * alias to `setNode`
     * @method
     * @memberof Konva.Transformer.prototype
     * @returns {Konva.Transformer}
     * @example
     * transformer.attachTo(shape);
     */
    attachTo: function(node) {
      this.setNode(node);
    },

    /**
     * attach transformer to a Konva.Node. Transformer will adapt to its size and listen its events
     * @method
     * @memberof Konva.Transformer.prototype
     * @returns {Konva.Transformer}
     * @example
     * transformer.setNode(shape);
     */
    setNode: function(node) {
      if (this._node) {
        this.detach();
      }
      this._node = node;
      this._resetTransformCache();

      node.on(TRANSFORM_CHANGE_STR, this._resetTransformCache.bind(this));
      node.on(
        REDRAW_CHANGE_STR,
        function() {
          if (!this._transforming) {
            this.update();
          }
        }.bind(this)
      );

      // TODO: why do we need this?
      var elementsCreated = !!this.findOne('.top-left');
      if (elementsCreated) {
        this.update();
      }
      return this;
    },

    getNode: function() {
      return this._node;
    },

    /**
     * detach transformer from a attached node
     * @method
     * @memberof Konva.Transformer.prototype
     * @returns {Konva.Transformer}
     * @example
     * transformer.detach();
     */
    detach: function() {
      if (this.getNode()) {
        this.getNode().off('.resizer');
        this._node = undefined;
      }
      this._resetTransformCache();
    },

    _resetTransformCache: function() {
      this._clearCache(NODE_RECT);
      this._clearCache('transform');
      this._clearSelfAndDescendantCache('absoluteTransform');
    },

    _getNodeRect: function() {
      return this._getCache(NODE_RECT, this.__getNodeRect);
    },

    __getNodeRect: function() {
      var node = this.getNode();
      if (!node) {
        return {
          x: -Number.MAX_SAFE_INTEGER,
          y: -Number.MAX_SAFE_INTEGER,
          width: 0,
          height: 0,
          rotation: 0
        };
      }
      var rect = node.getClientRect({ skipTransform: true, skipShadow: true });
      var rotation = Konva.getAngle(node.rotation());

      var dx = rect.x * node.scaleX() - node.offsetX() * node.scaleX();
      var dy = rect.y * node.scaleY() - node.offsetY() * node.scaleY();

      return {
        x: node.x() + dx * Math.cos(rotation) + dy * Math.sin(-rotation),
        y: node.y() + dy * Math.cos(rotation) + dx * Math.sin(rotation),
        width: rect.width * node.scaleX(),
        height: rect.height * node.scaleY(),
        rotation: node.rotation()
      };
    },

    getX: function() {
      return this._getNodeRect().x;
    },

    getY: function() {
      return this._getNodeRect().y;
    },

    getRotation: function() {
      return this._getNodeRect().rotation;
    },

    getWidth: function() {
      return this._getNodeRect().width;
    },

    getHeight: function() {
      return this._getNodeRect().height;
    },

    _createElements: function() {
      this._createBack();

      ANCHORS_NAMES.forEach(
        function(name) {
          this._createAnchor(name);
        }.bind(this)
      );

      this._createAnchor('rotater');
    },

    _createAnchor: function(name) {
      var anchor = new Konva.Rect({
        stroke: 'rgb(0, 161, 255)',
        fill: 'white',
        strokeWidth: 1,
        name: name + ' _anchor',
        dragDistance: 0,
        draggable: true
      });
      var self = this;
      anchor.on('mousedown touchstart', function(e) {
        self._handleMouseDown(e);
      });
      anchor.on('dragstart', function(e) {
        e.cancelBubble = true;
      });
      anchor.on('dragmove', function(e) {
        e.cancelBubble = true;
      });
      anchor.on('dragend', function(e) {
        e.cancelBubble = true;
      });

      // add hover styling
      anchor.on('mouseenter', function() {
        var tr = this.getParent();

        var rad = Konva.getAngle(tr.rotation());

        var scale = tr.getNode().getAbsoluteScale();
        // If scale.y < 0 xor scale.x < 0 we need to flip (not rotate).
        var isMirrored = scale.y * scale.x < 0;
        var cursor = getCursor(name, rad, isMirrored);
        anchor.getStage().content.style.cursor = cursor;
        tr._cursorChange = true;
      });
      anchor.on('mouseout', function() {
        if (!anchor.getStage() || !this.getParent()) {
          return;
        }
        anchor.getStage().content.style.cursor = '';
        this.getParent()._cursorChange = false;
      });
      this.add(anchor);
    },

    _createBack: function() {
      var back = new Konva.Shape({
        name: 'back',
        width: 0,
        height: 0,
        listening: false,
        sceneFunc: function(ctx) {
          var tr = this.getParent();
          var padding = tr.getPadding();
          ctx.beginPath();
          ctx.rect(
            -padding,
            -padding,
            this.width() + padding * 2,
            this.height() + padding * 2
          );
          ctx.moveTo(this.width() / 2, -padding);
          if (tr.rotateEnabled()) {
            ctx.lineTo(
              this.width() / 2,
              -tr.rotateAnchorOffset() * Konva.Util._sign(this.height())
            );
          }

          ctx.fillStrokeShape(this);
        }
      });
      this.add(back);
    },

    _handleMouseDown: function(e) {
      this.movingResizer = e.target.name().split(' ')[0];

      // var node = this.getNode();
      var attrs = this._getNodeRect();
      var width = attrs.width;
      var height = attrs.height;
      var hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
      this.sin = height / hypotenuse;
      this.cos = width / hypotenuse;

      window.addEventListener('mousemove', this._handleMouseMove);
      window.addEventListener('touchmove', this._handleMouseMove);
      window.addEventListener('mouseup', this._handleMouseUp, true);
      window.addEventListener('touchend', this._handleMouseUp, true);

      this._transforming = true;

      this._fire('transformstart', { evt: e });
      this.getNode()._fire('transformstart', { evt: e });
    },

    _handleMouseMove: function(e) {
      var x, y, newHypotenuse;
      var resizerNode = this.findOne('.' + this.movingResizer);
      var stage = resizerNode.getStage();

      var box = stage.getContent().getBoundingClientRect();
      var zeroPoint = {
        x: box.left,
        y: box.top
      };
      var pointerPos = {
        left: e.clientX !== undefined ? e.clientX : e.touches[0].clientX,
        top: e.clientX !== undefined ? e.clientY : e.touches[0].clientY
      };
      var newAbsPos = {
        x: pointerPos.left - zeroPoint.x,
        y: pointerPos.top - zeroPoint.y
      };

      resizerNode.setAbsolutePosition(newAbsPos);

      var keepProportion = this.keepRatio() || e.shiftKey;

      // console.log(keepProportion);

      if (this.movingResizer === 'top-left') {
        if (keepProportion) {
          newHypotenuse = Math.sqrt(
            Math.pow(this.findOne('.bottom-right').x() - resizerNode.x(), 2) +
              Math.pow(this.findOne('.bottom-right').y() - resizerNode.y(), 2)
          );

          x = newHypotenuse * this.cos;
          y = newHypotenuse * this.sin;

          this.findOne('.top-left').x(this.findOne('.bottom-right').x() - x);
          this.findOne('.top-left').y(this.findOne('.bottom-right').y() - y);
        }
      } else if (this.movingResizer === 'top-center') {
        this.findOne('.top-left').y(resizerNode.y());
      } else if (this.movingResizer === 'top-right') {
        if (keepProportion) {
          newHypotenuse = Math.sqrt(
            Math.pow(this.findOne('.bottom-left').x() - resizerNode.x(), 2) +
              Math.pow(this.findOne('.bottom-left').y() - resizerNode.y(), 2)
          );

          x = newHypotenuse * this.cos;
          y = newHypotenuse * this.sin;

          this.findOne('.top-right').x(x);
          this.findOne('.top-right').y(this.findOne('.bottom-left').y() - y);
        }
        var pos = resizerNode.position();

        this.findOne('.top-left').y(pos.y);
        this.findOne('.bottom-right').x(pos.x);
      } else if (this.movingResizer === 'middle-left') {
        this.findOne('.top-left').x(resizerNode.x());
      } else if (this.movingResizer === 'middle-right') {
        this.findOne('.bottom-right').x(resizerNode.x());
      } else if (this.movingResizer === 'bottom-left') {
        if (keepProportion) {
          newHypotenuse = Math.sqrt(
            Math.pow(this.findOne('.top-right').x() - resizerNode.x(), 2) +
              Math.pow(this.findOne('.top-right').y() - resizerNode.y(), 2)
          );

          x = newHypotenuse * this.cos;
          y = newHypotenuse * this.sin;

          this.findOne('.bottom-left').x(this.findOne('.top-right').x() - x);
          this.findOne('.bottom-left').y(y);
        }

        pos = resizerNode.position();

        this.findOne('.top-left').x(pos.x);
        this.findOne('.bottom-right').y(pos.y);
      } else if (this.movingResizer === 'bottom-center') {
        this.findOne('.bottom-right').y(resizerNode.y());
      } else if (this.movingResizer === 'bottom-right') {
        if (keepProportion) {
          newHypotenuse = Math.sqrt(
            Math.pow(this.findOne('.bottom-right').x(), 2) +
              Math.pow(this.findOne('.bottom-right').y(), 2)
          );

          x = newHypotenuse * this.cos;
          y = newHypotenuse * this.sin;

          this.findOne('.bottom-right').x(x);
          this.findOne('.bottom-right').y(y);
        }
      } else if (this.movingResizer === 'rotater') {
        var padding = this.getPadding();
        var attrs = this._getNodeRect();
        x = resizerNode.x() - attrs.width / 2;
        y = -resizerNode.y() + attrs.height / 2;

        var dAlpha = Math.atan2(-y, x) + Math.PI / 2;

        if (attrs.height < 0) {
          dAlpha -= Math.PI;
        }

        var rot = Konva.getAngle(this.rotation());

        var newRotation =
          Konva.Util._radToDeg(rot) + Konva.Util._radToDeg(dAlpha);

        var alpha = Konva.getAngle(this.getNode().rotation());
        var newAlpha = Konva.Util._degToRad(newRotation);

        var snaps = this.rotationSnaps();
        var offset = 0.1;
        for (var i = 0; i < snaps.length; i++) {
          var angle = Konva.getAngle(snaps[i]);

          var dif =
            Math.abs(angle - Konva.Util._degToRad(newRotation)) % (Math.PI * 2);

          if (dif < offset) {
            newRotation = Konva.Util._radToDeg(angle);
            newAlpha = Konva.Util._degToRad(newRotation);
          }
        }

        var dx = padding;
        var dy = padding;

        this._fitNodeInto(
          {
            rotation: Konva.angleDeg
              ? newRotation
              : Konva.Util._degToRad(newRotation),
            x:
              attrs.x +
              (attrs.width / 2 + padding) *
                (Math.cos(alpha) - Math.cos(newAlpha)) +
              (attrs.height / 2 + padding) *
                (Math.sin(-alpha) - Math.sin(-newAlpha)) -
              (dx * Math.cos(rot) + dy * Math.sin(-rot)),
            y:
              attrs.y +
              (attrs.height / 2 + padding) *
                (Math.cos(alpha) - Math.cos(newAlpha)) +
              (attrs.width / 2 + padding) *
                (Math.sin(alpha) - Math.sin(newAlpha)) -
              (dy * Math.cos(rot) + dx * Math.sin(rot)),
            width: attrs.width + padding * 2,
            height: attrs.height + padding * 2
          },
          e
        );
      } else {
        console.error(
          new Error(
            'Wrong position argument of selection resizer: ',
            this.movingResizer
          )
        );
      }

      if (this.movingResizer === 'rotater') {
        return;
      }

      var absPos = this.findOne('.top-left').getAbsolutePosition(
        this.getParent()
      );

      var centeredScaling = this.getCenteredScaling() || e.altKey;
      if (centeredScaling) {
        var topLeft = this.findOne('.top-left');
        var bottomRight = this.findOne('.bottom-right');
        var topOffsetX = topLeft.x();
        var topOffsetY = topLeft.y();

        var bottomOffsetX = this.getWidth() - bottomRight.x();
        var bottomOffsetY = this.getHeight() - bottomRight.y();

        // console.log(topOffsetX, topOffsetY, bottomOffsetX, bottomOffsetY);

        bottomRight.move({
          x: -topOffsetX,
          y: -topOffsetY
        });

        topLeft.move({
          x: bottomOffsetX,
          y: bottomOffsetY
        });

        absPos = topLeft.getAbsolutePosition(this.getParent());
      }

      x = absPos.x;
      y = absPos.y;
      var width =
        this.findOne('.bottom-right').x() - this.findOne('.top-left').x();

      var height =
        this.findOne('.bottom-right').y() - this.findOne('.top-left').y();

      // console.log(x, y, width, height);

      this._fitNodeInto(
        {
          x: x + this.offsetX(),
          y: y + this.offsetY(),
          width: width,
          height: height
        },
        e
      );
    },

    _handleMouseUp: function(e) {
      this._removeEvents(e);
    },

    _removeEvents: function(e) {
      if (this._transforming) {
        this._transforming = false;
        window.removeEventListener('mousemove', this._handleMouseMove);
        window.removeEventListener('touchmove', this._handleMouseMove);
        window.removeEventListener('mouseup', this._handleMouseUp, true);
        window.removeEventListener('touchend', this._handleMouseUp, true);
        this._fire('transformend', { evt: e });
        var node = this.getNode();
        if (node) {
          node.fire('transformend', { evt: e });
        }
      }
    },

    _fitNodeInto: function(newAttrs, evt) {
      // waring! in this attrs padding may be included
      var boundBoxFunc = this.getBoundBoxFunc();
      if (boundBoxFunc) {
        var oldAttrs = this._getNodeRect();
        newAttrs = boundBoxFunc.call(this, oldAttrs, newAttrs);
      }
      this._settings = true;
      var node = this.getNode();
      if (newAttrs.rotation !== undefined) {
        this.getNode().rotation(newAttrs.rotation);
      }
      var pure = node.getClientRect({ skipTransform: true, skipShadow: true });
      var padding = this.getPadding();
      var scaleX = (newAttrs.width - padding * 2) / pure.width;
      var scaleY = (newAttrs.height - padding * 2) / pure.height;

      var rotation = Konva.getAngle(node.getRotation());
      var dx = pure.x * scaleX - padding - node.offsetX() * scaleX;
      var dy = pure.y * scaleY - padding - node.offsetY() * scaleY;

      this.getNode().setAttrs({
        scaleX: scaleX,
        scaleY: scaleY,
        x: newAttrs.x - (dx * Math.cos(rotation) + dy * Math.sin(-rotation)),
        y: newAttrs.y - (dy * Math.cos(rotation) + dx * Math.sin(rotation))
      });
      this._settings = false;

      this._fire('transform', { evt: evt });
      this.getNode()._fire('transform', { evt: evt });
      this.update();
      this.getLayer().batchDraw();
    },
    /**
     * force update of Konva.Transformer.
     * Use it when you updated attached Konva.Group and now you need to reset transformer size
     * @method
     * @memberof Konva.Transformer.prototype
     */
    forceUpdate: function() {
      this._resetTransformCache();
      this.update();
    },
    update: function() {
      var attrs = this._getNodeRect();
      var node = this.getNode();
      var scale = { x: 1, y: 1 };
      if (node && node.getParent()) {
        scale = node.getParent().getAbsoluteScale();
      }
      var invertedScale = {
        x: 1 / scale.x,
        y: 1 / scale.y
      };
      var width = attrs.width;
      var height = attrs.height;

      var enabledAnchors = this.enabledAnchors();
      var resizeEnabled = this.resizeEnabled();
      var padding = this.getPadding();

      var anchorSize = this.getAnchorSize();
      this.find('._anchor').setAttrs({
        width: anchorSize,
        height: anchorSize,
        offsetX: anchorSize / 2,
        offsetY: anchorSize / 2,
        stroke: this.getAnchorStroke(),
        strokeWidth: this.getAnchorStrokeWidth(),
        fill: this.getAnchorFill(),
        cornerRadius: this.getAnchorCornerRadius()
      });

      this.findOne('.top-left').setAttrs({
        x: -padding,
        y: -padding,
        scale: invertedScale,
        visible: resizeEnabled && enabledAnchors.indexOf('top-left') >= 0
      });
      this.findOne('.top-center').setAttrs({
        x: width / 2,
        y: -padding,
        scale: invertedScale,
        visible: resizeEnabled && enabledAnchors.indexOf('top-center') >= 0
      });
      this.findOne('.top-right').setAttrs({
        x: width + padding,
        y: -padding,
        scale: invertedScale,
        visible: resizeEnabled && enabledAnchors.indexOf('top-right') >= 0
      });
      this.findOne('.middle-left').setAttrs({
        x: -padding,
        y: height / 2,
        scale: invertedScale,
        visible: resizeEnabled && enabledAnchors.indexOf('middle-left') >= 0
      });
      this.findOne('.middle-right').setAttrs({
        x: width + padding,
        y: height / 2,
        scale: invertedScale,
        visible: resizeEnabled && enabledAnchors.indexOf('middle-right') >= 0
      });
      this.findOne('.bottom-left').setAttrs({
        x: -padding,
        y: height + padding,
        scale: invertedScale,
        visible: resizeEnabled && enabledAnchors.indexOf('bottom-left') >= 0
      });
      this.findOne('.bottom-center').setAttrs({
        x: width / 2,
        y: height + padding,
        scale: invertedScale,
        visible: resizeEnabled && enabledAnchors.indexOf('bottom-center') >= 0
      });
      this.findOne('.bottom-right').setAttrs({
        x: width + padding,
        y: height + padding,
        scale: invertedScale,
        visible: resizeEnabled && enabledAnchors.indexOf('bottom-right') >= 0
      });

      var scaledRotateAnchorOffset =
        -this.rotateAnchorOffset() * Math.abs(invertedScale.y);
      this.findOne('.rotater').setAttrs({
        x: width / 2,
        y: scaledRotateAnchorOffset * Konva.Util._sign(height),
        scale: invertedScale,
        visible: this.rotateEnabled()
      });

      this.findOne('.back').setAttrs({
        width: width * scale.x,
        height: height * scale.y,
        scale: invertedScale,
        visible: this.borderEnabled(),
        stroke: this.getBorderStroke(),
        strokeWidth: this.getBorderStrokeWidth(),
        dash: this.getBorderDash()
      });
    },
    /**
     * determine if transformer is in active transform
     * @method
     * @memberof Konva.Transformer.prototype
     * @returns {Boolean}
     */
    isTransforming: function() {
      return this._transforming;
    },
    /**
     * Stop active transform action
     * @method
     * @memberof Konva.Transformer.prototype
     * @returns {Boolean}
     */
    stopTransform: function() {
      if (this._transforming) {
        this._removeEvents();
        var resizerNode = this.findOne('.' + this.movingResizer);
        if (resizerNode) {
          resizerNode.stopDrag();
        }
      }
    },
    destroy: function() {
      // console.log(this.isTransforming() && this.getStage());
      if (this.getStage() && this._cursorChange) {
        this.getStage().content.style.cursor = '';
      }
      Konva.Group.prototype.destroy.call(this);
      this.detach();
      this._removeEvents();
    },
    // do not work as a container
    // we will recreate inner nodes manually
    toObject: function() {
      return Konva.Node.prototype.toObject.call(this);
    }
  };
  Konva.Util.extend(Konva.Transformer, Konva.Group);

  function validateResizers(val) {
    if (!(val instanceof Array)) {
      Konva.Util.warn('enabledAnchors value should be an array');
    }
    if (val instanceof Array) {
      val.forEach(function(name) {
        if (ANCHORS_NAMES.indexOf(name) === -1) {
          Konva.Util.warn(
            'Unknown anchor name: ' +
              name +
              '. Available names are: ' +
              ANCHORS_NAMES.join(', ')
          );
        }
      });
    }
    return val || [];
  }

  /**
   * get/set enabled handlers
   * @name enabledAnchors
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Array} array
   * @returns {Array}
   * @example
   * // get list of handlers
   * var enabledAnchors = transformer.enabledAnchors();
   *
   * // set handlers
   * transformer.enabledAnchors(['top-left', 'top-center', 'top-right', 'middle-right', 'middle-left', 'bottom-left', 'bottom-center', 'bottom-right']);
   */
  Konva.Factory.addGetterSetter(
    Konva.Transformer,
    'enabledAnchors',
    ANCHORS_NAMES,
    validateResizers
  );

  /**
   * get/set resize ability. If false it will automatically hide resizing handlers
   * @name resizeEnabled
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Array} array
   * @returns {Array}
   * @example
   * // get
   * var resizeEnabled = transformer.resizeEnabled();
   *
   * // set
   * transformer.resizeEnabled(false);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'resizeEnabled', true);
  /**
   * get/set anchor size. Default is 10
   * @name validateAnchors
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Number} 10
   * @returns {Number}
   * @example
   * // get
   * var anchorSize = transformer.anchorSize();
   *
   * // set
   * transformer.anchorSize(20)
   */
  Konva.Factory.addGetterSetter(
    Konva.Transformer,
    'anchorSize',
    10,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set ability to rotate.
   * @name rotateEnabled
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get
   * var rotateEnabled = transformer.rotateEnabled();
   *
   * // set
   * transformer.rotateEnabled(false);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'rotateEnabled', true);

  /**
   * get/set rotation snaps angles.
   * @name rotationSnaps
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Array} array
   * @returns {Array}
   * @example
   * // get
   * var rotationSnaps = transformer.rotationSnaps();
   *
   * // set
   * transformer.rotationSnaps([0, 90, 180, 270]);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'rotationSnaps', []);

  /**
   * get/set distance for rotation handler
   * @name rotateAnchorOffset
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Number} offset
   * @returns {Number}
   * @example
   * // get
   * var rotateAnchorOffset = transformer.rotateAnchorOffset();
   *
   * // set
   * transformer.rotateAnchorOffset(100);
   */
  Konva.Factory.addGetterSetter(
    Konva.Transformer,
    'rotateAnchorOffset',
    50,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set visibility of border
   * @name borderEnabled
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get
   * var borderEnabled = transformer.borderEnabled();
   *
   * // set
   * transformer.borderEnabled(false);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'borderEnabled', true);

  /**
   * get/set anchor stroke color
   * @name anchorStroke
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get
   * var anchorStroke = transformer.anchorStroke();
   *
   * // set
   * transformer.anchorStroke('red');
   */
  Konva.Factory.addGetterSetter(
    Konva.Transformer,
    'anchorStroke',
    'rgb(0, 161, 255)'
  );

  /**
   * get/set anchor stroke width
   * @name anchorStrokeWidth
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get
   * var anchorStrokeWidth = transformer.anchorStrokeWidth();
   *
   * // set
   * transformer.anchorStrokeWidth(3);
   */
  Konva.Factory.addGetterSetter(
    Konva.Transformer,
    'anchorStrokeWidth',
    1,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set anchor fill color
   * @name anchorFill
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get
   * var anchorFill = transformer.anchorFill();
   *
   * // set
   * transformer.anchorFill('red');
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'anchorFill', 'white');

  /**
   * get/set anchor corner radius
   * @name anchorCornerRadius
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Number} enabled
   * @returns {Number}
   * @example
   * // get
   * var anchorCornerRadius = transformer.anchorCornerRadius();
   *
   * // set
   * transformer.anchorCornerRadius(3);
   */
  Konva.Factory.addGetterSetter(
    Konva.Transformer,
    'anchorCornerRadius',
    0,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set border stroke color
   * @name borderStroke
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get
   * var borderStroke = transformer.borderStroke();
   *
   * // set
   * transformer.borderStroke('red');
   */
  Konva.Factory.addGetterSetter(
    Konva.Transformer,
    'borderStroke',
    'rgb(0, 161, 255)'
  );

  /**
   * get/set border stroke width
   * @name borderStrokeWidth
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get
   * var borderStrokeWidth = transformer.borderStrokeWidth();
   *
   * // set
   * transformer.borderStrokeWidth(3);
   */
  Konva.Factory.addGetterSetter(
    Konva.Transformer,
    'borderStrokeWidth',
    1,
    Konva.Validators.getNumberValidator()
  );

  /**
   * get/set border dash array
   * @name borderDash
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get
   * var borderDash = transformer.borderDash();
   *
   * // set
   * transformer.borderDash([2, 2]);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'borderDash');

  /**
   * get/set should we keep ratio while resize anchors at corners
   * @name keepRatio
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Boolean} keepRatio
   * @returns {Boolean}
   * @example
   * // get
   * var keepRatio = transformer.keepRatio();
   *
   * // set
   * transformer.keepRatio(false);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'keepRatio', true);

  /**
   * get/set should we resize relative to node's center?
   * @name centeredScaling
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Boolean} centeredScaling
   * @returns {Boolean}
   * @example
   * // get
   * var centeredScaling = transformer.centeredScaling();
   *
   * // set
   * transformer.centeredScaling(true);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'centeredScaling', false);

  /**
   * get/set padding
   * @name padding
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Number} padding
   * @returns {Number}
   * @example
   * // get
   * var padding = transformer.padding();
   *
   * // set
   * transformer.padding(10);
   */
  Konva.Factory.addGetterSetter(
    Konva.Transformer,
    'padding',
    0,
    Konva.Validators.getNumberValidator()
  );

  Konva.Factory.addOverloadedGetterSetter(Konva.Transformer, 'node');

  /**
   * get/set bounding box function
   * @name boundBoxFunc
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Function} func
   * @returns {Function}
   * @example
   * // get
   * var boundBoxFunc = transformer.boundBoxFunc();
   *
   * // set
   * transformer.boundBoxFunc(function(oldBox, newBox) {
   *   if (newBox.width > 200) {
   *     return oldBox;
   *   }
   *   return newBox;
   * });
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'boundBoxFunc');

  Konva.Factory.backCompat(Konva.Transformer, {
    lineEnabled: 'borderEnabled',
    rotateHandlerOffset: 'rotateAnchorOffset',
    enabledHandlers: 'enabledAnchors'
  });

  Konva.Collection.mapMethods(Konva.Transformer);
})(Konva);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "./node_modules/strip-ansi/index.js":
/*!******************************************!*\
  !*** ./node_modules/strip-ansi/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(/*! ansi-regex */ "./node_modules/ansi-regex/index.js")();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),

/***/ "./node_modules/webpack-hot-middleware/client-overlay.js":
/*!**************************************************!*\
  !*** (webpack)-hot-middleware/client-overlay.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*eslint-env browser*/

var clientOverlay = document.createElement('div');
clientOverlay.id = 'webpack-hot-middleware-clientOverlay';
var styles = {
  background: 'rgba(0,0,0,0.85)',
  color: '#E8E8E8',
  lineHeight: '1.2',
  whiteSpace: 'pre',
  fontFamily: 'Menlo, Consolas, monospace',
  fontSize: '13px',
  position: 'fixed',
  zIndex: 9999,
  padding: '10px',
  left: 0,
  right: 0,
  top: 0,
  bottom: 0,
  overflow: 'auto',
  dir: 'ltr',
  textAlign: 'left'
};

var ansiHTML = __webpack_require__(/*! ansi-html */ "./node_modules/ansi-html/index.js");
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};

var Entities = __webpack_require__(/*! html-entities */ "./node_modules/html-entities/index.js").AllHtmlEntities;
var entities = new Entities();

function showProblems(type, lines) {
  clientOverlay.innerHTML = '';
  lines.forEach(function(msg) {
    msg = ansiHTML(entities.encode(msg));
    var div = document.createElement('div');
    div.style.marginBottom = '26px';
    div.innerHTML = problemType(type) + ' in ' + msg;
    clientOverlay.appendChild(div);
  });
  if (document.body) {
    document.body.appendChild(clientOverlay);
  }
}

function clear() {
  if (document.body && clientOverlay.parentNode) {
    document.body.removeChild(clientOverlay);
  }
}

function problemType (type) {
  var problemColors = {
    errors: colors.red,
    warnings: colors.yellow
  };
  var color = problemColors[type] || colors.red;
  return (
    '<span style="background-color:#' + color + '; color:#fff; padding:2px 4px; border-radius: 2px">' +
      type.slice(0, -1).toUpperCase() +
    '</span>'
  );
}

module.exports = function(options) {
  for (var color in options.overlayColors) {
    if (color in colors) {
      colors[color] = options.overlayColors[color];
    }
    ansiHTML.setColors(colors);
  }

  for (var style in options.overlayStyles) {
    styles[style] = options.overlayStyles[style];
  }

  for (var key in styles) {
    clientOverlay.style[key] = styles[key];
  }

  return {
    showProblems: showProblems,
    clear: clear
  }
};

module.exports.clear = clear;
module.exports.showProblems = showProblems;


/***/ }),

/***/ "./node_modules/webpack-hot-middleware/client.js?path=__webpack_hmr&dynamicPublicPath=true":
/*!************************************************************************************!*\
  !*** (webpack)-hot-middleware/client.js?path=__webpack_hmr&dynamicPublicPath=true ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__resourceQuery, module) {/*eslint-env browser*/
/*global __resourceQuery __webpack_public_path__*/

var options = {
  path: "/__webpack_hmr",
  timeout: 20 * 1000,
  overlay: true,
  reload: false,
  log: true,
  warn: true,
  name: '',
  autoConnect: true,
  overlayStyles: {},
  overlayWarnings: false,
  ansiColors: {}
};
if (true) {
  var querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");
  var overrides = querystring.parse(__resourceQuery.slice(1));
  setOverrides(overrides);
}

if (typeof window === 'undefined') {
  // do nothing
} else if (typeof window.EventSource === 'undefined') {
  console.warn(
    "webpack-hot-middleware's client requires EventSource to work. " +
    "You should include a polyfill if you want to support this browser: " +
    "https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events#Tools"
  );
} else {
  if (options.autoConnect) {
    connect();
  }
}

/* istanbul ignore next */
function setOptionsAndConnect(overrides) {
  setOverrides(overrides);
  connect();
}

function setOverrides(overrides) {
  if (overrides.autoConnect) options.autoConnect = overrides.autoConnect == 'true';
  if (overrides.path) options.path = overrides.path;
  if (overrides.timeout) options.timeout = overrides.timeout;
  if (overrides.overlay) options.overlay = overrides.overlay !== 'false';
  if (overrides.reload) options.reload = overrides.reload !== 'false';
  if (overrides.noInfo && overrides.noInfo !== 'false') {
    options.log = false;
  }
  if (overrides.name) {
    options.name = overrides.name;
  }
  if (overrides.quiet && overrides.quiet !== 'false') {
    options.log = false;
    options.warn = false;
  }

  if (overrides.dynamicPublicPath) {
    options.path = __webpack_require__.p + options.path;
  }

  if (overrides.ansiColors) options.ansiColors = JSON.parse(overrides.ansiColors);
  if (overrides.overlayStyles) options.overlayStyles = JSON.parse(overrides.overlayStyles);

  if (overrides.overlayWarnings) {
    options.overlayWarnings = overrides.overlayWarnings == 'true';
  }
}

function EventSourceWrapper() {
  var source;
  var lastActivity = new Date();
  var listeners = [];

  init();
  var timer = setInterval(function() {
    if ((new Date() - lastActivity) > options.timeout) {
      handleDisconnect();
    }
  }, options.timeout / 2);

  function init() {
    source = new window.EventSource(options.path);
    source.onopen = handleOnline;
    source.onerror = handleDisconnect;
    source.onmessage = handleMessage;
  }

  function handleOnline() {
    if (options.log) console.log("[HMR] connected");
    lastActivity = new Date();
  }

  function handleMessage(event) {
    lastActivity = new Date();
    for (var i = 0; i < listeners.length; i++) {
      listeners[i](event);
    }
  }

  function handleDisconnect() {
    clearInterval(timer);
    source.close();
    setTimeout(init, options.timeout);
  }

  return {
    addMessageListener: function(fn) {
      listeners.push(fn);
    }
  };
}

function getEventSourceWrapper() {
  if (!window.__whmEventSourceWrapper) {
    window.__whmEventSourceWrapper = {};
  }
  if (!window.__whmEventSourceWrapper[options.path]) {
    // cache the wrapper for other entries loaded on
    // the same page with the same options.path
    window.__whmEventSourceWrapper[options.path] = EventSourceWrapper();
  }
  return window.__whmEventSourceWrapper[options.path];
}

function connect() {
  getEventSourceWrapper().addMessageListener(handleMessage);

  function handleMessage(event) {
    if (event.data == "\uD83D\uDC93") {
      return;
    }
    try {
      processMessage(JSON.parse(event.data));
    } catch (ex) {
      if (options.warn) {
        console.warn("Invalid HMR message: " + event.data + "\n" + ex);
      }
    }
  }
}

// the reporter needs to be a singleton on the page
// in case the client is being used by multiple bundles
// we only want to report once.
// all the errors will go to all clients
var singletonKey = '__webpack_hot_middleware_reporter__';
var reporter;
if (typeof window !== 'undefined') {
  if (!window[singletonKey]) {
    window[singletonKey] = createReporter();
  }
  reporter = window[singletonKey];
}

function createReporter() {
  var strip = __webpack_require__(/*! strip-ansi */ "./node_modules/strip-ansi/index.js");

  var overlay;
  if (typeof document !== 'undefined' && options.overlay) {
    overlay = __webpack_require__(/*! ./client-overlay */ "./node_modules/webpack-hot-middleware/client-overlay.js")({
      ansiColors: options.ansiColors,
      overlayStyles: options.overlayStyles
    });
  }

  var styles = {
    errors: "color: #ff0000;",
    warnings: "color: #999933;"
  };
  var previousProblems = null;
  function log(type, obj) {
    var newProblems = obj[type].map(function(msg) { return strip(msg); }).join('\n');
    if (previousProblems == newProblems) {
      return;
    } else {
      previousProblems = newProblems;
    }

    var style = styles[type];
    var name = obj.name ? "'" + obj.name + "' " : "";
    var title = "[HMR] bundle " + name + "has " + obj[type].length + " " + type;
    // NOTE: console.warn or console.error will print the stack trace
    // which isn't helpful here, so using console.log to escape it.
    if (console.group && console.groupEnd) {
      console.group("%c" + title, style);
      console.log("%c" + newProblems, style);
      console.groupEnd();
    } else {
      console.log(
        "%c" + title + "\n\t%c" + newProblems.replace(/\n/g, "\n\t"),
        style + "font-weight: bold;",
        style + "font-weight: normal;"
      );
    }
  }

  return {
    cleanProblemsCache: function () {
      previousProblems = null;
    },
    problems: function(type, obj) {
      if (options.warn) {
        log(type, obj);
      }
      if (overlay) {
        if (options.overlayWarnings || type === 'errors') {
          overlay.showProblems(type, obj[type]);
          return false;
        }
        overlay.clear();
      }
      return true;
    },
    success: function() {
      if (overlay) overlay.clear();
    },
    useCustomOverlay: function(customOverlay) {
      overlay = customOverlay;
    }
  };
}

var processUpdate = __webpack_require__(/*! ./process-update */ "./node_modules/webpack-hot-middleware/process-update.js");

var customHandler;
var subscribeAllHandler;
function processMessage(obj) {
  switch(obj.action) {
    case "building":
      if (options.log) {
        console.log(
          "[HMR] bundle " + (obj.name ? "'" + obj.name + "' " : "") +
          "rebuilding"
        );
      }
      break;
    case "built":
      if (options.log) {
        console.log(
          "[HMR] bundle " + (obj.name ? "'" + obj.name + "' " : "") +
          "rebuilt in " + obj.time + "ms"
        );
      }
      // fall through
    case "sync":
      if (obj.name && options.name && obj.name !== options.name) {
        return;
      }
      var applyUpdate = true;
      if (obj.errors.length > 0) {
        if (reporter) reporter.problems('errors', obj);
        applyUpdate = false;
      } else if (obj.warnings.length > 0) {
        if (reporter) {
          var overlayShown = reporter.problems('warnings', obj);
          applyUpdate = overlayShown;
        }
      } else {
        if (reporter) {
          reporter.cleanProblemsCache();
          reporter.success();
        }
      }
      if (applyUpdate) {
        processUpdate(obj.hash, obj.modules, options);
      }
      break;
    default:
      if (customHandler) {
        customHandler(obj);
      }
  }

  if (subscribeAllHandler) {
    subscribeAllHandler(obj);
  }
}

if (module) {
  module.exports = {
    subscribeAll: function subscribeAll(handler) {
      subscribeAllHandler = handler;
    },
    subscribe: function subscribe(handler) {
      customHandler = handler;
    },
    useCustomOverlay: function useCustomOverlay(customOverlay) {
      if (reporter) reporter.useCustomOverlay(customOverlay);
    },
    setOptionsAndConnect: setOptionsAndConnect
  };
}

/* WEBPACK VAR INJECTION */}.call(this, "?path=__webpack_hmr&dynamicPublicPath=true", __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/webpack-hot-middleware/process-update.js":
/*!**************************************************!*\
  !*** (webpack)-hot-middleware/process-update.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Based heavily on https://github.com/webpack/webpack/blob/
 *  c0afdf9c6abc1dd70707c594e473802a566f7b6e/hot/only-dev-server.js
 * Original copyright Tobias Koppers @sokra (MIT license)
 */

/* global window __webpack_hash__ */

if (false) {}

var hmrDocsUrl = "https://webpack.js.org/concepts/hot-module-replacement/"; // eslint-disable-line max-len

var lastHash;
var failureStatuses = { abort: 1, fail: 1 };
var applyOptions = { 				
  ignoreUnaccepted: true,
  ignoreDeclined: true,
  ignoreErrored: true,
  onUnaccepted: function(data) {
    console.warn("Ignored an update to unaccepted module " + data.chain.join(" -> "));
  },
  onDeclined: function(data) {
    console.warn("Ignored an update to declined module " + data.chain.join(" -> "));
  },
  onErrored: function(data) {
    console.error(data.error);
    console.warn("Ignored an error while updating module " + data.moduleId + " (" + data.type + ")");
  } 
}

function upToDate(hash) {
  if (hash) lastHash = hash;
  return lastHash == __webpack_require__.h();
}

module.exports = function(hash, moduleMap, options) {
  var reload = options.reload;
  if (!upToDate(hash) && module.hot.status() == "idle") {
    if (options.log) console.log("[HMR] Checking for updates on the server...");
    check();
  }

  function check() {
    var cb = function(err, updatedModules) {
      if (err) return handleError(err);

      if(!updatedModules) {
        if (options.warn) {
          console.warn("[HMR] Cannot find update (Full reload needed)");
          console.warn("[HMR] (Probably because of restarting the server)");
        }
        performReload();
        return null;
      }

      var applyCallback = function(applyErr, renewedModules) {
        if (applyErr) return handleError(applyErr);

        if (!upToDate()) check();

        logUpdates(updatedModules, renewedModules);
      };

      var applyResult = module.hot.apply(applyOptions, applyCallback);
      // webpack 2 promise
      if (applyResult && applyResult.then) {
        // HotModuleReplacement.runtime.js refers to the result as `outdatedModules`
        applyResult.then(function(outdatedModules) {
          applyCallback(null, outdatedModules);
        });
        applyResult.catch(applyCallback);
      }

    };

    var result = module.hot.check(false, cb);
    // webpack 2 promise
    if (result && result.then) {
        result.then(function(updatedModules) {
            cb(null, updatedModules);
        });
        result.catch(cb);
    }
  }

  function logUpdates(updatedModules, renewedModules) {
    var unacceptedModules = updatedModules.filter(function(moduleId) {
      return renewedModules && renewedModules.indexOf(moduleId) < 0;
    });

    if(unacceptedModules.length > 0) {
      if (options.warn) {
        console.warn(
          "[HMR] The following modules couldn't be hot updated: " +
          "(Full reload needed)\n" +
          "This is usually because the modules which have changed " +
          "(and their parents) do not know how to hot reload themselves. " +
          "See " + hmrDocsUrl + " for more details."
        );
        unacceptedModules.forEach(function(moduleId) {
          console.warn("[HMR]  - " + (moduleMap[moduleId] || moduleId));
        });
      }
      performReload();
      return;
    }

    if (options.log) {
      if(!renewedModules || renewedModules.length === 0) {
        console.log("[HMR] Nothing hot updated.");
      } else {
        console.log("[HMR] Updated modules:");
        renewedModules.forEach(function(moduleId) {
          console.log("[HMR]  - " + (moduleMap[moduleId] || moduleId));
        });
      }

      if (upToDate()) {
        console.log("[HMR] App is up to date.");
      }
    }
  }

  function handleError(err) {
    if (module.hot.status() in failureStatuses) {
      if (options.warn) {
        console.warn("[HMR] Cannot check for update (Full reload needed)");
        console.warn("[HMR] " + (err.stack || err.message));
      }
      performReload();
      return;
    }
    if (options.warn) {
      console.warn("[HMR] Update check failed: " + (err.stack || err.message));
    }
  }

  function performReload() {
    if (reload) {
      if (options.warn) console.warn("[HMR] Reloading page");
      window.location.reload();
    }
  }
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/css/main.css":
/*!**************************!*\
  !*** ./src/css/main.css ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! ./css/main.css */ "./src/css/main.css");
var signalR = __webpack_require__(/*! @aspnet/signalr */ "./node_modules/@aspnet/signalr/dist/esm/index.js");
var Konva = __webpack_require__(/*! konva */ "./node_modules/konva/konva.js");
var divMessages = document.querySelector("#divMessages");
var tbMessage = document.querySelector("#tbMessage");
var btnSend = document.querySelector("#btnSend");
var divCanvas = document.querySelector("#divCanvas");
var username = new Date().getTime();
var connection = new signalR.HubConnectionBuilder()
    .withUrl("/hub")
    .build();
connection.start().catch(function (err) { return document.write(err); });
connection.on("messageReceived", function (username, message) {
    console.log('connection.on START');
    var messageContainer = document.createElement("div");
    messageContainer.innerHTML =
        "<div class=\"message-author\">" + username + "</div><div>" + message + "</div>";
    divMessages.appendChild(messageContainer);
    divMessages.scrollTop = divMessages.scrollHeight;
    showGrid();
    console.log('connection.on END');
});
tbMessage.addEventListener("keyup", function (e) {
    if (e.keyCode === 13) {
        send();
    }
});
btnSend.addEventListener("click", send);
function send() {
    connection.send("newMessage", username, tbMessage.value)
        .then(function () { return tbMessage.value = ""; });
}
function showGrid() {
    var WIDTH = 3000;
    var HEIGHT = 3000;
    var NUMBER = 200;
    var stage = new Konva.Stage({
        container: 'container',
        width: window.innerWidth,
        height: window.innerHeight,
    });
    var layer = new Konva.Layer();
    stage.add(layer);
    function generateNode() {
        return new Konva.Circle({
            x: WIDTH * Math.random(),
            y: HEIGHT * Math.random(),
            radius: 50,
            fill: 'red',
            stroke: 'black'
        });
    }
    for (var i = 0; i < NUMBER; i++) {
        layer.add(generateNode());
    }
    layer.draw();
    var scrollContainer = document.getElementById('scroll-container');
    scrollContainer.addEventListener('scroll', function () {
        var dx = scrollContainer.scrollLeft;
        var dy = scrollContainer.scrollTop;
        stage.container().style.transform = 'translate(' + dx + 'px, ' + dy + 'px)';
        stage.x(-dx);
        stage.y(-dy);
        stage.batchDraw();
    });
}
function paintCanvas() {
    // first we need to create a stage
    var stage = new Konva.Stage({
        container: 'divCanvas',
        width: 500,
        height: 500
    });
    // then create layer
    var layer = new Konva.Layer();
    // create our shape
    var circle = new Konva.Circle({
        x: stage.getWidth() / 2,
        y: stage.getHeight() / 2,
        radius: 70,
        fill: 'yellow',
        stroke: 'black',
        strokeWidth: 4
    });
    // add the shape to the layer
    layer.add(circle);
    // add the layer to the stage
    stage.add(layer);
    // draw the image
    layer.draw();
}


/***/ }),

/***/ 0:
/*!****************************************************************************************************!*\
  !*** multi webpack-hot-middleware/client?path=__webpack_hmr&dynamicPublicPath=true ./src/index.ts ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! webpack-hot-middleware/client?path=__webpack_hmr&dynamicPublicPath=true */"./node_modules/webpack-hot-middleware/client.js?path=__webpack_hmr&dynamicPublicPath=true");
module.exports = __webpack_require__(/*! ./src/index.ts */"./src/index.ts");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhc3BuZXQvc2lnbmFsci9kaXN0L2VzbS9BYm9ydENvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhc3BuZXQvc2lnbmFsci9kaXN0L2VzbS9EZWZhdWx0SHR0cENsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFzcG5ldC9zaWduYWxyL2Rpc3QvZXNtL0Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFzcG5ldC9zaWduYWxyL2Rpc3QvZXNtL0hhbmRzaGFrZVByb3RvY29sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXNwbmV0L3NpZ25hbHIvZGlzdC9lc20vSHR0cENsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFzcG5ldC9zaWduYWxyL2Rpc3QvZXNtL0h0dHBDb25uZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXNwbmV0L3NpZ25hbHIvZGlzdC9lc20vSHViQ29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFzcG5ldC9zaWduYWxyL2Rpc3QvZXNtL0h1YkNvbm5lY3Rpb25CdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXNwbmV0L3NpZ25hbHIvZGlzdC9lc20vSUh1YlByb3RvY29sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXNwbmV0L3NpZ25hbHIvZGlzdC9lc20vSUxvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFzcG5ldC9zaWduYWxyL2Rpc3QvZXNtL0lUcmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhc3BuZXQvc2lnbmFsci9kaXN0L2VzbS9Kc29uSHViUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhc3BuZXQvc2lnbmFsci9kaXN0L2VzbS9Mb2dnZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXNwbmV0L3NpZ25hbHIvZGlzdC9lc20vTG9uZ1BvbGxpbmdUcmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhc3BuZXQvc2lnbmFsci9kaXN0L2VzbS9TZXJ2ZXJTZW50RXZlbnRzVHJhbnNwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXNwbmV0L3NpZ25hbHIvZGlzdC9lc20vVGV4dE1lc3NhZ2VGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhc3BuZXQvc2lnbmFsci9kaXN0L2VzbS9VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFzcG5ldC9zaWduYWxyL2Rpc3QvZXNtL1dlYlNvY2tldFRyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFzcG5ldC9zaWduYWxyL2Rpc3QvZXNtL1hockh0dHBDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhc3BuZXQvc2lnbmFsci9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNC1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDUtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL3htbC1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva29udmEva29udmEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWhvdC1taWRkbGV3YXJlL2NsaWVudC1vdmVybGF5LmpzIiwid2VicGFjazovLy8od2VicGFjayktaG90LW1pZGRsZXdhcmUvY2xpZW50LmpzIiwid2VicGFjazovLy8od2VicGFjayktaG90LW1pZGRsZXdhcmUvcHJvY2Vzcy11cGRhdGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9jc3MvbWFpbi5jc3M/MTE3ZiIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUE2QjtBQUM3QixxQ0FBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBa0IsOEJBQThCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEJBQTBCLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFP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aUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFB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QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFrQztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPLFlBQVksb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2Qyw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTyxRQUFRLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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QU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU8saUVBQWlFO0FBQ3JGO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHdDQUF3QztBQUM3RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLFNBQVM7QUFDN0MsOENBQThDLFNBQVM7QUFDdkQsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3Q0FBd0M7QUFDN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLCtCQUErQixXQUFXO0FBQzFDLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHRmdW5jdGlvbiBob3REaXNwb3NlQ2h1bmsoY2h1bmtJZCkge1xuIFx0XHRkZWxldGUgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuIFx0fVxuIFx0dmFyIHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrID0gd2luZG93W1wid2VicGFja0hvdFVwZGF0ZVwiXTtcbiBcdHdpbmRvd1tcIndlYnBhY2tIb3RVcGRhdGVcIl0gPSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIHdlYnBhY2tIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcykge1xuIFx0XHRob3RBZGRVcGRhdGVDaHVuayhjaHVua0lkLCBtb3JlTW9kdWxlcyk7XG4gXHRcdGlmIChwYXJlbnRIb3RVcGRhdGVDYWxsYmFjaykgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xuIFx0fSA7XG5cbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRVcGRhdGVDaHVuayhjaHVua0lkKSB7XG4gXHRcdHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuIFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiBcdFx0c2NyaXB0LmNoYXJzZXQgPSBcInV0Zi04XCI7XG4gXHRcdHNjcmlwdC5zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzXCI7XG4gXHRcdGlmIChudWxsKSBzY3JpcHQuY3Jvc3NPcmlnaW4gPSBudWxsO1xuIFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gXHR9XG5cbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRNYW5pZmVzdChyZXF1ZXN0VGltZW91dCkge1xuIFx0XHRyZXF1ZXN0VGltZW91dCA9IHJlcXVlc3RUaW1lb3V0IHx8IDEwMDAwO1xuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gXHRcdFx0aWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJObyBicm93c2VyIHN1cHBvcnRcIikpO1xuIFx0XHRcdH1cbiBcdFx0XHR0cnkge1xuIFx0XHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiBcdFx0XHRcdHZhciByZXF1ZXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNvblwiO1xuIFx0XHRcdFx0cmVxdWVzdC5vcGVuKFwiR0VUXCIsIHJlcXVlc3RQYXRoLCB0cnVlKTtcbiBcdFx0XHRcdHJlcXVlc3QudGltZW91dCA9IHJlcXVlc3RUaW1lb3V0O1xuIFx0XHRcdFx0cmVxdWVzdC5zZW5kKG51bGwpO1xuIFx0XHRcdH0gY2F0Y2ggKGVycikge1xuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChlcnIpO1xuIFx0XHRcdH1cbiBcdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuIFx0XHRcdFx0aWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkgcmV0dXJuO1xuIFx0XHRcdFx0aWYgKHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gXHRcdFx0XHRcdC8vIHRpbWVvdXRcbiBcdFx0XHRcdFx0cmVqZWN0KFxuIFx0XHRcdFx0XHRcdG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIHRpbWVkIG91dC5cIilcbiBcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xuIFx0XHRcdFx0XHQvLyBubyB1cGRhdGUgYXZhaWxhYmxlXG4gXHRcdFx0XHRcdHJlc29sdmUoKTtcbiBcdFx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMzA0KSB7XG4gXHRcdFx0XHRcdC8vIG90aGVyIGZhaWx1cmVcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIGZhaWxlZC5cIikpO1xuIFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0Ly8gc3VjY2Vzc1xuIFx0XHRcdFx0XHR0cnkge1xuIFx0XHRcdFx0XHRcdHZhciB1cGRhdGUgPSBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiBcdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuIFx0XHRcdFx0XHRcdHJlamVjdChlKTtcbiBcdFx0XHRcdFx0XHRyZXR1cm47XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0cmVzb2x2ZSh1cGRhdGUpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH07XG4gXHRcdH0pO1xuIFx0fVxuXG4gXHR2YXIgaG90QXBwbHlPblVwZGF0ZSA9IHRydWU7XG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdHZhciBob3RDdXJyZW50SGFzaCA9IFwiNWJhNjExMzkyZDM3NWJlOWMwZWVcIjtcbiBcdHZhciBob3RSZXF1ZXN0VGltZW91dCA9IDEwMDAwO1xuIFx0dmFyIGhvdEN1cnJlbnRNb2R1bGVEYXRhID0ge307XG4gXHR2YXIgaG90Q3VycmVudENoaWxkTW9kdWxlO1xuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHMgPSBbXTtcbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCA9IFtdO1xuXG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpIHtcbiBcdFx0dmFyIG1lID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdGlmICghbWUpIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fO1xuIFx0XHR2YXIgZm4gPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gXHRcdFx0aWYgKG1lLmhvdC5hY3RpdmUpIHtcbiBcdFx0XHRcdGlmIChpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdKSB7XG4gXHRcdFx0XHRcdGlmIChpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPT09IC0xKSB7XG4gXHRcdFx0XHRcdFx0aW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLnB1c2gobW9kdWxlSWQpO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFttb2R1bGVJZF07XG4gXHRcdFx0XHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHJlcXVlc3Q7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAobWUuY2hpbGRyZW4uaW5kZXhPZihyZXF1ZXN0KSA9PT0gLTEpIHtcbiBcdFx0XHRcdFx0bWUuY2hpbGRyZW4ucHVzaChyZXF1ZXN0KTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0Y29uc29sZS53YXJuKFxuIFx0XHRcdFx0XHRcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArXG4gXHRcdFx0XHRcdFx0cmVxdWVzdCArXG4gXHRcdFx0XHRcdFx0XCIpIGZyb20gZGlzcG9zZWQgbW9kdWxlIFwiICtcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZFxuIFx0XHRcdFx0KTtcbiBcdFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW107XG4gXHRcdFx0fVxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHJlcXVlc3QpO1xuIFx0XHR9O1xuIFx0XHR2YXIgT2JqZWN0RmFjdG9yeSA9IGZ1bmN0aW9uIE9iamVjdEZhY3RvcnkobmFtZSkge1xuIFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcbiBcdFx0XHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX19bbmFtZV07XG4gXHRcdFx0XHR9LFxuIFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuIFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdID0gdmFsdWU7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fTtcbiBcdFx0fTtcbiBcdFx0Zm9yICh2YXIgbmFtZSBpbiBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9fd2VicGFja19yZXF1aXJlX18sIG5hbWUpICYmXG4gXHRcdFx0XHRuYW1lICE9PSBcImVcIiAmJlxuIFx0XHRcdFx0bmFtZSAhPT0gXCJ0XCJcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgT2JqZWN0RmFjdG9yeShuYW1lKSk7XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGZuLmUgPSBmdW5jdGlvbihjaHVua0lkKSB7XG4gXHRcdFx0aWYgKGhvdFN0YXR1cyA9PT0gXCJyZWFkeVwiKSBob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xuIFx0XHRcdGhvdENodW5rc0xvYWRpbmcrKztcbiBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5lKGNodW5rSWQpLnRoZW4oZmluaXNoQ2h1bmtMb2FkaW5nLCBmdW5jdGlvbihlcnIpIHtcbiBcdFx0XHRcdGZpbmlzaENodW5rTG9hZGluZygpO1xuIFx0XHRcdFx0dGhyb3cgZXJyO1xuIFx0XHRcdH0pO1xuXG4gXHRcdFx0ZnVuY3Rpb24gZmluaXNoQ2h1bmtMb2FkaW5nKCkge1xuIFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZy0tO1xuIFx0XHRcdFx0aWYgKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIpIHtcbiBcdFx0XHRcdFx0aWYgKCFob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0pIHtcbiBcdFx0XHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRpZiAoaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcbiBcdFx0XHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH07XG4gXHRcdGZuLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRcdGlmIChtb2RlICYgMSkgdmFsdWUgPSBmbih2YWx1ZSk7XG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18udCh2YWx1ZSwgbW9kZSAmIH4xKTtcbiBcdFx0fTtcbiBcdFx0cmV0dXJuIGZuO1xuIFx0fVxuXG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZU1vZHVsZShtb2R1bGVJZCkge1xuIFx0XHR2YXIgaG90ID0ge1xuIFx0XHRcdC8vIHByaXZhdGUgc3R1ZmZcbiBcdFx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxuIFx0XHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXG4gXHRcdFx0X3NlbGZBY2NlcHRlZDogZmFsc2UsXG4gXHRcdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXG4gXHRcdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXG4gXHRcdFx0X21haW46IGhvdEN1cnJlbnRDaGlsZE1vZHVsZSAhPT0gbW9kdWxlSWQsXG5cbiBcdFx0XHQvLyBNb2R1bGUgQVBJXG4gXHRcdFx0YWN0aXZlOiB0cnVlLFxuIFx0XHRcdGFjY2VwdDogZnVuY3Rpb24oZGVwLCBjYWxsYmFjaykge1xuIFx0XHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZBY2NlcHRlZCA9IHRydWU7XG4gXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpIGhvdC5fc2VsZkFjY2VwdGVkID0gZGVwO1xuIFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcbiBcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG4gXHRcdFx0XHRcdFx0aG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBbaV1dID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbiBcdFx0XHRcdGVsc2UgaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBdID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbiBcdFx0XHR9LFxuIFx0XHRcdGRlY2xpbmU6IGZ1bmN0aW9uKGRlcCkge1xuIFx0XHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZEZWNsaW5lZCA9IHRydWU7XG4gXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKVxuIFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcbiBcdFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcF0gPSB0cnVlO1xuIFx0XHRcdH0sXG4gXHRcdFx0ZGlzcG9zZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiBcdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xuIFx0XHRcdH0sXG4gXHRcdFx0YWRkRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcbiBcdFx0XHR9LFxuIFx0XHRcdHJlbW92ZURpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdC5fZGlzcG9zZUhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuIFx0XHRcdFx0aWYgKGlkeCA+PSAwKSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHR9LFxuXG4gXHRcdFx0Ly8gTWFuYWdlbWVudCBBUElcbiBcdFx0XHRjaGVjazogaG90Q2hlY2ssXG4gXHRcdFx0YXBwbHk6IGhvdEFwcGx5LFxuIFx0XHRcdHN0YXR1czogZnVuY3Rpb24obCkge1xuIFx0XHRcdFx0aWYgKCFsKSByZXR1cm4gaG90U3RhdHVzO1xuIFx0XHRcdFx0aG90U3RhdHVzSGFuZGxlcnMucHVzaChsKTtcbiBcdFx0XHR9LFxuIFx0XHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG4gXHRcdFx0fSxcbiBcdFx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XG4gXHRcdFx0XHR2YXIgaWR4ID0gaG90U3RhdHVzSGFuZGxlcnMuaW5kZXhPZihsKTtcbiBcdFx0XHRcdGlmIChpZHggPj0gMCkgaG90U3RhdHVzSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0fSxcblxuIFx0XHRcdC8vaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxuIFx0XHRcdGRhdGE6IGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXVxuIFx0XHR9O1xuIFx0XHRob3RDdXJyZW50Q2hpbGRNb2R1bGUgPSB1bmRlZmluZWQ7XG4gXHRcdHJldHVybiBob3Q7XG4gXHR9XG5cbiBcdHZhciBob3RTdGF0dXNIYW5kbGVycyA9IFtdO1xuIFx0dmFyIGhvdFN0YXR1cyA9IFwiaWRsZVwiO1xuXG4gXHRmdW5jdGlvbiBob3RTZXRTdGF0dXMobmV3U3RhdHVzKSB7XG4gXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcbiBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBob3RTdGF0dXNIYW5kbGVycy5sZW5ndGg7IGkrKylcbiBcdFx0XHRob3RTdGF0dXNIYW5kbGVyc1tpXS5jYWxsKG51bGwsIG5ld1N0YXR1cyk7XG4gXHR9XG5cbiBcdC8vIHdoaWxlIGRvd25sb2FkaW5nXG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzID0gMDtcbiBcdHZhciBob3RDaHVua3NMb2FkaW5nID0gMDtcbiBcdHZhciBob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcbiBcdHZhciBob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xuIFx0dmFyIGhvdEF2YWlsYWJsZUZpbGVzTWFwID0ge307XG4gXHR2YXIgaG90RGVmZXJyZWQ7XG5cbiBcdC8vIFRoZSB1cGRhdGUgaW5mb1xuIFx0dmFyIGhvdFVwZGF0ZSwgaG90VXBkYXRlTmV3SGFzaDtcblxuIFx0ZnVuY3Rpb24gdG9Nb2R1bGVJZChpZCkge1xuIFx0XHR2YXIgaXNOdW1iZXIgPSAraWQgKyBcIlwiID09PSBpZDtcbiBcdFx0cmV0dXJuIGlzTnVtYmVyID8gK2lkIDogaWQ7XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdENoZWNrKGFwcGx5KSB7XG4gXHRcdGlmIChob3RTdGF0dXMgIT09IFwiaWRsZVwiKSB7XG4gXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY2hlY2soKSBpcyBvbmx5IGFsbG93ZWQgaW4gaWRsZSBzdGF0dXNcIik7XG4gXHRcdH1cbiBcdFx0aG90QXBwbHlPblVwZGF0ZSA9IGFwcGx5O1xuIFx0XHRob3RTZXRTdGF0dXMoXCJjaGVja1wiKTtcbiBcdFx0cmV0dXJuIGhvdERvd25sb2FkTWFuaWZlc3QoaG90UmVxdWVzdFRpbWVvdXQpLnRoZW4oZnVuY3Rpb24odXBkYXRlKSB7XG4gXHRcdFx0aWYgKCF1cGRhdGUpIHtcbiBcdFx0XHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XG4gXHRcdFx0XHRyZXR1cm4gbnVsbDtcbiBcdFx0XHR9XG4gXHRcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXAgPSB7fTtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcbiBcdFx0XHRob3RBdmFpbGFibGVGaWxlc01hcCA9IHVwZGF0ZS5jO1xuIFx0XHRcdGhvdFVwZGF0ZU5ld0hhc2ggPSB1cGRhdGUuaDtcblxuIFx0XHRcdGhvdFNldFN0YXR1cyhcInByZXBhcmVcIik7XG4gXHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiBcdFx0XHRcdGhvdERlZmVycmVkID0ge1xuIFx0XHRcdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxuIFx0XHRcdFx0XHRyZWplY3Q6IHJlamVjdFxuIFx0XHRcdFx0fTtcbiBcdFx0XHR9KTtcbiBcdFx0XHRob3RVcGRhdGUgPSB7fTtcbiBcdFx0XHR2YXIgY2h1bmtJZCA9IFwibWFpblwiO1xuIFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xuIFx0XHRcdHtcbiBcdFx0XHRcdC8qZ2xvYmFscyBjaHVua0lkICovXG4gXHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcbiBcdFx0XHR9XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0aG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJlxuIFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJlxuIFx0XHRcdFx0aG90V2FpdGluZ0ZpbGVzID09PSAwXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XG4gXHRcdFx0fVxuIFx0XHRcdHJldHVybiBwcm9taXNlO1xuIFx0XHR9KTtcbiBcdH1cblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3RBZGRVcGRhdGVDaHVuayhjaHVua0lkLCBtb3JlTW9kdWxlcykge1xuIFx0XHRpZiAoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdIHx8ICFob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSlcbiBcdFx0XHRyZXR1cm47XG4gXHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gZmFsc2U7XG4gXHRcdGZvciAodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRob3RVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRpZiAoLS1ob3RXYWl0aW5nRmlsZXMgPT09IDAgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCkge1xuIFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKSB7XG4gXHRcdGlmICghaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0pIHtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xuIFx0XHR9IGVsc2Uge1xuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXMrKztcbiBcdFx0XHRob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpO1xuIFx0XHR9XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdFVwZGF0ZURvd25sb2FkZWQoKSB7XG4gXHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xuIFx0XHR2YXIgZGVmZXJyZWQgPSBob3REZWZlcnJlZDtcbiBcdFx0aG90RGVmZXJyZWQgPSBudWxsO1xuIFx0XHRpZiAoIWRlZmVycmVkKSByZXR1cm47XG4gXHRcdGlmIChob3RBcHBseU9uVXBkYXRlKSB7XG4gXHRcdFx0Ly8gV3JhcCBkZWZlcnJlZCBvYmplY3QgaW4gUHJvbWlzZSB0byBtYXJrIGl0IGFzIGEgd2VsbC1oYW5kbGVkIFByb21pc2UgdG9cbiBcdFx0XHQvLyBhdm9pZCB0cmlnZ2VyaW5nIHVuY2F1Z2h0IGV4Y2VwdGlvbiB3YXJuaW5nIGluIENocm9tZS5cbiBcdFx0XHQvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDY1NjY2XG4gXHRcdFx0UHJvbWlzZS5yZXNvbHZlKClcbiBcdFx0XHRcdC50aGVuKGZ1bmN0aW9uKCkge1xuIFx0XHRcdFx0XHRyZXR1cm4gaG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSk7XG4gXHRcdFx0XHR9KVxuIFx0XHRcdFx0LnRoZW4oXG4gXHRcdFx0XHRcdGZ1bmN0aW9uKHJlc3VsdCkge1xuIFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiBcdFx0XHRcdFx0fSxcbiBcdFx0XHRcdFx0ZnVuY3Rpb24oZXJyKSB7XG4gXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KGVycik7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdCk7XG4gXHRcdH0gZWxzZSB7XG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuIFx0XHRcdGZvciAodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xuIFx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaCh0b01vZHVsZUlkKGlkKSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHRcdGRlZmVycmVkLnJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RBcHBseShvcHRpb25zKSB7XG4gXHRcdGlmIChob3RTdGF0dXMgIT09IFwicmVhZHlcIilcbiBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhcHBseSgpIGlzIG9ubHkgYWxsb3dlZCBpbiByZWFkeSBzdGF0dXNcIik7XG4gXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gXHRcdHZhciBjYjtcbiBcdFx0dmFyIGk7XG4gXHRcdHZhciBqO1xuIFx0XHR2YXIgbW9kdWxlO1xuIFx0XHR2YXIgbW9kdWxlSWQ7XG5cbiBcdFx0ZnVuY3Rpb24gZ2V0QWZmZWN0ZWRTdHVmZih1cGRhdGVNb2R1bGVJZCkge1xuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xuIFx0XHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xuXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCkubWFwKGZ1bmN0aW9uKGlkKSB7XG4gXHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRjaGFpbjogW2lkXSxcbiBcdFx0XHRcdFx0aWQ6IGlkXG4gXHRcdFx0XHR9O1xuIFx0XHRcdH0pO1xuIFx0XHRcdHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gXHRcdFx0XHR2YXIgcXVldWVJdGVtID0gcXVldWUucG9wKCk7XG4gXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZUl0ZW0uaWQ7XG4gXHRcdFx0XHR2YXIgY2hhaW4gPSBxdWV1ZUl0ZW0uY2hhaW47XG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdGlmICghbW9kdWxlIHx8IG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZCkgY29udGludWU7XG4gXHRcdFx0XHRpZiAobW9kdWxlLmhvdC5fc2VsZkRlY2xpbmVkKSB7XG4gXHRcdFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWRlY2xpbmVkXCIsXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuIFx0XHRcdFx0XHR9O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKG1vZHVsZS5ob3QuX21haW4pIHtcbiBcdFx0XHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdFx0XHR0eXBlOiBcInVuYWNjZXB0ZWRcIixcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXG4gXHRcdFx0XHRcdH07XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZS5wYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0XHRcdHZhciBwYXJlbnRJZCA9IG1vZHVsZS5wYXJlbnRzW2ldO1xuIFx0XHRcdFx0XHR2YXIgcGFyZW50ID0gaW5zdGFsbGVkTW9kdWxlc1twYXJlbnRJZF07XG4gXHRcdFx0XHRcdGlmICghcGFyZW50KSBjb250aW51ZTtcbiBcdFx0XHRcdFx0aWYgKHBhcmVudC5ob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xuIFx0XHRcdFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHRcdFx0XHR0eXBlOiBcImRlY2xpbmVkXCIsXG4gXHRcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRcdFx0cGFyZW50SWQ6IHBhcmVudElkXG4gXHRcdFx0XHRcdFx0fTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRpZiAob3V0ZGF0ZWRNb2R1bGVzLmluZGV4T2YocGFyZW50SWQpICE9PSAtMSkgY29udGludWU7XG4gXHRcdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRcdFx0XHRpZiAoIW91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSlcbiBcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xuIFx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSwgW21vZHVsZUlkXSk7XG4gXHRcdFx0XHRcdFx0Y29udGludWU7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXTtcbiBcdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2gocGFyZW50SWQpO1xuIFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHtcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxuIFx0XHRcdFx0XHRcdGlkOiBwYXJlbnRJZFxuIFx0XHRcdFx0XHR9KTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG5cbiBcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0dHlwZTogXCJhY2NlcHRlZFwiLFxuIFx0XHRcdFx0bW9kdWxlSWQ6IHVwZGF0ZU1vZHVsZUlkLFxuIFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzOiBvdXRkYXRlZE1vZHVsZXMsXG4gXHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llczogb3V0ZGF0ZWREZXBlbmRlbmNpZXNcbiBcdFx0XHR9O1xuIFx0XHR9XG5cbiBcdFx0ZnVuY3Rpb24gYWRkQWxsVG9TZXQoYSwgYikge1xuIFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0dmFyIGl0ZW0gPSBiW2ldO1xuIFx0XHRcdFx0aWYgKGEuaW5kZXhPZihpdGVtKSA9PT0gLTEpIGEucHVzaChpdGVtKTtcbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBhdCBiZWdpbiBhbGwgdXBkYXRlcyBtb2R1bGVzIGFyZSBvdXRkYXRlZFxuIFx0XHQvLyB0aGUgXCJvdXRkYXRlZFwiIHN0YXR1cyBjYW4gcHJvcGFnYXRlIHRvIHBhcmVudHMgaWYgdGhleSBkb24ndCBhY2NlcHQgdGhlIGNoaWxkcmVuXG4gXHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xuIFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XG4gXHRcdHZhciBhcHBsaWVkVXBkYXRlID0ge307XG5cbiBcdFx0dmFyIHdhcm5VbmV4cGVjdGVkUmVxdWlyZSA9IGZ1bmN0aW9uIHdhcm5VbmV4cGVjdGVkUmVxdWlyZSgpIHtcbiBcdFx0XHRjb25zb2xlLndhcm4oXG4gXHRcdFx0XHRcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIHJlc3VsdC5tb2R1bGVJZCArIFwiKSB0byBkaXNwb3NlZCBtb2R1bGVcIlxuIFx0XHRcdCk7XG4gXHRcdH07XG5cbiBcdFx0Zm9yICh2YXIgaWQgaW4gaG90VXBkYXRlKSB7XG4gXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xuIFx0XHRcdFx0bW9kdWxlSWQgPSB0b01vZHVsZUlkKGlkKTtcbiBcdFx0XHRcdC8qKiBAdHlwZSB7VE9ET30gKi9cbiBcdFx0XHRcdHZhciByZXN1bHQ7XG4gXHRcdFx0XHRpZiAoaG90VXBkYXRlW2lkXSkge1xuIFx0XHRcdFx0XHRyZXN1bHQgPSBnZXRBZmZlY3RlZFN0dWZmKG1vZHVsZUlkKTtcbiBcdFx0XHRcdH0gZWxzZSB7XG4gXHRcdFx0XHRcdHJlc3VsdCA9IHtcbiBcdFx0XHRcdFx0XHR0eXBlOiBcImRpc3Bvc2VkXCIsXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IGlkXG4gXHRcdFx0XHRcdH07XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHQvKiogQHR5cGUge0Vycm9yfGZhbHNlfSAqL1xuIFx0XHRcdFx0dmFyIGFib3J0RXJyb3IgPSBmYWxzZTtcbiBcdFx0XHRcdHZhciBkb0FwcGx5ID0gZmFsc2U7XG4gXHRcdFx0XHR2YXIgZG9EaXNwb3NlID0gZmFsc2U7XG4gXHRcdFx0XHR2YXIgY2hhaW5JbmZvID0gXCJcIjtcbiBcdFx0XHRcdGlmIChyZXN1bHQuY2hhaW4pIHtcbiBcdFx0XHRcdFx0Y2hhaW5JbmZvID0gXCJcXG5VcGRhdGUgcHJvcGFnYXRpb246IFwiICsgcmVzdWx0LmNoYWluLmpvaW4oXCIgLT4gXCIpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0c3dpdGNoIChyZXN1bHQudHlwZSkge1xuIFx0XHRcdFx0XHRjYXNlIFwic2VsZi1kZWNsaW5lZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGVjbGluZWQpIG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xuIFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG4gXHRcdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIG9mIHNlbGYgZGVjbGluZTogXCIgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5tb2R1bGVJZCArXG4gXHRcdFx0XHRcdFx0XHRcdFx0Y2hhaW5JbmZvXG4gXHRcdFx0XHRcdFx0XHQpO1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0XHRjYXNlIFwiZGVjbGluZWRcIjpcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRlY2xpbmVkKSBvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuIFx0XHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBvZiBkZWNsaW5lZCBkZXBlbmRlbmN5OiBcIiArXG4gXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm1vZHVsZUlkICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRcIiBpbiBcIiArXG4gXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0LnBhcmVudElkICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRjaGFpbkluZm9cbiBcdFx0XHRcdFx0XHRcdCk7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGNhc2UgXCJ1bmFjY2VwdGVkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25VbmFjY2VwdGVkKSBvcHRpb25zLm9uVW5hY2NlcHRlZChyZXN1bHQpO1xuIFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVVbmFjY2VwdGVkKVxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcbiBcdFx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2UgXCIgKyBtb2R1bGVJZCArIFwiIGlzIG5vdCBhY2NlcHRlZFwiICsgY2hhaW5JbmZvXG4gXHRcdFx0XHRcdFx0XHQpO1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0XHRjYXNlIFwiYWNjZXB0ZWRcIjpcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkFjY2VwdGVkKSBvcHRpb25zLm9uQWNjZXB0ZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRkb0FwcGx5ID0gdHJ1ZTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcImRpc3Bvc2VkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EaXNwb3NlZCkgb3B0aW9ucy5vbkRpc3Bvc2VkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0ZG9EaXNwb3NlID0gdHJ1ZTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0ZGVmYXVsdDpcbiBcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4Y2VwdGlvbiB0eXBlIFwiICsgcmVzdWx0LnR5cGUpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKGFib3J0RXJyb3IpIHtcbiBcdFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiYWJvcnRcIik7XG4gXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmIChkb0FwcGx5KSB7XG4gXHRcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gaG90VXBkYXRlW21vZHVsZUlkXTtcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHQub3V0ZGF0ZWRNb2R1bGVzKTtcbiBcdFx0XHRcdFx0Zm9yIChtb2R1bGVJZCBpbiByZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcbiBcdFx0XHRcdFx0XHRpZiAoXG4gXHRcdFx0XHRcdFx0XHRPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcyxcbiBcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWRcbiBcdFx0XHRcdFx0XHRcdClcbiBcdFx0XHRcdFx0XHQpIHtcbiBcdFx0XHRcdFx0XHRcdGlmICghb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKVxuIFx0XHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0gPSBbXTtcbiBcdFx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KFxuIFx0XHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0sXG4gXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF1cbiBcdFx0XHRcdFx0XHRcdCk7XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAoZG9EaXNwb3NlKSB7XG4gXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgW3Jlc3VsdC5tb2R1bGVJZF0pO1xuIFx0XHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IHdhcm5VbmV4cGVjdGVkUmVxdWlyZTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBTdG9yZSBzZWxmIGFjY2VwdGVkIG91dGRhdGVkIG1vZHVsZXMgdG8gcmVxdWlyZSB0aGVtIGxhdGVyIGJ5IHRoZSBtb2R1bGUgc3lzdGVtXG4gXHRcdHZhciBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMgPSBbXTtcbiBcdFx0Zm9yIChpID0gMDsgaSA8IG91dGRhdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdG1vZHVsZUlkID0gb3V0ZGF0ZWRNb2R1bGVzW2ldO1xuIFx0XHRcdGlmIChcbiBcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdICYmXG4gXHRcdFx0XHRpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxuIFx0XHRcdClcbiBcdFx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcbiBcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxuIFx0XHRcdFx0fSk7XG4gXHRcdH1cblxuIFx0XHQvLyBOb3cgaW4gXCJkaXNwb3NlXCIgcGhhc2VcbiBcdFx0aG90U2V0U3RhdHVzKFwiZGlzcG9zZVwiKTtcbiBcdFx0T2JqZWN0LmtleXMoaG90QXZhaWxhYmxlRmlsZXNNYXApLmZvckVhY2goZnVuY3Rpb24oY2h1bmtJZCkge1xuIFx0XHRcdGlmIChob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSA9PT0gZmFsc2UpIHtcbiBcdFx0XHRcdGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKTtcbiBcdFx0XHR9XG4gXHRcdH0pO1xuXG4gXHRcdHZhciBpZHg7XG4gXHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpO1xuIFx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuIFx0XHRcdG1vZHVsZUlkID0gcXVldWUucG9wKCk7XG4gXHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0aWYgKCFtb2R1bGUpIGNvbnRpbnVlO1xuXG4gXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuIFx0XHRcdC8vIENhbGwgZGlzcG9zZSBoYW5kbGVyc1xuIFx0XHRcdHZhciBkaXNwb3NlSGFuZGxlcnMgPSBtb2R1bGUuaG90Ll9kaXNwb3NlSGFuZGxlcnM7XG4gXHRcdFx0Zm9yIChqID0gMDsgaiA8IGRpc3Bvc2VIYW5kbGVycy5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0Y2IgPSBkaXNwb3NlSGFuZGxlcnNbal07XG4gXHRcdFx0XHRjYihkYXRhKTtcbiBcdFx0XHR9XG4gXHRcdFx0aG90Q3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdID0gZGF0YTtcblxuIFx0XHRcdC8vIGRpc2FibGUgbW9kdWxlICh0aGlzIGRpc2FibGVzIHJlcXVpcmVzIGZyb20gdGhpcyBtb2R1bGUpXG4gXHRcdFx0bW9kdWxlLmhvdC5hY3RpdmUgPSBmYWxzZTtcblxuIFx0XHRcdC8vIHJlbW92ZSBtb2R1bGUgZnJvbSBjYWNoZVxuIFx0XHRcdGRlbGV0ZSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcblxuIFx0XHRcdC8vIHdoZW4gZGlzcG9zaW5nIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBkaXNwb3NlIGhhbmRsZXJcbiBcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xuXG4gXHRcdFx0Ly8gcmVtb3ZlIFwicGFyZW50c1wiIHJlZmVyZW5jZXMgZnJvbSBhbGwgY2hpbGRyZW5cbiBcdFx0XHRmb3IgKGogPSAwOyBqIDwgbW9kdWxlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gXHRcdFx0XHR2YXIgY2hpbGQgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZS5jaGlsZHJlbltqXV07XG4gXHRcdFx0XHRpZiAoIWNoaWxkKSBjb250aW51ZTtcbiBcdFx0XHRcdGlkeCA9IGNoaWxkLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCk7XG4gXHRcdFx0XHRpZiAoaWR4ID49IDApIHtcbiBcdFx0XHRcdFx0Y2hpbGQucGFyZW50cy5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxuIFx0XHR2YXIgZGVwZW5kZW5jeTtcbiBcdFx0dmFyIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzO1xuIFx0XHRmb3IgKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZClcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdFx0aWYgKG1vZHVsZSkge1xuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xuIFx0XHRcdFx0XHRcdGlkeCA9IG1vZHVsZS5jaGlsZHJlbi5pbmRleE9mKGRlcGVuZGVuY3kpO1xuIFx0XHRcdFx0XHRcdGlmIChpZHggPj0gMCkgbW9kdWxlLmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTm90IGluIFwiYXBwbHlcIiBwaGFzZVxuIFx0XHRob3RTZXRTdGF0dXMoXCJhcHBseVwiKTtcblxuIFx0XHRob3RDdXJyZW50SGFzaCA9IGhvdFVwZGF0ZU5ld0hhc2g7XG5cbiBcdFx0Ly8gaW5zZXJ0IG5ldyBjb2RlXG4gXHRcdGZvciAobW9kdWxlSWQgaW4gYXBwbGllZFVwZGF0ZSkge1xuIFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXBwbGllZFVwZGF0ZSwgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdO1xuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIGNhbGwgYWNjZXB0IGhhbmRsZXJzXG4gXHRcdHZhciBlcnJvciA9IG51bGw7XG4gXHRcdGZvciAobW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcbiBcdFx0XHRpZiAoXG4gXHRcdFx0XHRPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKVxuIFx0XHRcdCkge1xuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRpZiAobW9kdWxlKSB7XG4gXHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID0gb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xuIFx0XHRcdFx0XHR2YXIgY2FsbGJhY2tzID0gW107XG4gXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0XHRcdGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tpXTtcbiBcdFx0XHRcdFx0XHRjYiA9IG1vZHVsZS5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcGVuZGVuY3ldO1xuIFx0XHRcdFx0XHRcdGlmIChjYikge1xuIFx0XHRcdFx0XHRcdFx0aWYgKGNhbGxiYWNrcy5pbmRleE9mKGNiKSAhPT0gLTEpIGNvbnRpbnVlO1xuIFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzLnB1c2goY2IpO1xuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0XHRcdFx0Y2IgPSBjYWxsYmFja3NbaV07XG4gXHRcdFx0XHRcdFx0dHJ5IHtcbiBcdFx0XHRcdFx0XHRcdGNiKG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzKTtcbiBcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiBcdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuIFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG4gXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJhY2NlcHQtZXJyb3JlZFwiLFxuIFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2ldLFxuIFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcbiBcdFx0XHRcdFx0XHRcdFx0fSk7XG4gXHRcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuIFx0XHRcdFx0XHRcdFx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiBcdFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBMb2FkIHNlbGYgYWNjZXB0ZWQgbW9kdWxlc1xuIFx0XHRmb3IgKGkgPSAwOyBpIDwgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbaV07XG4gXHRcdFx0bW9kdWxlSWQgPSBpdGVtLm1vZHVsZTtcbiBcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFttb2R1bGVJZF07XG4gXHRcdFx0dHJ5IHtcbiBcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpO1xuIFx0XHRcdH0gY2F0Y2ggKGVycikge1xuIFx0XHRcdFx0aWYgKHR5cGVvZiBpdGVtLmVycm9ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gXHRcdFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyKTtcbiBcdFx0XHRcdFx0fSBjYXRjaCAoZXJyMikge1xuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuIFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxuIFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG4gXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxuIFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcbiBcdFx0XHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuIFx0XHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnIyO1xuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuIFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvcmVkXCIsXG4gXHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG4gXHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXG4gXHRcdFx0XHRcdFx0fSk7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXG4gXHRcdGlmIChlcnJvcikge1xuIFx0XHRcdGhvdFNldFN0YXR1cyhcImZhaWxcIik7XG4gXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiBcdFx0fVxuXG4gXHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XG4gXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gXHRcdFx0cmVzb2x2ZShvdXRkYXRlZE1vZHVsZXMpO1xuIFx0XHR9KTtcbiBcdH1cblxuIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aG90OiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpLFxuIFx0XHRcdHBhcmVudHM6IChob3RDdXJyZW50UGFyZW50c1RlbXAgPSBob3RDdXJyZW50UGFyZW50cywgaG90Q3VycmVudFBhcmVudHMgPSBbXSwgaG90Q3VycmVudFBhcmVudHNUZW1wKSxcbiBcdFx0XHRjaGlsZHJlbjogW11cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgaG90Q3JlYXRlUmVxdWlyZShtb2R1bGVJZCkpO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG4gXHQvLyBfX3dlYnBhY2tfaGFzaF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIGhvdENyZWF0ZVJlcXVpcmUoMCkoX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIC5ORVQgRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbi8vIFJvdWdoIHBvbHlmaWxsIG9mIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydENvbnRyb2xsZXJcclxuLy8gV2UgZG9uJ3QgYWN0dWFsbHkgZXZlciB1c2UgdGhlIEFQSSBiZWluZyBwb2x5ZmlsbGVkLCB3ZSBhbHdheXMgdXNlIHRoZSBwb2x5ZmlsbCBiZWNhdXNlXHJcbi8vIGl0J3MgYSB2ZXJ5IG5ldyBBUEkgcmlnaHQgbm93LlxyXG4vLyBOb3QgZXhwb3J0ZWQgZnJvbSBpbmRleC5cclxuLyoqIEBwcml2YXRlICovXHJcbnZhciBBYm9ydENvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBYm9ydENvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgdGhpcy5pc0Fib3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9uYWJvcnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgQWJvcnRDb250cm9sbGVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNBYm9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNBYm9ydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25hYm9ydCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbmFib3J0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFib3J0Q29udHJvbGxlci5wcm90b3R5cGUsIFwic2lnbmFsXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJvcnRDb250cm9sbGVyLnByb3RvdHlwZSwgXCJhYm9ydGVkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBYm9ydGVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEFib3J0Q29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0IHsgQWJvcnRDb250cm9sbGVyIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFib3J0Q29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIC5ORVQgRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5pbXBvcnQgeyBBYm9ydEVycm9yIH0gZnJvbSBcIi4vRXJyb3JzXCI7XHJcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tIFwiLi9IdHRwQ2xpZW50XCI7XHJcbmltcG9ydCB7IFhockh0dHBDbGllbnQgfSBmcm9tIFwiLi9YaHJIdHRwQ2xpZW50XCI7XHJcbnZhciBub2RlSHR0cENsaWVudE1vZHVsZTtcclxuaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgLy8gSW4gb3JkZXIgdG8gaWdub3JlIHRoZSBkeW5hbWljIHJlcXVpcmUgaW4gd2VicGFjayBidWlsZHMgd2UgbmVlZCB0byBkbyB0aGlzIG1hZ2ljXHJcbiAgICAvLyBAdHMtaWdub3JlOiBUUyBkb2Vzbid0IGtub3cgYWJvdXQgdGhlc2UgbmFtZXNcclxuICAgIHZhciByZXF1aXJlRnVuYyA9IHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fID09PSBcImZ1bmN0aW9uXCIgPyBfX25vbl93ZWJwYWNrX3JlcXVpcmVfXyA6IHJlcXVpcmU7XHJcbiAgICBub2RlSHR0cENsaWVudE1vZHVsZSA9IHJlcXVpcmVGdW5jKFwiLi9Ob2RlSHR0cENsaWVudFwiKTtcclxufVxyXG4vKiogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQGFzcG5ldC9zaWduYWxyLkh0dHBDbGllbnR9LiAqL1xyXG52YXIgRGVmYXVsdEh0dHBDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGVmYXVsdEh0dHBDbGllbnQsIF9zdXBlcik7XHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEBhc3BuZXQvc2lnbmFsci5EZWZhdWx0SHR0cENsaWVudH0sIHVzaW5nIHRoZSBwcm92aWRlZCB7QGxpbmsgQGFzcG5ldC9zaWduYWxyLklMb2dnZXJ9IHRvIGxvZyBtZXNzYWdlcy4gKi9cclxuICAgIGZ1bmN0aW9uIERlZmF1bHRIdHRwQ2xpZW50KGxvZ2dlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICBfdGhpcy5odHRwQ2xpZW50ID0gbmV3IFhockh0dHBDbGllbnQobG9nZ2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5vZGVIdHRwQ2xpZW50TW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmh0dHBDbGllbnQgPSBuZXcgbm9kZUh0dHBDbGllbnRNb2R1bGUuTm9kZUh0dHBDbGllbnQobG9nZ2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIEh0dHBDbGllbnQgY291bGQgYmUgY3JlYXRlZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgRGVmYXVsdEh0dHBDbGllbnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgYWJvcnQgd2FzIG5vdCBzaWduYWxlZCBiZWZvcmUgY2FsbGluZyBzZW5kXHJcbiAgICAgICAgaWYgKHJlcXVlc3QuYWJvcnRTaWduYWwgJiYgcmVxdWVzdC5hYm9ydFNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQWJvcnRFcnJvcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZXF1ZXN0Lm1ldGhvZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gbWV0aG9kIGRlZmluZWQuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZXF1ZXN0LnVybCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gdXJsIGRlZmluZWQuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5zZW5kKHJlcXVlc3QpO1xyXG4gICAgfTtcclxuICAgIERlZmF1bHRIdHRwQ2xpZW50LnByb3RvdHlwZS5nZXRDb29raWVTdHJpbmcgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5nZXRDb29raWVTdHJpbmcodXJsKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVmYXVsdEh0dHBDbGllbnQ7XHJcbn0oSHR0cENsaWVudCkpO1xyXG5leHBvcnQgeyBEZWZhdWx0SHR0cENsaWVudCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWZhdWx0SHR0cENsaWVudC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIC5ORVQgRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG4vKiogRXJyb3IgdGhyb3duIHdoZW4gYW4gSFRUUCByZXF1ZXN0IGZhaWxzLiAqL1xyXG52YXIgSHR0cEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEh0dHBFcnJvciwgX3N1cGVyKTtcclxuICAgIC8qKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBAYXNwbmV0L3NpZ25hbHIuSHR0cEVycm9yfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JNZXNzYWdlIEEgZGVzY3JpcHRpdmUgZXJyb3IgbWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBIVFRQIHN0YXR1cyBjb2RlIHJlcHJlc2VudGVkIGJ5IHRoaXMgZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEh0dHBFcnJvcihlcnJvck1lc3NhZ2UsIHN0YXR1c0NvZGUpIHtcclxuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdHJ1ZVByb3RvID0gX25ld1RhcmdldC5wcm90b3R5cGU7XHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlcnJvck1lc3NhZ2UpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XHJcbiAgICAgICAgLy8gV29ya2Fyb3VuZCBpc3N1ZSBpbiBUeXBlc2NyaXB0IGNvbXBpbGVyXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMzk2NSNpc3N1ZWNvbW1lbnQtMjc4NTcwMjAwXHJcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gdHJ1ZVByb3RvO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBIdHRwRXJyb3I7XHJcbn0oRXJyb3IpKTtcclxuZXhwb3J0IHsgSHR0cEVycm9yIH07XHJcbi8qKiBFcnJvciB0aHJvd24gd2hlbiBhIHRpbWVvdXQgZWxhcHNlcy4gKi9cclxudmFyIFRpbWVvdXRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUaW1lb3V0RXJyb3IsIF9zdXBlcik7XHJcbiAgICAvKiogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgQGFzcG5ldC9zaWduYWxyLlRpbWVvdXRFcnJvcn0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVycm9yTWVzc2FnZSBBIGRlc2NyaXB0aXZlIGVycm9yIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFRpbWVvdXRFcnJvcihlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZSA9PT0gdm9pZCAwKSB7IGVycm9yTWVzc2FnZSA9IFwiQSB0aW1lb3V0IG9jY3VycmVkLlwiOyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdHJ1ZVByb3RvID0gX25ld1RhcmdldC5wcm90b3R5cGU7XHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlcnJvck1lc3NhZ2UpIHx8IHRoaXM7XHJcbiAgICAgICAgLy8gV29ya2Fyb3VuZCBpc3N1ZSBpbiBUeXBlc2NyaXB0IGNvbXBpbGVyXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMzk2NSNpc3N1ZWNvbW1lbnQtMjc4NTcwMjAwXHJcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gdHJ1ZVByb3RvO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBUaW1lb3V0RXJyb3I7XHJcbn0oRXJyb3IpKTtcclxuZXhwb3J0IHsgVGltZW91dEVycm9yIH07XHJcbi8qKiBFcnJvciB0aHJvd24gd2hlbiBhbiBhY3Rpb24gaXMgYWJvcnRlZC4gKi9cclxudmFyIEFib3J0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWJvcnRFcnJvciwgX3N1cGVyKTtcclxuICAgIC8qKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBBYm9ydEVycm9yfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JNZXNzYWdlIEEgZGVzY3JpcHRpdmUgZXJyb3IgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQWJvcnRFcnJvcihlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZSA9PT0gdm9pZCAwKSB7IGVycm9yTWVzc2FnZSA9IFwiQW4gYWJvcnQgb2NjdXJyZWQuXCI7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB0cnVlUHJvdG8gPSBfbmV3VGFyZ2V0LnByb3RvdHlwZTtcclxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVycm9yTWVzc2FnZSkgfHwgdGhpcztcclxuICAgICAgICAvLyBXb3JrYXJvdW5kIGlzc3VlIGluIFR5cGVzY3JpcHQgY29tcGlsZXJcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEzOTY1I2lzc3VlY29tbWVudC0yNzg1NzAyMDBcclxuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSB0cnVlUHJvdG87XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFib3J0RXJyb3I7XHJcbn0oRXJyb3IpKTtcclxuZXhwb3J0IHsgQWJvcnRFcnJvciB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvcnMuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSAuTkVUIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG5pbXBvcnQgeyBUZXh0TWVzc2FnZUZvcm1hdCB9IGZyb20gXCIuL1RleHRNZXNzYWdlRm9ybWF0XCI7XHJcbmltcG9ydCB7IGlzQXJyYXlCdWZmZXIgfSBmcm9tIFwiLi9VdGlsc1wiO1xyXG4vKiogQHByaXZhdGUgKi9cclxudmFyIEhhbmRzaGFrZVByb3RvY29sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSGFuZHNoYWtlUHJvdG9jb2woKSB7XHJcbiAgICB9XHJcbiAgICAvLyBIYW5kc2hha2UgcmVxdWVzdCBpcyBhbHdheXMgSlNPTlxyXG4gICAgSGFuZHNoYWtlUHJvdG9jb2wucHJvdG90eXBlLndyaXRlSGFuZHNoYWtlUmVxdWVzdCA9IGZ1bmN0aW9uIChoYW5kc2hha2VSZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIFRleHRNZXNzYWdlRm9ybWF0LndyaXRlKEpTT04uc3RyaW5naWZ5KGhhbmRzaGFrZVJlcXVlc3QpKTtcclxuICAgIH07XHJcbiAgICBIYW5kc2hha2VQcm90b2NvbC5wcm90b3R5cGUucGFyc2VIYW5kc2hha2VSZXNwb25zZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIHJlc3BvbnNlTWVzc2FnZTtcclxuICAgICAgICB2YXIgbWVzc2FnZURhdGE7XHJcbiAgICAgICAgdmFyIHJlbWFpbmluZ0RhdGE7XHJcbiAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXIoZGF0YSkgfHwgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcclxuICAgICAgICAgICAgLy8gRm9ybWF0IGlzIGJpbmFyeSBidXQgc3RpbGwgbmVlZCB0byByZWFkIEpTT04gdGV4dCBmcm9tIGhhbmRzaGFrZSByZXNwb25zZVxyXG4gICAgICAgICAgICB2YXIgYmluYXJ5RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9ySW5kZXggPSBiaW5hcnlEYXRhLmluZGV4T2YoVGV4dE1lc3NhZ2VGb3JtYXQuUmVjb3JkU2VwYXJhdG9yQ29kZSk7XHJcbiAgICAgICAgICAgIGlmIChzZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2UgaXMgaW5jb21wbGV0ZS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29udGVudCBiZWZvcmUgc2VwYXJhdG9yIGlzIGhhbmRzaGFrZSByZXNwb25zZVxyXG4gICAgICAgICAgICAvLyBvcHRpb25hbCBjb250ZW50IGFmdGVyIGlzIGFkZGl0aW9uYWwgbWVzc2FnZXNcclxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlTGVuZ3RoID0gc2VwYXJhdG9ySW5kZXggKyAxO1xyXG4gICAgICAgICAgICBtZXNzYWdlRGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmluYXJ5RGF0YS5zbGljZSgwLCByZXNwb25zZUxlbmd0aCkpO1xyXG4gICAgICAgICAgICByZW1haW5pbmdEYXRhID0gKGJpbmFyeURhdGEuYnl0ZUxlbmd0aCA+IHJlc3BvbnNlTGVuZ3RoKSA/IGJpbmFyeURhdGEuc2xpY2UocmVzcG9uc2VMZW5ndGgpLmJ1ZmZlciA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgdGV4dERhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9ySW5kZXggPSB0ZXh0RGF0YS5pbmRleE9mKFRleHRNZXNzYWdlRm9ybWF0LlJlY29yZFNlcGFyYXRvcik7XHJcbiAgICAgICAgICAgIGlmIChzZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2UgaXMgaW5jb21wbGV0ZS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29udGVudCBiZWZvcmUgc2VwYXJhdG9yIGlzIGhhbmRzaGFrZSByZXNwb25zZVxyXG4gICAgICAgICAgICAvLyBvcHRpb25hbCBjb250ZW50IGFmdGVyIGlzIGFkZGl0aW9uYWwgbWVzc2FnZXNcclxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlTGVuZ3RoID0gc2VwYXJhdG9ySW5kZXggKyAxO1xyXG4gICAgICAgICAgICBtZXNzYWdlRGF0YSA9IHRleHREYXRhLnN1YnN0cmluZygwLCByZXNwb25zZUxlbmd0aCk7XHJcbiAgICAgICAgICAgIHJlbWFpbmluZ0RhdGEgPSAodGV4dERhdGEubGVuZ3RoID4gcmVzcG9uc2VMZW5ndGgpID8gdGV4dERhdGEuc3Vic3RyaW5nKHJlc3BvbnNlTGVuZ3RoKSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2Ugc2hvdWxkIGhhdmUganVzdCB0aGUgc2luZ2xlIGhhbmRzaGFrZSBtZXNzYWdlXHJcbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gVGV4dE1lc3NhZ2VGb3JtYXQucGFyc2UobWVzc2FnZURhdGEpO1xyXG4gICAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UobWVzc2FnZXNbMF0pO1xyXG4gICAgICAgIGlmIChyZXNwb25zZS50eXBlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGEgaGFuZHNoYWtlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IHJlc3BvbnNlO1xyXG4gICAgICAgIC8vIG11bHRpcGxlIG1lc3NhZ2VzIGNvdWxkIGhhdmUgYXJyaXZlZCB3aXRoIGhhbmRzaGFrZVxyXG4gICAgICAgIC8vIHJldHVybiBhZGRpdGlvbmFsIGRhdGEgdG8gYmUgcGFyc2VkIGFzIHVzdWFsLCBvciBudWxsIGlmIGFsbCBwYXJzZWRcclxuICAgICAgICByZXR1cm4gW3JlbWFpbmluZ0RhdGEsIHJlc3BvbnNlTWVzc2FnZV07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhhbmRzaGFrZVByb3RvY29sO1xyXG59KCkpO1xyXG5leHBvcnQgeyBIYW5kc2hha2VQcm90b2NvbCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1IYW5kc2hha2VQcm90b2NvbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIC5ORVQgRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xyXG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn07XHJcbi8qKiBSZXByZXNlbnRzIGFuIEhUVFAgcmVzcG9uc2UuICovXHJcbnZhciBIdHRwUmVzcG9uc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIdHRwUmVzcG9uc2Uoc3RhdHVzQ29kZSwgc3RhdHVzVGV4dCwgY29udGVudCkge1xyXG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XHJcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcclxuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEh0dHBSZXNwb25zZTtcclxufSgpKTtcclxuZXhwb3J0IHsgSHR0cFJlc3BvbnNlIH07XHJcbi8qKiBBYnN0cmFjdGlvbiBvdmVyIGFuIEhUVFAgY2xpZW50LlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGFuIGFic3RyYWN0aW9uIG92ZXIgYW4gSFRUUCBjbGllbnQgc28gdGhhdCBhIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbiBjYW4gYmUgcHJvdmlkZWQgb24gZGlmZmVyZW50IHBsYXRmb3Jtcy5cclxuICovXHJcbnZhciBIdHRwQ2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSHR0cENsaWVudCgpIHtcclxuICAgIH1cclxuICAgIEh0dHBDbGllbnQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKF9fYXNzaWduKHt9LCBvcHRpb25zLCB7IG1ldGhvZDogXCJHRVRcIiwgdXJsOiB1cmwgfSkpO1xyXG4gICAgfTtcclxuICAgIEh0dHBDbGllbnQucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChfX2Fzc2lnbih7fSwgb3B0aW9ucywgeyBtZXRob2Q6IFwiUE9TVFwiLCB1cmw6IHVybCB9KSk7XHJcbiAgICB9O1xyXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQoX19hc3NpZ24oe30sIG9wdGlvbnMsIHsgbWV0aG9kOiBcIkRFTEVURVwiLCB1cmw6IHVybCB9KSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEdldHMgYWxsIGNvb2tpZXMgdGhhdCBhcHBseSB0byB0aGUgc3BlY2lmaWVkIFVSTC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgdGhhdCB0aGUgY29va2llcyBhcmUgdmFsaWQgZm9yLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgY29udGFpbmluZyBhbGwgdGhlIGtleS12YWx1ZSBjb29raWUgcGFpcnMgZm9yIHRoZSBzcGVjaWZpZWQgVVJMLlxyXG4gICAgICovXHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5nZXRDb29raWVTdHJpbmcgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEh0dHBDbGllbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEh0dHBDbGllbnQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SHR0cENsaWVudC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIC5ORVQgRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufTtcclxuaW1wb3J0IHsgRGVmYXVsdEh0dHBDbGllbnQgfSBmcm9tIFwiLi9EZWZhdWx0SHR0cENsaWVudFwiO1xyXG5pbXBvcnQgeyBMb2dMZXZlbCB9IGZyb20gXCIuL0lMb2dnZXJcIjtcclxuaW1wb3J0IHsgSHR0cFRyYW5zcG9ydFR5cGUsIFRyYW5zZmVyRm9ybWF0IH0gZnJvbSBcIi4vSVRyYW5zcG9ydFwiO1xyXG5pbXBvcnQgeyBMb25nUG9sbGluZ1RyYW5zcG9ydCB9IGZyb20gXCIuL0xvbmdQb2xsaW5nVHJhbnNwb3J0XCI7XHJcbmltcG9ydCB7IFNlcnZlclNlbnRFdmVudHNUcmFuc3BvcnQgfSBmcm9tIFwiLi9TZXJ2ZXJTZW50RXZlbnRzVHJhbnNwb3J0XCI7XHJcbmltcG9ydCB7IEFyZywgY3JlYXRlTG9nZ2VyIH0gZnJvbSBcIi4vVXRpbHNcIjtcclxuaW1wb3J0IHsgV2ViU29ja2V0VHJhbnNwb3J0IH0gZnJvbSBcIi4vV2ViU29ja2V0VHJhbnNwb3J0XCI7XHJcbnZhciBNQVhfUkVESVJFQ1RTID0gMTAwO1xyXG52YXIgV2ViU29ja2V0TW9kdWxlID0gbnVsbDtcclxudmFyIEV2ZW50U291cmNlTW9kdWxlID0gbnVsbDtcclxuaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIC8vIEluIG9yZGVyIHRvIGlnbm9yZSB0aGUgZHluYW1pYyByZXF1aXJlIGluIHdlYnBhY2sgYnVpbGRzIHdlIG5lZWQgdG8gZG8gdGhpcyBtYWdpY1xyXG4gICAgLy8gQHRzLWlnbm9yZTogVFMgZG9lc24ndCBrbm93IGFib3V0IHRoZXNlIG5hbWVzXHJcbiAgICB2YXIgcmVxdWlyZUZ1bmMgPSB0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXyA9PT0gXCJmdW5jdGlvblwiID8gX19ub25fd2VicGFja19yZXF1aXJlX18gOiByZXF1aXJlO1xyXG4gICAgV2ViU29ja2V0TW9kdWxlID0gcmVxdWlyZUZ1bmMoXCJ3c1wiKTtcclxuICAgIEV2ZW50U291cmNlTW9kdWxlID0gcmVxdWlyZUZ1bmMoXCJldmVudHNvdXJjZVwiKTtcclxufVxyXG4vKiogQHByaXZhdGUgKi9cclxudmFyIEh0dHBDb25uZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSHR0cENvbm5lY3Rpb24odXJsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB0aGlzLmZlYXR1cmVzID0ge307XHJcbiAgICAgICAgQXJnLmlzUmVxdWlyZWQodXJsLCBcInVybFwiKTtcclxuICAgICAgICB0aGlzLmxvZ2dlciA9IGNyZWF0ZUxvZ2dlcihvcHRpb25zLmxvZ2dlcik7XHJcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gdGhpcy5yZXNvbHZlVXJsKHVybCk7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgb3B0aW9ucy5sb2dNZXNzYWdlQ29udGVudCA9IG9wdGlvbnMubG9nTWVzc2FnZUNvbnRlbnQgfHwgZmFsc2U7XHJcbiAgICAgICAgdmFyIGlzTm9kZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCI7XHJcbiAgICAgICAgaWYgKCFpc05vZGUgJiYgdHlwZW9mIFdlYlNvY2tldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhb3B0aW9ucy5XZWJTb2NrZXQpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTm9kZSAmJiAhb3B0aW9ucy5XZWJTb2NrZXQpIHtcclxuICAgICAgICAgICAgaWYgKFdlYlNvY2tldE1vZHVsZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5XZWJTb2NrZXQgPSBXZWJTb2NrZXRNb2R1bGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc05vZGUgJiYgdHlwZW9mIEV2ZW50U291cmNlICE9PSBcInVuZGVmaW5lZFwiICYmICFvcHRpb25zLkV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuRXZlbnRTb3VyY2UgPSBFdmVudFNvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNOb2RlICYmICFvcHRpb25zLkV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRXZlbnRTb3VyY2VNb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuRXZlbnRTb3VyY2UgPSBFdmVudFNvdXJjZU1vZHVsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmh0dHBDbGllbnQgPSBvcHRpb25zLmh0dHBDbGllbnQgfHwgbmV3IERlZmF1bHRIdHRwQ2xpZW50KHRoaXMubG9nZ2VyKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZSA9IDIgLyogRGlzY29ubmVjdGVkICovO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5vbnJlY2VpdmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25jbG9zZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBIdHRwQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodHJhbnNmZXJGb3JtYXQpIHtcclxuICAgICAgICB0cmFuc2ZlckZvcm1hdCA9IHRyYW5zZmVyRm9ybWF0IHx8IFRyYW5zZmVyRm9ybWF0LkJpbmFyeTtcclxuICAgICAgICBBcmcuaXNJbih0cmFuc2ZlckZvcm1hdCwgVHJhbnNmZXJGb3JtYXQsIFwidHJhbnNmZXJGb3JtYXRcIik7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLkRlYnVnLCBcIlN0YXJ0aW5nIGNvbm5lY3Rpb24gd2l0aCB0cmFuc2ZlciBmb3JtYXQgJ1wiICsgVHJhbnNmZXJGb3JtYXRbdHJhbnNmZXJGb3JtYXRdICsgXCInLlwiKTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uU3RhdGUgIT09IDIgLyogRGlzY29ubmVjdGVkICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJDYW5ub3Qgc3RhcnQgYSBjb25uZWN0aW9uIHRoYXQgaXMgbm90IGluIHRoZSAnRGlzY29ubmVjdGVkJyBzdGF0ZS5cIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZSA9IDAgLyogQ29ubmVjdGluZyAqLztcclxuICAgICAgICB0aGlzLnN0YXJ0UHJvbWlzZSA9IHRoaXMuc3RhcnRJbnRlcm5hbCh0cmFuc2ZlckZvcm1hdCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQcm9taXNlO1xyXG4gICAgfTtcclxuICAgIEh0dHBDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uU3RhdGUgIT09IDEgLyogQ29ubmVjdGVkICovKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZW5kIGRhdGEgaWYgdGhlIGNvbm5lY3Rpb24gaXMgbm90IGluIHRoZSAnQ29ubmVjdGVkJyBTdGF0ZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyYW5zcG9ydCB3aWxsIG5vdCBiZSBudWxsIGlmIHN0YXRlIGlzIGNvbm5lY3RlZFxyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5zZW5kKGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEh0dHBDb25uZWN0aW9uLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZV8xO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZSA9IDIgLyogRGlzY29ubmVjdGVkICovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZXJyb3IgYXMgc29vbiBhcyBwb3NzaWJsZSBvdGhlcndpc2UgdGhlcmUgaXMgYSByYWNlIGJldHdlZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHRyYW5zcG9ydCBjbG9zaW5nIGFuZCBwcm92aWRpbmcgYW4gZXJyb3IgYW5kIHRoZSBlcnJvciBmcm9tIGEgY2xvc2UgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3b3VsZCBwcmVmZXIgdGhlIGNsb3NlIG1lc3NhZ2UgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc3RhcnRQcm9taXNlXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zcG9ydCkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudHJhbnNwb3J0LnN0b3AoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDY7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBDb25uZWN0aW9uLnByb3RvdHlwZS5zdGFydEludGVybmFsID0gZnVuY3Rpb24gKHRyYW5zZmVyRm9ybWF0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCBuZWdvdGlhdGVSZXNwb25zZSwgcmVkaXJlY3RzLCBfbG9vcF8xLCB0aGlzXzEsIHN0YXRlXzEsIGVfMjtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdGhpcy5iYXNlVXJsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuRmFjdG9yeSA9IHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbkZhY3Rvcnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMTIsICwgMTNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2tpcE5lZ290aWF0aW9uKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zLnRyYW5zcG9ydCA9PT0gSHR0cFRyYW5zcG9ydFR5cGUuV2ViU29ja2V0cykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGFkZCBhIGNvbm5lY3Rpb24gSUQgaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdGhpcy5jb25zdHJ1Y3RUcmFuc3BvcnQoSHR0cFRyYW5zcG9ydFR5cGUuV2ViU29ja2V0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBqdXN0IGNhbGwgY29ubmVjdCBkaXJlY3RseSBpbiB0aGlzIGNhc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGZhbGxiYWNrIG9yIG5lZ290aWF0ZSBpbiB0aGlzIGNhc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudHJhbnNwb3J0LmNvbm5lY3QodXJsLCB0cmFuc2ZlckZvcm1hdCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGp1c3QgY2FsbCBjb25uZWN0IGRpcmVjdGx5IGluIHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gZmFsbGJhY2sgb3IgbmVnb3RpYXRlIGluIHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHRocm93IEVycm9yKFwiTmVnb3RpYXRpb24gY2FuIG9ubHkgYmUgc2tpcHBlZCB3aGVuIHVzaW5nIHRoZSBXZWJTb2NrZXQgdHJhbnNwb3J0IGRpcmVjdGx5LlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZ290aWF0ZVJlc3BvbnNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY2Nlc3NUb2tlbl8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzXzEuZ2V0TmVnb3RpYXRpb25SZXNwb25zZSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVnb3RpYXRlUmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdXNlciB0cmllcyB0byBzdG9wIHRoZSBjb25uZWN0aW9uIHdoZW4gaXQgaXMgYmVpbmcgc3RhcnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNfMS5jb25uZWN0aW9uU3RhdGUgPT09IDIgLyogRGlzY29ubmVjdGVkICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgdmFsdWU6IHZvaWQgMCB9XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWdvdGlhdGVSZXNwb25zZS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKG5lZ290aWF0ZVJlc3BvbnNlLmVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWdvdGlhdGVSZXNwb25zZS5Qcm90b2NvbFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkRldGVjdGVkIGEgY29ubmVjdGlvbiBhdHRlbXB0IHRvIGFuIEFTUC5ORVQgU2lnbmFsUiBTZXJ2ZXIuIFRoaXMgY2xpZW50IG9ubHkgc3VwcG9ydHMgY29ubmVjdGluZyB0byBhbiBBU1AuTkVUIENvcmUgU2lnbmFsUiBTZXJ2ZXIuIFNlZSBodHRwczovL2FrYS5tcy9zaWduYWxyLWNvcmUtZGlmZmVyZW5jZXMgZm9yIGRldGFpbHMuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZ290aWF0ZVJlc3BvbnNlLnVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IG5lZ290aWF0ZVJlc3BvbnNlLnVybDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWdvdGlhdGVSZXNwb25zZS5hY2Nlc3NUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuXzEgPSBuZWdvdGlhdGVSZXNwb25zZS5hY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYWNjZXNzVG9rZW5GYWN0b3J5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYWNjZXNzVG9rZW5fMTsgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0cysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDY7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzUgLyp5aWVsZCoqLywgX2xvb3BfMSgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlXzEgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBzdGF0ZV8xLnZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZ290aWF0ZVJlc3BvbnNlLnVybCAmJiByZWRpcmVjdHMgPCBNQVhfUkVESVJFQ1RTKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA5O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0cyA9PT0gTUFYX1JFRElSRUNUUyAmJiBuZWdvdGlhdGVSZXNwb25zZS51cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTmVnb3RpYXRlIHJlZGlyZWN0aW9uIGxpbWl0IGV4Y2VlZGVkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh1cmwsIHRoaXMub3B0aW9ucy50cmFuc3BvcnQsIG5lZ290aWF0ZVJlc3BvbnNlLCB0cmFuc2ZlckZvcm1hdCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQgaW5zdGFuY2VvZiBMb25nUG9sbGluZ1RyYW5zcG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlcy5pbmhlcmVudEtlZXBBbGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQub25yZWNlaXZlID0gdGhpcy5vbnJlY2VpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uY2xvc2UgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuc3RvcENvbm5lY3Rpb24oZSk7IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZSBpZiB3ZSB3ZXJlIGNvbm5lY3RpbmcgdG8gbm90IG92ZXJ3cml0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3RhdGUgaWYgdGhlIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBtYXJrZWQgYXMgRGlzY29ubmVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoMCAvKiBDb25uZWN0aW5nICovLCAxIC8qIENvbm5lY3RlZCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5FcnJvciwgXCJGYWlsZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb246IFwiICsgZV8yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdGUgPSAyIC8qIERpc2Nvbm5lY3RlZCAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBDb25uZWN0aW9uLnByb3RvdHlwZS5nZXROZWdvdGlhdGlvblJlc3BvbnNlID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBoZWFkZXJzLCB0b2tlbiwgbmVnb3RpYXRlVXJsLCByZXNwb25zZSwgZV8zO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWNjZXNzVG9rZW5GYWN0b3J5KSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5hY2Nlc3NUb2tlbkZhY3RvcnkoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0gKF9hID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCZWFyZXIgXCIgKyB0b2tlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVnb3RpYXRlVXJsID0gdGhpcy5yZXNvbHZlTmVnb3RpYXRlVXJsKHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5EZWJ1ZywgXCJTZW5kaW5nIG5lZ290aWF0aW9uIHJlcXVlc3Q6IFwiICsgbmVnb3RpYXRlVXJsICsgXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBDbGllbnQucG9zdChuZWdvdGlhdGVVcmwsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIHN0YXR1cyBjb2RlIHJldHVybmVkIGZyb20gbmVnb3RpYXRlIFwiICsgcmVzcG9uc2Uuc3RhdHVzQ29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEpTT04ucGFyc2UocmVzcG9uc2UuY29udGVudCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZV8zID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuRXJyb3IsIFwiRmFpbGVkIHRvIGNvbXBsZXRlIG5lZ290aWF0aW9uIHdpdGggdGhlIHNlcnZlcjogXCIgKyBlXzMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlXzM7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0VXJsID0gZnVuY3Rpb24gKHVybCwgY29ubmVjdGlvbklkKSB7XHJcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVybCArICh1cmwuaW5kZXhPZihcIj9cIikgPT09IC0xID8gXCI/XCIgOiBcIiZcIikgKyAoXCJpZD1cIiArIGNvbm5lY3Rpb25JZCk7XHJcbiAgICB9O1xyXG4gICAgSHR0cENvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uICh1cmwsIHJlcXVlc3RlZFRyYW5zcG9ydCwgbmVnb3RpYXRlUmVzcG9uc2UsIHJlcXVlc3RlZFRyYW5zZmVyRm9ybWF0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29ubmVjdFVybCwgdHJhbnNwb3J0cywgX2ksIHRyYW5zcG9ydHNfMSwgZW5kcG9pbnQsIHRyYW5zcG9ydCwgZXhfMTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdFVybCA9IHRoaXMuY3JlYXRlQ29ubmVjdFVybCh1cmwsIG5lZ290aWF0ZVJlc3BvbnNlLmNvbm5lY3Rpb25JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0lUcmFuc3BvcnQocmVxdWVzdGVkVHJhbnNwb3J0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5EZWJ1ZywgXCJDb25uZWN0aW9uIHdhcyBwcm92aWRlZCBhbiBpbnN0YW5jZSBvZiBJVHJhbnNwb3J0LCB1c2luZyB0aGF0IGRpcmVjdGx5LlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSByZXF1ZXN0ZWRUcmFuc3BvcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudHJhbnNwb3J0LmNvbm5lY3QoY29ubmVjdFVybCwgcmVxdWVzdGVkVHJhbnNmZXJGb3JtYXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBjaGFuZ2UgdGhlIHN0YXRlIGlmIHdlIHdlcmUgY29ubmVjdGluZyB0byBub3Qgb3ZlcndyaXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzdGF0ZSBpZiB0aGUgY29ubmVjdGlvbiBpcyBhbHJlYWR5IG1hcmtlZCBhcyBEaXNjb25uZWN0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgwIC8qIENvbm5lY3RpbmcgKi8sIDEgLyogQ29ubmVjdGVkICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0cyA9IG5lZ290aWF0ZVJlc3BvbnNlLmF2YWlsYWJsZVRyYW5zcG9ydHMgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgdHJhbnNwb3J0c18xID0gdHJhbnNwb3J0cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCB0cmFuc3BvcnRzXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gdHJhbnNwb3J0c18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdGUgPSAwIC8qIENvbm5lY3RpbmcgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IHRoaXMucmVzb2x2ZVRyYW5zcG9ydChlbmRwb2ludCwgcmVxdWVzdGVkVHJhbnNwb3J0LCByZXF1ZXN0ZWRUcmFuc2ZlckZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiB0cmFuc3BvcnQgPT09IFwibnVtYmVyXCIpKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLmNvbnN0cnVjdFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFuZWdvdGlhdGVSZXNwb25zZS5jb25uZWN0aW9uSWQpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5lZ290aWF0aW9uUmVzcG9uc2UodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWdvdGlhdGVSZXNwb25zZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdFVybCA9IHRoaXMuY3JlYXRlQ29ubmVjdFVybCh1cmwsIG5lZ290aWF0ZVJlc3BvbnNlLmNvbm5lY3Rpb25JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbNSwgNywgLCA4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudHJhbnNwb3J0LmNvbm5lY3QoY29ubmVjdFVybCwgcmVxdWVzdGVkVHJhbnNmZXJGb3JtYXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgwIC8qIENvbm5lY3RpbmcgKi8sIDEgLyogQ29ubmVjdGVkICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhfMSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLkVycm9yLCBcIkZhaWxlZCB0byBzdGFydCB0aGUgdHJhbnNwb3J0ICdcIiArIEh0dHBUcmFuc3BvcnRUeXBlW3RyYW5zcG9ydF0gKyBcIic6IFwiICsgZXhfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRlID0gMiAvKiBEaXNjb25uZWN0ZWQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZ290aWF0ZVJlc3BvbnNlLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6IHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBpbml0aWFsaXplIGFueSBvZiB0aGUgYXZhaWxhYmxlIHRyYW5zcG9ydHMuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIdHRwQ29ubmVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xyXG4gICAgICAgIHN3aXRjaCAodHJhbnNwb3J0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgSHR0cFRyYW5zcG9ydFR5cGUuV2ViU29ja2V0czpcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLldlYlNvY2tldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidXZWJTb2NrZXQnIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBlbnZpcm9ubWVudC5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdlYlNvY2tldFRyYW5zcG9ydCh0aGlzLmh0dHBDbGllbnQsIHRoaXMuYWNjZXNzVG9rZW5GYWN0b3J5LCB0aGlzLmxvZ2dlciwgdGhpcy5vcHRpb25zLmxvZ01lc3NhZ2VDb250ZW50IHx8IGZhbHNlLCB0aGlzLm9wdGlvbnMuV2ViU29ja2V0KTtcclxuICAgICAgICAgICAgY2FzZSBIdHRwVHJhbnNwb3J0VHlwZS5TZXJ2ZXJTZW50RXZlbnRzOlxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuRXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInRXZlbnRTb3VyY2UnIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBlbnZpcm9ubWVudC5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNlcnZlclNlbnRFdmVudHNUcmFuc3BvcnQodGhpcy5odHRwQ2xpZW50LCB0aGlzLmFjY2Vzc1Rva2VuRmFjdG9yeSwgdGhpcy5sb2dnZXIsIHRoaXMub3B0aW9ucy5sb2dNZXNzYWdlQ29udGVudCB8fCBmYWxzZSwgdGhpcy5vcHRpb25zLkV2ZW50U291cmNlKTtcclxuICAgICAgICAgICAgY2FzZSBIdHRwVHJhbnNwb3J0VHlwZS5Mb25nUG9sbGluZzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTG9uZ1BvbGxpbmdUcmFuc3BvcnQodGhpcy5odHRwQ2xpZW50LCB0aGlzLmFjY2Vzc1Rva2VuRmFjdG9yeSwgdGhpcy5sb2dnZXIsIHRoaXMub3B0aW9ucy5sb2dNZXNzYWdlQ29udGVudCB8fCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRyYW5zcG9ydDogXCIgKyB0cmFuc3BvcnQgKyBcIi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEh0dHBDb25uZWN0aW9uLnByb3RvdHlwZS5yZXNvbHZlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKGVuZHBvaW50LCByZXF1ZXN0ZWRUcmFuc3BvcnQsIHJlcXVlc3RlZFRyYW5zZmVyRm9ybWF0KSB7XHJcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IEh0dHBUcmFuc3BvcnRUeXBlW2VuZHBvaW50LnRyYW5zcG9ydF07XHJcbiAgICAgICAgaWYgKHRyYW5zcG9ydCA9PT0gbnVsbCB8fCB0cmFuc3BvcnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuRGVidWcsIFwiU2tpcHBpbmcgdHJhbnNwb3J0ICdcIiArIGVuZHBvaW50LnRyYW5zcG9ydCArIFwiJyBiZWNhdXNlIGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBjbGllbnQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHRyYW5zZmVyRm9ybWF0cyA9IGVuZHBvaW50LnRyYW5zZmVyRm9ybWF0cy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIFRyYW5zZmVyRm9ybWF0W3NdOyB9KTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydE1hdGNoZXMocmVxdWVzdGVkVHJhbnNwb3J0LCB0cmFuc3BvcnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmZXJGb3JtYXRzLmluZGV4T2YocmVxdWVzdGVkVHJhbnNmZXJGb3JtYXQpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHRyYW5zcG9ydCA9PT0gSHR0cFRyYW5zcG9ydFR5cGUuV2ViU29ja2V0cyAmJiAhdGhpcy5vcHRpb25zLldlYlNvY2tldCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRyYW5zcG9ydCA9PT0gSHR0cFRyYW5zcG9ydFR5cGUuU2VydmVyU2VudEV2ZW50cyAmJiAhdGhpcy5vcHRpb25zLkV2ZW50U291cmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuRGVidWcsIFwiU2tpcHBpbmcgdHJhbnNwb3J0ICdcIiArIEh0dHBUcmFuc3BvcnRUeXBlW3RyYW5zcG9ydF0gKyBcIicgYmVjYXVzZSBpdCBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIgZW52aXJvbm1lbnQuJ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5EZWJ1ZywgXCJTZWxlY3RpbmcgdHJhbnNwb3J0ICdcIiArIEh0dHBUcmFuc3BvcnRUeXBlW3RyYW5zcG9ydF0gKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5EZWJ1ZywgXCJTa2lwcGluZyB0cmFuc3BvcnQgJ1wiICsgSHR0cFRyYW5zcG9ydFR5cGVbdHJhbnNwb3J0XSArIFwiJyBiZWNhdXNlIGl0IGRvZXMgbm90IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCB0cmFuc2ZlciBmb3JtYXQgJ1wiICsgVHJhbnNmZXJGb3JtYXRbcmVxdWVzdGVkVHJhbnNmZXJGb3JtYXRdICsgXCInLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5EZWJ1ZywgXCJTa2lwcGluZyB0cmFuc3BvcnQgJ1wiICsgSHR0cFRyYW5zcG9ydFR5cGVbdHJhbnNwb3J0XSArIFwiJyBiZWNhdXNlIGl0IHdhcyBkaXNhYmxlZCBieSB0aGUgY2xpZW50LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBIdHRwQ29ubmVjdGlvbi5wcm90b3R5cGUuaXNJVHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xyXG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQgJiYgdHlwZW9mICh0cmFuc3BvcnQpID09PSBcIm9iamVjdFwiICYmIFwiY29ubmVjdFwiIGluIHRyYW5zcG9ydDtcclxuICAgIH07XHJcbiAgICBIdHRwQ29ubmVjdGlvbi5wcm90b3R5cGUuY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uU3RhdGUgPT09IGZyb20pIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdGUgPSB0bztcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBIdHRwQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RvcENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgc3RvcEVycm9yLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIGVycm9yIGZyb20gdGhlIHRyYW5zcG9ydFxyXG4gICAgICAgIGVycm9yID0gdGhpcy5zdG9wRXJyb3IgfHwgZXJyb3I7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5FcnJvciwgXCJDb25uZWN0aW9uIGRpc2Nvbm5lY3RlZCB3aXRoIGVycm9yICdcIiArIGVycm9yICsgXCInLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5JbmZvcm1hdGlvbiwgXCJDb25uZWN0aW9uIGRpc2Nvbm5lY3RlZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRlID0gMiAvKiBEaXNjb25uZWN0ZWQgKi87XHJcbiAgICAgICAgaWYgKHRoaXMub25jbG9zZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9uY2xvc2UoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIdHRwQ29ubmVjdGlvbi5wcm90b3R5cGUucmVzb2x2ZVVybCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAvLyBzdGFydHNXaXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUVcclxuICAgICAgICBpZiAodXJsLmxhc3RJbmRleE9mKFwiaHR0cHM6Ly9cIiwgMCkgPT09IDAgfHwgdXJsLmxhc3RJbmRleE9mKFwiaHR0cDovL1wiLCAwKSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgJ1wiICsgdXJsICsgXCInLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgdXJsIHRvIHRoZSBocmVmIHByb3Blcnkgb2YgYW4gYW5jaG9yIHRhZyBoYW5kbGVzIG5vcm1hbGl6YXRpb25cclxuICAgICAgICAvLyBmb3IgdXMuIFRoZXJlIGFyZSAzIG1haW4gY2FzZXMuXHJcbiAgICAgICAgLy8gMS4gUmVsYXRpdmUgIHBhdGggbm9ybWFsaXphdGlvbiBlLmcgXCJiXCIgLT4gXCJodHRwOi8vbG9jYWxob3N0OjUwMDAvYS9iXCJcclxuICAgICAgICAvLyAyLiBBYnNvbHV0ZSBwYXRoIG5vcm1hbGl6YXRpb24gZS5nIFwiL2EvYlwiIC0+IFwiaHR0cDovL2xvY2FsaG9zdDo1MDAwL2EvYlwiXHJcbiAgICAgICAgLy8gMy4gTmV0d29ya3BhdGggcmVmZXJlbmNlIG5vcm1hbGl6YXRpb24gZS5nIFwiLy9sb2NhbGhvc3Q6NTAwMC9hL2JcIiAtPiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9hL2JcIlxyXG4gICAgICAgIHZhciBhVGFnID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gICAgICAgIGFUYWcuaHJlZiA9IHVybDtcclxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuSW5mb3JtYXRpb24sIFwiTm9ybWFsaXppbmcgJ1wiICsgdXJsICsgXCInIHRvICdcIiArIGFUYWcuaHJlZiArIFwiJy5cIik7XHJcbiAgICAgICAgcmV0dXJuIGFUYWcuaHJlZjtcclxuICAgIH07XHJcbiAgICBIdHRwQ29ubmVjdGlvbi5wcm90b3R5cGUucmVzb2x2ZU5lZ290aWF0ZVVybCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB1cmwuaW5kZXhPZihcIj9cIik7XHJcbiAgICAgICAgdmFyIG5lZ290aWF0ZVVybCA9IHVybC5zdWJzdHJpbmcoMCwgaW5kZXggPT09IC0xID8gdXJsLmxlbmd0aCA6IGluZGV4KTtcclxuICAgICAgICBpZiAobmVnb3RpYXRlVXJsW25lZ290aWF0ZVVybC5sZW5ndGggLSAxXSAhPT0gXCIvXCIpIHtcclxuICAgICAgICAgICAgbmVnb3RpYXRlVXJsICs9IFwiL1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZWdvdGlhdGVVcmwgKz0gXCJuZWdvdGlhdGVcIjtcclxuICAgICAgICBuZWdvdGlhdGVVcmwgKz0gaW5kZXggPT09IC0xID8gXCJcIiA6IHVybC5zdWJzdHJpbmcoaW5kZXgpO1xyXG4gICAgICAgIHJldHVybiBuZWdvdGlhdGVVcmw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEh0dHBDb25uZWN0aW9uO1xyXG59KCkpO1xyXG5leHBvcnQgeyBIdHRwQ29ubmVjdGlvbiB9O1xyXG5mdW5jdGlvbiB0cmFuc3BvcnRNYXRjaGVzKHJlcXVlc3RlZFRyYW5zcG9ydCwgYWN0dWFsVHJhbnNwb3J0KSB7XHJcbiAgICByZXR1cm4gIXJlcXVlc3RlZFRyYW5zcG9ydCB8fCAoKGFjdHVhbFRyYW5zcG9ydCAmIHJlcXVlc3RlZFRyYW5zcG9ydCkgIT09IDApO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUh0dHBDb25uZWN0aW9uLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgLk5FVCBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59O1xyXG5pbXBvcnQgeyBIYW5kc2hha2VQcm90b2NvbCB9IGZyb20gXCIuL0hhbmRzaGFrZVByb3RvY29sXCI7XHJcbmltcG9ydCB7IE1lc3NhZ2VUeXBlIH0gZnJvbSBcIi4vSUh1YlByb3RvY29sXCI7XHJcbmltcG9ydCB7IExvZ0xldmVsIH0gZnJvbSBcIi4vSUxvZ2dlclwiO1xyXG5pbXBvcnQgeyBBcmcsIFN1YmplY3QgfSBmcm9tIFwiLi9VdGlsc1wiO1xyXG52YXIgREVGQVVMVF9USU1FT1VUX0lOX01TID0gMzAgKiAxMDAwO1xyXG52YXIgREVGQVVMVF9QSU5HX0lOVEVSVkFMX0lOX01TID0gMTUgKiAxMDAwO1xyXG4vKiogRGVzY3JpYmVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB7QGxpbmsgSHViQ29ubmVjdGlvbn0gdG8gdGhlIHNlcnZlci4gKi9cclxuZXhwb3J0IHZhciBIdWJDb25uZWN0aW9uU3RhdGU7XHJcbihmdW5jdGlvbiAoSHViQ29ubmVjdGlvblN0YXRlKSB7XHJcbiAgICAvKiogVGhlIGh1YiBjb25uZWN0aW9uIGlzIGRpc2Nvbm5lY3RlZC4gKi9cclxuICAgIEh1YkNvbm5lY3Rpb25TdGF0ZVtIdWJDb25uZWN0aW9uU3RhdGVbXCJEaXNjb25uZWN0ZWRcIl0gPSAwXSA9IFwiRGlzY29ubmVjdGVkXCI7XHJcbiAgICAvKiogVGhlIGh1YiBjb25uZWN0aW9uIGlzIGNvbm5lY3RlZC4gKi9cclxuICAgIEh1YkNvbm5lY3Rpb25TdGF0ZVtIdWJDb25uZWN0aW9uU3RhdGVbXCJDb25uZWN0ZWRcIl0gPSAxXSA9IFwiQ29ubmVjdGVkXCI7XHJcbn0pKEh1YkNvbm5lY3Rpb25TdGF0ZSB8fCAoSHViQ29ubmVjdGlvblN0YXRlID0ge30pKTtcclxuLyoqIFJlcHJlc2VudHMgYSBjb25uZWN0aW9uIHRvIGEgU2lnbmFsUiBIdWIuICovXHJcbnZhciBIdWJDb25uZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSHViQ29ubmVjdGlvbihjb25uZWN0aW9uLCBsb2dnZXIsIHByb3RvY29sKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBBcmcuaXNSZXF1aXJlZChjb25uZWN0aW9uLCBcImNvbm5lY3Rpb25cIik7XHJcbiAgICAgICAgQXJnLmlzUmVxdWlyZWQobG9nZ2VyLCBcImxvZ2dlclwiKTtcclxuICAgICAgICBBcmcuaXNSZXF1aXJlZChwcm90b2NvbCwgXCJwcm90b2NvbFwiKTtcclxuICAgICAgICB0aGlzLnNlcnZlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA9IERFRkFVTFRfVElNRU9VVF9JTl9NUztcclxuICAgICAgICB0aGlzLmtlZXBBbGl2ZUludGVydmFsSW5NaWxsaXNlY29uZHMgPSBERUZBVUxUX1BJTkdfSU5URVJWQUxfSU5fTVM7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XHJcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IHByb3RvY29sO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XHJcbiAgICAgICAgdGhpcy5oYW5kc2hha2VQcm90b2NvbCA9IG5ldyBIYW5kc2hha2VQcm90b2NvbCgpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbnJlY2VpdmUgPSBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gX3RoaXMucHJvY2Vzc0luY29taW5nRGF0YShkYXRhKTsgfTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub25jbG9zZSA9IGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gX3RoaXMuY29ubmVjdGlvbkNsb3NlZChlcnJvcik7IH07XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcclxuICAgICAgICB0aGlzLm1ldGhvZHMgPSB7fTtcclxuICAgICAgICB0aGlzLmNsb3NlZENhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaWQgPSAwO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZWRIYW5kc2hha2VSZXNwb25zZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRlID0gSHViQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZDtcclxuICAgICAgICB0aGlzLmNhY2hlZFBpbmdNZXNzYWdlID0gdGhpcy5wcm90b2NvbC53cml0ZU1lc3NhZ2UoeyB0eXBlOiBNZXNzYWdlVHlwZS5QaW5nIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgLy8gVXNpbmcgYSBwdWJsaWMgc3RhdGljIGZhY3RvcnkgbWV0aG9kIG1lYW5zIHdlIGNhbiBoYXZlIGEgcHJpdmF0ZSBjb25zdHJ1Y3RvciBhbmQgYW4gX2ludGVybmFsX1xyXG4gICAgLy8gY3JlYXRlIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIGJ5IEh1YkNvbm5lY3Rpb25CdWlsZGVyLiBBbiBcImludGVybmFsXCIgY29uc3RydWN0b3Igd291bGQganVzdFxyXG4gICAgLy8gYmUgc3RyaXBwZWQgYXdheSBhbmQgdGhlICcuZC50cycgZmlsZSB3b3VsZCBoYXZlIG5vIGNvbnN0cnVjdG9yLCB3aGljaCBpcyBpbnRlcnByZXRlZCBhcyBhXHJcbiAgICAvLyBwdWJsaWMgcGFyYW1ldGVyLWxlc3MgY29uc3RydWN0b3IuXHJcbiAgICBIdWJDb25uZWN0aW9uLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBsb2dnZXIsIHByb3RvY29sKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIdWJDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGxvZ2dlciwgcHJvdG9jb2wpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIdWJDb25uZWN0aW9uLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XHJcbiAgICAgICAgLyoqIEluZGljYXRlcyB0aGUgc3RhdGUgb2YgdGhlIHtAbGluayBIdWJDb25uZWN0aW9ufSB0byB0aGUgc2VydmVyLiAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKiogU3RhcnRzIHRoZSBjb25uZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCwgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBIdWJDb25uZWN0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBoYW5kc2hha2VSZXF1ZXN0LCBoYW5kc2hha2VQcm9taXNlO1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2VSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IHRoaXMucHJvdG9jb2wubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHRoaXMucHJvdG9jb2wudmVyc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLkRlYnVnLCBcIlN0YXJ0aW5nIEh1YkNvbm5lY3Rpb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmVkSGFuZHNoYWtlUmVzcG9uc2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRzaGFrZVJlc29sdmVyID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRzaGFrZVJlamVjdGVyID0gcmVqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jb25uZWN0aW9uLnN0YXJ0KHRoaXMucHJvdG9jb2wudHJhbnNmZXJGb3JtYXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLkRlYnVnLCBcIlNlbmRpbmcgaGFuZHNoYWtlIHJlcXVlc3QuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlbmRNZXNzYWdlKHRoaXMuaGFuZHNoYWtlUHJvdG9jb2wud3JpdGVIYW5kc2hha2VSZXF1ZXN0KGhhbmRzaGFrZVJlcXVlc3QpKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5JbmZvcm1hdGlvbiwgXCJVc2luZyBIdWJQcm90b2NvbCAnXCIgKyB0aGlzLnByb3RvY29sLm5hbWUgKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZlbnNpdmVseSBjbGVhbnVwIHRpbWVvdXQgaW4gY2FzZSB3ZSByZWNlaXZlIGEgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIHdlIGZpbmlzaCBzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRUaW1lb3V0UGVyaW9kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRLZWVwQWxpdmVJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgaGFuZHNoYWtlIHRvIGNvbXBsZXRlIGJlZm9yZSBtYXJraW5nIGNvbm5lY3Rpb24gYXMgY29ubmVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGhhbmRzaGFrZVByb21pc2VdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGhhbmRzaGFrZSB0byBjb21wbGV0ZSBiZWZvcmUgbWFya2luZyBjb25uZWN0aW9uIGFzIGNvbm5lY3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRlID0gSHViQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKiogU3RvcHMgdGhlIGNvbm5lY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHRlcm1pbmF0ZWQsIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgSHViQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuRGVidWcsIFwiU3RvcHBpbmcgSHViQ29ubmVjdGlvbi5cIik7XHJcbiAgICAgICAgdGhpcy5jbGVhbnVwVGltZW91dCgpO1xyXG4gICAgICAgIHRoaXMuY2xlYW51cFBpbmdUaW1lcigpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc3RvcCgpO1xyXG4gICAgfTtcclxuICAgIC8qKiBJbnZva2VzIGEgc3RyZWFtaW5nIGh1YiBtZXRob2Qgb24gdGhlIHNlcnZlciB1c2luZyB0aGUgc3BlY2lmaWVkIG5hbWUgYW5kIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIGl0ZW1zIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgc2VydmVyIG1ldGhvZCB0byBpbnZva2UuXHJcbiAgICAgKiBAcGFyYW0ge2FueVtdfSBhcmdzIFRoZSBhcmd1bWVudHMgdXNlZCB0byBpbnZva2UgdGhlIHNlcnZlciBtZXRob2QuXHJcbiAgICAgKiBAcmV0dXJucyB7SVN0cmVhbVJlc3VsdDxUPn0gQW4gb2JqZWN0IHRoYXQgeWllbGRzIHJlc3VsdHMgZnJvbSB0aGUgc2VydmVyIGFzIHRoZXkgYXJlIHJlY2VpdmVkLlxyXG4gICAgICovXHJcbiAgICBIdWJDb25uZWN0aW9uLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW52b2NhdGlvbkRlc2NyaXB0b3IgPSB0aGlzLmNyZWF0ZVN0cmVhbUludm9jYXRpb24obWV0aG9kTmFtZSwgYXJncyk7XHJcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXcgU3ViamVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjYW5jZWxJbnZvY2F0aW9uID0gX3RoaXMuY3JlYXRlQ2FuY2VsSW52b2NhdGlvbihpbnZvY2F0aW9uRGVzY3JpcHRvci5pbnZvY2F0aW9uSWQpO1xyXG4gICAgICAgICAgICB2YXIgY2FuY2VsTWVzc2FnZSA9IF90aGlzLnByb3RvY29sLndyaXRlTWVzc2FnZShjYW5jZWxJbnZvY2F0aW9uKTtcclxuICAgICAgICAgICAgZGVsZXRlIF90aGlzLmNhbGxiYWNrc1tpbnZvY2F0aW9uRGVzY3JpcHRvci5pbnZvY2F0aW9uSWRdO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VuZE1lc3NhZ2UoY2FuY2VsTWVzc2FnZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3NbaW52b2NhdGlvbkRlc2NyaXB0b3IuaW52b2NhdGlvbklkXSA9IGZ1bmN0aW9uIChpbnZvY2F0aW9uRXZlbnQsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW52b2NhdGlvbkV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnZvY2F0aW9uRXZlbnQgd2lsbCBub3QgYmUgbnVsbCB3aGVuIGFuIGVycm9yIGlzIG5vdCBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICBpZiAoaW52b2NhdGlvbkV2ZW50LnR5cGUgPT09IE1lc3NhZ2VUeXBlLkNvbXBsZXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW52b2NhdGlvbkV2ZW50LmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3QuZXJyb3IobmV3IEVycm9yKGludm9jYXRpb25FdmVudC5lcnJvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3QubmV4dCgoaW52b2NhdGlvbkV2ZW50Lml0ZW0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLnByb3RvY29sLndyaXRlTWVzc2FnZShpbnZvY2F0aW9uRGVzY3JpcHRvcik7XHJcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShtZXNzYWdlKVxyXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlKTtcclxuICAgICAgICAgICAgZGVsZXRlIF90aGlzLmNhbGxiYWNrc1tpbnZvY2F0aW9uRGVzY3JpcHRvci5pbnZvY2F0aW9uSWRdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xyXG4gICAgfTtcclxuICAgIEh1YkNvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLnJlc2V0S2VlcEFsaXZlSW50ZXJ2YWwoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmQobWVzc2FnZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEludm9rZXMgYSBodWIgbWV0aG9kIG9uIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIHNwZWNpZmllZCBuYW1lIGFuZCBhcmd1bWVudHMuIERvZXMgbm90IHdhaXQgZm9yIGEgcmVzcG9uc2UgZnJvbSB0aGUgcmVjZWl2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIFByb21pc2UgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QgcmVzb2x2ZXMgd2hlbiB0aGUgY2xpZW50IGhhcyBzZW50IHRoZSBpbnZvY2F0aW9uIHRvIHRoZSBzZXJ2ZXIuIFRoZSBzZXJ2ZXIgbWF5IHN0aWxsXHJcbiAgICAgKiBiZSBwcm9jZXNzaW5nIHRoZSBpbnZvY2F0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBzZXJ2ZXIgbWV0aG9kIHRvIGludm9rZS5cclxuICAgICAqIEBwYXJhbSB7YW55W119IGFyZ3MgVGhlIGFyZ3VtZW50cyB1c2VkIHRvIGludm9rZSB0aGUgc2VydmVyIG1ldGhvZC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBpbnZvY2F0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzZW50LCBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIEh1YkNvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGludm9jYXRpb25EZXNjcmlwdG9yID0gdGhpcy5jcmVhdGVJbnZvY2F0aW9uKG1ldGhvZE5hbWUsIGFyZ3MsIHRydWUpO1xyXG4gICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5wcm90b2NvbC53cml0ZU1lc3NhZ2UoaW52b2NhdGlvbkRlc2NyaXB0b3IpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgfTtcclxuICAgIC8qKiBJbnZva2VzIGEgaHViIG1ldGhvZCBvbiB0aGUgc2VydmVyIHVzaW5nIHRoZSBzcGVjaWZpZWQgbmFtZSBhbmQgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBQcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIHJlc29sdmVzIHdoZW4gdGhlIHNlcnZlciBpbmRpY2F0ZXMgaXQgaGFzIGZpbmlzaGVkIGludm9raW5nIHRoZSBtZXRob2QuIFdoZW4gdGhlIHByb21pc2VcclxuICAgICAqIHJlc29sdmVzLCB0aGUgc2VydmVyIGhhcyBmaW5pc2hlZCBpbnZva2luZyB0aGUgbWV0aG9kLiBJZiB0aGUgc2VydmVyIG1ldGhvZCByZXR1cm5zIGEgcmVzdWx0LCBpdCBpcyBwcm9kdWNlZCBhcyB0aGUgcmVzdWx0IG9mXHJcbiAgICAgKiByZXNvbHZpbmcgdGhlIFByb21pc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGVwYXJhbSBUIFRoZSBleHBlY3RlZCByZXR1cm4gdHlwZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBzZXJ2ZXIgbWV0aG9kIHRvIGludm9rZS5cclxuICAgICAqIEBwYXJhbSB7YW55W119IGFyZ3MgVGhlIGFyZ3VtZW50cyB1c2VkIHRvIGludm9rZSB0aGUgc2VydmVyIG1ldGhvZC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFQ+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIHNlcnZlciBtZXRob2QgKGlmIGFueSksIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgSHViQ29ubmVjdGlvbi5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGludm9jYXRpb25EZXNjcmlwdG9yID0gdGhpcy5jcmVhdGVJbnZvY2F0aW9uKG1ldGhvZE5hbWUsIGFyZ3MsIGZhbHNlKTtcclxuICAgICAgICB2YXIgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgLy8gaW52b2NhdGlvbklkIHdpbGwgYWx3YXlzIGhhdmUgYSB2YWx1ZSBmb3IgYSBub24tYmxvY2tpbmcgaW52b2NhdGlvblxyXG4gICAgICAgICAgICBfdGhpcy5jYWxsYmFja3NbaW52b2NhdGlvbkRlc2NyaXB0b3IuaW52b2NhdGlvbklkXSA9IGZ1bmN0aW9uIChpbnZvY2F0aW9uRXZlbnQsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGludm9jYXRpb25FdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludm9jYXRpb25FdmVudCB3aWxsIG5vdCBiZSBudWxsIHdoZW4gYW4gZXJyb3IgaXMgbm90IHBhc3NlZCB0byB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW52b2NhdGlvbkV2ZW50LnR5cGUgPT09IE1lc3NhZ2VUeXBlLkNvbXBsZXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludm9jYXRpb25FdmVudC5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihpbnZvY2F0aW9uRXZlbnQuZXJyb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW52b2NhdGlvbkV2ZW50LnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZTogXCIgKyBpbnZvY2F0aW9uRXZlbnQudHlwZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBfdGhpcy5wcm90b2NvbC53cml0ZU1lc3NhZ2UoaW52b2NhdGlvbkRlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICBfdGhpcy5zZW5kTWVzc2FnZShtZXNzYWdlKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnZvY2F0aW9uSWQgd2lsbCBhbHdheXMgaGF2ZSBhIHZhbHVlIGZvciBhIG5vbi1ibG9ja2luZyBpbnZvY2F0aW9uXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuY2FsbGJhY2tzW2ludm9jYXRpb25EZXNjcmlwdG9yLmludm9jYXRpb25JZF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfTtcclxuICAgIC8qKiBSZWdpc3RlcnMgYSBoYW5kbGVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGh1YiBtZXRob2Qgd2l0aCB0aGUgc3BlY2lmaWVkIG1ldGhvZCBuYW1lIGlzIGludm9rZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGh1YiBtZXRob2QgdG8gZGVmaW5lLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3TWV0aG9kIFRoZSBoYW5kbGVyIHRoYXQgd2lsbCBiZSByYWlzZWQgd2hlbiB0aGUgaHViIG1ldGhvZCBpcyBpbnZva2VkLlxyXG4gICAgICovXHJcbiAgICBIdWJDb25uZWN0aW9uLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBuZXdNZXRob2QpIHtcclxuICAgICAgICBpZiAoIW1ldGhvZE5hbWUgfHwgIW5ld01ldGhvZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1ldGhvZE5hbWUgPSBtZXRob2ROYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1ldGhvZHNbbWV0aG9kTmFtZV0pIHtcclxuICAgICAgICAgICAgdGhpcy5tZXRob2RzW21ldGhvZE5hbWVdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByZXZlbnRpbmcgYWRkaW5nIHRoZSBzYW1lIGhhbmRsZXIgbXVsdGlwbGUgdGltZXMuXHJcbiAgICAgICAgaWYgKHRoaXMubWV0aG9kc1ttZXRob2ROYW1lXS5pbmRleE9mKG5ld01ldGhvZCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tZXRob2RzW21ldGhvZE5hbWVdLnB1c2gobmV3TWV0aG9kKTtcclxuICAgIH07XHJcbiAgICBIdWJDb25uZWN0aW9uLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgbWV0aG9kKSB7XHJcbiAgICAgICAgaWYgKCFtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLm1ldGhvZHNbbWV0aG9kTmFtZV07XHJcbiAgICAgICAgaWYgKCFoYW5kbGVycykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXRob2QpIHtcclxuICAgICAgICAgICAgdmFyIHJlbW92ZUlkeCA9IGhhbmRsZXJzLmluZGV4T2YobWV0aG9kKTtcclxuICAgICAgICAgICAgaWYgKHJlbW92ZUlkeCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShyZW1vdmVJZHgsIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1ldGhvZHNbbWV0aG9kTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1ldGhvZHNbbWV0aG9kTmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBSZWdpc3RlcnMgYSBoYW5kbGVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBoYW5kbGVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLiBPcHRpb25hbGx5IHJlY2VpdmVzIGEgc2luZ2xlIGFyZ3VtZW50IGNvbnRhaW5pbmcgdGhlIGVycm9yIHRoYXQgY2F1c2VkIHRoZSBjb25uZWN0aW9uIHRvIGNsb3NlIChpZiBhbnkpLlxyXG4gICAgICovXHJcbiAgICBIdWJDb25uZWN0aW9uLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIdWJDb25uZWN0aW9uLnByb3RvdHlwZS5wcm9jZXNzSW5jb21pbmdEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmNsZWFudXBUaW1lb3V0KCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlY2VpdmVkSGFuZHNoYWtlUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHRoaXMucHJvY2Vzc0hhbmRzaGFrZVJlc3BvbnNlKGRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVkSGFuZHNoYWtlUmVzcG9uc2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEYXRhIG1heSBoYXZlIGFsbCBiZWVuIHJlYWQgd2hlbiBwcm9jZXNzaW5nIGhhbmRzaGFrZSByZXNwb25zZVxyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBtZXNzYWdlc1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSB0aGlzLnByb3RvY29sLnBhcnNlTWVzc2FnZXMoZGF0YSwgdGhpcy5sb2dnZXIpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1lc3NhZ2VzXzEgPSBtZXNzYWdlczsgX2kgPCBtZXNzYWdlc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBtZXNzYWdlc18xW19pXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5JbnZvY2F0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludm9rZUNsaWVudE1ldGhvZChtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TdHJlYW1JdGVtOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQ29tcGxldGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3NbbWVzc2FnZS5pbnZvY2F0aW9uSWRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gTWVzc2FnZVR5cGUuQ29tcGxldGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1ttZXNzYWdlLmludm9jYXRpb25JZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNhcmUgYWJvdXQgcGluZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5DbG9zZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLkluZm9ybWF0aW9uLCBcIkNsb3NlIG1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHdhaXQgb24gdGhlIHN0b3AgaXRzZWxmLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnN0b3AobWVzc2FnZS5lcnJvciA/IG5ldyBFcnJvcihcIlNlcnZlciByZXR1cm5lZCBhbiBlcnJvciBvbiBjbG9zZTogXCIgKyBtZXNzYWdlLmVycm9yKSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5XYXJuaW5nLCBcIkludmFsaWQgbWVzc2FnZSB0eXBlOiBcIiArIG1lc3NhZ2UudHlwZSArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNldFRpbWVvdXRQZXJpb2QoKTtcclxuICAgIH07XHJcbiAgICBIdWJDb25uZWN0aW9uLnByb3RvdHlwZS5wcm9jZXNzSGFuZHNoYWtlUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgcmVzcG9uc2VNZXNzYWdlO1xyXG4gICAgICAgIHZhciByZW1haW5pbmdEYXRhO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIF9hID0gdGhpcy5oYW5kc2hha2VQcm90b2NvbC5wYXJzZUhhbmRzaGFrZVJlc3BvbnNlKGRhdGEpLCByZW1haW5pbmdEYXRhID0gX2FbMF0sIHJlc3BvbnNlTWVzc2FnZSA9IF9hWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiRXJyb3IgcGFyc2luZyBoYW5kc2hha2UgcmVzcG9uc2U6IFwiICsgZTtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLkVycm9yLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHdhaXQgb24gdGhlIHN0b3AgaXRzZWxmLlxyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnN0b3AoZXJyb3IpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRzaGFrZVJlamVjdGVyKGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlNlcnZlciByZXR1cm5lZCBoYW5kc2hha2UgZXJyb3I6IFwiICsgcmVzcG9uc2VNZXNzYWdlLmVycm9yO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuRXJyb3IsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRzaGFrZVJlamVjdGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHdhaXQgb24gdGhlIHN0b3AgaXRzZWxmLlxyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnN0b3AobmV3IEVycm9yKG1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLkRlYnVnLCBcIlNlcnZlciBoYW5kc2hha2UgY29tcGxldGUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhhbmRzaGFrZVJlc29sdmVyKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ0RhdGE7XHJcbiAgICB9O1xyXG4gICAgSHViQ29ubmVjdGlvbi5wcm90b3R5cGUucmVzZXRLZWVwQWxpdmVJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2xlYW51cFBpbmdUaW1lcigpO1xyXG4gICAgICAgIHRoaXMucGluZ1NlcnZlckhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuY29ubmVjdGlvblN0YXRlID09PSBIdWJDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2VuZE1lc3NhZ2UodGhpcy5jYWNoZWRQaW5nTWVzc2FnZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRoZSBlcnJvci4gSXQgc2hvdWxkIGJlIHNlZW4gZWxzZXdoZXJlIGluIHRoZSBjbGllbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb25uZWN0aW9uIGlzIHByb2JhYmx5IGluIGEgYmFkIG9yIGNsb3NlZCBzdGF0ZSBub3csIGNsZWFudXAgdGhlIHRpbWVyIHNvIGl0IHN0b3BzIHRyaWdnZXJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwUGluZ1RpbWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgfSwgdGhpcy5rZWVwQWxpdmVJbnRlcnZhbEluTWlsbGlzZWNvbmRzKTtcclxuICAgIH07XHJcbiAgICBIdWJDb25uZWN0aW9uLnByb3RvdHlwZS5yZXNldFRpbWVvdXRQZXJpb2QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGlvbi5mZWF0dXJlcyB8fCAhdGhpcy5jb25uZWN0aW9uLmZlYXR1cmVzLmluaGVyZW50S2VlcEFsaXZlKSB7XHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgdGltZW91dCB0aW1lclxyXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNlcnZlclRpbWVvdXQoKTsgfSwgdGhpcy5zZXJ2ZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIdWJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXJ2ZXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgaGFzbid0IHRhbGtlZCB0byB1cyBpbiBhIHdoaWxlLiBJdCBkb2Vzbid0IGxpa2UgdXMgYW55bW9yZSAuLi4gOihcclxuICAgICAgICAvLyBUZXJtaW5hdGUgdGhlIGNvbm5lY3Rpb24sIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIHdhaXQgb24gdGhlIHByb21pc2UuXHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnN0b3AobmV3IEVycm9yKFwiU2VydmVyIHRpbWVvdXQgZWxhcHNlZCB3aXRob3V0IHJlY2VpdmluZyBhIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyLlwiKSk7XHJcbiAgICB9O1xyXG4gICAgSHViQ29ubmVjdGlvbi5wcm90b3R5cGUuaW52b2tlQ2xpZW50TWV0aG9kID0gZnVuY3Rpb24gKGludm9jYXRpb25NZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMubWV0aG9kc1tpbnZvY2F0aW9uTWVzc2FnZS50YXJnZXQudG9Mb3dlckNhc2UoKV07XHJcbiAgICAgICAgaWYgKG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmFwcGx5KF90aGlzLCBpbnZvY2F0aW9uTWVzc2FnZS5hcmd1bWVudHMpOyB9KTtcclxuICAgICAgICAgICAgaWYgKGludm9jYXRpb25NZXNzYWdlLmludm9jYXRpb25JZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHYxLiBTbyB3ZSByZXR1cm4gYW4gZXJyb3IgdG8gYXZvaWQgYmxvY2tpbmcgdGhlIHNlcnZlciB3YWl0aW5nIGZvciB0aGUgcmVzcG9uc2UuXHJcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiU2VydmVyIHJlcXVlc3RlZCBhIHJlc3BvbnNlLCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgdmVyc2lvbiBvZiB0aGUgY2xpZW50LlwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLkVycm9yLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gd2FpdCBvbiB0aGlzIFByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5zdG9wKG5ldyBFcnJvcihtZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5XYXJuaW5nLCBcIk5vIGNsaWVudCBtZXRob2Qgd2l0aCB0aGUgbmFtZSAnXCIgKyBpbnZvY2F0aW9uTWVzc2FnZS50YXJnZXQgKyBcIicgZm91bmQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIdWJDb25uZWN0aW9uLnByb3RvdHlwZS5jb25uZWN0aW9uQ2xvc2VkID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3M7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZSA9IEh1YkNvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQ7XHJcbiAgICAgICAgLy8gaWYgaGFuZHNoYWtlIGlzIGluIHByb2dyZXNzIHN0YXJ0IHdpbGwgYmUgd2FpdGluZyBmb3IgdGhlIGhhbmRzaGFrZSBwcm9taXNlLCBzbyB3ZSBjb21wbGV0ZSBpdFxyXG4gICAgICAgIC8vIGlmIGl0IGhhcyBhbHJlYWR5IGNvbXBsZXRlZCB0aGlzIHNob3VsZCBqdXN0IG5vb3BcclxuICAgICAgICBpZiAodGhpcy5oYW5kc2hha2VSZWplY3Rlcikge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRzaGFrZVJlamVjdGVyKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmtleXMoY2FsbGJhY2tzKVxyXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBlcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFwiSW52b2NhdGlvbiBjYW5jZWxlZCBkdWUgdG8gY29ubmVjdGlvbiBiZWluZyBjbG9zZWQuXCIpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNsZWFudXBUaW1lb3V0KCk7XHJcbiAgICAgICAgdGhpcy5jbGVhbnVwUGluZ1RpbWVyKCk7XHJcbiAgICAgICAgdGhpcy5jbG9zZWRDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5hcHBseShfdGhpcywgW2Vycm9yXSk7IH0pO1xyXG4gICAgfTtcclxuICAgIEh1YkNvbm5lY3Rpb24ucHJvdG90eXBlLmNsZWFudXBQaW5nVGltZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGluZ1NlcnZlckhhbmRsZSkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nU2VydmVySGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSHViQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xlYW51cFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZW91dEhhbmRsZSkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSHViQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlSW52b2NhdGlvbiA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBhcmdzLCBub25ibG9ja2luZykge1xyXG4gICAgICAgIGlmIChub25ibG9ja2luZykge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmdzLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBtZXRob2ROYW1lLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuSW52b2NhdGlvbixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgICAgIHRoaXMuaWQrKztcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJncyxcclxuICAgICAgICAgICAgICAgIGludm9jYXRpb25JZDogaWQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogbWV0aG9kTmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkludm9jYXRpb24sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEh1YkNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZVN0cmVhbUludm9jYXRpb24gPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgYXJncykge1xyXG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgdGhpcy5pZCsrO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFyZ3VtZW50czogYXJncyxcclxuICAgICAgICAgICAgaW52b2NhdGlvbklkOiBpZC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG1ldGhvZE5hbWUsXHJcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlN0cmVhbUludm9jYXRpb24sXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBIdWJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVDYW5jZWxJbnZvY2F0aW9uID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaW52b2NhdGlvbklkOiBpZCxcclxuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ2FuY2VsSW52b2NhdGlvbixcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBIdWJDb25uZWN0aW9uO1xyXG59KCkpO1xyXG5leHBvcnQgeyBIdWJDb25uZWN0aW9uIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUh1YkNvbm5lY3Rpb24uanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSAuTkVUIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG5pbXBvcnQgeyBIdHRwQ29ubmVjdGlvbiB9IGZyb20gXCIuL0h0dHBDb25uZWN0aW9uXCI7XHJcbmltcG9ydCB7IEh1YkNvbm5lY3Rpb24gfSBmcm9tIFwiLi9IdWJDb25uZWN0aW9uXCI7XHJcbmltcG9ydCB7IEpzb25IdWJQcm90b2NvbCB9IGZyb20gXCIuL0pzb25IdWJQcm90b2NvbFwiO1xyXG5pbXBvcnQgeyBOdWxsTG9nZ2VyIH0gZnJvbSBcIi4vTG9nZ2Vyc1wiO1xyXG5pbXBvcnQgeyBBcmcsIENvbnNvbGVMb2dnZXIgfSBmcm9tIFwiLi9VdGlsc1wiO1xyXG4vKiogQSBidWlsZGVyIGZvciBjb25maWd1cmluZyB7QGxpbmsgQGFzcG5ldC9zaWduYWxyLkh1YkNvbm5lY3Rpb259IGluc3RhbmNlcy4gKi9cclxudmFyIEh1YkNvbm5lY3Rpb25CdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSHViQ29ubmVjdGlvbkJ1aWxkZXIoKSB7XHJcbiAgICB9XHJcbiAgICBIdWJDb25uZWN0aW9uQnVpbGRlci5wcm90b3R5cGUuY29uZmlndXJlTG9nZ2luZyA9IGZ1bmN0aW9uIChsb2dnaW5nKSB7XHJcbiAgICAgICAgQXJnLmlzUmVxdWlyZWQobG9nZ2luZywgXCJsb2dnaW5nXCIpO1xyXG4gICAgICAgIGlmIChpc0xvZ2dlcihsb2dnaW5nKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IG5ldyBDb25zb2xlTG9nZ2VyKGxvZ2dpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBIdWJDb25uZWN0aW9uQnVpbGRlci5wcm90b3R5cGUud2l0aFVybCA9IGZ1bmN0aW9uICh1cmwsIHRyYW5zcG9ydFR5cGVPck9wdGlvbnMpIHtcclxuICAgICAgICBBcmcuaXNSZXF1aXJlZCh1cmwsIFwidXJsXCIpO1xyXG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xyXG4gICAgICAgIC8vIEZsb3ctdHlwaW5nIGtub3dzIHdoZXJlIGl0J3MgYXQuIFNpbmNlIEh0dHBUcmFuc3BvcnRUeXBlIGlzIGEgbnVtYmVyIGFuZCBJSHR0cENvbm5lY3Rpb25PcHRpb25zIGlzIGd1YXJhbnRlZWRcclxuICAgICAgICAvLyB0byBiZSBhbiBvYmplY3QsIHdlIGtub3cgKGFzIGRvZXMgVHlwZVNjcmlwdCkgdGhpcyBjb21wYXJpc29uIGlzIGFsbCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgd2hpY2ggb3ZlcmxvYWQgd2FzIGNhbGxlZC5cclxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zcG9ydFR5cGVPck9wdGlvbnMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgdGhpcy5odHRwQ29ubmVjdGlvbk9wdGlvbnMgPSB0cmFuc3BvcnRUeXBlT3JPcHRpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5odHRwQ29ubmVjdGlvbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydFR5cGVPck9wdGlvbnMsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKiBDb25maWd1cmVzIHRoZSB7QGxpbmsgQGFzcG5ldC9zaWduYWxyLkh1YkNvbm5lY3Rpb259IHRvIHVzZSB0aGUgc3BlY2lmaWVkIEh1YiBQcm90b2NvbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0lIdWJQcm90b2NvbH0gcHJvdG9jb2wgVGhlIHtAbGluayBAYXNwbmV0L3NpZ25hbHIuSUh1YlByb3RvY29sfSBpbXBsZW1lbnRhdGlvbiB0byB1c2UuXHJcbiAgICAgKi9cclxuICAgIEh1YkNvbm5lY3Rpb25CdWlsZGVyLnByb3RvdHlwZS53aXRoSHViUHJvdG9jb2wgPSBmdW5jdGlvbiAocHJvdG9jb2wpIHtcclxuICAgICAgICBBcmcuaXNSZXF1aXJlZChwcm90b2NvbCwgXCJwcm90b2NvbFwiKTtcclxuICAgICAgICB0aGlzLnByb3RvY29sID0gcHJvdG9jb2w7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqIENyZWF0ZXMgYSB7QGxpbmsgQGFzcG5ldC9zaWduYWxyLkh1YkNvbm5lY3Rpb259IGZyb20gdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBzcGVjaWZpZWQgaW4gdGhpcyBidWlsZGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtIdWJDb25uZWN0aW9ufSBUaGUgY29uZmlndXJlZCB7QGxpbmsgQGFzcG5ldC9zaWduYWxyLkh1YkNvbm5lY3Rpb259LlxyXG4gICAgICovXHJcbiAgICBIdWJDb25uZWN0aW9uQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gSWYgaHR0cENvbm5lY3Rpb25PcHRpb25zIGhhcyBhIGxvZ2dlciwgdXNlIGl0LiBPdGhlcndpc2UsIG92ZXJyaWRlIGl0IHdpdGggdGhlIG9uZVxyXG4gICAgICAgIC8vIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZUxvZ2dlclxyXG4gICAgICAgIHZhciBodHRwQ29ubmVjdGlvbk9wdGlvbnMgPSB0aGlzLmh0dHBDb25uZWN0aW9uT3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAvLyBJZiBpdCdzICdudWxsJywgdGhlIHVzZXIgKipleHBsaWNpdGx5KiogYXNrZWQgZm9yIG51bGwsIGRvbid0IG1lc3Mgd2l0aCBpdC5cclxuICAgICAgICBpZiAoaHR0cENvbm5lY3Rpb25PcHRpb25zLmxvZ2dlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIElmIG91ciBsb2dnZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwsIHRoYXQncyBPSywgdGhlIEh0dHBDb25uZWN0aW9uIGNvbnN0cnVjdG9yIHdpbGwgaGFuZGxlIGl0LlxyXG4gICAgICAgICAgICBodHRwQ29ubmVjdGlvbk9wdGlvbnMubG9nZ2VyID0gdGhpcy5sb2dnZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdyBjcmVhdGUgdGhlIGNvbm5lY3Rpb25cclxuICAgICAgICBpZiAoIXRoaXMudXJsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnSHViQ29ubmVjdGlvbkJ1aWxkZXIud2l0aFVybCcgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBidWlsZGluZyB0aGUgY29ubmVjdGlvbi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gbmV3IEh0dHBDb25uZWN0aW9uKHRoaXMudXJsLCBodHRwQ29ubmVjdGlvbk9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBIdWJDb25uZWN0aW9uLmNyZWF0ZShjb25uZWN0aW9uLCB0aGlzLmxvZ2dlciB8fCBOdWxsTG9nZ2VyLmluc3RhbmNlLCB0aGlzLnByb3RvY29sIHx8IG5ldyBKc29uSHViUHJvdG9jb2woKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEh1YkNvbm5lY3Rpb25CdWlsZGVyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBIdWJDb25uZWN0aW9uQnVpbGRlciB9O1xyXG5mdW5jdGlvbiBpc0xvZ2dlcihsb2dnZXIpIHtcclxuICAgIHJldHVybiBsb2dnZXIubG9nICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SHViQ29ubmVjdGlvbkJ1aWxkZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSAuTkVUIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4vKiogRGVmaW5lcyB0aGUgdHlwZSBvZiBhIEh1YiBNZXNzYWdlLiAqL1xyXG5leHBvcnQgdmFyIE1lc3NhZ2VUeXBlO1xyXG4oZnVuY3Rpb24gKE1lc3NhZ2VUeXBlKSB7XHJcbiAgICAvKiogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGFuIEludm9jYXRpb24gbWVzc2FnZSBhbmQgaW1wbGVtZW50cyB0aGUge0BsaW5rIEBhc3BuZXQvc2lnbmFsci5JbnZvY2F0aW9uTWVzc2FnZX0gaW50ZXJmYWNlLiAqL1xyXG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJJbnZvY2F0aW9uXCJdID0gMV0gPSBcIkludm9jYXRpb25cIjtcclxuICAgIC8qKiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgYSBTdHJlYW1JdGVtIG1lc3NhZ2UgYW5kIGltcGxlbWVudHMgdGhlIHtAbGluayBAYXNwbmV0L3NpZ25hbHIuU3RyZWFtSXRlbU1lc3NhZ2V9IGludGVyZmFjZS4gKi9cclxuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU3RyZWFtSXRlbVwiXSA9IDJdID0gXCJTdHJlYW1JdGVtXCI7XHJcbiAgICAvKiogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGEgQ29tcGxldGlvbiBtZXNzYWdlIGFuZCBpbXBsZW1lbnRzIHRoZSB7QGxpbmsgQGFzcG5ldC9zaWduYWxyLkNvbXBsZXRpb25NZXNzYWdlfSBpbnRlcmZhY2UuICovXHJcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkNvbXBsZXRpb25cIl0gPSAzXSA9IFwiQ29tcGxldGlvblwiO1xyXG4gICAgLyoqIEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBhIFN0cmVhbSBJbnZvY2F0aW9uIG1lc3NhZ2UgYW5kIGltcGxlbWVudHMgdGhlIHtAbGluayBAYXNwbmV0L3NpZ25hbHIuU3RyZWFtSW52b2NhdGlvbk1lc3NhZ2V9IGludGVyZmFjZS4gKi9cclxuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU3RyZWFtSW52b2NhdGlvblwiXSA9IDRdID0gXCJTdHJlYW1JbnZvY2F0aW9uXCI7XHJcbiAgICAvKiogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGEgQ2FuY2VsIEludm9jYXRpb24gbWVzc2FnZSBhbmQgaW1wbGVtZW50cyB0aGUge0BsaW5rIEBhc3BuZXQvc2lnbmFsci5DYW5jZWxJbnZvY2F0aW9uTWVzc2FnZX0gaW50ZXJmYWNlLiAqL1xyXG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJDYW5jZWxJbnZvY2F0aW9uXCJdID0gNV0gPSBcIkNhbmNlbEludm9jYXRpb25cIjtcclxuICAgIC8qKiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgYSBQaW5nIG1lc3NhZ2UgYW5kIGltcGxlbWVudHMgdGhlIHtAbGluayBAYXNwbmV0L3NpZ25hbHIuUGluZ01lc3NhZ2V9IGludGVyZmFjZS4gKi9cclxuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiUGluZ1wiXSA9IDZdID0gXCJQaW5nXCI7XHJcbiAgICAvKiogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGEgQ2xvc2UgbWVzc2FnZSBhbmQgaW1wbGVtZW50cyB0aGUge0BsaW5rIEBhc3BuZXQvc2lnbmFsci5DbG9zZU1lc3NhZ2V9IGludGVyZmFjZS4gKi9cclxuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQ2xvc2VcIl0gPSA3XSA9IFwiQ2xvc2VcIjtcclxufSkoTWVzc2FnZVR5cGUgfHwgKE1lc3NhZ2VUeXBlID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUh1YlByb3RvY29sLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgLk5FVCBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuLy8gVGhlc2UgdmFsdWVzIGFyZSBkZXNpZ25lZCB0byBtYXRjaCB0aGUgQVNQLk5FVCBMb2cgTGV2ZWxzIHNpbmNlIHRoYXQncyB0aGUgcGF0dGVybiB3ZSdyZSBlbXVsYXRpbmcgaGVyZS5cclxuLyoqIEluZGljYXRlcyB0aGUgc2V2ZXJpdHkgb2YgYSBsb2cgbWVzc2FnZS5cclxuICpcclxuICogTG9nIExldmVscyBhcmUgb3JkZXJlZCBpbiBpbmNyZWFzaW5nIHNldmVyaXR5LiBTbyBgRGVidWdgIGlzIG1vcmUgc2V2ZXJlIHRoYW4gYFRyYWNlYCwgZXRjLlxyXG4gKi9cclxuZXhwb3J0IHZhciBMb2dMZXZlbDtcclxuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xyXG4gICAgLyoqIExvZyBsZXZlbCBmb3IgdmVyeSBsb3cgc2V2ZXJpdHkgZGlhZ25vc3RpYyBtZXNzYWdlcy4gKi9cclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiVHJhY2VcIl0gPSAwXSA9IFwiVHJhY2VcIjtcclxuICAgIC8qKiBMb2cgbGV2ZWwgZm9yIGxvdyBzZXZlcml0eSBkaWFnbm9zdGljIG1lc3NhZ2VzLiAqL1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJEZWJ1Z1wiXSA9IDFdID0gXCJEZWJ1Z1wiO1xyXG4gICAgLyoqIExvZyBsZXZlbCBmb3IgaW5mb3JtYXRpb25hbCBkaWFnbm9zdGljIG1lc3NhZ2VzLiAqL1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJbmZvcm1hdGlvblwiXSA9IDJdID0gXCJJbmZvcm1hdGlvblwiO1xyXG4gICAgLyoqIExvZyBsZXZlbCBmb3IgZGlhZ25vc3RpYyBtZXNzYWdlcyB0aGF0IGluZGljYXRlIGEgbm9uLWZhdGFsIHByb2JsZW0uICovXHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5pbmdcIl0gPSAzXSA9IFwiV2FybmluZ1wiO1xyXG4gICAgLyoqIExvZyBsZXZlbCBmb3IgZGlhZ25vc3RpYyBtZXNzYWdlcyB0aGF0IGluZGljYXRlIGEgZmFpbHVyZSBpbiB0aGUgY3VycmVudCBvcGVyYXRpb24uICovXHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVycm9yXCJdID0gNF0gPSBcIkVycm9yXCI7XHJcbiAgICAvKiogTG9nIGxldmVsIGZvciBkaWFnbm9zdGljIG1lc3NhZ2VzIHRoYXQgaW5kaWNhdGUgYSBmYWlsdXJlIHRoYXQgd2lsbCB0ZXJtaW5hdGUgdGhlIGVudGlyZSBhcHBsaWNhdGlvbi4gKi9cclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiQ3JpdGljYWxcIl0gPSA1XSA9IFwiQ3JpdGljYWxcIjtcclxuICAgIC8qKiBUaGUgaGlnaGVzdCBwb3NzaWJsZSBsb2cgbGV2ZWwuIFVzZWQgd2hlbiBjb25maWd1cmluZyBsb2dnaW5nIHRvIGluZGljYXRlIHRoYXQgbm8gbG9nIG1lc3NhZ2VzIHNob3VsZCBiZSBlbWl0dGVkLiAqL1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJOb25lXCJdID0gNl0gPSBcIk5vbmVcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUxvZ2dlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIC5ORVQgRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbi8vIFRoaXMgd2lsbCBiZSB0cmVhdGVkIGFzIGEgYml0IGZsYWcgaW4gdGhlIGZ1dHVyZSwgc28gd2Uga2VlcCBpdCB1c2luZyBwb3dlci1vZi10d28gdmFsdWVzLlxyXG4vKiogU3BlY2lmaWVzIGEgc3BlY2lmaWMgSFRUUCB0cmFuc3BvcnQgdHlwZS4gKi9cclxuZXhwb3J0IHZhciBIdHRwVHJhbnNwb3J0VHlwZTtcclxuKGZ1bmN0aW9uIChIdHRwVHJhbnNwb3J0VHlwZSkge1xyXG4gICAgLyoqIFNwZWNpZmllcyBubyB0cmFuc3BvcnQgcHJlZmVyZW5jZS4gKi9cclxuICAgIEh0dHBUcmFuc3BvcnRUeXBlW0h0dHBUcmFuc3BvcnRUeXBlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICAvKiogU3BlY2lmaWVzIHRoZSBXZWJTb2NrZXRzIHRyYW5zcG9ydC4gKi9cclxuICAgIEh0dHBUcmFuc3BvcnRUeXBlW0h0dHBUcmFuc3BvcnRUeXBlW1wiV2ViU29ja2V0c1wiXSA9IDFdID0gXCJXZWJTb2NrZXRzXCI7XHJcbiAgICAvKiogU3BlY2lmaWVzIHRoZSBTZXJ2ZXItU2VudCBFdmVudHMgdHJhbnNwb3J0LiAqL1xyXG4gICAgSHR0cFRyYW5zcG9ydFR5cGVbSHR0cFRyYW5zcG9ydFR5cGVbXCJTZXJ2ZXJTZW50RXZlbnRzXCJdID0gMl0gPSBcIlNlcnZlclNlbnRFdmVudHNcIjtcclxuICAgIC8qKiBTcGVjaWZpZXMgdGhlIExvbmcgUG9sbGluZyB0cmFuc3BvcnQuICovXHJcbiAgICBIdHRwVHJhbnNwb3J0VHlwZVtIdHRwVHJhbnNwb3J0VHlwZVtcIkxvbmdQb2xsaW5nXCJdID0gNF0gPSBcIkxvbmdQb2xsaW5nXCI7XHJcbn0pKEh0dHBUcmFuc3BvcnRUeXBlIHx8IChIdHRwVHJhbnNwb3J0VHlwZSA9IHt9KSk7XHJcbi8qKiBTcGVjaWZpZXMgdGhlIHRyYW5zZmVyIGZvcm1hdCBmb3IgYSBjb25uZWN0aW9uLiAqL1xyXG5leHBvcnQgdmFyIFRyYW5zZmVyRm9ybWF0O1xyXG4oZnVuY3Rpb24gKFRyYW5zZmVyRm9ybWF0KSB7XHJcbiAgICAvKiogU3BlY2lmaWVzIHRoYXQgb25seSB0ZXh0IGRhdGEgd2lsbCBiZSB0cmFuc21pdHRlZCBvdmVyIHRoZSBjb25uZWN0aW9uLiAqL1xyXG4gICAgVHJhbnNmZXJGb3JtYXRbVHJhbnNmZXJGb3JtYXRbXCJUZXh0XCJdID0gMV0gPSBcIlRleHRcIjtcclxuICAgIC8qKiBTcGVjaWZpZXMgdGhhdCBiaW5hcnkgZGF0YSB3aWxsIGJlIHRyYW5zbWl0dGVkIG92ZXIgdGhlIGNvbm5lY3Rpb24uICovXHJcbiAgICBUcmFuc2ZlckZvcm1hdFtUcmFuc2ZlckZvcm1hdFtcIkJpbmFyeVwiXSA9IDJdID0gXCJCaW5hcnlcIjtcclxufSkoVHJhbnNmZXJGb3JtYXQgfHwgKFRyYW5zZmVyRm9ybWF0ID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SVRyYW5zcG9ydC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIC5ORVQgRm91bmRhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbmltcG9ydCB7IE1lc3NhZ2VUeXBlIH0gZnJvbSBcIi4vSUh1YlByb3RvY29sXCI7XHJcbmltcG9ydCB7IExvZ0xldmVsIH0gZnJvbSBcIi4vSUxvZ2dlclwiO1xyXG5pbXBvcnQgeyBUcmFuc2ZlckZvcm1hdCB9IGZyb20gXCIuL0lUcmFuc3BvcnRcIjtcclxuaW1wb3J0IHsgTnVsbExvZ2dlciB9IGZyb20gXCIuL0xvZ2dlcnNcIjtcclxuaW1wb3J0IHsgVGV4dE1lc3NhZ2VGb3JtYXQgfSBmcm9tIFwiLi9UZXh0TWVzc2FnZUZvcm1hdFwiO1xyXG52YXIgSlNPTl9IVUJfUFJPVE9DT0xfTkFNRSA9IFwianNvblwiO1xyXG4vKiogSW1wbGVtZW50cyB0aGUgSlNPTiBIdWIgUHJvdG9jb2wuICovXHJcbnZhciBKc29uSHViUHJvdG9jb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBKc29uSHViUHJvdG9jb2woKSB7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy5uYW1lID0gSlNPTl9IVUJfUFJPVE9DT0xfTkFNRTtcclxuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgICAgICB0aGlzLnZlcnNpb24gPSAxO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMudHJhbnNmZXJGb3JtYXQgPSBUcmFuc2ZlckZvcm1hdC5UZXh0O1xyXG4gICAgfVxyXG4gICAgLyoqIENyZWF0ZXMgYW4gYXJyYXkgb2Yge0BsaW5rIEBhc3BuZXQvc2lnbmFsci5IdWJNZXNzYWdlfSBvYmplY3RzIGZyb20gdGhlIHNwZWNpZmllZCBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBBIHN0cmluZyBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtJTG9nZ2VyfSBsb2dnZXIgQSBsb2dnZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbG9nIG1lc3NhZ2VzIHRoYXQgb2NjdXIgZHVyaW5nIHBhcnNpbmcuXHJcbiAgICAgKi9cclxuICAgIEpzb25IdWJQcm90b2NvbC5wcm90b3R5cGUucGFyc2VNZXNzYWdlcyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9nZ2VyKSB7XHJcbiAgICAgICAgLy8gVGhlIGludGVyZmFjZSBkb2VzIGFsbG93IFwiQXJyYXlCdWZmZXJcIiB0byBiZSBwYXNzZWQgaW4sIGJ1dCB0aGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90LiBTbyBsZXQncyB0aHJvdyBhIHVzZWZ1bCBlcnJvci5cclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEpTT04gaHViIHByb3RvY29sLiBFeHBlY3RlZCBhIHN0cmluZy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaW5wdXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobG9nZ2VyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlciA9IE51bGxMb2dnZXIuaW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBhcnNlIHRoZSBtZXNzYWdlc1xyXG4gICAgICAgIHZhciBtZXNzYWdlcyA9IFRleHRNZXNzYWdlRm9ybWF0LnBhcnNlKGlucHV0KTtcclxuICAgICAgICB2YXIgaHViTWVzc2FnZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1lc3NhZ2VzXzEgPSBtZXNzYWdlczsgX2kgPCBtZXNzYWdlc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzXzFbX2ldO1xyXG4gICAgICAgICAgICB2YXIgcGFyc2VkTWVzc2FnZSA9IEpTT04ucGFyc2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2VkTWVzc2FnZS50eXBlICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBheWxvYWQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAocGFyc2VkTWVzc2FnZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkludm9jYXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0ludm9jYXRpb25NZXNzYWdlKHBhcnNlZE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TdHJlYW1JdGVtOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTdHJlYW1JdGVtTWVzc2FnZShwYXJzZWRNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQ29tcGxldGlvbjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29tcGxldGlvbk1lc3NhZ2UocGFyc2VkTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luZ2xlIHZhbHVlLCBubyBuZWVkIHRvIHZhbGlkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNsb3NlOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBvcHRpb25hbCB2YWx1ZXMsIG5vIG5lZWQgdG8gdmFsaWRhdGVcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRnV0dXJlIHByb3RvY29sIGNoYW5nZXMgY2FuIGFkZCBtZXNzYWdlIHR5cGVzLCBvbGQgY2xpZW50cyBjYW4gaWdub3JlIHRoZW1cclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKExvZ0xldmVsLkluZm9ybWF0aW9uLCBcIlVua25vd24gbWVzc2FnZSB0eXBlICdcIiArIHBhcnNlZE1lc3NhZ2UudHlwZSArIFwiJyBpZ25vcmVkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBodWJNZXNzYWdlcy5wdXNoKHBhcnNlZE1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaHViTWVzc2FnZXM7XHJcbiAgICB9O1xyXG4gICAgLyoqIFdyaXRlcyB0aGUgc3BlY2lmaWVkIHtAbGluayBAYXNwbmV0L3NpZ25hbHIuSHViTWVzc2FnZX0gdG8gYSBzdHJpbmcgYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtIdWJNZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHdyaXRlLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgY29udGFpbmluZyB0aGUgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgSnNvbkh1YlByb3RvY29sLnByb3RvdHlwZS53cml0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBUZXh0TWVzc2FnZUZvcm1hdC53cml0ZShKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XHJcbiAgICB9O1xyXG4gICAgSnNvbkh1YlByb3RvY29sLnByb3RvdHlwZS5pc0ludm9jYXRpb25NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLmFzc2VydE5vdEVtcHR5U3RyaW5nKG1lc3NhZ2UudGFyZ2V0LCBcIkludmFsaWQgcGF5bG9hZCBmb3IgSW52b2NhdGlvbiBtZXNzYWdlLlwiKTtcclxuICAgICAgICBpZiAobWVzc2FnZS5pbnZvY2F0aW9uSWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmFzc2VydE5vdEVtcHR5U3RyaW5nKG1lc3NhZ2UuaW52b2NhdGlvbklkLCBcIkludmFsaWQgcGF5bG9hZCBmb3IgSW52b2NhdGlvbiBtZXNzYWdlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSnNvbkh1YlByb3RvY29sLnByb3RvdHlwZS5pc1N0cmVhbUl0ZW1NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLmFzc2VydE5vdEVtcHR5U3RyaW5nKG1lc3NhZ2UuaW52b2NhdGlvbklkLCBcIkludmFsaWQgcGF5bG9hZCBmb3IgU3RyZWFtSXRlbSBtZXNzYWdlLlwiKTtcclxuICAgICAgICBpZiAobWVzc2FnZS5pdGVtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXlsb2FkIGZvciBTdHJlYW1JdGVtIG1lc3NhZ2UuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBKc29uSHViUHJvdG9jb2wucHJvdG90eXBlLmlzQ29tcGxldGlvbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCAmJiBtZXNzYWdlLmVycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGF5bG9hZCBmb3IgQ29tcGxldGlvbiBtZXNzYWdlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFtZXNzYWdlLnJlc3VsdCAmJiBtZXNzYWdlLmVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Tm90RW1wdHlTdHJpbmcobWVzc2FnZS5lcnJvciwgXCJJbnZhbGlkIHBheWxvYWQgZm9yIENvbXBsZXRpb24gbWVzc2FnZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90RW1wdHlTdHJpbmcobWVzc2FnZS5pbnZvY2F0aW9uSWQsIFwiSW52YWxpZCBwYXlsb2FkIGZvciBDb21wbGV0aW9uIG1lc3NhZ2UuXCIpO1xyXG4gICAgfTtcclxuICAgIEpzb25IdWJQcm90b2NvbC5wcm90b3R5cGUuYXNzZXJ0Tm90RW1wdHlTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGVycm9yTWVzc2FnZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUgPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBKc29uSHViUHJvdG9jb2w7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEpzb25IdWJQcm90b2NvbCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Kc29uSHViUHJvdG9jb2wuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSAuTkVUIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4vKiogQSBsb2dnZXIgdGhhdCBkb2VzIG5vdGhpbmcgd2hlbiBsb2cgbWVzc2FnZXMgYXJlIHNlbnQgdG8gaXQuICovXHJcbnZhciBOdWxsTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTnVsbExvZ2dlcigpIHtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXHJcbiAgICBOdWxsTG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoX2xvZ0xldmVsLCBfbWVzc2FnZSkge1xyXG4gICAgfTtcclxuICAgIC8qKiBUaGUgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQGFzcG5ldC9zaWduYWxyLk51bGxMb2dnZXJ9LiAqL1xyXG4gICAgTnVsbExvZ2dlci5pbnN0YW5jZSA9IG5ldyBOdWxsTG9nZ2VyKCk7XHJcbiAgICByZXR1cm4gTnVsbExvZ2dlcjtcclxufSgpKTtcclxuZXhwb3J0IHsgTnVsbExvZ2dlciB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2dnZXJzLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgLk5FVCBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59O1xyXG5pbXBvcnQgeyBBYm9ydENvbnRyb2xsZXIgfSBmcm9tIFwiLi9BYm9ydENvbnRyb2xsZXJcIjtcclxuaW1wb3J0IHsgSHR0cEVycm9yLCBUaW1lb3V0RXJyb3IgfSBmcm9tIFwiLi9FcnJvcnNcIjtcclxuaW1wb3J0IHsgTG9nTGV2ZWwgfSBmcm9tIFwiLi9JTG9nZ2VyXCI7XHJcbmltcG9ydCB7IFRyYW5zZmVyRm9ybWF0IH0gZnJvbSBcIi4vSVRyYW5zcG9ydFwiO1xyXG5pbXBvcnQgeyBBcmcsIGdldERhdGFEZXRhaWwsIHNlbmRNZXNzYWdlIH0gZnJvbSBcIi4vVXRpbHNcIjtcclxuLy8gTm90IGV4cG9ydGVkIGZyb20gJ2luZGV4JywgdGhpcyB0eXBlIGlzIGludGVybmFsLlxyXG4vKiogQHByaXZhdGUgKi9cclxudmFyIExvbmdQb2xsaW5nVHJhbnNwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTG9uZ1BvbGxpbmdUcmFuc3BvcnQoaHR0cENsaWVudCwgYWNjZXNzVG9rZW5GYWN0b3J5LCBsb2dnZXIsIGxvZ01lc3NhZ2VDb250ZW50KSB7XHJcbiAgICAgICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcclxuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuRmFjdG9yeSA9IGFjY2Vzc1Rva2VuRmFjdG9yeTtcclxuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcclxuICAgICAgICB0aGlzLnBvbGxBYm9ydCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgICAgICB0aGlzLmxvZ01lc3NhZ2VDb250ZW50ID0gbG9nTWVzc2FnZUNvbnRlbnQ7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbnJlY2VpdmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25jbG9zZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZ1BvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLCBcInBvbGxBYm9ydGVkXCIsIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVybmFsIHR5cGUsIG5vdCBleHBvcnRlZCBmcm9tICdpbmRleCcgc28gdGhpcyBpcyByZWFsbHkganVzdCBpbnRlcm5hbC5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9sbEFib3J0LmFib3J0ZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBMb25nUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1cmwsIHRyYW5zZmVyRm9ybWF0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcG9sbE9wdGlvbnMsIHRva2VuLCBwb2xsVXJsLCByZXNwb25zZTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXJnLmlzUmVxdWlyZWQodXJsLCBcInVybFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXJnLmlzUmVxdWlyZWQodHJhbnNmZXJGb3JtYXQsIFwidHJhbnNmZXJGb3JtYXRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFyZy5pc0luKHRyYW5zZmVyRm9ybWF0LCBUcmFuc2ZlckZvcm1hdCwgXCJ0cmFuc2ZlckZvcm1hdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5UcmFjZSwgXCIoTG9uZ1BvbGxpbmcgdHJhbnNwb3J0KSBDb25uZWN0aW5nLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgYmluYXJ5IGZvcm1hdCBvbiBOb2RlIGFuZCBCcm93c2VycyB0aGF0IHN1cHBvcnQgYmluYXJ5IGNvbnRlbnQgKGluZGljYXRlZCBieSB0aGUgcHJlc2VuY2Ugb2YgcmVzcG9uc2VUeXBlIHByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmZXJGb3JtYXQgPT09IFRyYW5zZmVyRm9ybWF0LkJpbmFyeSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmV3IFhNTEh0dHBSZXF1ZXN0KCkucmVzcG9uc2VUeXBlICE9PSBcInN0cmluZ1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmluYXJ5IHByb3RvY29scyBvdmVyIFhtbEh0dHBSZXF1ZXN0IG5vdCBpbXBsZW1lbnRpbmcgYWR2YW5jZWQgZmVhdHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbGxPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IHRoaXMucG9sbEFib3J0LnNpZ25hbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogMTAwMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmZXJGb3JtYXQgPT09IFRyYW5zZmVyRm9ybWF0LkJpbmFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9sbE9wdGlvbnMucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QWNjZXNzVG9rZW4oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIZWFkZXJUb2tlbihwb2xsT3B0aW9ucywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2xsVXJsID0gdXJsICsgXCImXz1cIiArIERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5UcmFjZSwgXCIoTG9uZ1BvbGxpbmcgdHJhbnNwb3J0KSBwb2xsaW5nOiBcIiArIHBvbGxVcmwgKyBcIi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cENsaWVudC5nZXQocG9sbFVybCwgcG9sbE9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuRXJyb3IsIFwiKExvbmdQb2xsaW5nIHRyYW5zcG9ydCkgVW5leHBlY3RlZCByZXNwb25zZSBjb2RlOiBcIiArIHJlc3BvbnNlLnN0YXR1c0NvZGUgKyBcIi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIHJ1bm5pbmcgYXMgZmFsc2Ugc28gdGhhdCB0aGUgcG9sbCBpbW1lZGlhdGVseSBlbmRzIGFuZCBydW5zIHRoZSBjbG9zZSBsb2dpY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUVycm9yID0gbmV3IEh0dHBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0IHx8IFwiXCIsIHJlc3BvbnNlLnN0YXR1c0NvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nID0gdGhpcy5wb2xsKHRoaXMudXJsLCBwb2xsT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTG9uZ1BvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLmdldEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFjY2Vzc1Rva2VuRmFjdG9yeSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuYWNjZXNzVG9rZW5GYWN0b3J5KCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIExvbmdQb2xsaW5nVHJhbnNwb3J0LnByb3RvdHlwZS51cGRhdGVIZWFkZXJUb2tlbiA9IGZ1bmN0aW9uIChyZXF1ZXN0LCB0b2tlbikge1xyXG4gICAgICAgIGlmICghcmVxdWVzdC5oZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXN0cmluZy1saXRlcmFsXHJcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJlYXJlciBcIiArIHRva2VuO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zdHJpbmctbGl0ZXJhbFxyXG4gICAgICAgIGlmIChyZXF1ZXN0LmhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zdHJpbmctbGl0ZXJhbFxyXG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdC5oZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTG9uZ1BvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAodXJsLCBwb2xsT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuLCBwb2xsVXJsLCByZXNwb25zZSwgZV8xO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsICwgOCwgOV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucnVubmluZykgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QWNjZXNzVG9rZW4oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIZWFkZXJUb2tlbihwb2xsT3B0aW9ucywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2xsVXJsID0gdXJsICsgXCImXz1cIiArIERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5UcmFjZSwgXCIoTG9uZ1BvbGxpbmcgdHJhbnNwb3J0KSBwb2xsaW5nOiBcIiArIHBvbGxVcmwgKyBcIi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cENsaWVudC5nZXQocG9sbFVybCwgcG9sbE9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuSW5mb3JtYXRpb24sIFwiKExvbmdQb2xsaW5nIHRyYW5zcG9ydCkgUG9sbCB0ZXJtaW5hdGVkIGJ5IHNlcnZlci5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5FcnJvciwgXCIoTG9uZ1BvbGxpbmcgdHJhbnNwb3J0KSBVbmV4cGVjdGVkIHJlc3BvbnNlIGNvZGU6IFwiICsgcmVzcG9uc2Uuc3RhdHVzQ29kZSArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgc3RhdHVzIGNvZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VFcnJvciA9IG5ldyBIdHRwRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCB8fCBcIlwiLCByZXNwb25zZS5zdGF0dXNDb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLlRyYWNlLCBcIihMb25nUG9sbGluZyB0cmFuc3BvcnQpIGRhdGEgcmVjZWl2ZWQuIFwiICsgZ2V0RGF0YURldGFpbChyZXNwb25zZS5jb250ZW50LCB0aGlzLmxvZ01lc3NhZ2VDb250ZW50KSArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbnJlY2VpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbnJlY2VpdmUocmVzcG9uc2UuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbm90aGVyIHdheSB0aW1lb3V0IG1hbmlmZXN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5UcmFjZSwgXCIoTG9uZ1BvbGxpbmcgdHJhbnNwb3J0KSBQb2xsIHRpbWVkIG91dCwgcmVpc3N1aW5nLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvZyBidXQgZGlzcmVnYXJkIGVycm9ycyB0aGF0IG9jY3VyIGFmdGVyIHN0b3BwaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuVHJhY2UsIFwiKExvbmdQb2xsaW5nIHRyYW5zcG9ydCkgUG9sbCBlcnJvcmVkIGFmdGVyIHNodXRkb3duOiBcIiArIGVfMS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEgaW5zdGFuY2VvZiBUaW1lb3V0RXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGltZW91dHMgYW5kIHJlaXNzdWUgdGhlIHBvbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLlRyYWNlLCBcIihMb25nUG9sbGluZyB0cmFuc3BvcnQpIFBvbGwgdGltZWQgb3V0LCByZWlzc3VpbmcuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2UgdGhlIGNvbm5lY3Rpb24gd2l0aCB0aGUgZXJyb3IgYXMgdGhlIHJlc3VsdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlRXJyb3IgPSBlXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLlRyYWNlLCBcIihMb25nUG9sbGluZyB0cmFuc3BvcnQpIFBvbGxpbmcgY29tcGxldGUuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIHJlYWNoIGhlcmUgd2l0aCBwb2xsQWJvcnRlZD09ZmFsc2Ugd2hlbiB0aGUgc2VydmVyIHJldHVybmVkIGEgcmVzcG9uc2UgY2F1c2luZyB0aGUgdHJhbnNwb3J0IHRvIHN0b3AuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHBvbGxBYm9ydGVkPT10cnVlIHRoZW4gY2xpZW50IGluaXRpYXRlZCB0aGUgc3RvcCBhbmQgdGhlIHN0b3AgbWV0aG9kIHdpbGwgcmFpc2UgdGhlIGNsb3NlIGV2ZW50IGFmdGVyIERFTEVURSBpcyBzZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucG9sbEFib3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2VPbkNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTG9uZ1BvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQ2Fubm90IHNlbmQgdW50aWwgdGhlIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWRcIikpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBzZW5kTWVzc2FnZSh0aGlzLmxvZ2dlciwgXCJMb25nUG9sbGluZ1wiLCB0aGlzLmh0dHBDbGllbnQsIHRoaXMudXJsLCB0aGlzLmFjY2Vzc1Rva2VuRmFjdG9yeSwgZGF0YSwgdGhpcy5sb2dNZXNzYWdlQ29udGVudCldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBMb25nUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWxldGVPcHRpb25zLCB0b2tlbjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLlRyYWNlLCBcIihMb25nUG9sbGluZyB0cmFuc3BvcnQpIFN0b3BwaW5nIHBvbGxpbmcuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIHJlY2VpdmluZyBsb29wIHRvIHN0b3AsIGFib3J0IGFueSBjdXJyZW50IHJlcXVlc3QsIGFuZCB0aGVuIHdhaXQgZm9yIGl0IHRvIGZpbmlzaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsQWJvcnQuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAsIDUsIDZdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZWNlaXZpbmddO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIERFTEVURSB0byBjbGVhbiB1cCBsb25nIHBvbGxpbmcgb24gdGhlIHNlcnZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuVHJhY2UsIFwiKExvbmdQb2xsaW5nIHRyYW5zcG9ydCkgc2VuZGluZyBERUxFVEUgcmVxdWVzdCB0byBcIiArIHRoaXMudXJsICsgXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QWNjZXNzVG9rZW4oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIZWFkZXJUb2tlbihkZWxldGVPcHRpb25zLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cENsaWVudC5kZWxldGUodGhpcy51cmwsIGRlbGV0ZU9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLlRyYWNlLCBcIihMb25nUG9sbGluZyB0cmFuc3BvcnQpIERFTEVURSByZXF1ZXN0IHNlbnQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5UcmFjZSwgXCIoTG9uZ1BvbGxpbmcgdHJhbnNwb3J0KSBTdG9wIGZpbmlzaGVkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmFpc2UgY2xvc2UgZXZlbnQgaGVyZSBpbnN0ZWFkIG9mIGluIHBvbGxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSBERUxFVEUgcmVxdWVzdCBpcyBzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2VPbkNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIExvbmdQb2xsaW5nVHJhbnNwb3J0LnByb3RvdHlwZS5yYWlzZU9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub25jbG9zZSkge1xyXG4gICAgICAgICAgICB2YXIgbG9nTWVzc2FnZSA9IFwiKExvbmdQb2xsaW5nIHRyYW5zcG9ydCkgRmlyaW5nIG9uY2xvc2UgZXZlbnQuXCI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsb3NlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGxvZ01lc3NhZ2UgKz0gXCIgRXJyb3I6IFwiICsgdGhpcy5jbG9zZUVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5UcmFjZSwgbG9nTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHRoaXMub25jbG9zZSh0aGlzLmNsb3NlRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTG9uZ1BvbGxpbmdUcmFuc3BvcnQ7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IExvbmdQb2xsaW5nVHJhbnNwb3J0IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvbmdQb2xsaW5nVHJhbnNwb3J0LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgLk5FVCBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59O1xyXG5pbXBvcnQgeyBMb2dMZXZlbCB9IGZyb20gXCIuL0lMb2dnZXJcIjtcclxuaW1wb3J0IHsgVHJhbnNmZXJGb3JtYXQgfSBmcm9tIFwiLi9JVHJhbnNwb3J0XCI7XHJcbmltcG9ydCB7IEFyZywgZ2V0RGF0YURldGFpbCwgc2VuZE1lc3NhZ2UgfSBmcm9tIFwiLi9VdGlsc1wiO1xyXG4vKiogQHByaXZhdGUgKi9cclxudmFyIFNlcnZlclNlbnRFdmVudHNUcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZXJ2ZXJTZW50RXZlbnRzVHJhbnNwb3J0KGh0dHBDbGllbnQsIGFjY2Vzc1Rva2VuRmFjdG9yeSwgbG9nZ2VyLCBsb2dNZXNzYWdlQ29udGVudCwgZXZlbnRTb3VyY2VDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbkZhY3RvcnkgPSBhY2Nlc3NUb2tlbkZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XHJcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlQ29udGVudCA9IGxvZ01lc3NhZ2VDb250ZW50O1xyXG4gICAgICAgIHRoaXMuZXZlbnRTb3VyY2VDb25zdHJ1Y3RvciA9IGV2ZW50U291cmNlQ29uc3RydWN0b3I7XHJcbiAgICAgICAgdGhpcy5vbnJlY2VpdmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25jbG9zZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBTZXJ2ZXJTZW50RXZlbnRzVHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHVybCwgdHJhbnNmZXJGb3JtYXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbjtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXJnLmlzUmVxdWlyZWQodXJsLCBcInVybFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXJnLmlzUmVxdWlyZWQodHJhbnNmZXJGb3JtYXQsIFwidHJhbnNmZXJGb3JtYXRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFyZy5pc0luKHRyYW5zZmVyRm9ybWF0LCBUcmFuc2ZlckZvcm1hdCwgXCJ0cmFuc2ZlckZvcm1hdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLlRyYWNlLCBcIihTU0UgdHJhbnNwb3J0KSBDb25uZWN0aW5nLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHVybCBiZWZvcmUgYWNjZXNzVG9rZW5GYWN0b3J5IGJlY2F1c2UgdGhpcy51cmwgaXMgb25seSBmb3Igc2VuZCBhbmQgd2Ugc2V0IHRoZSBhdXRoIGhlYWRlciBpbnN0ZWFkIG9mIHRoZSBxdWVyeSBzdHJpbmcgZm9yIHNlbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY2Nlc3NUb2tlbkZhY3RvcnkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmFjY2Vzc1Rva2VuRmFjdG9yeSgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSAodXJsLmluZGV4T2YoXCI/XCIpIDwgMCA/IFwiP1wiIDogXCImXCIpICsgKFwiYWNjZXNzX3Rva2VuPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHRva2VuKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2ZlckZvcm1hdCAhPT0gVHJhbnNmZXJGb3JtYXQuVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaGUgU2VydmVyLVNlbnQgRXZlbnRzIHRyYW5zcG9ydCBvbmx5IHN1cHBvcnRzIHRoZSAnVGV4dCcgdHJhbnNmZXIgZm9ybWF0XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlID0gbmV3IF90aGlzLmV2ZW50U291cmNlQ29uc3RydWN0b3IodXJsLCB7IHdpdGhDcmVkZW50aWFsczogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vbi1icm93c2VyIHBhc3NlcyBjb29raWVzIHZpYSB0aGUgZGljdGlvbmFyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29raWVzID0gX3RoaXMuaHR0cENsaWVudC5nZXRDb29raWVTdHJpbmcodXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZSA9IG5ldyBfdGhpcy5ldmVudFNvdXJjZUNvbnN0cnVjdG9yKHVybCwgeyB3aXRoQ3JlZGVudGlhbHM6IHRydWUsIGhlYWRlcnM6IHsgQ29va2llOiBjb29raWVzIH0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vbnJlY2VpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5UcmFjZSwgXCIoU1NFIHRyYW5zcG9ydCkgZGF0YSByZWNlaXZlZC4gXCIgKyBnZXREYXRhRGV0YWlsKGUuZGF0YSwgX3RoaXMubG9nTWVzc2FnZUNvbnRlbnQpICsgXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9ucmVjZWl2ZShlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2Uub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihlLmRhdGEgfHwgXCJFcnJvciBvY2N1cnJlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2Uub25vcGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLkluZm9ybWF0aW9uLCBcIlNTRSBjb25uZWN0ZWQgdG8gXCIgKyBfdGhpcy51cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudFNvdXJjZSA9IGV2ZW50U291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTZXJ2ZXJTZW50RXZlbnRzVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5ldmVudFNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJDYW5ub3Qgc2VuZCB1bnRpbCB0aGUgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZFwiKSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNlbmRNZXNzYWdlKHRoaXMubG9nZ2VyLCBcIlNTRVwiLCB0aGlzLmh0dHBDbGllbnQsIHRoaXMudXJsLCB0aGlzLmFjY2Vzc1Rva2VuRmFjdG9yeSwgZGF0YSwgdGhpcy5sb2dNZXNzYWdlQ29udGVudCldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTZXJ2ZXJTZW50RXZlbnRzVHJhbnNwb3J0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9O1xyXG4gICAgU2VydmVyU2VudEV2ZW50c1RyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTb3VyY2UuY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFNvdXJjZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25jbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbmNsb3NlKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTZXJ2ZXJTZW50RXZlbnRzVHJhbnNwb3J0O1xyXG59KCkpO1xyXG5leHBvcnQgeyBTZXJ2ZXJTZW50RXZlbnRzVHJhbnNwb3J0IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlcnZlclNlbnRFdmVudHNUcmFuc3BvcnQuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSAuTkVUIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4vLyBOb3QgZXhwb3J0ZWQgZnJvbSBpbmRleFxyXG4vKiogQHByaXZhdGUgKi9cclxudmFyIFRleHRNZXNzYWdlRm9ybWF0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGV4dE1lc3NhZ2VGb3JtYXQoKSB7XHJcbiAgICB9XHJcbiAgICBUZXh0TWVzc2FnZUZvcm1hdC53cml0ZSA9IGZ1bmN0aW9uIChvdXRwdXQpIHtcclxuICAgICAgICByZXR1cm4gXCJcIiArIG91dHB1dCArIFRleHRNZXNzYWdlRm9ybWF0LlJlY29yZFNlcGFyYXRvcjtcclxuICAgIH07XHJcbiAgICBUZXh0TWVzc2FnZUZvcm1hdC5wYXJzZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIGlmIChpbnB1dFtpbnB1dC5sZW5ndGggLSAxXSAhPT0gVGV4dE1lc3NhZ2VGb3JtYXQuUmVjb3JkU2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2UgaXMgaW5jb21wbGV0ZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtZXNzYWdlcyA9IGlucHV0LnNwbGl0KFRleHRNZXNzYWdlRm9ybWF0LlJlY29yZFNlcGFyYXRvcik7XHJcbiAgICAgICAgbWVzc2FnZXMucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xyXG4gICAgfTtcclxuICAgIFRleHRNZXNzYWdlRm9ybWF0LlJlY29yZFNlcGFyYXRvckNvZGUgPSAweDFlO1xyXG4gICAgVGV4dE1lc3NhZ2VGb3JtYXQuUmVjb3JkU2VwYXJhdG9yID0gU3RyaW5nLmZyb21DaGFyQ29kZShUZXh0TWVzc2FnZUZvcm1hdC5SZWNvcmRTZXBhcmF0b3JDb2RlKTtcclxuICAgIHJldHVybiBUZXh0TWVzc2FnZUZvcm1hdDtcclxufSgpKTtcclxuZXhwb3J0IHsgVGV4dE1lc3NhZ2VGb3JtYXQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dE1lc3NhZ2VGb3JtYXQuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSAuTkVUIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbmltcG9ydCB7IExvZ0xldmVsIH0gZnJvbSBcIi4vSUxvZ2dlclwiO1xyXG5pbXBvcnQgeyBOdWxsTG9nZ2VyIH0gZnJvbSBcIi4vTG9nZ2Vyc1wiO1xyXG4vKiogQHByaXZhdGUgKi9cclxudmFyIEFyZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFyZygpIHtcclxuICAgIH1cclxuICAgIEFyZy5pc1JlcXVpcmVkID0gZnVuY3Rpb24gKHZhbCwgbmFtZSkge1xyXG4gICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdcIiArIG5hbWUgKyBcIicgYXJndW1lbnQgaXMgcmVxdWlyZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBcmcuaXNJbiA9IGZ1bmN0aW9uICh2YWwsIHZhbHVlcywgbmFtZSkge1xyXG4gICAgICAgIC8vIFR5cGVTY3JpcHQgZW51bXMgaGF2ZSBrZXlzIGZvciAqKmJvdGgqKiB0aGUgbmFtZSBhbmQgdGhlIHZhbHVlIG9mIGVhY2ggZW51bSBtZW1iZXIgb24gdGhlIHR5cGUgaXRzZWxmLlxyXG4gICAgICAgIGlmICghKHZhbCBpbiB2YWx1ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gXCIgKyBuYW1lICsgXCIgdmFsdWU6IFwiICsgdmFsICsgXCIuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQXJnO1xyXG59KCkpO1xyXG5leHBvcnQgeyBBcmcgfTtcclxuLyoqIEBwcml2YXRlICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhRGV0YWlsKGRhdGEsIGluY2x1ZGVDb250ZW50KSB7XHJcbiAgICB2YXIgZGV0YWlsID0gXCJcIjtcclxuICAgIGlmIChpc0FycmF5QnVmZmVyKGRhdGEpKSB7XHJcbiAgICAgICAgZGV0YWlsID0gXCJCaW5hcnkgZGF0YSBvZiBsZW5ndGggXCIgKyBkYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVDb250ZW50KSB7XHJcbiAgICAgICAgICAgIGRldGFpbCArPSBcIi4gQ29udGVudDogJ1wiICsgZm9ybWF0QXJyYXlCdWZmZXIoZGF0YSkgKyBcIidcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGRldGFpbCA9IFwiU3RyaW5nIGRhdGEgb2YgbGVuZ3RoIFwiICsgZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVDb250ZW50KSB7XHJcbiAgICAgICAgICAgIGRldGFpbCArPSBcIi4gQ29udGVudDogJ1wiICsgZGF0YSArIFwiJ1wiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZXRhaWw7XHJcbn1cclxuLyoqIEBwcml2YXRlICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBcnJheUJ1ZmZlcihkYXRhKSB7XHJcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgLy8gVWludDhBcnJheS5tYXAgb25seSBzdXBwb3J0cyByZXR1cm5pbmcgYW5vdGhlciBVaW50OEFycmF5P1xyXG4gICAgdmFyIHN0ciA9IFwiXCI7XHJcbiAgICB2aWV3LmZvckVhY2goZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHZhciBwYWQgPSBudW0gPCAxNiA/IFwiMFwiIDogXCJcIjtcclxuICAgICAgICBzdHIgKz0gXCIweFwiICsgcGFkICsgbnVtLnRvU3RyaW5nKDE2KSArIFwiIFwiO1xyXG4gICAgfSk7XHJcbiAgICAvLyBUcmltIG9mIHRyYWlsaW5nIHNwYWNlLlxyXG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgc3RyLmxlbmd0aCAtIDEpO1xyXG59XHJcbi8vIEFsc28gaW4gc2lnbmFsci1wcm90b2NvbC1tc2dwYWNrL1V0aWxzLnRzXHJcbi8qKiBAcHJpdmF0ZSAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcclxuICAgIHJldHVybiB2YWwgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmXHJcbiAgICAgICAgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XHJcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyB3ZSBnZXQgYW4gQXJyYXlCdWZmZXIgdGhhdCBkb2Vzbid0IHNhdGlzZnkgaW5zdGFuY2VvZlxyXG4gICAgICAgICAgICAodmFsLmNvbnN0cnVjdG9yICYmIHZhbC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkFycmF5QnVmZmVyXCIpKTtcclxufVxyXG4vKiogQHByaXZhdGUgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRNZXNzYWdlKGxvZ2dlciwgdHJhbnNwb3J0TmFtZSwgaHR0cENsaWVudCwgdXJsLCBhY2Nlc3NUb2tlbkZhY3RvcnksIGNvbnRlbnQsIGxvZ01lc3NhZ2VDb250ZW50KSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBoZWFkZXJzLCB0b2tlbiwgcmVzcG9uc2VUeXBlLCByZXNwb25zZTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFjY2Vzc1Rva2VuRmFjdG9yeSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYWNjZXNzVG9rZW5GYWN0b3J5KCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0gKF9hID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYVtcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJlYXJlciBcIiArIHRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhMb2dMZXZlbC5UcmFjZSwgXCIoXCIgKyB0cmFuc3BvcnROYW1lICsgXCIgdHJhbnNwb3J0KSBzZW5kaW5nIGRhdGEuIFwiICsgZ2V0RGF0YURldGFpbChjb250ZW50LCBsb2dNZXNzYWdlQ29udGVudCkgKyBcIi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlID0gaXNBcnJheUJ1ZmZlcihjb250ZW50KSA/IFwiYXJyYXlidWZmZXJcIiA6IFwidGV4dFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGh0dHBDbGllbnQucG9zdCh1cmwsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiByZXNwb25zZVR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKExvZ0xldmVsLlRyYWNlLCBcIihcIiArIHRyYW5zcG9ydE5hbWUgKyBcIiB0cmFuc3BvcnQpIHJlcXVlc3QgY29tcGxldGUuIFJlc3BvbnNlIHN0YXR1czogXCIgKyByZXNwb25zZS5zdGF0dXNDb2RlICsgXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqIEBwcml2YXRlICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2dnZXIobG9nZ2VyKSB7XHJcbiAgICBpZiAobG9nZ2VyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbnNvbGVMb2dnZXIoTG9nTGV2ZWwuSW5mb3JtYXRpb24pO1xyXG4gICAgfVxyXG4gICAgaWYgKGxvZ2dlciA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBOdWxsTG9nZ2VyLmluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGxvZ2dlci5sb2cpIHtcclxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBDb25zb2xlTG9nZ2VyKGxvZ2dlcik7XHJcbn1cclxuLyoqIEBwcml2YXRlICovXHJcbnZhciBTdWJqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3ViamVjdChjYW5jZWxDYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5jYW5jZWxDYWxsYmFjayA9IGNhbmNlbENhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMub2JzZXJ2ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFN1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLm9ic2VydmVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIG9ic2VydmVyID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMub2JzZXJ2ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGlmIChvYnNlcnZlci5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpcHRpb24odGhpcywgb2JzZXJ2ZXIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdWJqZWN0O1xyXG59KCkpO1xyXG5leHBvcnQgeyBTdWJqZWN0IH07XHJcbi8qKiBAcHJpdmF0ZSAqL1xyXG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpcHRpb24oc3ViamVjdCwgb2JzZXJ2ZXIpIHtcclxuICAgICAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgIH1cclxuICAgIFN1YmplY3RTdWJzY3JpcHRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5zdWJqZWN0Lm9ic2VydmVycy5pbmRleE9mKHRoaXMub2JzZXJ2ZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdC5vYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3ViamVjdC5vYnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdC5jYW5jZWxDYWxsYmFjaygpLmNhdGNoKGZ1bmN0aW9uIChfKSB7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gU3ViamVjdFN1YnNjcmlwdGlvbjtcclxufSgpKTtcclxuZXhwb3J0IHsgU3ViamVjdFN1YnNjcmlwdGlvbiB9O1xyXG4vKiogQHByaXZhdGUgKi9cclxudmFyIENvbnNvbGVMb2dnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb25zb2xlTG9nZ2VyKG1pbmltdW1Mb2dMZXZlbCkge1xyXG4gICAgICAgIHRoaXMubWluaW11bUxvZ0xldmVsID0gbWluaW11bUxvZ0xldmVsO1xyXG4gICAgfVxyXG4gICAgQ29uc29sZUxvZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGxvZ0xldmVsLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGxvZ0xldmVsID49IHRoaXMubWluaW11bUxvZ0xldmVsKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobG9nTGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTG9nTGV2ZWwuQ3JpdGljYWw6XHJcbiAgICAgICAgICAgICAgICBjYXNlIExvZ0xldmVsLkVycm9yOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbXCIgKyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyBcIl0gXCIgKyBMb2dMZXZlbFtsb2dMZXZlbF0gKyBcIjogXCIgKyBtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTG9nTGV2ZWwuV2FybmluZzpcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbXCIgKyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyBcIl0gXCIgKyBMb2dMZXZlbFtsb2dMZXZlbF0gKyBcIjogXCIgKyBtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTG9nTGV2ZWwuSW5mb3JtYXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiW1wiICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgXCJdIFwiICsgTG9nTGV2ZWxbbG9nTGV2ZWxdICsgXCI6IFwiICsgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcgb25seSBnb2VzIHRvIGF0dGFjaGVkIGRlYnVnZ2VycyBpbiBOb2RlLCBzbyB3ZSB1c2UgY29uc29sZS5sb2cgZm9yIFRyYWNlIGFuZCBEZWJ1Z1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1wiICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgXCJdIFwiICsgTG9nTGV2ZWxbbG9nTGV2ZWxdICsgXCI6IFwiICsgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbnNvbGVMb2dnZXI7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IENvbnNvbGVMb2dnZXIgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXRpbHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSAuTkVUIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbmltcG9ydCB7IExvZ0xldmVsIH0gZnJvbSBcIi4vSUxvZ2dlclwiO1xyXG5pbXBvcnQgeyBUcmFuc2ZlckZvcm1hdCB9IGZyb20gXCIuL0lUcmFuc3BvcnRcIjtcclxuaW1wb3J0IHsgQXJnLCBnZXREYXRhRGV0YWlsIH0gZnJvbSBcIi4vVXRpbHNcIjtcclxuLyoqIEBwcml2YXRlICovXHJcbnZhciBXZWJTb2NrZXRUcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQoaHR0cENsaWVudCwgYWNjZXNzVG9rZW5GYWN0b3J5LCBsb2dnZXIsIGxvZ01lc3NhZ2VDb250ZW50LCB3ZWJTb2NrZXRDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW5GYWN0b3J5ID0gYWNjZXNzVG9rZW5GYWN0b3J5O1xyXG4gICAgICAgIHRoaXMubG9nTWVzc2FnZUNvbnRlbnQgPSBsb2dNZXNzYWdlQ29udGVudDtcclxuICAgICAgICB0aGlzLndlYlNvY2tldENvbnN0cnVjdG9yID0gd2ViU29ja2V0Q29uc3RydWN0b3I7XHJcbiAgICAgICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcclxuICAgICAgICB0aGlzLm9ucmVjZWl2ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gbnVsbDtcclxuICAgIH1cclxuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1cmwsIHRyYW5zZmVyRm9ybWF0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdG9rZW47XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFyZy5pc1JlcXVpcmVkKHVybCwgXCJ1cmxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFyZy5pc1JlcXVpcmVkKHRyYW5zZmVyRm9ybWF0LCBcInRyYW5zZmVyRm9ybWF0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBBcmcuaXNJbih0cmFuc2ZlckZvcm1hdCwgVHJhbnNmZXJGb3JtYXQsIFwidHJhbnNmZXJGb3JtYXRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhMb2dMZXZlbC5UcmFjZSwgXCIoV2ViU29ja2V0cyB0cmFuc3BvcnQpIENvbm5lY3RpbmcuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWNjZXNzVG9rZW5GYWN0b3J5KSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5hY2Nlc3NUb2tlbkZhY3RvcnkoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gKHVybC5pbmRleE9mKFwiP1wiKSA8IDAgPyBcIj9cIiA6IFwiJlwiKSArIChcImFjY2Vzc190b2tlbj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh0b2tlbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXmh0dHAvLCBcIndzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlYlNvY2tldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29raWVzID0gX3RoaXMuaHR0cENsaWVudC5nZXRDb29raWVTdHJpbmcodXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiICYmIGNvb2tpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHBhc3MgY29va2llcyB3aGVuIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYlNvY2tldCA9IG5ldyBfdGhpcy53ZWJTb2NrZXRDb25zdHJ1Y3Rvcih1cmwsIHVuZGVmaW5lZCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb29raWU6IFwiXCIgKyBjb29raWVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3ZWJTb2NrZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgaXMgbm90IGhhcHB5IHdpdGggcGFzc2luZyAndW5kZWZpbmVkJyBhcyBwcm90b2NvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYlNvY2tldCA9IG5ldyBfdGhpcy53ZWJTb2NrZXRDb25zdHJ1Y3Rvcih1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZmVyRm9ybWF0ID09PSBUcmFuc2ZlckZvcm1hdC5CaW5hcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJTb2NrZXQuYmluYXJ5VHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJTb2NrZXQub25vcGVuID0gZnVuY3Rpb24gKF9ldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuSW5mb3JtYXRpb24sIFwiV2ViU29ja2V0IGNvbm5lY3RlZCB0byBcIiArIHVybCArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy53ZWJTb2NrZXQgPSB3ZWJTb2NrZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYlNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFcnJvckV2ZW50IGlzIGEgYnJvd3NlciBvbmx5IHR5cGUgd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgdHlwZSBleGlzdHMgYmVmb3JlIHVzaW5nIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBFcnJvckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGV2ZW50IGluc3RhbmNlb2YgRXJyb3JFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYlNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuVHJhY2UsIFwiKFdlYlNvY2tldHMgdHJhbnNwb3J0KSBkYXRhIHJlY2VpdmVkLiBcIiArIGdldERhdGFEZXRhaWwobWVzc2FnZS5kYXRhLCBfdGhpcy5sb2dNZXNzYWdlQ29udGVudCkgKyBcIi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLm9ucmVjZWl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbnJlY2VpdmUobWVzc2FnZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViU29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmNsb3NlKGV2ZW50KTsgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLndlYlNvY2tldCAmJiB0aGlzLndlYlNvY2tldC5yZWFkeVN0YXRlID09PSB0aGlzLndlYlNvY2tldENvbnN0cnVjdG9yLk9QRU4pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLlRyYWNlLCBcIihXZWJTb2NrZXRzIHRyYW5zcG9ydCkgc2VuZGluZyBkYXRhLiBcIiArIGdldERhdGFEZXRhaWwoZGF0YSwgdGhpcy5sb2dNZXNzYWdlQ29udGVudCkgKyBcIi5cIik7XHJcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0LnNlbmQoZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiV2ViU29ja2V0IGlzIG5vdCBpbiB0aGUgT1BFTiBzdGF0ZVwiKTtcclxuICAgIH07XHJcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2ViU29ja2V0KSB7XHJcbiAgICAgICAgICAgIC8vIENsZWFyIHdlYnNvY2tldCBoYW5kbGVycyBiZWNhdXNlIHdlIGFyZSBjb25zaWRlcmluZyB0aGUgc29ja2V0IGNsb3NlZCBub3dcclxuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldC5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIG9uY2xvc2UgY2FsbGJhY2sgaW5saW5lIHNvIHdlIGtub3cgdGhlIEh0dHBDb25uZWN0aW9uIHdhcyBjbG9zZWQgcHJvcGVybHkgYmVmb3JlIHJldHVybmluZ1xyXG4gICAgICAgICAgICAvLyBUaGlzIGFsc28gc29sdmVzIGFuIGlzc3VlIHdoZXJlIHdlYnNvY2tldC5vbmNsb3NlIGNvdWxkIHRha2UgMTgrIHNlY29uZHMgdG8gdHJpZ2dlciBkdXJpbmcgbmV0d29yayBkaXNjb25uZWN0c1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH07XHJcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgLy8gd2ViU29ja2V0IHdpbGwgYmUgbnVsbCBpZiB0aGUgdHJhbnNwb3J0IGRpZCBub3Qgc3RhcnQgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLlRyYWNlLCBcIihXZWJTb2NrZXRzIHRyYW5zcG9ydCkgc29ja2V0IGNsb3NlZC5cIik7XHJcbiAgICAgICAgaWYgKHRoaXMub25jbG9zZSkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgKGV2ZW50Lndhc0NsZWFuID09PSBmYWxzZSB8fCBldmVudC5jb2RlICE9PSAxMDAwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbmNsb3NlKG5ldyBFcnJvcihcIldlYlNvY2tldCBjbG9zZWQgd2l0aCBzdGF0dXMgY29kZTogXCIgKyBldmVudC5jb2RlICsgXCIgKFwiICsgZXZlbnQucmVhc29uICsgXCIpLlwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gV2ViU29ja2V0VHJhbnNwb3J0O1xyXG59KCkpO1xyXG5leHBvcnQgeyBXZWJTb2NrZXRUcmFuc3BvcnQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViU29ja2V0VHJhbnNwb3J0LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgLk5FVCBGb3VuZGF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbmltcG9ydCB7IEFib3J0RXJyb3IsIEh0dHBFcnJvciwgVGltZW91dEVycm9yIH0gZnJvbSBcIi4vRXJyb3JzXCI7XHJcbmltcG9ydCB7IEh0dHBDbGllbnQsIEh0dHBSZXNwb25zZSB9IGZyb20gXCIuL0h0dHBDbGllbnRcIjtcclxuaW1wb3J0IHsgTG9nTGV2ZWwgfSBmcm9tIFwiLi9JTG9nZ2VyXCI7XHJcbnZhciBYaHJIdHRwQ2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFhockh0dHBDbGllbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBYaHJIdHRwQ2xpZW50KGxvZ2dlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgWGhySHR0cENsaWVudC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBDaGVjayB0aGF0IGFib3J0IHdhcyBub3Qgc2lnbmFsZWQgYmVmb3JlIGNhbGxpbmcgc2VuZFxyXG4gICAgICAgIGlmIChyZXF1ZXN0LmFib3J0U2lnbmFsICYmIHJlcXVlc3QuYWJvcnRTaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEFib3J0RXJyb3IoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcmVxdWVzdC5tZXRob2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIG1ldGhvZCBkZWZpbmVkLlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcmVxdWVzdC51cmwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIHVybCBkZWZpbmVkLlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKTtcclxuICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XHJcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLCBcIlhNTEh0dHBSZXF1ZXN0XCIpO1xyXG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHNldHRpbmcgdGhlIENvbnRlbnQtVHlwZSBoZWFkZXIgZm9yIFJlYWN0IE5hdGl2ZSBvbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiKTtcclxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnM7XHJcbiAgICAgICAgICAgIGlmIChoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5yZXNwb25zZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5hYm9ydFNpZ25hbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydFNpZ25hbC5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQWJvcnRFcnJvcigpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlcXVlc3QudGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSByZXF1ZXN0LnRpbWVvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmFib3J0U2lnbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydFNpZ25hbC5vbmFib3J0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgSHR0cFJlc3BvbnNlKHhoci5zdGF0dXMsIHhoci5zdGF0dXNUZXh0LCB4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBIdHRwRXJyb3IoeGhyLnN0YXR1c1RleHQsIHhoci5zdGF0dXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKExvZ0xldmVsLldhcm5pbmcsIFwiRXJyb3IgZnJvbSBIVFRQIHJlcXVlc3QuIFwiICsgeGhyLnN0YXR1cyArIFwiOiBcIiArIHhoci5zdGF0dXNUZXh0ICsgXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBIdHRwRXJyb3IoeGhyLnN0YXR1c1RleHQsIHhoci5zdGF0dXMpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coTG9nTGV2ZWwuV2FybmluZywgXCJUaW1lb3V0IGZyb20gSFRUUCByZXF1ZXN0LlwiKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVGltZW91dEVycm9yKCkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB4aHIuc2VuZChyZXF1ZXN0LmNvbnRlbnQgfHwgXCJcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFhockh0dHBDbGllbnQ7XHJcbn0oSHR0cENsaWVudCkpO1xyXG5leHBvcnQgeyBYaHJIdHRwQ2xpZW50IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVhockh0dHBDbGllbnQuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSAuTkVUIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4vLyBWZXJzaW9uIHRva2VuIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgcHJlcGFjayBjb21tYW5kXHJcbi8qKiBUaGUgdmVyc2lvbiBvZiB0aGUgU2lnbmFsUiBjbGllbnQuICovXHJcbmV4cG9ydCB2YXIgVkVSU0lPTiA9IFwiMS4xLjBcIjtcclxuZXhwb3J0IHsgQWJvcnRFcnJvciwgSHR0cEVycm9yLCBUaW1lb3V0RXJyb3IgfSBmcm9tIFwiLi9FcnJvcnNcIjtcclxuZXhwb3J0IHsgSHR0cENsaWVudCwgSHR0cFJlc3BvbnNlIH0gZnJvbSBcIi4vSHR0cENsaWVudFwiO1xyXG5leHBvcnQgeyBEZWZhdWx0SHR0cENsaWVudCB9IGZyb20gXCIuL0RlZmF1bHRIdHRwQ2xpZW50XCI7XHJcbmV4cG9ydCB7IEh1YkNvbm5lY3Rpb24sIEh1YkNvbm5lY3Rpb25TdGF0ZSB9IGZyb20gXCIuL0h1YkNvbm5lY3Rpb25cIjtcclxuZXhwb3J0IHsgSHViQ29ubmVjdGlvbkJ1aWxkZXIgfSBmcm9tIFwiLi9IdWJDb25uZWN0aW9uQnVpbGRlclwiO1xyXG5leHBvcnQgeyBNZXNzYWdlVHlwZSB9IGZyb20gXCIuL0lIdWJQcm90b2NvbFwiO1xyXG5leHBvcnQgeyBMb2dMZXZlbCB9IGZyb20gXCIuL0lMb2dnZXJcIjtcclxuZXhwb3J0IHsgSHR0cFRyYW5zcG9ydFR5cGUsIFRyYW5zZmVyRm9ybWF0IH0gZnJvbSBcIi4vSVRyYW5zcG9ydFwiO1xyXG5leHBvcnQgeyBOdWxsTG9nZ2VyIH0gZnJvbSBcIi4vTG9nZ2Vyc1wiO1xyXG5leHBvcnQgeyBKc29uSHViUHJvdG9jb2wgfSBmcm9tIFwiLi9Kc29uSHViUHJvdG9jb2xcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYW5zaUhUTUxcblxuLy8gUmVmZXJlbmNlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYW5zaS1yZWdleFxudmFyIF9yZWdBTlNJID0gLyg/Oig/OlxcdTAwMWJcXFspfFxcdTAwOWIpKD86KD86WzAtOV17MSwzfSk/KD86KD86O1swLTldezAsM30pKik/W0EtTXxmLW1dKXxcXHUwMDFiW0EtTV0vXG5cbnZhciBfZGVmQ29sb3JzID0ge1xuICByZXNldDogWydmZmYnLCAnMDAwJ10sIC8vIFtGT1JFR1JPVURfQ09MT1IsIEJBQ0tHUk9VTkRfQ09MT1JdXG4gIGJsYWNrOiAnMDAwJyxcbiAgcmVkOiAnZmYwMDAwJyxcbiAgZ3JlZW46ICcyMDk4MDUnLFxuICB5ZWxsb3c6ICdlOGJmMDMnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgbWFnZW50YTogJ2ZmMDBmZicsXG4gIGN5YW46ICcwMGZmZWUnLFxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxuICBkYXJrZ3JleTogJzg4OCdcbn1cbnZhciBfc3R5bGVzID0ge1xuICAzMDogJ2JsYWNrJyxcbiAgMzE6ICdyZWQnLFxuICAzMjogJ2dyZWVuJyxcbiAgMzM6ICd5ZWxsb3cnLFxuICAzNDogJ2JsdWUnLFxuICAzNTogJ21hZ2VudGEnLFxuICAzNjogJ2N5YW4nLFxuICAzNzogJ2xpZ2h0Z3JleSdcbn1cbnZhciBfb3BlblRhZ3MgPSB7XG4gICcxJzogJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAvLyBib2xkXG4gICcyJzogJ29wYWNpdHk6MC41JywgLy8gZGltXG4gICczJzogJzxpPicsIC8vIGl0YWxpY1xuICAnNCc6ICc8dT4nLCAvLyB1bmRlcnNjb3JlXG4gICc4JzogJ2Rpc3BsYXk6bm9uZScsIC8vIGhpZGRlblxuICAnOSc6ICc8ZGVsPicgLy8gZGVsZXRlXG59XG52YXIgX2Nsb3NlVGFncyA9IHtcbiAgJzIzJzogJzwvaT4nLCAvLyByZXNldCBpdGFsaWNcbiAgJzI0JzogJzwvdT4nLCAvLyByZXNldCB1bmRlcnNjb3JlXG4gICcyOSc6ICc8L2RlbD4nIC8vIHJlc2V0IGRlbGV0ZVxufVxuXG47WzAsIDIxLCAyMiwgMjcsIDI4LCAzOSwgNDldLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgX2Nsb3NlVGFnc1tuXSA9ICc8L3NwYW4+J1xufSlcblxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0IHdpdGggQU5TSSBjb2xvciBjb2RlcyB0byBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYW5zaUhUTUwgKHRleHQpIHtcbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBpZiB0aGUgc3RyaW5nIGhhcyBubyBBTlNJIGVzY2FwZSBjb2RlLlxuICBpZiAoIV9yZWdBTlNJLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLy8gQ2FjaGUgb3BlbmVkIHNlcXVlbmNlLlxuICB2YXIgYW5zaUNvZGVzID0gW11cbiAgLy8gUmVwbGFjZSB3aXRoIG1hcmt1cC5cbiAgdmFyIHJldCA9IHRleHQucmVwbGFjZSgvXFwwMzNcXFsoXFxkKykqbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xuICAgIHZhciBvdCA9IF9vcGVuVGFnc1tzZXFdXG4gICAgaWYgKG90KSB7XG4gICAgICAvLyBJZiBjdXJyZW50IHNlcXVlbmNlIGhhcyBiZWVuIG9wZW5lZCwgY2xvc2UgaXQuXG4gICAgICBpZiAoISF+YW5zaUNvZGVzLmluZGV4T2Yoc2VxKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLWJvb2xlYW4tY2FzdFxuICAgICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+J1xuICAgICAgfVxuICAgICAgLy8gT3BlbiB0YWcuXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpXG4gICAgICByZXR1cm4gb3RbMF0gPT09ICc8JyA/IG90IDogJzxzcGFuIHN0eWxlPVwiJyArIG90ICsgJztcIj4nXG4gICAgfVxuXG4gICAgdmFyIGN0ID0gX2Nsb3NlVGFnc1tzZXFdXG4gICAgaWYgKGN0KSB7XG4gICAgICAvLyBQb3Agc2VxdWVuY2VcbiAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIGN0XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9KVxuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aFxuICA7KGwgPiAwKSAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpXG5cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIHJlZmVyZW5jZSB0byBfZGVmQ29sb3JzXG4gKi9cbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgY29sb3JzYCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBPYmplY3QuJylcbiAgfVxuXG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fVxuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xuICAgIHZhciBoZXggPSBjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbG9yc1trZXldIDogbnVsbFxuICAgIGlmICghaGV4KSB7XG4gICAgICBfZmluYWxDb2xvcnNba2V5XSA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IFtoZXhdXG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGV4KSB8fCBoZXgubGVuZ3RoID09PSAwIHx8IGhleC5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaCAhPT0gJ3N0cmluZydcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgICAgfVxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBpZiAoIWhleFswXSkge1xuICAgICAgICBoZXhbMF0gPSBkZWZIZXhDb2xvclswXVxuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXVxuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSlcbiAgICAgIH1cblxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICB9XG4gICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBoZXhcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpXG59XG5cbi8qKlxuICogUmVzZXQgY29sb3JzLlxuICovXG5hbnNpSFRNTC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgX3NldFRhZ3MoX2RlZkNvbG9ycylcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGFncywgaW5jbHVkaW5nIG9wZW4gYW5kIGNsb3NlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuYW5zaUhUTUwudGFncyA9IHt9XG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX29wZW5UYWdzIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdjbG9zZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jbG9zZVRhZ3MgfVxuICB9KVxufSBlbHNlIHtcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzXG4gIGFuc2lIVE1MLnRhZ3MuY2xvc2UgPSBfY2xvc2VUYWdzXG59XG5cbmZ1bmN0aW9uIF9zZXRUYWdzIChjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV1cbiAgLy8gaW52ZXJzZVxuICBfb3BlblRhZ3NbJzcnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5yZXNldFsxXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFswXVxuICAvLyBkYXJrIGdyZXlcbiAgX29wZW5UYWdzWyc5MCddID0gJ2NvbG9yOiMnICsgY29sb3JzLmRhcmtncmV5XG5cbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XG4gICAgdmFyIGNvbG9yID0gX3N0eWxlc1tjb2RlXVxuICAgIHZhciBvcmlDb2xvciA9IGNvbG9yc1tjb2xvcl0gfHwgJzAwMCdcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvclxuICAgIGNvZGUgPSBwYXJzZUludChjb2RlKVxuICAgIF9vcGVuVGFnc1soY29kZSArIDEwKS50b1N0cmluZygpXSA9ICdiYWNrZ3JvdW5kOiMnICsgb3JpQ29sb3JcbiAgfVxufVxuXG5hbnNpSFRNTC5yZXNldCgpXG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIC9bXFx1MDAxYlxcdTAwOWJdW1soKSM7P10qKD86WzAtOV17MSw0fSg/OjtbMC05XXswLDR9KSopP1swLTlBLVBSWmNmLW5xcnk9PjxdL2c7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBYbWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIveG1sLWVudGl0aWVzLmpzJyksXG4gIEh0bWw0RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw0LWVudGl0aWVzLmpzJyksXG4gIEh0bWw1RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJyksXG4gIEFsbEh0bWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDUtZW50aXRpZXMuanMnKVxufTtcbiIsInZhciBIVE1MX0FMUEhBID0gWydhcG9zJywgJ25ic3AnLCAnaWV4Y2wnLCAnY2VudCcsICdwb3VuZCcsICdjdXJyZW4nLCAneWVuJywgJ2JydmJhcicsICdzZWN0JywgJ3VtbCcsICdjb3B5JywgJ29yZGYnLCAnbGFxdW8nLCAnbm90JywgJ3NoeScsICdyZWcnLCAnbWFjcicsICdkZWcnLCAncGx1c21uJywgJ3N1cDInLCAnc3VwMycsICdhY3V0ZScsICdtaWNybycsICdwYXJhJywgJ21pZGRvdCcsICdjZWRpbCcsICdzdXAxJywgJ29yZG0nLCAncmFxdW8nLCAnZnJhYzE0JywgJ2ZyYWMxMicsICdmcmFjMzQnLCAnaXF1ZXN0JywgJ0FncmF2ZScsICdBYWN1dGUnLCAnQWNpcmMnLCAnQXRpbGRlJywgJ0F1bWwnLCAnQXJpbmcnLCAnQWVsaWcnLCAnQ2NlZGlsJywgJ0VncmF2ZScsICdFYWN1dGUnLCAnRWNpcmMnLCAnRXVtbCcsICdJZ3JhdmUnLCAnSWFjdXRlJywgJ0ljaXJjJywgJ0l1bWwnLCAnRVRIJywgJ050aWxkZScsICdPZ3JhdmUnLCAnT2FjdXRlJywgJ09jaXJjJywgJ090aWxkZScsICdPdW1sJywgJ3RpbWVzJywgJ09zbGFzaCcsICdVZ3JhdmUnLCAnVWFjdXRlJywgJ1VjaXJjJywgJ1V1bWwnLCAnWWFjdXRlJywgJ1RIT1JOJywgJ3N6bGlnJywgJ2FncmF2ZScsICdhYWN1dGUnLCAnYWNpcmMnLCAnYXRpbGRlJywgJ2F1bWwnLCAnYXJpbmcnLCAnYWVsaWcnLCAnY2NlZGlsJywgJ2VncmF2ZScsICdlYWN1dGUnLCAnZWNpcmMnLCAnZXVtbCcsICdpZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjJywgJ2l1bWwnLCAnZXRoJywgJ250aWxkZScsICdvZ3JhdmUnLCAnb2FjdXRlJywgJ29jaXJjJywgJ290aWxkZScsICdvdW1sJywgJ2RpdmlkZScsICdvc2xhc2gnLCAndWdyYXZlJywgJ3VhY3V0ZScsICd1Y2lyYycsICd1dW1sJywgJ3lhY3V0ZScsICd0aG9ybicsICd5dW1sJywgJ3F1b3QnLCAnYW1wJywgJ2x0JywgJ2d0JywgJ09FbGlnJywgJ29lbGlnJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWXVtbCcsICdjaXJjJywgJ3RpbGRlJywgJ2Vuc3AnLCAnZW1zcCcsICd0aGluc3AnLCAnenduaicsICd6d2onLCAnbHJtJywgJ3JsbScsICduZGFzaCcsICdtZGFzaCcsICdsc3F1bycsICdyc3F1bycsICdzYnF1bycsICdsZHF1bycsICdyZHF1bycsICdiZHF1bycsICdkYWdnZXInLCAnRGFnZ2VyJywgJ3Blcm1pbCcsICdsc2FxdW8nLCAncnNhcXVvJywgJ2V1cm8nLCAnZm5vZicsICdBbHBoYScsICdCZXRhJywgJ0dhbW1hJywgJ0RlbHRhJywgJ0Vwc2lsb24nLCAnWmV0YScsICdFdGEnLCAnVGhldGEnLCAnSW90YScsICdLYXBwYScsICdMYW1iZGEnLCAnTXUnLCAnTnUnLCAnWGknLCAnT21pY3JvbicsICdQaScsICdSaG8nLCAnU2lnbWEnLCAnVGF1JywgJ1Vwc2lsb24nLCAnUGhpJywgJ0NoaScsICdQc2knLCAnT21lZ2EnLCAnYWxwaGEnLCAnYmV0YScsICdnYW1tYScsICdkZWx0YScsICdlcHNpbG9uJywgJ3pldGEnLCAnZXRhJywgJ3RoZXRhJywgJ2lvdGEnLCAna2FwcGEnLCAnbGFtYmRhJywgJ211JywgJ251JywgJ3hpJywgJ29taWNyb24nLCAncGknLCAncmhvJywgJ3NpZ21hZicsICdzaWdtYScsICd0YXUnLCAndXBzaWxvbicsICdwaGknLCAnY2hpJywgJ3BzaScsICdvbWVnYScsICd0aGV0YXN5bScsICd1cHNpaCcsICdwaXYnLCAnYnVsbCcsICdoZWxsaXAnLCAncHJpbWUnLCAnUHJpbWUnLCAnb2xpbmUnLCAnZnJhc2wnLCAnd2VpZXJwJywgJ2ltYWdlJywgJ3JlYWwnLCAndHJhZGUnLCAnYWxlZnN5bScsICdsYXJyJywgJ3VhcnInLCAncmFycicsICdkYXJyJywgJ2hhcnInLCAnY3JhcnInLCAnbEFycicsICd1QXJyJywgJ3JBcnInLCAnZEFycicsICdoQXJyJywgJ2ZvcmFsbCcsICdwYXJ0JywgJ2V4aXN0JywgJ2VtcHR5JywgJ25hYmxhJywgJ2lzaW4nLCAnbm90aW4nLCAnbmknLCAncHJvZCcsICdzdW0nLCAnbWludXMnLCAnbG93YXN0JywgJ3JhZGljJywgJ3Byb3AnLCAnaW5maW4nLCAnYW5nJywgJ2FuZCcsICdvcicsICdjYXAnLCAnY3VwJywgJ2ludCcsICd0aGVyZTQnLCAnc2ltJywgJ2NvbmcnLCAnYXN5bXAnLCAnbmUnLCAnZXF1aXYnLCAnbGUnLCAnZ2UnLCAnc3ViJywgJ3N1cCcsICduc3ViJywgJ3N1YmUnLCAnc3VwZScsICdvcGx1cycsICdvdGltZXMnLCAncGVycCcsICdzZG90JywgJ2xjZWlsJywgJ3JjZWlsJywgJ2xmbG9vcicsICdyZmxvb3InLCAnbGFuZycsICdyYW5nJywgJ2xveicsICdzcGFkZXMnLCAnY2x1YnMnLCAnaGVhcnRzJywgJ2RpYW1zJ107XG52YXIgSFRNTF9DT0RFUyA9IFszOSwgMTYwLCAxNjEsIDE2MiwgMTYzLCAxNjQsIDE2NSwgMTY2LCAxNjcsIDE2OCwgMTY5LCAxNzAsIDE3MSwgMTcyLCAxNzMsIDE3NCwgMTc1LCAxNzYsIDE3NywgMTc4LCAxNzksIDE4MCwgMTgxLCAxODIsIDE4MywgMTg0LCAxODUsIDE4NiwgMTg3LCAxODgsIDE4OSwgMTkwLCAxOTEsIDE5MiwgMTkzLCAxOTQsIDE5NSwgMTk2LCAxOTcsIDE5OCwgMTk5LCAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCwgMjA1LCAyMDYsIDIwNywgMjA4LCAyMDksIDIxMCwgMjExLCAyMTIsIDIxMywgMjE0LCAyMTUsIDIxNiwgMjE3LCAyMTgsIDIxOSwgMjIwLCAyMjEsIDIyMiwgMjIzLCAyMjQsIDIyNSwgMjI2LCAyMjcsIDIyOCwgMjI5LCAyMzAsIDIzMSwgMjMyLCAyMzMsIDIzNCwgMjM1LCAyMzYsIDIzNywgMjM4LCAyMzksIDI0MCwgMjQxLCAyNDIsIDI0MywgMjQ0LCAyNDUsIDI0NiwgMjQ3LCAyNDgsIDI0OSwgMjUwLCAyNTEsIDI1MiwgMjUzLCAyNTQsIDI1NSwgMzQsIDM4LCA2MCwgNjIsIDMzOCwgMzM5LCAzNTIsIDM1MywgMzc2LCA3MTAsIDczMiwgODE5NCwgODE5NSwgODIwMSwgODIwNCwgODIwNSwgODIwNiwgODIwNywgODIxMSwgODIxMiwgODIxNiwgODIxNywgODIxOCwgODIyMCwgODIyMSwgODIyMiwgODIyNCwgODIyNSwgODI0MCwgODI0OSwgODI1MCwgODM2NCwgNDAyLCA5MTMsIDkxNCwgOTE1LCA5MTYsIDkxNywgOTE4LCA5MTksIDkyMCwgOTIxLCA5MjIsIDkyMywgOTI0LCA5MjUsIDkyNiwgOTI3LCA5MjgsIDkyOSwgOTMxLCA5MzIsIDkzMywgOTM0LCA5MzUsIDkzNiwgOTM3LCA5NDUsIDk0NiwgOTQ3LCA5NDgsIDk0OSwgOTUwLCA5NTEsIDk1MiwgOTUzLCA5NTQsIDk1NSwgOTU2LCA5NTcsIDk1OCwgOTU5LCA5NjAsIDk2MSwgOTYyLCA5NjMsIDk2NCwgOTY1LCA5NjYsIDk2NywgOTY4LCA5NjksIDk3NywgOTc4LCA5ODIsIDgyMjYsIDgyMzAsIDgyNDIsIDgyNDMsIDgyNTQsIDgyNjAsIDg0NzIsIDg0NjUsIDg0NzYsIDg0ODIsIDg1MDEsIDg1OTIsIDg1OTMsIDg1OTQsIDg1OTUsIDg1OTYsIDg2MjksIDg2NTYsIDg2NTcsIDg2NTgsIDg2NTksIDg2NjAsIDg3MDQsIDg3MDYsIDg3MDcsIDg3MDksIDg3MTEsIDg3MTIsIDg3MTMsIDg3MTUsIDg3MTksIDg3MjEsIDg3MjIsIDg3MjcsIDg3MzAsIDg3MzMsIDg3MzQsIDg3MzYsIDg3NDMsIDg3NDQsIDg3NDUsIDg3NDYsIDg3NDcsIDg3NTYsIDg3NjQsIDg3NzMsIDg3NzYsIDg4MDAsIDg4MDEsIDg4MDQsIDg4MDUsIDg4MzQsIDg4MzUsIDg4MzYsIDg4MzgsIDg4MzksIDg4NTMsIDg4NTUsIDg4NjksIDg5MDEsIDg5NjgsIDg5NjksIDg5NzAsIDg5NzEsIDkwMDEsIDkwMDIsIDk2NzQsIDk4MjQsIDk4MjcsIDk4MjksIDk4MzBdO1xuXG52YXIgYWxwaGFJbmRleCA9IHt9O1xudmFyIG51bUluZGV4ID0ge307XG5cbnZhciBpID0gMDtcbnZhciBsZW5ndGggPSBIVE1MX0FMUEhBLmxlbmd0aDtcbndoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGEgPSBIVE1MX0FMUEhBW2ldO1xuICAgIHZhciBjID0gSFRNTF9DT0RFU1tpXTtcbiAgICBhbHBoYUluZGV4W2FdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICBudW1JbmRleFtjXSA9IGE7XG4gICAgaSsrO1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdG1sNEVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNocjtcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuXG4gICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgcmVzdWx0ICs9IGFscGhhID8gXCImXCIgKyBhbHBoYSArIFwiO1wiIDogc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W2NjXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGNjIDwgMzIgfHwgY2MgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiYjXCIgKyBjYyArIFwiO1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbDRFbnRpdGllcztcbiIsInZhciBFTlRJVElFUyA9IFtbJ0FhY3V0ZScsIFsxOTNdXSwgWydhYWN1dGUnLCBbMjI1XV0sIFsnQWJyZXZlJywgWzI1OF1dLCBbJ2FicmV2ZScsIFsyNTldXSwgWydhYycsIFs4NzY2XV0sIFsnYWNkJywgWzg3NjddXSwgWydhY0UnLCBbODc2NiwgODE5XV0sIFsnQWNpcmMnLCBbMTk0XV0sIFsnYWNpcmMnLCBbMjI2XV0sIFsnYWN1dGUnLCBbMTgwXV0sIFsnQWN5JywgWzEwNDBdXSwgWydhY3knLCBbMTA3Ml1dLCBbJ0FFbGlnJywgWzE5OF1dLCBbJ2FlbGlnJywgWzIzMF1dLCBbJ2FmJywgWzgyODldXSwgWydBZnInLCBbMTIwMDY4XV0sIFsnYWZyJywgWzEyMDA5NF1dLCBbJ0FncmF2ZScsIFsxOTJdXSwgWydhZ3JhdmUnLCBbMjI0XV0sIFsnYWxlZnN5bScsIFs4NTAxXV0sIFsnYWxlcGgnLCBbODUwMV1dLCBbJ0FscGhhJywgWzkxM11dLCBbJ2FscGhhJywgWzk0NV1dLCBbJ0FtYWNyJywgWzI1Nl1dLCBbJ2FtYWNyJywgWzI1N11dLCBbJ2FtYWxnJywgWzEwODE1XV0sIFsnYW1wJywgWzM4XV0sIFsnQU1QJywgWzM4XV0sIFsnYW5kYW5kJywgWzEwODM3XV0sIFsnQW5kJywgWzEwODM1XV0sIFsnYW5kJywgWzg3NDNdXSwgWydhbmRkJywgWzEwODQ0XV0sIFsnYW5kc2xvcGUnLCBbMTA4NDBdXSwgWydhbmR2JywgWzEwODQyXV0sIFsnYW5nJywgWzg3MzZdXSwgWydhbmdlJywgWzEwNjYwXV0sIFsnYW5nbGUnLCBbODczNl1dLCBbJ2FuZ21zZGFhJywgWzEwNjY0XV0sIFsnYW5nbXNkYWInLCBbMTA2NjVdXSwgWydhbmdtc2RhYycsIFsxMDY2Nl1dLCBbJ2FuZ21zZGFkJywgWzEwNjY3XV0sIFsnYW5nbXNkYWUnLCBbMTA2NjhdXSwgWydhbmdtc2RhZicsIFsxMDY2OV1dLCBbJ2FuZ21zZGFnJywgWzEwNjcwXV0sIFsnYW5nbXNkYWgnLCBbMTA2NzFdXSwgWydhbmdtc2QnLCBbODczN11dLCBbJ2FuZ3J0JywgWzg3MzVdXSwgWydhbmdydHZiJywgWzg4OTRdXSwgWydhbmdydHZiZCcsIFsxMDY1M11dLCBbJ2FuZ3NwaCcsIFs4NzM4XV0sIFsnYW5nc3QnLCBbMTk3XV0sIFsnYW5nemFycicsIFs5MDg0XV0sIFsnQW9nb24nLCBbMjYwXV0sIFsnYW9nb24nLCBbMjYxXV0sIFsnQW9wZicsIFsxMjAxMjBdXSwgWydhb3BmJywgWzEyMDE0Nl1dLCBbJ2FwYWNpcicsIFsxMDg2M11dLCBbJ2FwJywgWzg3NzZdXSwgWydhcEUnLCBbMTA4NjRdXSwgWydhcGUnLCBbODc3OF1dLCBbJ2FwaWQnLCBbODc3OV1dLCBbJ2Fwb3MnLCBbMzldXSwgWydBcHBseUZ1bmN0aW9uJywgWzgyODldXSwgWydhcHByb3gnLCBbODc3Nl1dLCBbJ2FwcHJveGVxJywgWzg3NzhdXSwgWydBcmluZycsIFsxOTddXSwgWydhcmluZycsIFsyMjldXSwgWydBc2NyJywgWzExOTk2NF1dLCBbJ2FzY3InLCBbMTE5OTkwXV0sIFsnQXNzaWduJywgWzg3ODhdXSwgWydhc3QnLCBbNDJdXSwgWydhc3ltcCcsIFs4Nzc2XV0sIFsnYXN5bXBlcScsIFs4NzgxXV0sIFsnQXRpbGRlJywgWzE5NV1dLCBbJ2F0aWxkZScsIFsyMjddXSwgWydBdW1sJywgWzE5Nl1dLCBbJ2F1bWwnLCBbMjI4XV0sIFsnYXdjb25pbnQnLCBbODc1NV1dLCBbJ2F3aW50JywgWzEwNzY5XV0sIFsnYmFja2NvbmcnLCBbODc4MF1dLCBbJ2JhY2tlcHNpbG9uJywgWzEwMTRdXSwgWydiYWNrcHJpbWUnLCBbODI0NV1dLCBbJ2JhY2tzaW0nLCBbODc2NV1dLCBbJ2JhY2tzaW1lcScsIFs4OTA5XV0sIFsnQmFja3NsYXNoJywgWzg3MjZdXSwgWydCYXJ2JywgWzEwOTgzXV0sIFsnYmFydmVlJywgWzg4OTNdXSwgWydiYXJ3ZWQnLCBbODk2NV1dLCBbJ0JhcndlZCcsIFs4OTY2XV0sIFsnYmFyd2VkZ2UnLCBbODk2NV1dLCBbJ2JicmsnLCBbOTE0MV1dLCBbJ2Jicmt0YnJrJywgWzkxNDJdXSwgWydiY29uZycsIFs4NzgwXV0sIFsnQmN5JywgWzEwNDFdXSwgWydiY3knLCBbMTA3M11dLCBbJ2JkcXVvJywgWzgyMjJdXSwgWydiZWNhdXMnLCBbODc1N11dLCBbJ2JlY2F1c2UnLCBbODc1N11dLCBbJ0JlY2F1c2UnLCBbODc1N11dLCBbJ2JlbXB0eXYnLCBbMTA2NzJdXSwgWydiZXBzaScsIFsxMDE0XV0sIFsnYmVybm91JywgWzg0OTJdXSwgWydCZXJub3VsbGlzJywgWzg0OTJdXSwgWydCZXRhJywgWzkxNF1dLCBbJ2JldGEnLCBbOTQ2XV0sIFsnYmV0aCcsIFs4NTAyXV0sIFsnYmV0d2VlbicsIFs4ODEyXV0sIFsnQmZyJywgWzEyMDA2OV1dLCBbJ2JmcicsIFsxMjAwOTVdXSwgWydiaWdjYXAnLCBbODg5OF1dLCBbJ2JpZ2NpcmMnLCBbOTcxMV1dLCBbJ2JpZ2N1cCcsIFs4ODk5XV0sIFsnYmlnb2RvdCcsIFsxMDc1Ml1dLCBbJ2JpZ29wbHVzJywgWzEwNzUzXV0sIFsnYmlnb3RpbWVzJywgWzEwNzU0XV0sIFsnYmlnc3FjdXAnLCBbMTA3NThdXSwgWydiaWdzdGFyJywgWzk3MzNdXSwgWydiaWd0cmlhbmdsZWRvd24nLCBbOTY2MV1dLCBbJ2JpZ3RyaWFuZ2xldXAnLCBbOTY1MV1dLCBbJ2JpZ3VwbHVzJywgWzEwNzU2XV0sIFsnYmlndmVlJywgWzg4OTddXSwgWydiaWd3ZWRnZScsIFs4ODk2XV0sIFsnYmthcm93JywgWzEwNTA5XV0sIFsnYmxhY2tsb3plbmdlJywgWzEwNzMxXV0sIFsnYmxhY2tzcXVhcmUnLCBbOTY0Ml1dLCBbJ2JsYWNrdHJpYW5nbGUnLCBbOTY1Ml1dLCBbJ2JsYWNrdHJpYW5nbGVkb3duJywgWzk2NjJdXSwgWydibGFja3RyaWFuZ2xlbGVmdCcsIFs5NjY2XV0sIFsnYmxhY2t0cmlhbmdsZXJpZ2h0JywgWzk2NTZdXSwgWydibGFuaycsIFs5MjUxXV0sIFsnYmxrMTInLCBbOTYxOF1dLCBbJ2JsazE0JywgWzk2MTddXSwgWydibGszNCcsIFs5NjE5XV0sIFsnYmxvY2snLCBbOTYwOF1dLCBbJ2JuZScsIFs2MSwgODQyMV1dLCBbJ2JuZXF1aXYnLCBbODgwMSwgODQyMV1dLCBbJ2JOb3QnLCBbMTA5ODldXSwgWydibm90JywgWzg5NzZdXSwgWydCb3BmJywgWzEyMDEyMV1dLCBbJ2JvcGYnLCBbMTIwMTQ3XV0sIFsnYm90JywgWzg4NjldXSwgWydib3R0b20nLCBbODg2OV1dLCBbJ2Jvd3RpZScsIFs4OTA0XV0sIFsnYm94Ym94JywgWzEwNjk3XV0sIFsnYm94ZGwnLCBbOTQ4OF1dLCBbJ2JveGRMJywgWzk1NTddXSwgWydib3hEbCcsIFs5NTU4XV0sIFsnYm94REwnLCBbOTU1OV1dLCBbJ2JveGRyJywgWzk0ODRdXSwgWydib3hkUicsIFs5NTU0XV0sIFsnYm94RHInLCBbOTU1NV1dLCBbJ2JveERSJywgWzk1NTZdXSwgWydib3hoJywgWzk0NzJdXSwgWydib3hIJywgWzk1NTJdXSwgWydib3hoZCcsIFs5NTE2XV0sIFsnYm94SGQnLCBbOTU3Ml1dLCBbJ2JveGhEJywgWzk1NzNdXSwgWydib3hIRCcsIFs5NTc0XV0sIFsnYm94aHUnLCBbOTUyNF1dLCBbJ2JveEh1JywgWzk1NzVdXSwgWydib3hoVScsIFs5NTc2XV0sIFsnYm94SFUnLCBbOTU3N11dLCBbJ2JveG1pbnVzJywgWzg4NjNdXSwgWydib3hwbHVzJywgWzg4NjJdXSwgWydib3h0aW1lcycsIFs4ODY0XV0sIFsnYm94dWwnLCBbOTQ5Nl1dLCBbJ2JveHVMJywgWzk1NjNdXSwgWydib3hVbCcsIFs5NTY0XV0sIFsnYm94VUwnLCBbOTU2NV1dLCBbJ2JveHVyJywgWzk0OTJdXSwgWydib3h1UicsIFs5NTYwXV0sIFsnYm94VXInLCBbOTU2MV1dLCBbJ2JveFVSJywgWzk1NjJdXSwgWydib3h2JywgWzk0NzRdXSwgWydib3hWJywgWzk1NTNdXSwgWydib3h2aCcsIFs5NTMyXV0sIFsnYm94dkgnLCBbOTU3OF1dLCBbJ2JveFZoJywgWzk1NzldXSwgWydib3hWSCcsIFs5NTgwXV0sIFsnYm94dmwnLCBbOTUwOF1dLCBbJ2JveHZMJywgWzk1NjldXSwgWydib3hWbCcsIFs5NTcwXV0sIFsnYm94VkwnLCBbOTU3MV1dLCBbJ2JveHZyJywgWzk1MDBdXSwgWydib3h2UicsIFs5NTY2XV0sIFsnYm94VnInLCBbOTU2N11dLCBbJ2JveFZSJywgWzk1NjhdXSwgWydicHJpbWUnLCBbODI0NV1dLCBbJ2JyZXZlJywgWzcyOF1dLCBbJ0JyZXZlJywgWzcyOF1dLCBbJ2JydmJhcicsIFsxNjZdXSwgWydic2NyJywgWzExOTk5MV1dLCBbJ0JzY3InLCBbODQ5Ml1dLCBbJ2JzZW1pJywgWzgyNzFdXSwgWydic2ltJywgWzg3NjVdXSwgWydic2ltZScsIFs4OTA5XV0sIFsnYnNvbGInLCBbMTA2OTNdXSwgWydic29sJywgWzkyXV0sIFsnYnNvbGhzdWInLCBbMTAxODRdXSwgWydidWxsJywgWzgyMjZdXSwgWydidWxsZXQnLCBbODIyNl1dLCBbJ2J1bXAnLCBbODc4Ml1dLCBbJ2J1bXBFJywgWzEwOTI2XV0sIFsnYnVtcGUnLCBbODc4M11dLCBbJ0J1bXBlcScsIFs4NzgyXV0sIFsnYnVtcGVxJywgWzg3ODNdXSwgWydDYWN1dGUnLCBbMjYyXV0sIFsnY2FjdXRlJywgWzI2M11dLCBbJ2NhcGFuZCcsIFsxMDgyMF1dLCBbJ2NhcGJyY3VwJywgWzEwODI1XV0sIFsnY2FwY2FwJywgWzEwODI3XV0sIFsnY2FwJywgWzg3NDVdXSwgWydDYXAnLCBbODkxNF1dLCBbJ2NhcGN1cCcsIFsxMDgyM11dLCBbJ2NhcGRvdCcsIFsxMDgxNl1dLCBbJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJywgWzg1MTddXSwgWydjYXBzJywgWzg3NDUsIDY1MDI0XV0sIFsnY2FyZXQnLCBbODI1N11dLCBbJ2Nhcm9uJywgWzcxMV1dLCBbJ0NheWxleXMnLCBbODQ5M11dLCBbJ2NjYXBzJywgWzEwODI5XV0sIFsnQ2Nhcm9uJywgWzI2OF1dLCBbJ2NjYXJvbicsIFsyNjldXSwgWydDY2VkaWwnLCBbMTk5XV0sIFsnY2NlZGlsJywgWzIzMV1dLCBbJ0NjaXJjJywgWzI2NF1dLCBbJ2NjaXJjJywgWzI2NV1dLCBbJ0Njb25pbnQnLCBbODc1Ml1dLCBbJ2NjdXBzJywgWzEwODI4XV0sIFsnY2N1cHNzbScsIFsxMDgzMl1dLCBbJ0Nkb3QnLCBbMjY2XV0sIFsnY2RvdCcsIFsyNjddXSwgWydjZWRpbCcsIFsxODRdXSwgWydDZWRpbGxhJywgWzE4NF1dLCBbJ2NlbXB0eXYnLCBbMTA2NzRdXSwgWydjZW50JywgWzE2Ml1dLCBbJ2NlbnRlcmRvdCcsIFsxODNdXSwgWydDZW50ZXJEb3QnLCBbMTgzXV0sIFsnY2ZyJywgWzEyMDA5Nl1dLCBbJ0NmcicsIFs4NDkzXV0sIFsnQ0hjeScsIFsxMDYzXV0sIFsnY2hjeScsIFsxMDk1XV0sIFsnY2hlY2snLCBbMTAwMDNdXSwgWydjaGVja21hcmsnLCBbMTAwMDNdXSwgWydDaGknLCBbOTM1XV0sIFsnY2hpJywgWzk2N11dLCBbJ2NpcmMnLCBbNzEwXV0sIFsnY2lyY2VxJywgWzg3OTFdXSwgWydjaXJjbGVhcnJvd2xlZnQnLCBbODYzNF1dLCBbJ2NpcmNsZWFycm93cmlnaHQnLCBbODYzNV1dLCBbJ2NpcmNsZWRhc3QnLCBbODg1OV1dLCBbJ2NpcmNsZWRjaXJjJywgWzg4NThdXSwgWydjaXJjbGVkZGFzaCcsIFs4ODYxXV0sIFsnQ2lyY2xlRG90JywgWzg4NTddXSwgWydjaXJjbGVkUicsIFsxNzRdXSwgWydjaXJjbGVkUycsIFs5NDE2XV0sIFsnQ2lyY2xlTWludXMnLCBbODg1NF1dLCBbJ0NpcmNsZVBsdXMnLCBbODg1M11dLCBbJ0NpcmNsZVRpbWVzJywgWzg4NTVdXSwgWydjaXInLCBbOTY3NV1dLCBbJ2NpckUnLCBbMTA2OTFdXSwgWydjaXJlJywgWzg3OTFdXSwgWydjaXJmbmludCcsIFsxMDc2OF1dLCBbJ2Npcm1pZCcsIFsxMDk5MV1dLCBbJ2NpcnNjaXInLCBbMTA2OTBdXSwgWydDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NF1dLCBbJ2NsdWJzJywgWzk4MjddXSwgWydjbHVic3VpdCcsIFs5ODI3XV0sIFsnY29sb24nLCBbNThdXSwgWydDb2xvbicsIFs4NzU5XV0sIFsnQ29sb25lJywgWzEwODY4XV0sIFsnY29sb25lJywgWzg3ODhdXSwgWydjb2xvbmVxJywgWzg3ODhdXSwgWydjb21tYScsIFs0NF1dLCBbJ2NvbW1hdCcsIFs2NF1dLCBbJ2NvbXAnLCBbODcwNV1dLCBbJ2NvbXBmbicsIFs4NzI4XV0sIFsnY29tcGxlbWVudCcsIFs4NzA1XV0sIFsnY29tcGxleGVzJywgWzg0NTBdXSwgWydjb25nJywgWzg3NzNdXSwgWydjb25nZG90JywgWzEwODYxXV0sIFsnQ29uZ3J1ZW50JywgWzg4MDFdXSwgWydjb25pbnQnLCBbODc1MF1dLCBbJ0NvbmludCcsIFs4NzUxXV0sIFsnQ29udG91ckludGVncmFsJywgWzg3NTBdXSwgWydjb3BmJywgWzEyMDE0OF1dLCBbJ0NvcGYnLCBbODQ1MF1dLCBbJ2NvcHJvZCcsIFs4NzIwXV0sIFsnQ29wcm9kdWN0JywgWzg3MjBdXSwgWydjb3B5JywgWzE2OV1dLCBbJ0NPUFknLCBbMTY5XV0sIFsnY29weXNyJywgWzg0NzFdXSwgWydDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTVdXSwgWydjcmFycicsIFs4NjI5XV0sIFsnY3Jvc3MnLCBbMTAwMDddXSwgWydDcm9zcycsIFsxMDc5OV1dLCBbJ0NzY3InLCBbMTE5OTY2XV0sIFsnY3NjcicsIFsxMTk5OTJdXSwgWydjc3ViJywgWzEwOTU5XV0sIFsnY3N1YmUnLCBbMTA5NjFdXSwgWydjc3VwJywgWzEwOTYwXV0sIFsnY3N1cGUnLCBbMTA5NjJdXSwgWydjdGRvdCcsIFs4OTQzXV0sIFsnY3VkYXJybCcsIFsxMDU1Ml1dLCBbJ2N1ZGFycnInLCBbMTA1NDldXSwgWydjdWVwcicsIFs4OTI2XV0sIFsnY3Vlc2MnLCBbODkyN11dLCBbJ2N1bGFycicsIFs4NjMwXV0sIFsnY3VsYXJycCcsIFsxMDU1N11dLCBbJ2N1cGJyY2FwJywgWzEwODI0XV0sIFsnY3VwY2FwJywgWzEwODIyXV0sIFsnQ3VwQ2FwJywgWzg3ODFdXSwgWydjdXAnLCBbODc0Nl1dLCBbJ0N1cCcsIFs4OTE1XV0sIFsnY3VwY3VwJywgWzEwODI2XV0sIFsnY3VwZG90JywgWzg4NDVdXSwgWydjdXBvcicsIFsxMDgyMV1dLCBbJ2N1cHMnLCBbODc0NiwgNjUwMjRdXSwgWydjdXJhcnInLCBbODYzMV1dLCBbJ2N1cmFycm0nLCBbMTA1NTZdXSwgWydjdXJseWVxcHJlYycsIFs4OTI2XV0sIFsnY3VybHllcXN1Y2MnLCBbODkyN11dLCBbJ2N1cmx5dmVlJywgWzg5MTBdXSwgWydjdXJseXdlZGdlJywgWzg5MTFdXSwgWydjdXJyZW4nLCBbMTY0XV0sIFsnY3VydmVhcnJvd2xlZnQnLCBbODYzMF1dLCBbJ2N1cnZlYXJyb3dyaWdodCcsIFs4NjMxXV0sIFsnY3V2ZWUnLCBbODkxMF1dLCBbJ2N1d2VkJywgWzg5MTFdXSwgWydjd2NvbmludCcsIFs4NzU0XV0sIFsnY3dpbnQnLCBbODc1M11dLCBbJ2N5bGN0eScsIFs5MDA1XV0sIFsnZGFnZ2VyJywgWzgyMjRdXSwgWydEYWdnZXInLCBbODIyNV1dLCBbJ2RhbGV0aCcsIFs4NTA0XV0sIFsnZGFycicsIFs4NTk1XV0sIFsnRGFycicsIFs4NjA5XV0sIFsnZEFycicsIFs4NjU5XV0sIFsnZGFzaCcsIFs4MjA4XV0sIFsnRGFzaHYnLCBbMTA5ODBdXSwgWydkYXNodicsIFs4ODY3XV0sIFsnZGJrYXJvdycsIFsxMDUxMV1dLCBbJ2RibGFjJywgWzczM11dLCBbJ0RjYXJvbicsIFsyNzBdXSwgWydkY2Fyb24nLCBbMjcxXV0sIFsnRGN5JywgWzEwNDRdXSwgWydkY3knLCBbMTA3Nl1dLCBbJ2RkYWdnZXInLCBbODIyNV1dLCBbJ2RkYXJyJywgWzg2NTBdXSwgWydERCcsIFs4NTE3XV0sIFsnZGQnLCBbODUxOF1dLCBbJ0REb3RyYWhkJywgWzEwNTEzXV0sIFsnZGRvdHNlcScsIFsxMDg3MV1dLCBbJ2RlZycsIFsxNzZdXSwgWydEZWwnLCBbODcxMV1dLCBbJ0RlbHRhJywgWzkxNl1dLCBbJ2RlbHRhJywgWzk0OF1dLCBbJ2RlbXB0eXYnLCBbMTA2NzNdXSwgWydkZmlzaHQnLCBbMTA2MjNdXSwgWydEZnInLCBbMTIwMDcxXV0sIFsnZGZyJywgWzEyMDA5N11dLCBbJ2RIYXInLCBbMTA1OTddXSwgWydkaGFybCcsIFs4NjQzXV0sIFsnZGhhcnInLCBbODY0Ml1dLCBbJ0RpYWNyaXRpY2FsQWN1dGUnLCBbMTgwXV0sIFsnRGlhY3JpdGljYWxEb3QnLCBbNzI5XV0sIFsnRGlhY3JpdGljYWxEb3VibGVBY3V0ZScsIFs3MzNdXSwgWydEaWFjcml0aWNhbEdyYXZlJywgWzk2XV0sIFsnRGlhY3JpdGljYWxUaWxkZScsIFs3MzJdXSwgWydkaWFtJywgWzg5MDBdXSwgWydkaWFtb25kJywgWzg5MDBdXSwgWydEaWFtb25kJywgWzg5MDBdXSwgWydkaWFtb25kc3VpdCcsIFs5ODMwXV0sIFsnZGlhbXMnLCBbOTgzMF1dLCBbJ2RpZScsIFsxNjhdXSwgWydEaWZmZXJlbnRpYWxEJywgWzg1MThdXSwgWydkaWdhbW1hJywgWzk4OV1dLCBbJ2Rpc2luJywgWzg5NDZdXSwgWydkaXYnLCBbMjQ3XV0sIFsnZGl2aWRlJywgWzI0N11dLCBbJ2RpdmlkZW9udGltZXMnLCBbODkwM11dLCBbJ2Rpdm9ueCcsIFs4OTAzXV0sIFsnREpjeScsIFsxMDI2XV0sIFsnZGpjeScsIFsxMTA2XV0sIFsnZGxjb3JuJywgWzg5OTBdXSwgWydkbGNyb3AnLCBbODk3M11dLCBbJ2RvbGxhcicsIFszNl1dLCBbJ0RvcGYnLCBbMTIwMTIzXV0sIFsnZG9wZicsIFsxMjAxNDldXSwgWydEb3QnLCBbMTY4XV0sIFsnZG90JywgWzcyOV1dLCBbJ0RvdERvdCcsIFs4NDEyXV0sIFsnZG90ZXEnLCBbODc4NF1dLCBbJ2RvdGVxZG90JywgWzg3ODVdXSwgWydEb3RFcXVhbCcsIFs4Nzg0XV0sIFsnZG90bWludXMnLCBbODc2MF1dLCBbJ2RvdHBsdXMnLCBbODcyNF1dLCBbJ2RvdHNxdWFyZScsIFs4ODY1XV0sIFsnZG91YmxlYmFyd2VkZ2UnLCBbODk2Nl1dLCBbJ0RvdWJsZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzUxXV0sIFsnRG91YmxlRG90JywgWzE2OF1dLCBbJ0RvdWJsZURvd25BcnJvdycsIFs4NjU5XV0sIFsnRG91YmxlTGVmdEFycm93JywgWzg2NTZdXSwgWydEb3VibGVMZWZ0UmlnaHRBcnJvdycsIFs4NjYwXV0sIFsnRG91YmxlTGVmdFRlZScsIFsxMDk4MF1dLCBbJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnLCBbMTAyMzJdXSwgWydEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzRdXSwgWydEb3VibGVMb25nUmlnaHRBcnJvdycsIFsxMDIzM11dLCBbJ0RvdWJsZVJpZ2h0QXJyb3cnLCBbODY1OF1dLCBbJ0RvdWJsZVJpZ2h0VGVlJywgWzg4NzJdXSwgWydEb3VibGVVcEFycm93JywgWzg2NTddXSwgWydEb3VibGVVcERvd25BcnJvdycsIFs4NjYxXV0sIFsnRG91YmxlVmVydGljYWxCYXInLCBbODc0MV1dLCBbJ0Rvd25BcnJvd0JhcicsIFsxMDUxNV1dLCBbJ2Rvd25hcnJvdycsIFs4NTk1XV0sIFsnRG93bkFycm93JywgWzg1OTVdXSwgWydEb3duYXJyb3cnLCBbODY1OV1dLCBbJ0Rvd25BcnJvd1VwQXJyb3cnLCBbODY5M11dLCBbJ0Rvd25CcmV2ZScsIFs3ODVdXSwgWydkb3duZG93bmFycm93cycsIFs4NjUwXV0sIFsnZG93bmhhcnBvb25sZWZ0JywgWzg2NDNdXSwgWydkb3duaGFycG9vbnJpZ2h0JywgWzg2NDJdXSwgWydEb3duTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc2XV0sIFsnRG93bkxlZnRUZWVWZWN0b3InLCBbMTA1OTBdXSwgWydEb3duTGVmdFZlY3RvckJhcicsIFsxMDU4Ml1dLCBbJ0Rvd25MZWZ0VmVjdG9yJywgWzg2MzddXSwgWydEb3duUmlnaHRUZWVWZWN0b3InLCBbMTA1OTFdXSwgWydEb3duUmlnaHRWZWN0b3JCYXInLCBbMTA1ODNdXSwgWydEb3duUmlnaHRWZWN0b3InLCBbODY0MV1dLCBbJ0Rvd25UZWVBcnJvdycsIFs4NjE1XV0sIFsnRG93blRlZScsIFs4ODY4XV0sIFsnZHJia2Fyb3cnLCBbMTA1MTJdXSwgWydkcmNvcm4nLCBbODk5MV1dLCBbJ2RyY3JvcCcsIFs4OTcyXV0sIFsnRHNjcicsIFsxMTk5NjddXSwgWydkc2NyJywgWzExOTk5M11dLCBbJ0RTY3knLCBbMTAyOV1dLCBbJ2RzY3knLCBbMTEwOV1dLCBbJ2Rzb2wnLCBbMTA3NDJdXSwgWydEc3Ryb2snLCBbMjcyXV0sIFsnZHN0cm9rJywgWzI3M11dLCBbJ2R0ZG90JywgWzg5NDVdXSwgWydkdHJpJywgWzk2NjNdXSwgWydkdHJpZicsIFs5NjYyXV0sIFsnZHVhcnInLCBbODY5M11dLCBbJ2R1aGFyJywgWzEwNjA3XV0sIFsnZHdhbmdsZScsIFsxMDY2Ml1dLCBbJ0RaY3knLCBbMTAzOV1dLCBbJ2R6Y3knLCBbMTExOV1dLCBbJ2R6aWdyYXJyJywgWzEwMjM5XV0sIFsnRWFjdXRlJywgWzIwMV1dLCBbJ2VhY3V0ZScsIFsyMzNdXSwgWydlYXN0ZXInLCBbMTA4NjJdXSwgWydFY2Fyb24nLCBbMjgyXV0sIFsnZWNhcm9uJywgWzI4M11dLCBbJ0VjaXJjJywgWzIwMl1dLCBbJ2VjaXJjJywgWzIzNF1dLCBbJ2VjaXInLCBbODc5MF1dLCBbJ2Vjb2xvbicsIFs4Nzg5XV0sIFsnRWN5JywgWzEwNjldXSwgWydlY3knLCBbMTEwMV1dLCBbJ2VERG90JywgWzEwODcxXV0sIFsnRWRvdCcsIFsyNzhdXSwgWydlZG90JywgWzI3OV1dLCBbJ2VEb3QnLCBbODc4NV1dLCBbJ2VlJywgWzg1MTldXSwgWydlZkRvdCcsIFs4Nzg2XV0sIFsnRWZyJywgWzEyMDA3Ml1dLCBbJ2VmcicsIFsxMjAwOThdXSwgWydlZycsIFsxMDkwNl1dLCBbJ0VncmF2ZScsIFsyMDBdXSwgWydlZ3JhdmUnLCBbMjMyXV0sIFsnZWdzJywgWzEwOTAyXV0sIFsnZWdzZG90JywgWzEwOTA0XV0sIFsnZWwnLCBbMTA5MDVdXSwgWydFbGVtZW50JywgWzg3MTJdXSwgWydlbGludGVycycsIFs5MTkxXV0sIFsnZWxsJywgWzg0NjddXSwgWydlbHMnLCBbMTA5MDFdXSwgWydlbHNkb3QnLCBbMTA5MDNdXSwgWydFbWFjcicsIFsyNzRdXSwgWydlbWFjcicsIFsyNzVdXSwgWydlbXB0eScsIFs4NzA5XV0sIFsnZW1wdHlzZXQnLCBbODcwOV1dLCBbJ0VtcHR5U21hbGxTcXVhcmUnLCBbOTcyM11dLCBbJ2VtcHR5dicsIFs4NzA5XV0sIFsnRW1wdHlWZXJ5U21hbGxTcXVhcmUnLCBbOTY0M11dLCBbJ2Vtc3AxMycsIFs4MTk2XV0sIFsnZW1zcDE0JywgWzgxOTddXSwgWydlbXNwJywgWzgxOTVdXSwgWydFTkcnLCBbMzMwXV0sIFsnZW5nJywgWzMzMV1dLCBbJ2Vuc3AnLCBbODE5NF1dLCBbJ0VvZ29uJywgWzI4MF1dLCBbJ2VvZ29uJywgWzI4MV1dLCBbJ0VvcGYnLCBbMTIwMTI0XV0sIFsnZW9wZicsIFsxMjAxNTBdXSwgWydlcGFyJywgWzg5MTddXSwgWydlcGFyc2wnLCBbMTA3MjNdXSwgWydlcGx1cycsIFsxMDg2NV1dLCBbJ2Vwc2knLCBbOTQ5XV0sIFsnRXBzaWxvbicsIFs5MTddXSwgWydlcHNpbG9uJywgWzk0OV1dLCBbJ2Vwc2l2JywgWzEwMTNdXSwgWydlcWNpcmMnLCBbODc5MF1dLCBbJ2VxY29sb24nLCBbODc4OV1dLCBbJ2Vxc2ltJywgWzg3NzBdXSwgWydlcXNsYW50Z3RyJywgWzEwOTAyXV0sIFsnZXFzbGFudGxlc3MnLCBbMTA5MDFdXSwgWydFcXVhbCcsIFsxMDg2OV1dLCBbJ2VxdWFscycsIFs2MV1dLCBbJ0VxdWFsVGlsZGUnLCBbODc3MF1dLCBbJ2VxdWVzdCcsIFs4Nzk5XV0sIFsnRXF1aWxpYnJpdW0nLCBbODY1Ml1dLCBbJ2VxdWl2JywgWzg4MDFdXSwgWydlcXVpdkREJywgWzEwODcyXV0sIFsnZXF2cGFyc2wnLCBbMTA3MjVdXSwgWydlcmFycicsIFsxMDYwOV1dLCBbJ2VyRG90JywgWzg3ODddXSwgWydlc2NyJywgWzg0OTVdXSwgWydFc2NyJywgWzg0OTZdXSwgWydlc2RvdCcsIFs4Nzg0XV0sIFsnRXNpbScsIFsxMDg2N11dLCBbJ2VzaW0nLCBbODc3MF1dLCBbJ0V0YScsIFs5MTldXSwgWydldGEnLCBbOTUxXV0sIFsnRVRIJywgWzIwOF1dLCBbJ2V0aCcsIFsyNDBdXSwgWydFdW1sJywgWzIwM11dLCBbJ2V1bWwnLCBbMjM1XV0sIFsnZXVybycsIFs4MzY0XV0sIFsnZXhjbCcsIFszM11dLCBbJ2V4aXN0JywgWzg3MDddXSwgWydFeGlzdHMnLCBbODcwN11dLCBbJ2V4cGVjdGF0aW9uJywgWzg0OTZdXSwgWydleHBvbmVudGlhbGUnLCBbODUxOV1dLCBbJ0V4cG9uZW50aWFsRScsIFs4NTE5XV0sIFsnZmFsbGluZ2RvdHNlcScsIFs4Nzg2XV0sIFsnRmN5JywgWzEwNjBdXSwgWydmY3knLCBbMTA5Ml1dLCBbJ2ZlbWFsZScsIFs5NzkyXV0sIFsnZmZpbGlnJywgWzY0MjU5XV0sIFsnZmZsaWcnLCBbNjQyNTZdXSwgWydmZmxsaWcnLCBbNjQyNjBdXSwgWydGZnInLCBbMTIwMDczXV0sIFsnZmZyJywgWzEyMDA5OV1dLCBbJ2ZpbGlnJywgWzY0MjU3XV0sIFsnRmlsbGVkU21hbGxTcXVhcmUnLCBbOTcyNF1dLCBbJ0ZpbGxlZFZlcnlTbWFsbFNxdWFyZScsIFs5NjQyXV0sIFsnZmpsaWcnLCBbMTAyLCAxMDZdXSwgWydmbGF0JywgWzk4MzddXSwgWydmbGxpZycsIFs2NDI1OF1dLCBbJ2ZsdG5zJywgWzk2NDldXSwgWydmbm9mJywgWzQwMl1dLCBbJ0ZvcGYnLCBbMTIwMTI1XV0sIFsnZm9wZicsIFsxMjAxNTFdXSwgWydmb3JhbGwnLCBbODcwNF1dLCBbJ0ZvckFsbCcsIFs4NzA0XV0sIFsnZm9yaycsIFs4OTE2XV0sIFsnZm9ya3YnLCBbMTA5NjldXSwgWydGb3VyaWVydHJmJywgWzg0OTddXSwgWydmcGFydGludCcsIFsxMDc2NV1dLCBbJ2ZyYWMxMicsIFsxODldXSwgWydmcmFjMTMnLCBbODUzMV1dLCBbJ2ZyYWMxNCcsIFsxODhdXSwgWydmcmFjMTUnLCBbODUzM11dLCBbJ2ZyYWMxNicsIFs4NTM3XV0sIFsnZnJhYzE4JywgWzg1MzldXSwgWydmcmFjMjMnLCBbODUzMl1dLCBbJ2ZyYWMyNScsIFs4NTM0XV0sIFsnZnJhYzM0JywgWzE5MF1dLCBbJ2ZyYWMzNScsIFs4NTM1XV0sIFsnZnJhYzM4JywgWzg1NDBdXSwgWydmcmFjNDUnLCBbODUzNl1dLCBbJ2ZyYWM1NicsIFs4NTM4XV0sIFsnZnJhYzU4JywgWzg1NDFdXSwgWydmcmFjNzgnLCBbODU0Ml1dLCBbJ2ZyYXNsJywgWzgyNjBdXSwgWydmcm93bicsIFs4OTk0XV0sIFsnZnNjcicsIFsxMTk5OTVdXSwgWydGc2NyJywgWzg0OTddXSwgWydnYWN1dGUnLCBbNTAxXV0sIFsnR2FtbWEnLCBbOTE1XV0sIFsnZ2FtbWEnLCBbOTQ3XV0sIFsnR2FtbWFkJywgWzk4OF1dLCBbJ2dhbW1hZCcsIFs5ODldXSwgWydnYXAnLCBbMTA4ODZdXSwgWydHYnJldmUnLCBbMjg2XV0sIFsnZ2JyZXZlJywgWzI4N11dLCBbJ0djZWRpbCcsIFsyOTBdXSwgWydHY2lyYycsIFsyODRdXSwgWydnY2lyYycsIFsyODVdXSwgWydHY3knLCBbMTA0M11dLCBbJ2djeScsIFsxMDc1XV0sIFsnR2RvdCcsIFsyODhdXSwgWydnZG90JywgWzI4OV1dLCBbJ2dlJywgWzg4MDVdXSwgWydnRScsIFs4ODA3XV0sIFsnZ0VsJywgWzEwODkyXV0sIFsnZ2VsJywgWzg5MjNdXSwgWydnZXEnLCBbODgwNV1dLCBbJ2dlcXEnLCBbODgwN11dLCBbJ2dlcXNsYW50JywgWzEwODc4XV0sIFsnZ2VzY2MnLCBbMTA5MjFdXSwgWydnZXMnLCBbMTA4NzhdXSwgWydnZXNkb3QnLCBbMTA4ODBdXSwgWydnZXNkb3RvJywgWzEwODgyXV0sIFsnZ2VzZG90b2wnLCBbMTA4ODRdXSwgWydnZXNsJywgWzg5MjMsIDY1MDI0XV0sIFsnZ2VzbGVzJywgWzEwOTAwXV0sIFsnR2ZyJywgWzEyMDA3NF1dLCBbJ2dmcicsIFsxMjAxMDBdXSwgWydnZycsIFs4ODExXV0sIFsnR2cnLCBbODkyMV1dLCBbJ2dnZycsIFs4OTIxXV0sIFsnZ2ltZWwnLCBbODUwM11dLCBbJ0dKY3knLCBbMTAyN11dLCBbJ2dqY3knLCBbMTEwN11dLCBbJ2dsYScsIFsxMDkxN11dLCBbJ2dsJywgWzg4MjNdXSwgWydnbEUnLCBbMTA4OThdXSwgWydnbGonLCBbMTA5MTZdXSwgWydnbmFwJywgWzEwODkwXV0sIFsnZ25hcHByb3gnLCBbMTA4OTBdXSwgWydnbmUnLCBbMTA4ODhdXSwgWydnbkUnLCBbODgwOV1dLCBbJ2duZXEnLCBbMTA4ODhdXSwgWydnbmVxcScsIFs4ODA5XV0sIFsnZ25zaW0nLCBbODkzNV1dLCBbJ0dvcGYnLCBbMTIwMTI2XV0sIFsnZ29wZicsIFsxMjAxNTJdXSwgWydncmF2ZScsIFs5Nl1dLCBbJ0dyZWF0ZXJFcXVhbCcsIFs4ODA1XV0sIFsnR3JlYXRlckVxdWFsTGVzcycsIFs4OTIzXV0sIFsnR3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3XV0sIFsnR3JlYXRlckdyZWF0ZXInLCBbMTA5MTRdXSwgWydHcmVhdGVyTGVzcycsIFs4ODIzXV0sIFsnR3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzhdXSwgWydHcmVhdGVyVGlsZGUnLCBbODgxOV1dLCBbJ0dzY3InLCBbMTE5OTcwXV0sIFsnZ3NjcicsIFs4NDU4XV0sIFsnZ3NpbScsIFs4ODE5XV0sIFsnZ3NpbWUnLCBbMTA4OTRdXSwgWydnc2ltbCcsIFsxMDg5Nl1dLCBbJ2d0Y2MnLCBbMTA5MTldXSwgWydndGNpcicsIFsxMDg3NF1dLCBbJ2d0JywgWzYyXV0sIFsnR1QnLCBbNjJdXSwgWydHdCcsIFs4ODExXV0sIFsnZ3Rkb3QnLCBbODkxOV1dLCBbJ2d0bFBhcicsIFsxMDY0NV1dLCBbJ2d0cXVlc3QnLCBbMTA4NzZdXSwgWydndHJhcHByb3gnLCBbMTA4ODZdXSwgWydndHJhcnInLCBbMTA2MTZdXSwgWydndHJkb3QnLCBbODkxOV1dLCBbJ2d0cmVxbGVzcycsIFs4OTIzXV0sIFsnZ3RyZXFxbGVzcycsIFsxMDg5Ml1dLCBbJ2d0cmxlc3MnLCBbODgyM11dLCBbJ2d0cnNpbScsIFs4ODE5XV0sIFsnZ3ZlcnRuZXFxJywgWzg4MDksIDY1MDI0XV0sIFsnZ3ZuRScsIFs4ODA5LCA2NTAyNF1dLCBbJ0hhY2VrJywgWzcxMV1dLCBbJ2hhaXJzcCcsIFs4MjAyXV0sIFsnaGFsZicsIFsxODldXSwgWydoYW1pbHQnLCBbODQ1OV1dLCBbJ0hBUkRjeScsIFsxMDY2XV0sIFsnaGFyZGN5JywgWzEwOThdXSwgWydoYXJyY2lyJywgWzEwNTY4XV0sIFsnaGFycicsIFs4NTk2XV0sIFsnaEFycicsIFs4NjYwXV0sIFsnaGFycncnLCBbODYyMV1dLCBbJ0hhdCcsIFs5NF1dLCBbJ2hiYXInLCBbODQ2M11dLCBbJ0hjaXJjJywgWzI5Ml1dLCBbJ2hjaXJjJywgWzI5M11dLCBbJ2hlYXJ0cycsIFs5ODI5XV0sIFsnaGVhcnRzdWl0JywgWzk4MjldXSwgWydoZWxsaXAnLCBbODIzMF1dLCBbJ2hlcmNvbicsIFs4ODg5XV0sIFsnaGZyJywgWzEyMDEwMV1dLCBbJ0hmcicsIFs4NDYwXV0sIFsnSGlsYmVydFNwYWNlJywgWzg0NTldXSwgWydoa3NlYXJvdycsIFsxMDUzM11dLCBbJ2hrc3dhcm93JywgWzEwNTM0XV0sIFsnaG9hcnInLCBbODcwM11dLCBbJ2hvbXRodCcsIFs4NzYzXV0sIFsnaG9va2xlZnRhcnJvdycsIFs4NjE3XV0sIFsnaG9va3JpZ2h0YXJyb3cnLCBbODYxOF1dLCBbJ2hvcGYnLCBbMTIwMTUzXV0sIFsnSG9wZicsIFs4NDYxXV0sIFsnaG9yYmFyJywgWzgyMTNdXSwgWydIb3Jpem9udGFsTGluZScsIFs5NDcyXV0sIFsnaHNjcicsIFsxMTk5OTddXSwgWydIc2NyJywgWzg0NTldXSwgWydoc2xhc2gnLCBbODQ2M11dLCBbJ0hzdHJvaycsIFsyOTRdXSwgWydoc3Ryb2snLCBbMjk1XV0sIFsnSHVtcERvd25IdW1wJywgWzg3ODJdXSwgWydIdW1wRXF1YWwnLCBbODc4M11dLCBbJ2h5YnVsbCcsIFs4MjU5XV0sIFsnaHlwaGVuJywgWzgyMDhdXSwgWydJYWN1dGUnLCBbMjA1XV0sIFsnaWFjdXRlJywgWzIzN11dLCBbJ2ljJywgWzgyOTFdXSwgWydJY2lyYycsIFsyMDZdXSwgWydpY2lyYycsIFsyMzhdXSwgWydJY3knLCBbMTA0OF1dLCBbJ2ljeScsIFsxMDgwXV0sIFsnSWRvdCcsIFszMDRdXSwgWydJRWN5JywgWzEwNDVdXSwgWydpZWN5JywgWzEwNzddXSwgWydpZXhjbCcsIFsxNjFdXSwgWydpZmYnLCBbODY2MF1dLCBbJ2lmcicsIFsxMjAxMDJdXSwgWydJZnInLCBbODQ2NV1dLCBbJ0lncmF2ZScsIFsyMDRdXSwgWydpZ3JhdmUnLCBbMjM2XV0sIFsnaWknLCBbODUyMF1dLCBbJ2lpaWludCcsIFsxMDc2NF1dLCBbJ2lpaW50JywgWzg3NDldXSwgWydpaW5maW4nLCBbMTA3MTZdXSwgWydpaW90YScsIFs4NDg5XV0sIFsnSUpsaWcnLCBbMzA2XV0sIFsnaWpsaWcnLCBbMzA3XV0sIFsnSW1hY3InLCBbMjk4XV0sIFsnaW1hY3InLCBbMjk5XV0sIFsnaW1hZ2UnLCBbODQ2NV1dLCBbJ0ltYWdpbmFyeUknLCBbODUyMF1dLCBbJ2ltYWdsaW5lJywgWzg0NjRdXSwgWydpbWFncGFydCcsIFs4NDY1XV0sIFsnaW1hdGgnLCBbMzA1XV0sIFsnSW0nLCBbODQ2NV1dLCBbJ2ltb2YnLCBbODg4N11dLCBbJ2ltcGVkJywgWzQzN11dLCBbJ0ltcGxpZXMnLCBbODY1OF1dLCBbJ2luY2FyZScsIFs4NDUzXV0sIFsnaW4nLCBbODcxMl1dLCBbJ2luZmluJywgWzg3MzRdXSwgWydpbmZpbnRpZScsIFsxMDcxN11dLCBbJ2lub2RvdCcsIFszMDVdXSwgWydpbnRjYWwnLCBbODg5MF1dLCBbJ2ludCcsIFs4NzQ3XV0sIFsnSW50JywgWzg3NDhdXSwgWydpbnRlZ2VycycsIFs4NDg0XV0sIFsnSW50ZWdyYWwnLCBbODc0N11dLCBbJ2ludGVyY2FsJywgWzg4OTBdXSwgWydJbnRlcnNlY3Rpb24nLCBbODg5OF1dLCBbJ2ludGxhcmhrJywgWzEwNzc1XV0sIFsnaW50cHJvZCcsIFsxMDgxMl1dLCBbJ0ludmlzaWJsZUNvbW1hJywgWzgyOTFdXSwgWydJbnZpc2libGVUaW1lcycsIFs4MjkwXV0sIFsnSU9jeScsIFsxMDI1XV0sIFsnaW9jeScsIFsxMTA1XV0sIFsnSW9nb24nLCBbMzAyXV0sIFsnaW9nb24nLCBbMzAzXV0sIFsnSW9wZicsIFsxMjAxMjhdXSwgWydpb3BmJywgWzEyMDE1NF1dLCBbJ0lvdGEnLCBbOTIxXV0sIFsnaW90YScsIFs5NTNdXSwgWydpcHJvZCcsIFsxMDgxMl1dLCBbJ2lxdWVzdCcsIFsxOTFdXSwgWydpc2NyJywgWzExOTk5OF1dLCBbJ0lzY3InLCBbODQ2NF1dLCBbJ2lzaW4nLCBbODcxMl1dLCBbJ2lzaW5kb3QnLCBbODk0OV1dLCBbJ2lzaW5FJywgWzg5NTNdXSwgWydpc2lucycsIFs4OTQ4XV0sIFsnaXNpbnN2JywgWzg5NDddXSwgWydpc2ludicsIFs4NzEyXV0sIFsnaXQnLCBbODI5MF1dLCBbJ0l0aWxkZScsIFsyOTZdXSwgWydpdGlsZGUnLCBbMjk3XV0sIFsnSXVrY3knLCBbMTAzMF1dLCBbJ2l1a2N5JywgWzExMTBdXSwgWydJdW1sJywgWzIwN11dLCBbJ2l1bWwnLCBbMjM5XV0sIFsnSmNpcmMnLCBbMzA4XV0sIFsnamNpcmMnLCBbMzA5XV0sIFsnSmN5JywgWzEwNDldXSwgWydqY3knLCBbMTA4MV1dLCBbJ0pmcicsIFsxMjAwNzddXSwgWydqZnInLCBbMTIwMTAzXV0sIFsnam1hdGgnLCBbNTY3XV0sIFsnSm9wZicsIFsxMjAxMjldXSwgWydqb3BmJywgWzEyMDE1NV1dLCBbJ0pzY3InLCBbMTE5OTczXV0sIFsnanNjcicsIFsxMTk5OTldXSwgWydKc2VyY3knLCBbMTAzMl1dLCBbJ2pzZXJjeScsIFsxMTEyXV0sIFsnSnVrY3knLCBbMTAyOF1dLCBbJ2p1a2N5JywgWzExMDhdXSwgWydLYXBwYScsIFs5MjJdXSwgWydrYXBwYScsIFs5NTRdXSwgWydrYXBwYXYnLCBbMTAwOF1dLCBbJ0tjZWRpbCcsIFszMTBdXSwgWydrY2VkaWwnLCBbMzExXV0sIFsnS2N5JywgWzEwNTBdXSwgWydrY3knLCBbMTA4Ml1dLCBbJ0tmcicsIFsxMjAwNzhdXSwgWydrZnInLCBbMTIwMTA0XV0sIFsna2dyZWVuJywgWzMxMl1dLCBbJ0tIY3knLCBbMTA2MV1dLCBbJ2toY3knLCBbMTA5M11dLCBbJ0tKY3knLCBbMTAzNl1dLCBbJ2tqY3knLCBbMTExNl1dLCBbJ0tvcGYnLCBbMTIwMTMwXV0sIFsna29wZicsIFsxMjAxNTZdXSwgWydLc2NyJywgWzExOTk3NF1dLCBbJ2tzY3InLCBbMTIwMDAwXV0sIFsnbEFhcnInLCBbODY2Nl1dLCBbJ0xhY3V0ZScsIFszMTNdXSwgWydsYWN1dGUnLCBbMzE0XV0sIFsnbGFlbXB0eXYnLCBbMTA2NzZdXSwgWydsYWdyYW4nLCBbODQ2Nl1dLCBbJ0xhbWJkYScsIFs5MjNdXSwgWydsYW1iZGEnLCBbOTU1XV0sIFsnbGFuZycsIFsxMDIxNl1dLCBbJ0xhbmcnLCBbMTAyMThdXSwgWydsYW5nZCcsIFsxMDY0MV1dLCBbJ2xhbmdsZScsIFsxMDIxNl1dLCBbJ2xhcCcsIFsxMDg4NV1dLCBbJ0xhcGxhY2V0cmYnLCBbODQ2Nl1dLCBbJ2xhcXVvJywgWzE3MV1dLCBbJ2xhcnJiJywgWzg2NzZdXSwgWydsYXJyYmZzJywgWzEwNTI3XV0sIFsnbGFycicsIFs4NTkyXV0sIFsnTGFycicsIFs4NjA2XV0sIFsnbEFycicsIFs4NjU2XV0sIFsnbGFycmZzJywgWzEwNTI1XV0sIFsnbGFycmhrJywgWzg2MTddXSwgWydsYXJybHAnLCBbODYxOV1dLCBbJ2xhcnJwbCcsIFsxMDU1M11dLCBbJ2xhcnJzaW0nLCBbMTA2MTFdXSwgWydsYXJydGwnLCBbODYxMF1dLCBbJ2xhdGFpbCcsIFsxMDUyMV1dLCBbJ2xBdGFpbCcsIFsxMDUyM11dLCBbJ2xhdCcsIFsxMDkyM11dLCBbJ2xhdGUnLCBbMTA5MjVdXSwgWydsYXRlcycsIFsxMDkyNSwgNjUwMjRdXSwgWydsYmFycicsIFsxMDUwOF1dLCBbJ2xCYXJyJywgWzEwNTEwXV0sIFsnbGJicmsnLCBbMTAwOThdXSwgWydsYnJhY2UnLCBbMTIzXV0sIFsnbGJyYWNrJywgWzkxXV0sIFsnbGJya2UnLCBbMTA2MzVdXSwgWydsYnJrc2xkJywgWzEwNjM5XV0sIFsnbGJya3NsdScsIFsxMDYzN11dLCBbJ0xjYXJvbicsIFszMTddXSwgWydsY2Fyb24nLCBbMzE4XV0sIFsnTGNlZGlsJywgWzMxNV1dLCBbJ2xjZWRpbCcsIFszMTZdXSwgWydsY2VpbCcsIFs4OTY4XV0sIFsnbGN1YicsIFsxMjNdXSwgWydMY3knLCBbMTA1MV1dLCBbJ2xjeScsIFsxMDgzXV0sIFsnbGRjYScsIFsxMDU1MF1dLCBbJ2xkcXVvJywgWzgyMjBdXSwgWydsZHF1b3InLCBbODIyMl1dLCBbJ2xkcmRoYXInLCBbMTA1OTldXSwgWydsZHJ1c2hhcicsIFsxMDU3MV1dLCBbJ2xkc2gnLCBbODYyNl1dLCBbJ2xlJywgWzg4MDRdXSwgWydsRScsIFs4ODA2XV0sIFsnTGVmdEFuZ2xlQnJhY2tldCcsIFsxMDIxNl1dLCBbJ0xlZnRBcnJvd0JhcicsIFs4Njc2XV0sIFsnbGVmdGFycm93JywgWzg1OTJdXSwgWydMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRhcnJvdycsIFs4NjU2XV0sIFsnTGVmdEFycm93UmlnaHRBcnJvdycsIFs4NjQ2XV0sIFsnbGVmdGFycm93dGFpbCcsIFs4NjEwXV0sIFsnTGVmdENlaWxpbmcnLCBbODk2OF1dLCBbJ0xlZnREb3VibGVCcmFja2V0JywgWzEwMjE0XV0sIFsnTGVmdERvd25UZWVWZWN0b3InLCBbMTA1OTNdXSwgWydMZWZ0RG93blZlY3RvckJhcicsIFsxMDU4NV1dLCBbJ0xlZnREb3duVmVjdG9yJywgWzg2NDNdXSwgWydMZWZ0Rmxvb3InLCBbODk3MF1dLCBbJ2xlZnRoYXJwb29uZG93bicsIFs4NjM3XV0sIFsnbGVmdGhhcnBvb251cCcsIFs4NjM2XV0sIFsnbGVmdGxlZnRhcnJvd3MnLCBbODY0N11dLCBbJ2xlZnRyaWdodGFycm93JywgWzg1OTZdXSwgWydMZWZ0UmlnaHRBcnJvdycsIFs4NTk2XV0sIFsnTGVmdHJpZ2h0YXJyb3cnLCBbODY2MF1dLCBbJ2xlZnRyaWdodGFycm93cycsIFs4NjQ2XV0sIFsnbGVmdHJpZ2h0aGFycG9vbnMnLCBbODY1MV1dLCBbJ2xlZnRyaWdodHNxdWlnYXJyb3cnLCBbODYyMV1dLCBbJ0xlZnRSaWdodFZlY3RvcicsIFsxMDU3NF1dLCBbJ0xlZnRUZWVBcnJvdycsIFs4NjEyXV0sIFsnTGVmdFRlZScsIFs4ODY3XV0sIFsnTGVmdFRlZVZlY3RvcicsIFsxMDU4Nl1dLCBbJ2xlZnR0aHJlZXRpbWVzJywgWzg5MDddXSwgWydMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDNdXSwgWydMZWZ0VHJpYW5nbGUnLCBbODg4Ml1dLCBbJ0xlZnRUcmlhbmdsZUVxdWFsJywgWzg4ODRdXSwgWydMZWZ0VXBEb3duVmVjdG9yJywgWzEwNTc3XV0sIFsnTGVmdFVwVGVlVmVjdG9yJywgWzEwNTkyXV0sIFsnTGVmdFVwVmVjdG9yQmFyJywgWzEwNTg0XV0sIFsnTGVmdFVwVmVjdG9yJywgWzg2MzldXSwgWydMZWZ0VmVjdG9yQmFyJywgWzEwNTc4XV0sIFsnTGVmdFZlY3RvcicsIFs4NjM2XV0sIFsnbEVnJywgWzEwODkxXV0sIFsnbGVnJywgWzg5MjJdXSwgWydsZXEnLCBbODgwNF1dLCBbJ2xlcXEnLCBbODgwNl1dLCBbJ2xlcXNsYW50JywgWzEwODc3XV0sIFsnbGVzY2MnLCBbMTA5MjBdXSwgWydsZXMnLCBbMTA4NzddXSwgWydsZXNkb3QnLCBbMTA4NzldXSwgWydsZXNkb3RvJywgWzEwODgxXV0sIFsnbGVzZG90b3InLCBbMTA4ODNdXSwgWydsZXNnJywgWzg5MjIsIDY1MDI0XV0sIFsnbGVzZ2VzJywgWzEwODk5XV0sIFsnbGVzc2FwcHJveCcsIFsxMDg4NV1dLCBbJ2xlc3Nkb3QnLCBbODkxOF1dLCBbJ2xlc3NlcWd0cicsIFs4OTIyXV0sIFsnbGVzc2VxcWd0cicsIFsxMDg5MV1dLCBbJ0xlc3NFcXVhbEdyZWF0ZXInLCBbODkyMl1dLCBbJ0xlc3NGdWxsRXF1YWwnLCBbODgwNl1dLCBbJ0xlc3NHcmVhdGVyJywgWzg4MjJdXSwgWydsZXNzZ3RyJywgWzg4MjJdXSwgWydMZXNzTGVzcycsIFsxMDkxM11dLCBbJ2xlc3NzaW0nLCBbODgxOF1dLCBbJ0xlc3NTbGFudEVxdWFsJywgWzEwODc3XV0sIFsnTGVzc1RpbGRlJywgWzg4MThdXSwgWydsZmlzaHQnLCBbMTA2MjBdXSwgWydsZmxvb3InLCBbODk3MF1dLCBbJ0xmcicsIFsxMjAwNzldXSwgWydsZnInLCBbMTIwMTA1XV0sIFsnbGcnLCBbODgyMl1dLCBbJ2xnRScsIFsxMDg5N11dLCBbJ2xIYXInLCBbMTA1OTRdXSwgWydsaGFyZCcsIFs4NjM3XV0sIFsnbGhhcnUnLCBbODYzNl1dLCBbJ2xoYXJ1bCcsIFsxMDYwMl1dLCBbJ2xoYmxrJywgWzk2MDRdXSwgWydMSmN5JywgWzEwMzNdXSwgWydsamN5JywgWzExMTNdXSwgWydsbGFycicsIFs4NjQ3XV0sIFsnbGwnLCBbODgxMF1dLCBbJ0xsJywgWzg5MjBdXSwgWydsbGNvcm5lcicsIFs4OTkwXV0sIFsnTGxlZnRhcnJvdycsIFs4NjY2XV0sIFsnbGxoYXJkJywgWzEwNjAzXV0sIFsnbGx0cmknLCBbOTcyMl1dLCBbJ0xtaWRvdCcsIFszMTldXSwgWydsbWlkb3QnLCBbMzIwXV0sIFsnbG1vdXN0YWNoZScsIFs5MTM2XV0sIFsnbG1vdXN0JywgWzkxMzZdXSwgWydsbmFwJywgWzEwODg5XV0sIFsnbG5hcHByb3gnLCBbMTA4ODldXSwgWydsbmUnLCBbMTA4ODddXSwgWydsbkUnLCBbODgwOF1dLCBbJ2xuZXEnLCBbMTA4ODddXSwgWydsbmVxcScsIFs4ODA4XV0sIFsnbG5zaW0nLCBbODkzNF1dLCBbJ2xvYW5nJywgWzEwMjIwXV0sIFsnbG9hcnInLCBbODcwMV1dLCBbJ2xvYnJrJywgWzEwMjE0XV0sIFsnbG9uZ2xlZnRhcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdMZWZ0QXJyb3cnLCBbMTAyMjldXSwgWydMb25nbGVmdGFycm93JywgWzEwMjMyXV0sIFsnbG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjMxXV0sIFsnTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjMxXV0sIFsnTG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjM0XV0sIFsnbG9uZ21hcHN0bycsIFsxMDIzNl1dLCBbJ2xvbmdyaWdodGFycm93JywgWzEwMjMwXV0sIFsnTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzBdXSwgWydMb25ncmlnaHRhcnJvdycsIFsxMDIzM11dLCBbJ2xvb3BhcnJvd2xlZnQnLCBbODYxOV1dLCBbJ2xvb3BhcnJvd3JpZ2h0JywgWzg2MjBdXSwgWydsb3BhcicsIFsxMDYyOV1dLCBbJ0xvcGYnLCBbMTIwMTMxXV0sIFsnbG9wZicsIFsxMjAxNTddXSwgWydsb3BsdXMnLCBbMTA3OTddXSwgWydsb3RpbWVzJywgWzEwODA0XV0sIFsnbG93YXN0JywgWzg3MjddXSwgWydsb3diYXInLCBbOTVdXSwgWydMb3dlckxlZnRBcnJvdycsIFs4NjAxXV0sIFsnTG93ZXJSaWdodEFycm93JywgWzg2MDBdXSwgWydsb3onLCBbOTY3NF1dLCBbJ2xvemVuZ2UnLCBbOTY3NF1dLCBbJ2xvemYnLCBbMTA3MzFdXSwgWydscGFyJywgWzQwXV0sIFsnbHBhcmx0JywgWzEwNjQzXV0sIFsnbHJhcnInLCBbODY0Nl1dLCBbJ2xyY29ybmVyJywgWzg5OTFdXSwgWydscmhhcicsIFs4NjUxXV0sIFsnbHJoYXJkJywgWzEwNjA1XV0sIFsnbHJtJywgWzgyMDZdXSwgWydscnRyaScsIFs4ODk1XV0sIFsnbHNhcXVvJywgWzgyNDldXSwgWydsc2NyJywgWzEyMDAwMV1dLCBbJ0xzY3InLCBbODQ2Nl1dLCBbJ2xzaCcsIFs4NjI0XV0sIFsnTHNoJywgWzg2MjRdXSwgWydsc2ltJywgWzg4MThdXSwgWydsc2ltZScsIFsxMDg5M11dLCBbJ2xzaW1nJywgWzEwODk1XV0sIFsnbHNxYicsIFs5MV1dLCBbJ2xzcXVvJywgWzgyMTZdXSwgWydsc3F1b3InLCBbODIxOF1dLCBbJ0xzdHJvaycsIFszMjFdXSwgWydsc3Ryb2snLCBbMzIyXV0sIFsnbHRjYycsIFsxMDkxOF1dLCBbJ2x0Y2lyJywgWzEwODczXV0sIFsnbHQnLCBbNjBdXSwgWydMVCcsIFs2MF1dLCBbJ0x0JywgWzg4MTBdXSwgWydsdGRvdCcsIFs4OTE4XV0sIFsnbHRocmVlJywgWzg5MDddXSwgWydsdGltZXMnLCBbODkwNV1dLCBbJ2x0bGFycicsIFsxMDYxNF1dLCBbJ2x0cXVlc3QnLCBbMTA4NzVdXSwgWydsdHJpJywgWzk2NjddXSwgWydsdHJpZScsIFs4ODg0XV0sIFsnbHRyaWYnLCBbOTY2Nl1dLCBbJ2x0clBhcicsIFsxMDY0Nl1dLCBbJ2x1cmRzaGFyJywgWzEwNTcwXV0sIFsnbHVydWhhcicsIFsxMDU5OF1dLCBbJ2x2ZXJ0bmVxcScsIFs4ODA4LCA2NTAyNF1dLCBbJ2x2bkUnLCBbODgwOCwgNjUwMjRdXSwgWydtYWNyJywgWzE3NV1dLCBbJ21hbGUnLCBbOTc5NF1dLCBbJ21hbHQnLCBbMTAwMTZdXSwgWydtYWx0ZXNlJywgWzEwMDE2XV0sIFsnTWFwJywgWzEwNTAxXV0sIFsnbWFwJywgWzg2MTRdXSwgWydtYXBzdG8nLCBbODYxNF1dLCBbJ21hcHN0b2Rvd24nLCBbODYxNV1dLCBbJ21hcHN0b2xlZnQnLCBbODYxMl1dLCBbJ21hcHN0b3VwJywgWzg2MTNdXSwgWydtYXJrZXInLCBbOTY0Nl1dLCBbJ21jb21tYScsIFsxMDc5M11dLCBbJ01jeScsIFsxMDUyXV0sIFsnbWN5JywgWzEwODRdXSwgWydtZGFzaCcsIFs4MjEyXV0sIFsnbUREb3QnLCBbODc2Ml1dLCBbJ21lYXN1cmVkYW5nbGUnLCBbODczN11dLCBbJ01lZGl1bVNwYWNlJywgWzgyODddXSwgWydNZWxsaW50cmYnLCBbODQ5OV1dLCBbJ01mcicsIFsxMjAwODBdXSwgWydtZnInLCBbMTIwMTA2XV0sIFsnbWhvJywgWzg0ODddXSwgWydtaWNybycsIFsxODFdXSwgWydtaWRhc3QnLCBbNDJdXSwgWydtaWRjaXInLCBbMTA5OTJdXSwgWydtaWQnLCBbODczOV1dLCBbJ21pZGRvdCcsIFsxODNdXSwgWydtaW51c2InLCBbODg2M11dLCBbJ21pbnVzJywgWzg3MjJdXSwgWydtaW51c2QnLCBbODc2MF1dLCBbJ21pbnVzZHUnLCBbMTA3OTRdXSwgWydNaW51c1BsdXMnLCBbODcyM11dLCBbJ21sY3AnLCBbMTA5NzFdXSwgWydtbGRyJywgWzgyMzBdXSwgWydtbnBsdXMnLCBbODcyM11dLCBbJ21vZGVscycsIFs4ODcxXV0sIFsnTW9wZicsIFsxMjAxMzJdXSwgWydtb3BmJywgWzEyMDE1OF1dLCBbJ21wJywgWzg3MjNdXSwgWydtc2NyJywgWzEyMDAwMl1dLCBbJ01zY3InLCBbODQ5OV1dLCBbJ21zdHBvcycsIFs4NzY2XV0sIFsnTXUnLCBbOTI0XV0sIFsnbXUnLCBbOTU2XV0sIFsnbXVsdGltYXAnLCBbODg4OF1dLCBbJ211bWFwJywgWzg4ODhdXSwgWyduYWJsYScsIFs4NzExXV0sIFsnTmFjdXRlJywgWzMyM11dLCBbJ25hY3V0ZScsIFszMjRdXSwgWyduYW5nJywgWzg3MzYsIDg0MDJdXSwgWyduYXAnLCBbODc3N11dLCBbJ25hcEUnLCBbMTA4NjQsIDgyNF1dLCBbJ25hcGlkJywgWzg3NzksIDgyNF1dLCBbJ25hcG9zJywgWzMyOV1dLCBbJ25hcHByb3gnLCBbODc3N11dLCBbJ25hdHVyYWwnLCBbOTgzOF1dLCBbJ25hdHVyYWxzJywgWzg0NjldXSwgWyduYXR1cicsIFs5ODM4XV0sIFsnbmJzcCcsIFsxNjBdXSwgWyduYnVtcCcsIFs4NzgyLCA4MjRdXSwgWyduYnVtcGUnLCBbODc4MywgODI0XV0sIFsnbmNhcCcsIFsxMDgxOV1dLCBbJ05jYXJvbicsIFszMjddXSwgWyduY2Fyb24nLCBbMzI4XV0sIFsnTmNlZGlsJywgWzMyNV1dLCBbJ25jZWRpbCcsIFszMjZdXSwgWyduY29uZycsIFs4Nzc1XV0sIFsnbmNvbmdkb3QnLCBbMTA4NjEsIDgyNF1dLCBbJ25jdXAnLCBbMTA4MThdXSwgWydOY3knLCBbMTA1M11dLCBbJ25jeScsIFsxMDg1XV0sIFsnbmRhc2gnLCBbODIxMV1dLCBbJ25lYXJoaycsIFsxMDUzMl1dLCBbJ25lYXJyJywgWzg1OTldXSwgWyduZUFycicsIFs4NjYzXV0sIFsnbmVhcnJvdycsIFs4NTk5XV0sIFsnbmUnLCBbODgwMF1dLCBbJ25lZG90JywgWzg3ODQsIDgyNF1dLCBbJ05lZ2F0aXZlTWVkaXVtU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpY2tTcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGluU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVmVyeVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnbmVxdWl2JywgWzg4MDJdXSwgWyduZXNlYXInLCBbMTA1MzZdXSwgWyduZXNpbScsIFs4NzcwLCA4MjRdXSwgWydOZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFs4ODExXV0sIFsnTmVzdGVkTGVzc0xlc3MnLCBbODgxMF1dLCBbJ25leGlzdCcsIFs4NzA4XV0sIFsnbmV4aXN0cycsIFs4NzA4XV0sIFsnTmZyJywgWzEyMDA4MV1dLCBbJ25mcicsIFsxMjAxMDddXSwgWyduZ0UnLCBbODgwNywgODI0XV0sIFsnbmdlJywgWzg4MTddXSwgWyduZ2VxJywgWzg4MTddXSwgWyduZ2VxcScsIFs4ODA3LCA4MjRdXSwgWyduZ2Vxc2xhbnQnLCBbMTA4NzgsIDgyNF1dLCBbJ25nZXMnLCBbMTA4NzgsIDgyNF1dLCBbJ25HZycsIFs4OTIxLCA4MjRdXSwgWyduZ3NpbScsIFs4ODIxXV0sIFsnbkd0JywgWzg4MTEsIDg0MDJdXSwgWyduZ3QnLCBbODgxNV1dLCBbJ25ndHInLCBbODgxNV1dLCBbJ25HdHYnLCBbODgxMSwgODI0XV0sIFsnbmhhcnInLCBbODYyMl1dLCBbJ25oQXJyJywgWzg2NTRdXSwgWyduaHBhcicsIFsxMDk5NF1dLCBbJ25pJywgWzg3MTVdXSwgWyduaXMnLCBbODk1Nl1dLCBbJ25pc2QnLCBbODk1NF1dLCBbJ25pdicsIFs4NzE1XV0sIFsnTkpjeScsIFsxMDM0XV0sIFsnbmpjeScsIFsxMTE0XV0sIFsnbmxhcnInLCBbODYwMl1dLCBbJ25sQXJyJywgWzg2NTNdXSwgWydubGRyJywgWzgyMjldXSwgWydubEUnLCBbODgwNiwgODI0XV0sIFsnbmxlJywgWzg4MTZdXSwgWydubGVmdGFycm93JywgWzg2MDJdXSwgWyduTGVmdGFycm93JywgWzg2NTNdXSwgWydubGVmdHJpZ2h0YXJyb3cnLCBbODYyMl1dLCBbJ25MZWZ0cmlnaHRhcnJvdycsIFs4NjU0XV0sIFsnbmxlcScsIFs4ODE2XV0sIFsnbmxlcXEnLCBbODgwNiwgODI0XV0sIFsnbmxlcXNsYW50JywgWzEwODc3LCA4MjRdXSwgWydubGVzJywgWzEwODc3LCA4MjRdXSwgWydubGVzcycsIFs4ODE0XV0sIFsnbkxsJywgWzg5MjAsIDgyNF1dLCBbJ25sc2ltJywgWzg4MjBdXSwgWyduTHQnLCBbODgxMCwgODQwMl1dLCBbJ25sdCcsIFs4ODE0XV0sIFsnbmx0cmknLCBbODkzOF1dLCBbJ25sdHJpZScsIFs4OTQwXV0sIFsnbkx0dicsIFs4ODEwLCA4MjRdXSwgWydubWlkJywgWzg3NDBdXSwgWydOb0JyZWFrJywgWzgyODhdXSwgWydOb25CcmVha2luZ1NwYWNlJywgWzE2MF1dLCBbJ25vcGYnLCBbMTIwMTU5XV0sIFsnTm9wZicsIFs4NDY5XV0sIFsnTm90JywgWzEwOTg4XV0sIFsnbm90JywgWzE3Ml1dLCBbJ05vdENvbmdydWVudCcsIFs4ODAyXV0sIFsnTm90Q3VwQ2FwJywgWzg4MTNdXSwgWydOb3REb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQyXV0sIFsnTm90RWxlbWVudCcsIFs4NzEzXV0sIFsnTm90RXF1YWwnLCBbODgwMF1dLCBbJ05vdEVxdWFsVGlsZGUnLCBbODc3MCwgODI0XV0sIFsnTm90RXhpc3RzJywgWzg3MDhdXSwgWydOb3RHcmVhdGVyJywgWzg4MTVdXSwgWydOb3RHcmVhdGVyRXF1YWwnLCBbODgxN11dLCBbJ05vdEdyZWF0ZXJGdWxsRXF1YWwnLCBbODgwNywgODI0XV0sIFsnTm90R3JlYXRlckdyZWF0ZXInLCBbODgxMSwgODI0XV0sIFsnTm90R3JlYXRlckxlc3MnLCBbODgyNV1dLCBbJ05vdEdyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4LCA4MjRdXSwgWydOb3RHcmVhdGVyVGlsZGUnLCBbODgyMV1dLCBbJ05vdEh1bXBEb3duSHVtcCcsIFs4NzgyLCA4MjRdXSwgWydOb3RIdW1wRXF1YWwnLCBbODc4MywgODI0XV0sIFsnbm90aW4nLCBbODcxM11dLCBbJ25vdGluZG90JywgWzg5NDksIDgyNF1dLCBbJ25vdGluRScsIFs4OTUzLCA4MjRdXSwgWydub3RpbnZhJywgWzg3MTNdXSwgWydub3RpbnZiJywgWzg5NTFdXSwgWydub3RpbnZjJywgWzg5NTBdXSwgWydOb3RMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDMsIDgyNF1dLCBbJ05vdExlZnRUcmlhbmdsZScsIFs4OTM4XV0sIFsnTm90TGVmdFRyaWFuZ2xlRXF1YWwnLCBbODk0MF1dLCBbJ05vdExlc3MnLCBbODgxNF1dLCBbJ05vdExlc3NFcXVhbCcsIFs4ODE2XV0sIFsnTm90TGVzc0dyZWF0ZXInLCBbODgyNF1dLCBbJ05vdExlc3NMZXNzJywgWzg4MTAsIDgyNF1dLCBbJ05vdExlc3NTbGFudEVxdWFsJywgWzEwODc3LCA4MjRdXSwgWydOb3RMZXNzVGlsZGUnLCBbODgyMF1dLCBbJ05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzEwOTE0LCA4MjRdXSwgWydOb3ROZXN0ZWRMZXNzTGVzcycsIFsxMDkxMywgODI0XV0sIFsnbm90bmknLCBbODcxNl1dLCBbJ25vdG5pdmEnLCBbODcxNl1dLCBbJ25vdG5pdmInLCBbODk1OF1dLCBbJ25vdG5pdmMnLCBbODk1N11dLCBbJ05vdFByZWNlZGVzJywgWzg4MzJdXSwgWydOb3RQcmVjZWRlc0VxdWFsJywgWzEwOTI3LCA4MjRdXSwgWydOb3RQcmVjZWRlc1NsYW50RXF1YWwnLCBbODkyOF1dLCBbJ05vdFJldmVyc2VFbGVtZW50JywgWzg3MTZdXSwgWydOb3RSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0LCA4MjRdXSwgWydOb3RSaWdodFRyaWFuZ2xlJywgWzg5MzldXSwgWydOb3RSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODk0MV1dLCBbJ05vdFNxdWFyZVN1YnNldCcsIFs4ODQ3LCA4MjRdXSwgWydOb3RTcXVhcmVTdWJzZXRFcXVhbCcsIFs4OTMwXV0sIFsnTm90U3F1YXJlU3VwZXJzZXQnLCBbODg0OCwgODI0XV0sIFsnTm90U3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4OTMxXV0sIFsnTm90U3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWydOb3RTdWJzZXRFcXVhbCcsIFs4ODQwXV0sIFsnTm90U3VjY2VlZHMnLCBbODgzM11dLCBbJ05vdFN1Y2NlZWRzRXF1YWwnLCBbMTA5MjgsIDgyNF1dLCBbJ05vdFN1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4OTI5XV0sIFsnTm90U3VjY2VlZHNUaWxkZScsIFs4ODMxLCA4MjRdXSwgWydOb3RTdXBlcnNldCcsIFs4ODM1LCA4NDAyXV0sIFsnTm90U3VwZXJzZXRFcXVhbCcsIFs4ODQxXV0sIFsnTm90VGlsZGUnLCBbODc2OV1dLCBbJ05vdFRpbGRlRXF1YWwnLCBbODc3Ml1dLCBbJ05vdFRpbGRlRnVsbEVxdWFsJywgWzg3NzVdXSwgWydOb3RUaWxkZVRpbGRlJywgWzg3NzddXSwgWydOb3RWZXJ0aWNhbEJhcicsIFs4NzQwXV0sIFsnbnBhcmFsbGVsJywgWzg3NDJdXSwgWyducGFyJywgWzg3NDJdXSwgWyducGFyc2wnLCBbMTEwMDUsIDg0MjFdXSwgWyducGFydCcsIFs4NzA2LCA4MjRdXSwgWyducG9saW50JywgWzEwNzcyXV0sIFsnbnByJywgWzg4MzJdXSwgWyducHJjdWUnLCBbODkyOF1dLCBbJ25wcmVjJywgWzg4MzJdXSwgWyducHJlY2VxJywgWzEwOTI3LCA4MjRdXSwgWyducHJlJywgWzEwOTI3LCA4MjRdXSwgWyducmFycmMnLCBbMTA1NDcsIDgyNF1dLCBbJ25yYXJyJywgWzg2MDNdXSwgWyduckFycicsIFs4NjU1XV0sIFsnbnJhcnJ3JywgWzg2MDUsIDgyNF1dLCBbJ25yaWdodGFycm93JywgWzg2MDNdXSwgWyduUmlnaHRhcnJvdycsIFs4NjU1XV0sIFsnbnJ0cmknLCBbODkzOV1dLCBbJ25ydHJpZScsIFs4OTQxXV0sIFsnbnNjJywgWzg4MzNdXSwgWyduc2NjdWUnLCBbODkyOV1dLCBbJ25zY2UnLCBbMTA5MjgsIDgyNF1dLCBbJ05zY3InLCBbMTE5OTc3XV0sIFsnbnNjcicsIFsxMjAwMDNdXSwgWyduc2hvcnRtaWQnLCBbODc0MF1dLCBbJ25zaG9ydHBhcmFsbGVsJywgWzg3NDJdXSwgWyduc2ltJywgWzg3NjldXSwgWyduc2ltZScsIFs4NzcyXV0sIFsnbnNpbWVxJywgWzg3NzJdXSwgWyduc21pZCcsIFs4NzQwXV0sIFsnbnNwYXInLCBbODc0Ml1dLCBbJ25zcXN1YmUnLCBbODkzMF1dLCBbJ25zcXN1cGUnLCBbODkzMV1dLCBbJ25zdWInLCBbODgzNl1dLCBbJ25zdWJFJywgWzEwOTQ5LCA4MjRdXSwgWyduc3ViZScsIFs4ODQwXV0sIFsnbnN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnbnN1YnNldGVxJywgWzg4NDBdXSwgWyduc3Vic2V0ZXFxJywgWzEwOTQ5LCA4MjRdXSwgWyduc3VjYycsIFs4ODMzXV0sIFsnbnN1Y2NlcScsIFsxMDkyOCwgODI0XV0sIFsnbnN1cCcsIFs4ODM3XV0sIFsnbnN1cEUnLCBbMTA5NTAsIDgyNF1dLCBbJ25zdXBlJywgWzg4NDFdXSwgWyduc3Vwc2V0JywgWzg4MzUsIDg0MDJdXSwgWyduc3Vwc2V0ZXEnLCBbODg0MV1dLCBbJ25zdXBzZXRlcXEnLCBbMTA5NTAsIDgyNF1dLCBbJ250Z2wnLCBbODgyNV1dLCBbJ050aWxkZScsIFsyMDldXSwgWydudGlsZGUnLCBbMjQxXV0sIFsnbnRsZycsIFs4ODI0XV0sIFsnbnRyaWFuZ2xlbGVmdCcsIFs4OTM4XV0sIFsnbnRyaWFuZ2xlbGVmdGVxJywgWzg5NDBdXSwgWydudHJpYW5nbGVyaWdodCcsIFs4OTM5XV0sIFsnbnRyaWFuZ2xlcmlnaHRlcScsIFs4OTQxXV0sIFsnTnUnLCBbOTI1XV0sIFsnbnUnLCBbOTU3XV0sIFsnbnVtJywgWzM1XV0sIFsnbnVtZXJvJywgWzg0NzBdXSwgWydudW1zcCcsIFs4MTk5XV0sIFsnbnZhcCcsIFs4NzgxLCA4NDAyXV0sIFsnbnZkYXNoJywgWzg4NzZdXSwgWydudkRhc2gnLCBbODg3N11dLCBbJ25WZGFzaCcsIFs4ODc4XV0sIFsnblZEYXNoJywgWzg4NzldXSwgWydudmdlJywgWzg4MDUsIDg0MDJdXSwgWydudmd0JywgWzYyLCA4NDAyXV0sIFsnbnZIYXJyJywgWzEwNTAwXV0sIFsnbnZpbmZpbicsIFsxMDcxOF1dLCBbJ252bEFycicsIFsxMDQ5OF1dLCBbJ252bGUnLCBbODgwNCwgODQwMl1dLCBbJ252bHQnLCBbNjAsIDg0MDJdXSwgWydudmx0cmllJywgWzg4ODQsIDg0MDJdXSwgWydudnJBcnInLCBbMTA0OTldXSwgWydudnJ0cmllJywgWzg4ODUsIDg0MDJdXSwgWydudnNpbScsIFs4NzY0LCA4NDAyXV0sIFsnbndhcmhrJywgWzEwNTMxXV0sIFsnbndhcnInLCBbODU5OF1dLCBbJ253QXJyJywgWzg2NjJdXSwgWydud2Fycm93JywgWzg1OThdXSwgWydud25lYXInLCBbMTA1MzVdXSwgWydPYWN1dGUnLCBbMjExXV0sIFsnb2FjdXRlJywgWzI0M11dLCBbJ29hc3QnLCBbODg1OV1dLCBbJ09jaXJjJywgWzIxMl1dLCBbJ29jaXJjJywgWzI0NF1dLCBbJ29jaXInLCBbODg1OF1dLCBbJ09jeScsIFsxMDU0XV0sIFsnb2N5JywgWzEwODZdXSwgWydvZGFzaCcsIFs4ODYxXV0sIFsnT2RibGFjJywgWzMzNl1dLCBbJ29kYmxhYycsIFszMzddXSwgWydvZGl2JywgWzEwODA4XV0sIFsnb2RvdCcsIFs4ODU3XV0sIFsnb2Rzb2xkJywgWzEwNjg0XV0sIFsnT0VsaWcnLCBbMzM4XV0sIFsnb2VsaWcnLCBbMzM5XV0sIFsnb2ZjaXInLCBbMTA2ODddXSwgWydPZnInLCBbMTIwMDgyXV0sIFsnb2ZyJywgWzEyMDEwOF1dLCBbJ29nb24nLCBbNzMxXV0sIFsnT2dyYXZlJywgWzIxMF1dLCBbJ29ncmF2ZScsIFsyNDJdXSwgWydvZ3QnLCBbMTA2ODldXSwgWydvaGJhcicsIFsxMDY3N11dLCBbJ29obScsIFs5MzddXSwgWydvaW50JywgWzg3NTBdXSwgWydvbGFycicsIFs4NjM0XV0sIFsnb2xjaXInLCBbMTA2ODZdXSwgWydvbGNyb3NzJywgWzEwNjgzXV0sIFsnb2xpbmUnLCBbODI1NF1dLCBbJ29sdCcsIFsxMDY4OF1dLCBbJ09tYWNyJywgWzMzMl1dLCBbJ29tYWNyJywgWzMzM11dLCBbJ09tZWdhJywgWzkzN11dLCBbJ29tZWdhJywgWzk2OV1dLCBbJ09taWNyb24nLCBbOTI3XV0sIFsnb21pY3JvbicsIFs5NTldXSwgWydvbWlkJywgWzEwNjc4XV0sIFsnb21pbnVzJywgWzg4NTRdXSwgWydPb3BmJywgWzEyMDEzNF1dLCBbJ29vcGYnLCBbMTIwMTYwXV0sIFsnb3BhcicsIFsxMDY3OV1dLCBbJ09wZW5DdXJseURvdWJsZVF1b3RlJywgWzgyMjBdXSwgWydPcGVuQ3VybHlRdW90ZScsIFs4MjE2XV0sIFsnb3BlcnAnLCBbMTA2ODFdXSwgWydvcGx1cycsIFs4ODUzXV0sIFsnb3JhcnInLCBbODYzNV1dLCBbJ09yJywgWzEwODM2XV0sIFsnb3InLCBbODc0NF1dLCBbJ29yZCcsIFsxMDg0NV1dLCBbJ29yZGVyJywgWzg1MDBdXSwgWydvcmRlcm9mJywgWzg1MDBdXSwgWydvcmRmJywgWzE3MF1dLCBbJ29yZG0nLCBbMTg2XV0sIFsnb3JpZ29mJywgWzg4ODZdXSwgWydvcm9yJywgWzEwODM4XV0sIFsnb3JzbG9wZScsIFsxMDgzOV1dLCBbJ29ydicsIFsxMDg0M11dLCBbJ29TJywgWzk0MTZdXSwgWydPc2NyJywgWzExOTk3OF1dLCBbJ29zY3InLCBbODUwMF1dLCBbJ09zbGFzaCcsIFsyMTZdXSwgWydvc2xhc2gnLCBbMjQ4XV0sIFsnb3NvbCcsIFs4ODU2XV0sIFsnT3RpbGRlJywgWzIxM11dLCBbJ290aWxkZScsIFsyNDVdXSwgWydvdGltZXNhcycsIFsxMDgwNl1dLCBbJ090aW1lcycsIFsxMDgwN11dLCBbJ290aW1lcycsIFs4ODU1XV0sIFsnT3VtbCcsIFsyMTRdXSwgWydvdW1sJywgWzI0Nl1dLCBbJ292YmFyJywgWzkwMjFdXSwgWydPdmVyQmFyJywgWzgyNTRdXSwgWydPdmVyQnJhY2UnLCBbOTE4Ml1dLCBbJ092ZXJCcmFja2V0JywgWzkxNDBdXSwgWydPdmVyUGFyZW50aGVzaXMnLCBbOTE4MF1dLCBbJ3BhcmEnLCBbMTgyXV0sIFsncGFyYWxsZWwnLCBbODc0MV1dLCBbJ3BhcicsIFs4NzQxXV0sIFsncGFyc2ltJywgWzEwOTk1XV0sIFsncGFyc2wnLCBbMTEwMDVdXSwgWydwYXJ0JywgWzg3MDZdXSwgWydQYXJ0aWFsRCcsIFs4NzA2XV0sIFsnUGN5JywgWzEwNTVdXSwgWydwY3knLCBbMTA4N11dLCBbJ3BlcmNudCcsIFszN11dLCBbJ3BlcmlvZCcsIFs0Nl1dLCBbJ3Blcm1pbCcsIFs4MjQwXV0sIFsncGVycCcsIFs4ODY5XV0sIFsncGVydGVuaycsIFs4MjQxXV0sIFsnUGZyJywgWzEyMDA4M11dLCBbJ3BmcicsIFsxMjAxMDldXSwgWydQaGknLCBbOTM0XV0sIFsncGhpJywgWzk2Nl1dLCBbJ3BoaXYnLCBbOTgxXV0sIFsncGhtbWF0JywgWzg0OTldXSwgWydwaG9uZScsIFs5NzQyXV0sIFsnUGknLCBbOTI4XV0sIFsncGknLCBbOTYwXV0sIFsncGl0Y2hmb3JrJywgWzg5MTZdXSwgWydwaXYnLCBbOTgyXV0sIFsncGxhbmNrJywgWzg0NjNdXSwgWydwbGFuY2toJywgWzg0NjJdXSwgWydwbGFua3YnLCBbODQ2M11dLCBbJ3BsdXNhY2lyJywgWzEwNzg3XV0sIFsncGx1c2InLCBbODg2Ml1dLCBbJ3BsdXNjaXInLCBbMTA3ODZdXSwgWydwbHVzJywgWzQzXV0sIFsncGx1c2RvJywgWzg3MjRdXSwgWydwbHVzZHUnLCBbMTA3ODldXSwgWydwbHVzZScsIFsxMDg2Nl1dLCBbJ1BsdXNNaW51cycsIFsxNzddXSwgWydwbHVzbW4nLCBbMTc3XV0sIFsncGx1c3NpbScsIFsxMDc5MF1dLCBbJ3BsdXN0d28nLCBbMTA3OTFdXSwgWydwbScsIFsxNzddXSwgWydQb2luY2FyZXBsYW5lJywgWzg0NjBdXSwgWydwb2ludGludCcsIFsxMDc3M11dLCBbJ3BvcGYnLCBbMTIwMTYxXV0sIFsnUG9wZicsIFs4NDczXV0sIFsncG91bmQnLCBbMTYzXV0sIFsncHJhcCcsIFsxMDkzNV1dLCBbJ1ByJywgWzEwOTM5XV0sIFsncHInLCBbODgyNl1dLCBbJ3ByY3VlJywgWzg4MjhdXSwgWydwcmVjYXBwcm94JywgWzEwOTM1XV0sIFsncHJlYycsIFs4ODI2XV0sIFsncHJlY2N1cmx5ZXEnLCBbODgyOF1dLCBbJ1ByZWNlZGVzJywgWzg4MjZdXSwgWydQcmVjZWRlc0VxdWFsJywgWzEwOTI3XV0sIFsnUHJlY2VkZXNTbGFudEVxdWFsJywgWzg4MjhdXSwgWydQcmVjZWRlc1RpbGRlJywgWzg4MzBdXSwgWydwcmVjZXEnLCBbMTA5MjddXSwgWydwcmVjbmFwcHJveCcsIFsxMDkzN11dLCBbJ3ByZWNuZXFxJywgWzEwOTMzXV0sIFsncHJlY25zaW0nLCBbODkzNl1dLCBbJ3ByZScsIFsxMDkyN11dLCBbJ3ByRScsIFsxMDkzMV1dLCBbJ3ByZWNzaW0nLCBbODgzMF1dLCBbJ3ByaW1lJywgWzgyNDJdXSwgWydQcmltZScsIFs4MjQzXV0sIFsncHJpbWVzJywgWzg0NzNdXSwgWydwcm5hcCcsIFsxMDkzN11dLCBbJ3BybkUnLCBbMTA5MzNdXSwgWydwcm5zaW0nLCBbODkzNl1dLCBbJ3Byb2QnLCBbODcxOV1dLCBbJ1Byb2R1Y3QnLCBbODcxOV1dLCBbJ3Byb2ZhbGFyJywgWzkwMDZdXSwgWydwcm9mbGluZScsIFs4OTc4XV0sIFsncHJvZnN1cmYnLCBbODk3OV1dLCBbJ3Byb3AnLCBbODczM11dLCBbJ1Byb3BvcnRpb25hbCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbicsIFs4NzU5XV0sIFsncHJvcHRvJywgWzg3MzNdXSwgWydwcnNpbScsIFs4ODMwXV0sIFsncHJ1cmVsJywgWzg4ODBdXSwgWydQc2NyJywgWzExOTk3OV1dLCBbJ3BzY3InLCBbMTIwMDA1XV0sIFsnUHNpJywgWzkzNl1dLCBbJ3BzaScsIFs5NjhdXSwgWydwdW5jc3AnLCBbODIwMF1dLCBbJ1FmcicsIFsxMjAwODRdXSwgWydxZnInLCBbMTIwMTEwXV0sIFsncWludCcsIFsxMDc2NF1dLCBbJ3FvcGYnLCBbMTIwMTYyXV0sIFsnUW9wZicsIFs4NDc0XV0sIFsncXByaW1lJywgWzgyNzldXSwgWydRc2NyJywgWzExOTk4MF1dLCBbJ3FzY3InLCBbMTIwMDA2XV0sIFsncXVhdGVybmlvbnMnLCBbODQ2MV1dLCBbJ3F1YXRpbnQnLCBbMTA3NzRdXSwgWydxdWVzdCcsIFs2M11dLCBbJ3F1ZXN0ZXEnLCBbODc5OV1dLCBbJ3F1b3QnLCBbMzRdXSwgWydRVU9UJywgWzM0XV0sIFsnckFhcnInLCBbODY2N11dLCBbJ3JhY2UnLCBbODc2NSwgODE3XV0sIFsnUmFjdXRlJywgWzM0MF1dLCBbJ3JhY3V0ZScsIFszNDFdXSwgWydyYWRpYycsIFs4NzMwXV0sIFsncmFlbXB0eXYnLCBbMTA2NzVdXSwgWydyYW5nJywgWzEwMjE3XV0sIFsnUmFuZycsIFsxMDIxOV1dLCBbJ3JhbmdkJywgWzEwNjQyXV0sIFsncmFuZ2UnLCBbMTA2NjFdXSwgWydyYW5nbGUnLCBbMTAyMTddXSwgWydyYXF1bycsIFsxODddXSwgWydyYXJyYXAnLCBbMTA2MTNdXSwgWydyYXJyYicsIFs4Njc3XV0sIFsncmFycmJmcycsIFsxMDUyOF1dLCBbJ3JhcnJjJywgWzEwNTQ3XV0sIFsncmFycicsIFs4NTk0XV0sIFsnUmFycicsIFs4NjA4XV0sIFsnckFycicsIFs4NjU4XV0sIFsncmFycmZzJywgWzEwNTI2XV0sIFsncmFycmhrJywgWzg2MThdXSwgWydyYXJybHAnLCBbODYyMF1dLCBbJ3JhcnJwbCcsIFsxMDU2NV1dLCBbJ3JhcnJzaW0nLCBbMTA2MTJdXSwgWydSYXJydGwnLCBbMTA1MThdXSwgWydyYXJydGwnLCBbODYxMV1dLCBbJ3JhcnJ3JywgWzg2MDVdXSwgWydyYXRhaWwnLCBbMTA1MjJdXSwgWydyQXRhaWwnLCBbMTA1MjRdXSwgWydyYXRpbycsIFs4NzU4XV0sIFsncmF0aW9uYWxzJywgWzg0NzRdXSwgWydyYmFycicsIFsxMDUwOV1dLCBbJ3JCYXJyJywgWzEwNTExXV0sIFsnUkJhcnInLCBbMTA1MTJdXSwgWydyYmJyaycsIFsxMDA5OV1dLCBbJ3JicmFjZScsIFsxMjVdXSwgWydyYnJhY2snLCBbOTNdXSwgWydyYnJrZScsIFsxMDYzNl1dLCBbJ3JicmtzbGQnLCBbMTA2MzhdXSwgWydyYnJrc2x1JywgWzEwNjQwXV0sIFsnUmNhcm9uJywgWzM0NF1dLCBbJ3JjYXJvbicsIFszNDVdXSwgWydSY2VkaWwnLCBbMzQyXV0sIFsncmNlZGlsJywgWzM0M11dLCBbJ3JjZWlsJywgWzg5NjldXSwgWydyY3ViJywgWzEyNV1dLCBbJ1JjeScsIFsxMDU2XV0sIFsncmN5JywgWzEwODhdXSwgWydyZGNhJywgWzEwNTUxXV0sIFsncmRsZGhhcicsIFsxMDYwMV1dLCBbJ3JkcXVvJywgWzgyMjFdXSwgWydyZHF1b3InLCBbODIyMV1dLCBbJ0Nsb3NlQ3VybHlEb3VibGVRdW90ZScsIFs4MjIxXV0sIFsncmRzaCcsIFs4NjI3XV0sIFsncmVhbCcsIFs4NDc2XV0sIFsncmVhbGluZScsIFs4NDc1XV0sIFsncmVhbHBhcnQnLCBbODQ3Nl1dLCBbJ3JlYWxzJywgWzg0NzddXSwgWydSZScsIFs4NDc2XV0sIFsncmVjdCcsIFs5NjQ1XV0sIFsncmVnJywgWzE3NF1dLCBbJ1JFRycsIFsxNzRdXSwgWydSZXZlcnNlRWxlbWVudCcsIFs4NzE1XV0sIFsnUmV2ZXJzZUVxdWlsaWJyaXVtJywgWzg2NTFdXSwgWydSZXZlcnNlVXBFcXVpbGlicml1bScsIFsxMDYwN11dLCBbJ3JmaXNodCcsIFsxMDYyMV1dLCBbJ3JmbG9vcicsIFs4OTcxXV0sIFsncmZyJywgWzEyMDExMV1dLCBbJ1JmcicsIFs4NDc2XV0sIFsnckhhcicsIFsxMDU5Nl1dLCBbJ3JoYXJkJywgWzg2NDFdXSwgWydyaGFydScsIFs4NjQwXV0sIFsncmhhcnVsJywgWzEwNjA0XV0sIFsnUmhvJywgWzkyOV1dLCBbJ3JobycsIFs5NjFdXSwgWydyaG92JywgWzEwMDldXSwgWydSaWdodEFuZ2xlQnJhY2tldCcsIFsxMDIxN11dLCBbJ1JpZ2h0QXJyb3dCYXInLCBbODY3N11dLCBbJ3JpZ2h0YXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0YXJyb3cnLCBbODY1OF1dLCBbJ1JpZ2h0QXJyb3dMZWZ0QXJyb3cnLCBbODY0NF1dLCBbJ3JpZ2h0YXJyb3d0YWlsJywgWzg2MTFdXSwgWydSaWdodENlaWxpbmcnLCBbODk2OV1dLCBbJ1JpZ2h0RG91YmxlQnJhY2tldCcsIFsxMDIxNV1dLCBbJ1JpZ2h0RG93blRlZVZlY3RvcicsIFsxMDU4OV1dLCBbJ1JpZ2h0RG93blZlY3RvckJhcicsIFsxMDU4MV1dLCBbJ1JpZ2h0RG93blZlY3RvcicsIFs4NjQyXV0sIFsnUmlnaHRGbG9vcicsIFs4OTcxXV0sIFsncmlnaHRoYXJwb29uZG93bicsIFs4NjQxXV0sIFsncmlnaHRoYXJwb29udXAnLCBbODY0MF1dLCBbJ3JpZ2h0bGVmdGFycm93cycsIFs4NjQ0XV0sIFsncmlnaHRsZWZ0aGFycG9vbnMnLCBbODY1Ml1dLCBbJ3JpZ2h0cmlnaHRhcnJvd3MnLCBbODY0OV1dLCBbJ3JpZ2h0c3F1aWdhcnJvdycsIFs4NjA1XV0sIFsnUmlnaHRUZWVBcnJvdycsIFs4NjE0XV0sIFsnUmlnaHRUZWUnLCBbODg2Nl1dLCBbJ1JpZ2h0VGVlVmVjdG9yJywgWzEwNTg3XV0sIFsncmlnaHR0aHJlZXRpbWVzJywgWzg5MDhdXSwgWydSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0XV0sIFsnUmlnaHRUcmlhbmdsZScsIFs4ODgzXV0sIFsnUmlnaHRUcmlhbmdsZUVxdWFsJywgWzg4ODVdXSwgWydSaWdodFVwRG93blZlY3RvcicsIFsxMDU3NV1dLCBbJ1JpZ2h0VXBUZWVWZWN0b3InLCBbMTA1ODhdXSwgWydSaWdodFVwVmVjdG9yQmFyJywgWzEwNTgwXV0sIFsnUmlnaHRVcFZlY3RvcicsIFs4NjM4XV0sIFsnUmlnaHRWZWN0b3JCYXInLCBbMTA1NzldXSwgWydSaWdodFZlY3RvcicsIFs4NjQwXV0sIFsncmluZycsIFs3MzBdXSwgWydyaXNpbmdkb3RzZXEnLCBbODc4N11dLCBbJ3JsYXJyJywgWzg2NDRdXSwgWydybGhhcicsIFs4NjUyXV0sIFsncmxtJywgWzgyMDddXSwgWydybW91c3RhY2hlJywgWzkxMzddXSwgWydybW91c3QnLCBbOTEzN11dLCBbJ3JubWlkJywgWzEwOTkwXV0sIFsncm9hbmcnLCBbMTAyMjFdXSwgWydyb2FycicsIFs4NzAyXV0sIFsncm9icmsnLCBbMTAyMTVdXSwgWydyb3BhcicsIFsxMDYzMF1dLCBbJ3JvcGYnLCBbMTIwMTYzXV0sIFsnUm9wZicsIFs4NDc3XV0sIFsncm9wbHVzJywgWzEwNzk4XV0sIFsncm90aW1lcycsIFsxMDgwNV1dLCBbJ1JvdW5kSW1wbGllcycsIFsxMDYwOF1dLCBbJ3JwYXInLCBbNDFdXSwgWydycGFyZ3QnLCBbMTA2NDRdXSwgWydycHBvbGludCcsIFsxMDc3MF1dLCBbJ3JyYXJyJywgWzg2NDldXSwgWydScmlnaHRhcnJvdycsIFs4NjY3XV0sIFsncnNhcXVvJywgWzgyNTBdXSwgWydyc2NyJywgWzEyMDAwN11dLCBbJ1JzY3InLCBbODQ3NV1dLCBbJ3JzaCcsIFs4NjI1XV0sIFsnUnNoJywgWzg2MjVdXSwgWydyc3FiJywgWzkzXV0sIFsncnNxdW8nLCBbODIxN11dLCBbJ3JzcXVvcicsIFs4MjE3XV0sIFsnQ2xvc2VDdXJseVF1b3RlJywgWzgyMTddXSwgWydydGhyZWUnLCBbODkwOF1dLCBbJ3J0aW1lcycsIFs4OTA2XV0sIFsncnRyaScsIFs5NjU3XV0sIFsncnRyaWUnLCBbODg4NV1dLCBbJ3J0cmlmJywgWzk2NTZdXSwgWydydHJpbHRyaScsIFsxMDcwMl1dLCBbJ1J1bGVEZWxheWVkJywgWzEwNzQwXV0sIFsncnVsdWhhcicsIFsxMDYwMF1dLCBbJ3J4JywgWzg0NzhdXSwgWydTYWN1dGUnLCBbMzQ2XV0sIFsnc2FjdXRlJywgWzM0N11dLCBbJ3NicXVvJywgWzgyMThdXSwgWydzY2FwJywgWzEwOTM2XV0sIFsnU2Nhcm9uJywgWzM1Ml1dLCBbJ3NjYXJvbicsIFszNTNdXSwgWydTYycsIFsxMDk0MF1dLCBbJ3NjJywgWzg4MjddXSwgWydzY2N1ZScsIFs4ODI5XV0sIFsnc2NlJywgWzEwOTI4XV0sIFsnc2NFJywgWzEwOTMyXV0sIFsnU2NlZGlsJywgWzM1MF1dLCBbJ3NjZWRpbCcsIFszNTFdXSwgWydTY2lyYycsIFszNDhdXSwgWydzY2lyYycsIFszNDldXSwgWydzY25hcCcsIFsxMDkzOF1dLCBbJ3NjbkUnLCBbMTA5MzRdXSwgWydzY25zaW0nLCBbODkzN11dLCBbJ3NjcG9saW50JywgWzEwNzcxXV0sIFsnc2NzaW0nLCBbODgzMV1dLCBbJ1NjeScsIFsxMDU3XV0sIFsnc2N5JywgWzEwODldXSwgWydzZG90YicsIFs4ODY1XV0sIFsnc2RvdCcsIFs4OTAxXV0sIFsnc2RvdGUnLCBbMTA4NTRdXSwgWydzZWFyaGsnLCBbMTA1MzNdXSwgWydzZWFycicsIFs4NjAwXV0sIFsnc2VBcnInLCBbODY2NF1dLCBbJ3NlYXJyb3cnLCBbODYwMF1dLCBbJ3NlY3QnLCBbMTY3XV0sIFsnc2VtaScsIFs1OV1dLCBbJ3Nlc3dhcicsIFsxMDUzN11dLCBbJ3NldG1pbnVzJywgWzg3MjZdXSwgWydzZXRtbicsIFs4NzI2XV0sIFsnc2V4dCcsIFsxMDAzOF1dLCBbJ1NmcicsIFsxMjAwODZdXSwgWydzZnInLCBbMTIwMTEyXV0sIFsnc2Zyb3duJywgWzg5OTRdXSwgWydzaGFycCcsIFs5ODM5XV0sIFsnU0hDSGN5JywgWzEwNjVdXSwgWydzaGNoY3knLCBbMTA5N11dLCBbJ1NIY3knLCBbMTA2NF1dLCBbJ3NoY3knLCBbMTA5Nl1dLCBbJ1Nob3J0RG93bkFycm93JywgWzg1OTVdXSwgWydTaG9ydExlZnRBcnJvdycsIFs4NTkyXV0sIFsnc2hvcnRtaWQnLCBbODczOV1dLCBbJ3Nob3J0cGFyYWxsZWwnLCBbODc0MV1dLCBbJ1Nob3J0UmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnU2hvcnRVcEFycm93JywgWzg1OTNdXSwgWydzaHknLCBbMTczXV0sIFsnU2lnbWEnLCBbOTMxXV0sIFsnc2lnbWEnLCBbOTYzXV0sIFsnc2lnbWFmJywgWzk2Ml1dLCBbJ3NpZ21hdicsIFs5NjJdXSwgWydzaW0nLCBbODc2NF1dLCBbJ3NpbWRvdCcsIFsxMDg1OF1dLCBbJ3NpbWUnLCBbODc3MV1dLCBbJ3NpbWVxJywgWzg3NzFdXSwgWydzaW1nJywgWzEwOTEwXV0sIFsnc2ltZ0UnLCBbMTA5MTJdXSwgWydzaW1sJywgWzEwOTA5XV0sIFsnc2ltbEUnLCBbMTA5MTFdXSwgWydzaW1uZScsIFs4Nzc0XV0sIFsnc2ltcGx1cycsIFsxMDc4OF1dLCBbJ3NpbXJhcnInLCBbMTA2MTBdXSwgWydzbGFycicsIFs4NTkyXV0sIFsnU21hbGxDaXJjbGUnLCBbODcyOF1dLCBbJ3NtYWxsc2V0bWludXMnLCBbODcyNl1dLCBbJ3NtYXNocCcsIFsxMDgwM11dLCBbJ3NtZXBhcnNsJywgWzEwNzI0XV0sIFsnc21pZCcsIFs4NzM5XV0sIFsnc21pbGUnLCBbODk5NV1dLCBbJ3NtdCcsIFsxMDkyMl1dLCBbJ3NtdGUnLCBbMTA5MjRdXSwgWydzbXRlcycsIFsxMDkyNCwgNjUwMjRdXSwgWydTT0ZUY3knLCBbMTA2OF1dLCBbJ3NvZnRjeScsIFsxMTAwXV0sIFsnc29sYmFyJywgWzkwMjNdXSwgWydzb2xiJywgWzEwNjkyXV0sIFsnc29sJywgWzQ3XV0sIFsnU29wZicsIFsxMjAxMzhdXSwgWydzb3BmJywgWzEyMDE2NF1dLCBbJ3NwYWRlcycsIFs5ODI0XV0sIFsnc3BhZGVzdWl0JywgWzk4MjRdXSwgWydzcGFyJywgWzg3NDFdXSwgWydzcWNhcCcsIFs4ODUxXV0sIFsnc3FjYXBzJywgWzg4NTEsIDY1MDI0XV0sIFsnc3FjdXAnLCBbODg1Ml1dLCBbJ3NxY3VwcycsIFs4ODUyLCA2NTAyNF1dLCBbJ1NxcnQnLCBbODczMF1dLCBbJ3Nxc3ViJywgWzg4NDddXSwgWydzcXN1YmUnLCBbODg0OV1dLCBbJ3Nxc3Vic2V0JywgWzg4NDddXSwgWydzcXN1YnNldGVxJywgWzg4NDldXSwgWydzcXN1cCcsIFs4ODQ4XV0sIFsnc3FzdXBlJywgWzg4NTBdXSwgWydzcXN1cHNldCcsIFs4ODQ4XV0sIFsnc3FzdXBzZXRlcScsIFs4ODUwXV0sIFsnc3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZUludGVyc2VjdGlvbicsIFs4ODUxXV0sIFsnU3F1YXJlU3Vic2V0JywgWzg4NDddXSwgWydTcXVhcmVTdWJzZXRFcXVhbCcsIFs4ODQ5XV0sIFsnU3F1YXJlU3VwZXJzZXQnLCBbODg0OF1dLCBbJ1NxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODg1MF1dLCBbJ1NxdWFyZVVuaW9uJywgWzg4NTJdXSwgWydzcXVhcmYnLCBbOTY0Ml1dLCBbJ3NxdScsIFs5NjMzXV0sIFsnc3F1ZicsIFs5NjQyXV0sIFsnc3JhcnInLCBbODU5NF1dLCBbJ1NzY3InLCBbMTE5OTgyXV0sIFsnc3NjcicsIFsxMjAwMDhdXSwgWydzc2V0bW4nLCBbODcyNl1dLCBbJ3NzbWlsZScsIFs4OTk1XV0sIFsnc3N0YXJmJywgWzg5MDJdXSwgWydTdGFyJywgWzg5MDJdXSwgWydzdGFyJywgWzk3MzRdXSwgWydzdGFyZicsIFs5NzMzXV0sIFsnc3RyYWlnaHRlcHNpbG9uJywgWzEwMTNdXSwgWydzdHJhaWdodHBoaScsIFs5ODFdXSwgWydzdHJucycsIFsxNzVdXSwgWydzdWInLCBbODgzNF1dLCBbJ1N1YicsIFs4OTEyXV0sIFsnc3ViZG90JywgWzEwOTQxXV0sIFsnc3ViRScsIFsxMDk0OV1dLCBbJ3N1YmUnLCBbODgzOF1dLCBbJ3N1YmVkb3QnLCBbMTA5NDddXSwgWydzdWJtdWx0JywgWzEwOTQ1XV0sIFsnc3VibkUnLCBbMTA5NTVdXSwgWydzdWJuZScsIFs4ODQyXV0sIFsnc3VicGx1cycsIFsxMDk0M11dLCBbJ3N1YnJhcnInLCBbMTA2MTddXSwgWydzdWJzZXQnLCBbODgzNF1dLCBbJ1N1YnNldCcsIFs4OTEyXV0sIFsnc3Vic2V0ZXEnLCBbODgzOF1dLCBbJ3N1YnNldGVxcScsIFsxMDk0OV1dLCBbJ1N1YnNldEVxdWFsJywgWzg4MzhdXSwgWydzdWJzZXRuZXEnLCBbODg0Ml1dLCBbJ3N1YnNldG5lcXEnLCBbMTA5NTVdXSwgWydzdWJzaW0nLCBbMTA5NTFdXSwgWydzdWJzdWInLCBbMTA5NjVdXSwgWydzdWJzdXAnLCBbMTA5NjNdXSwgWydzdWNjYXBwcm94JywgWzEwOTM2XV0sIFsnc3VjYycsIFs4ODI3XV0sIFsnc3VjY2N1cmx5ZXEnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzJywgWzg4MjddXSwgWydTdWNjZWVkc0VxdWFsJywgWzEwOTI4XV0sIFsnU3VjY2VlZHNTbGFudEVxdWFsJywgWzg4MjldXSwgWydTdWNjZWVkc1RpbGRlJywgWzg4MzFdXSwgWydzdWNjZXEnLCBbMTA5MjhdXSwgWydzdWNjbmFwcHJveCcsIFsxMDkzOF1dLCBbJ3N1Y2NuZXFxJywgWzEwOTM0XV0sIFsnc3VjY25zaW0nLCBbODkzN11dLCBbJ3N1Y2NzaW0nLCBbODgzMV1dLCBbJ1N1Y2hUaGF0JywgWzg3MTVdXSwgWydzdW0nLCBbODcyMV1dLCBbJ1N1bScsIFs4NzIxXV0sIFsnc3VuZycsIFs5ODM0XV0sIFsnc3VwMScsIFsxODVdXSwgWydzdXAyJywgWzE3OF1dLCBbJ3N1cDMnLCBbMTc5XV0sIFsnc3VwJywgWzg4MzVdXSwgWydTdXAnLCBbODkxM11dLCBbJ3N1cGRvdCcsIFsxMDk0Ml1dLCBbJ3N1cGRzdWInLCBbMTA5NjhdXSwgWydzdXBFJywgWzEwOTUwXV0sIFsnc3VwZScsIFs4ODM5XV0sIFsnc3VwZWRvdCcsIFsxMDk0OF1dLCBbJ1N1cGVyc2V0JywgWzg4MzVdXSwgWydTdXBlcnNldEVxdWFsJywgWzg4MzldXSwgWydzdXBoc29sJywgWzEwMTg1XV0sIFsnc3VwaHN1YicsIFsxMDk2N11dLCBbJ3N1cGxhcnInLCBbMTA2MTldXSwgWydzdXBtdWx0JywgWzEwOTQ2XV0sIFsnc3VwbkUnLCBbMTA5NTZdXSwgWydzdXBuZScsIFs4ODQzXV0sIFsnc3VwcGx1cycsIFsxMDk0NF1dLCBbJ3N1cHNldCcsIFs4ODM1XV0sIFsnU3Vwc2V0JywgWzg5MTNdXSwgWydzdXBzZXRlcScsIFs4ODM5XV0sIFsnc3Vwc2V0ZXFxJywgWzEwOTUwXV0sIFsnc3Vwc2V0bmVxJywgWzg4NDNdXSwgWydzdXBzZXRuZXFxJywgWzEwOTU2XV0sIFsnc3Vwc2ltJywgWzEwOTUyXV0sIFsnc3Vwc3ViJywgWzEwOTY0XV0sIFsnc3Vwc3VwJywgWzEwOTY2XV0sIFsnc3dhcmhrJywgWzEwNTM0XV0sIFsnc3dhcnInLCBbODYwMV1dLCBbJ3N3QXJyJywgWzg2NjVdXSwgWydzd2Fycm93JywgWzg2MDFdXSwgWydzd253YXInLCBbMTA1MzhdXSwgWydzemxpZycsIFsyMjNdXSwgWydUYWInLCBbOV1dLCBbJ3RhcmdldCcsIFs4OTgyXV0sIFsnVGF1JywgWzkzMl1dLCBbJ3RhdScsIFs5NjRdXSwgWyd0YnJrJywgWzkxNDBdXSwgWydUY2Fyb24nLCBbMzU2XV0sIFsndGNhcm9uJywgWzM1N11dLCBbJ1RjZWRpbCcsIFszNTRdXSwgWyd0Y2VkaWwnLCBbMzU1XV0sIFsnVGN5JywgWzEwNThdXSwgWyd0Y3knLCBbMTA5MF1dLCBbJ3Rkb3QnLCBbODQxMV1dLCBbJ3RlbHJlYycsIFs4OTgxXV0sIFsnVGZyJywgWzEyMDA4N11dLCBbJ3RmcicsIFsxMjAxMTNdXSwgWyd0aGVyZTQnLCBbODc1Nl1dLCBbJ3RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGV0YScsIFs5MjBdXSwgWyd0aGV0YScsIFs5NTJdXSwgWyd0aGV0YXN5bScsIFs5NzddXSwgWyd0aGV0YXYnLCBbOTc3XV0sIFsndGhpY2thcHByb3gnLCBbODc3Nl1dLCBbJ3RoaWNrc2ltJywgWzg3NjRdXSwgWydUaGlja1NwYWNlJywgWzgyODcsIDgyMDJdXSwgWydUaGluU3BhY2UnLCBbODIwMV1dLCBbJ3RoaW5zcCcsIFs4MjAxXV0sIFsndGhrYXAnLCBbODc3Nl1dLCBbJ3Roa3NpbScsIFs4NzY0XV0sIFsnVEhPUk4nLCBbMjIyXV0sIFsndGhvcm4nLCBbMjU0XV0sIFsndGlsZGUnLCBbNzMyXV0sIFsnVGlsZGUnLCBbODc2NF1dLCBbJ1RpbGRlRXF1YWwnLCBbODc3MV1dLCBbJ1RpbGRlRnVsbEVxdWFsJywgWzg3NzNdXSwgWydUaWxkZVRpbGRlJywgWzg3NzZdXSwgWyd0aW1lc2JhcicsIFsxMDgwMV1dLCBbJ3RpbWVzYicsIFs4ODY0XV0sIFsndGltZXMnLCBbMjE1XV0sIFsndGltZXNkJywgWzEwODAwXV0sIFsndGludCcsIFs4NzQ5XV0sIFsndG9lYScsIFsxMDUzNl1dLCBbJ3RvcGJvdCcsIFs5MDE0XV0sIFsndG9wY2lyJywgWzEwOTkzXV0sIFsndG9wJywgWzg4NjhdXSwgWydUb3BmJywgWzEyMDEzOV1dLCBbJ3RvcGYnLCBbMTIwMTY1XV0sIFsndG9wZm9yaycsIFsxMDk3MF1dLCBbJ3Rvc2EnLCBbMTA1MzddXSwgWyd0cHJpbWUnLCBbODI0NF1dLCBbJ3RyYWRlJywgWzg0ODJdXSwgWydUUkFERScsIFs4NDgyXV0sIFsndHJpYW5nbGUnLCBbOTY1M11dLCBbJ3RyaWFuZ2xlZG93bicsIFs5NjYzXV0sIFsndHJpYW5nbGVsZWZ0JywgWzk2NjddXSwgWyd0cmlhbmdsZWxlZnRlcScsIFs4ODg0XV0sIFsndHJpYW5nbGVxJywgWzg3OTZdXSwgWyd0cmlhbmdsZXJpZ2h0JywgWzk2NTddXSwgWyd0cmlhbmdsZXJpZ2h0ZXEnLCBbODg4NV1dLCBbJ3RyaWRvdCcsIFs5NzA4XV0sIFsndHJpZScsIFs4Nzk2XV0sIFsndHJpbWludXMnLCBbMTA4MTBdXSwgWydUcmlwbGVEb3QnLCBbODQxMV1dLCBbJ3RyaXBsdXMnLCBbMTA4MDldXSwgWyd0cmlzYicsIFsxMDcwMV1dLCBbJ3RyaXRpbWUnLCBbMTA4MTFdXSwgWyd0cnBleml1bScsIFs5MTg2XV0sIFsnVHNjcicsIFsxMTk5ODNdXSwgWyd0c2NyJywgWzEyMDAwOV1dLCBbJ1RTY3knLCBbMTA2Ml1dLCBbJ3RzY3knLCBbMTA5NF1dLCBbJ1RTSGN5JywgWzEwMzVdXSwgWyd0c2hjeScsIFsxMTE1XV0sIFsnVHN0cm9rJywgWzM1OF1dLCBbJ3RzdHJvaycsIFszNTldXSwgWyd0d2l4dCcsIFs4ODEyXV0sIFsndHdvaGVhZGxlZnRhcnJvdycsIFs4NjA2XV0sIFsndHdvaGVhZHJpZ2h0YXJyb3cnLCBbODYwOF1dLCBbJ1VhY3V0ZScsIFsyMThdXSwgWyd1YWN1dGUnLCBbMjUwXV0sIFsndWFycicsIFs4NTkzXV0sIFsnVWFycicsIFs4NjA3XV0sIFsndUFycicsIFs4NjU3XV0sIFsnVWFycm9jaXInLCBbMTA1NjldXSwgWydVYnJjeScsIFsxMDM4XV0sIFsndWJyY3knLCBbMTExOF1dLCBbJ1VicmV2ZScsIFszNjRdXSwgWyd1YnJldmUnLCBbMzY1XV0sIFsnVWNpcmMnLCBbMjE5XV0sIFsndWNpcmMnLCBbMjUxXV0sIFsnVWN5JywgWzEwNTldXSwgWyd1Y3knLCBbMTA5MV1dLCBbJ3VkYXJyJywgWzg2NDVdXSwgWydVZGJsYWMnLCBbMzY4XV0sIFsndWRibGFjJywgWzM2OV1dLCBbJ3VkaGFyJywgWzEwNjA2XV0sIFsndWZpc2h0JywgWzEwNjIyXV0sIFsnVWZyJywgWzEyMDA4OF1dLCBbJ3VmcicsIFsxMjAxMTRdXSwgWydVZ3JhdmUnLCBbMjE3XV0sIFsndWdyYXZlJywgWzI0OV1dLCBbJ3VIYXInLCBbMTA1OTVdXSwgWyd1aGFybCcsIFs4NjM5XV0sIFsndWhhcnInLCBbODYzOF1dLCBbJ3VoYmxrJywgWzk2MDBdXSwgWyd1bGNvcm4nLCBbODk4OF1dLCBbJ3VsY29ybmVyJywgWzg5ODhdXSwgWyd1bGNyb3AnLCBbODk3NV1dLCBbJ3VsdHJpJywgWzk3MjBdXSwgWydVbWFjcicsIFszNjJdXSwgWyd1bWFjcicsIFszNjNdXSwgWyd1bWwnLCBbMTY4XV0sIFsnVW5kZXJCYXInLCBbOTVdXSwgWydVbmRlckJyYWNlJywgWzkxODNdXSwgWydVbmRlckJyYWNrZXQnLCBbOTE0MV1dLCBbJ1VuZGVyUGFyZW50aGVzaXMnLCBbOTE4MV1dLCBbJ1VuaW9uJywgWzg4OTldXSwgWydVbmlvblBsdXMnLCBbODg0Nl1dLCBbJ1VvZ29uJywgWzM3MF1dLCBbJ3VvZ29uJywgWzM3MV1dLCBbJ1VvcGYnLCBbMTIwMTQwXV0sIFsndW9wZicsIFsxMjAxNjZdXSwgWydVcEFycm93QmFyJywgWzEwNTE0XV0sIFsndXBhcnJvdycsIFs4NTkzXV0sIFsnVXBBcnJvdycsIFs4NTkzXV0sIFsnVXBhcnJvdycsIFs4NjU3XV0sIFsnVXBBcnJvd0Rvd25BcnJvdycsIFs4NjQ1XV0sIFsndXBkb3duYXJyb3cnLCBbODU5N11dLCBbJ1VwRG93bkFycm93JywgWzg1OTddXSwgWydVcGRvd25hcnJvdycsIFs4NjYxXV0sIFsnVXBFcXVpbGlicml1bScsIFsxMDYwNl1dLCBbJ3VwaGFycG9vbmxlZnQnLCBbODYzOV1dLCBbJ3VwaGFycG9vbnJpZ2h0JywgWzg2MzhdXSwgWyd1cGx1cycsIFs4ODQ2XV0sIFsnVXBwZXJMZWZ0QXJyb3cnLCBbODU5OF1dLCBbJ1VwcGVyUmlnaHRBcnJvdycsIFs4NTk5XV0sIFsndXBzaScsIFs5NjVdXSwgWydVcHNpJywgWzk3OF1dLCBbJ3Vwc2loJywgWzk3OF1dLCBbJ1Vwc2lsb24nLCBbOTMzXV0sIFsndXBzaWxvbicsIFs5NjVdXSwgWydVcFRlZUFycm93JywgWzg2MTNdXSwgWydVcFRlZScsIFs4ODY5XV0sIFsndXB1cGFycm93cycsIFs4NjQ4XV0sIFsndXJjb3JuJywgWzg5ODldXSwgWyd1cmNvcm5lcicsIFs4OTg5XV0sIFsndXJjcm9wJywgWzg5NzRdXSwgWydVcmluZycsIFszNjZdXSwgWyd1cmluZycsIFszNjddXSwgWyd1cnRyaScsIFs5NzIxXV0sIFsnVXNjcicsIFsxMTk5ODRdXSwgWyd1c2NyJywgWzEyMDAxMF1dLCBbJ3V0ZG90JywgWzg5NDRdXSwgWydVdGlsZGUnLCBbMzYwXV0sIFsndXRpbGRlJywgWzM2MV1dLCBbJ3V0cmknLCBbOTY1M11dLCBbJ3V0cmlmJywgWzk2NTJdXSwgWyd1dWFycicsIFs4NjQ4XV0sIFsnVXVtbCcsIFsyMjBdXSwgWyd1dW1sJywgWzI1Ml1dLCBbJ3V3YW5nbGUnLCBbMTA2NjNdXSwgWyd2YW5ncnQnLCBbMTA2NTJdXSwgWyd2YXJlcHNpbG9uJywgWzEwMTNdXSwgWyd2YXJrYXBwYScsIFsxMDA4XV0sIFsndmFybm90aGluZycsIFs4NzA5XV0sIFsndmFycGhpJywgWzk4MV1dLCBbJ3ZhcnBpJywgWzk4Ml1dLCBbJ3ZhcnByb3B0bycsIFs4NzMzXV0sIFsndmFycicsIFs4NTk3XV0sIFsndkFycicsIFs4NjYxXV0sIFsndmFycmhvJywgWzEwMDldXSwgWyd2YXJzaWdtYScsIFs5NjJdXSwgWyd2YXJzdWJzZXRuZXEnLCBbODg0MiwgNjUwMjRdXSwgWyd2YXJzdWJzZXRuZXFxJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcScsIFs4ODQzLCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcXEnLCBbMTA5NTYsIDY1MDI0XV0sIFsndmFydGhldGEnLCBbOTc3XV0sIFsndmFydHJpYW5nbGVsZWZ0JywgWzg4ODJdXSwgWyd2YXJ0cmlhbmdsZXJpZ2h0JywgWzg4ODNdXSwgWyd2QmFyJywgWzEwOTg0XV0sIFsnVmJhcicsIFsxMDk4N11dLCBbJ3ZCYXJ2JywgWzEwOTg1XV0sIFsnVmN5JywgWzEwNDJdXSwgWyd2Y3knLCBbMTA3NF1dLCBbJ3ZkYXNoJywgWzg4NjZdXSwgWyd2RGFzaCcsIFs4ODcyXV0sIFsnVmRhc2gnLCBbODg3M11dLCBbJ1ZEYXNoJywgWzg4NzVdXSwgWydWZGFzaGwnLCBbMTA5ODJdXSwgWyd2ZWViYXInLCBbODg5MV1dLCBbJ3ZlZScsIFs4NzQ0XV0sIFsnVmVlJywgWzg4OTddXSwgWyd2ZWVlcScsIFs4Nzk0XV0sIFsndmVsbGlwJywgWzg5NDJdXSwgWyd2ZXJiYXInLCBbMTI0XV0sIFsnVmVyYmFyJywgWzgyMTRdXSwgWyd2ZXJ0JywgWzEyNF1dLCBbJ1ZlcnQnLCBbODIxNF1dLCBbJ1ZlcnRpY2FsQmFyJywgWzg3MzldXSwgWydWZXJ0aWNhbExpbmUnLCBbMTI0XV0sIFsnVmVydGljYWxTZXBhcmF0b3InLCBbMTAwNzJdXSwgWydWZXJ0aWNhbFRpbGRlJywgWzg3NjhdXSwgWydWZXJ5VGhpblNwYWNlJywgWzgyMDJdXSwgWydWZnInLCBbMTIwMDg5XV0sIFsndmZyJywgWzEyMDExNV1dLCBbJ3ZsdHJpJywgWzg4ODJdXSwgWyd2bnN1YicsIFs4ODM0LCA4NDAyXV0sIFsndm5zdXAnLCBbODgzNSwgODQwMl1dLCBbJ1ZvcGYnLCBbMTIwMTQxXV0sIFsndm9wZicsIFsxMjAxNjddXSwgWyd2cHJvcCcsIFs4NzMzXV0sIFsndnJ0cmknLCBbODg4M11dLCBbJ1ZzY3InLCBbMTE5OTg1XV0sIFsndnNjcicsIFsxMjAwMTFdXSwgWyd2c3VibkUnLCBbMTA5NTUsIDY1MDI0XV0sIFsndnN1Ym5lJywgWzg4NDIsIDY1MDI0XV0sIFsndnN1cG5FJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZzdXBuZScsIFs4ODQzLCA2NTAyNF1dLCBbJ1Z2ZGFzaCcsIFs4ODc0XV0sIFsndnppZ3phZycsIFsxMDY1MF1dLCBbJ1djaXJjJywgWzM3Ml1dLCBbJ3djaXJjJywgWzM3M11dLCBbJ3dlZGJhcicsIFsxMDg0N11dLCBbJ3dlZGdlJywgWzg3NDNdXSwgWydXZWRnZScsIFs4ODk2XV0sIFsnd2VkZ2VxJywgWzg3OTNdXSwgWyd3ZWllcnAnLCBbODQ3Ml1dLCBbJ1dmcicsIFsxMjAwOTBdXSwgWyd3ZnInLCBbMTIwMTE2XV0sIFsnV29wZicsIFsxMjAxNDJdXSwgWyd3b3BmJywgWzEyMDE2OF1dLCBbJ3dwJywgWzg0NzJdXSwgWyd3cicsIFs4NzY4XV0sIFsnd3JlYXRoJywgWzg3NjhdXSwgWydXc2NyJywgWzExOTk4Nl1dLCBbJ3dzY3InLCBbMTIwMDEyXV0sIFsneGNhcCcsIFs4ODk4XV0sIFsneGNpcmMnLCBbOTcxMV1dLCBbJ3hjdXAnLCBbODg5OV1dLCBbJ3hkdHJpJywgWzk2NjFdXSwgWydYZnInLCBbMTIwMDkxXV0sIFsneGZyJywgWzEyMDExN11dLCBbJ3hoYXJyJywgWzEwMjMxXV0sIFsneGhBcnInLCBbMTAyMzRdXSwgWydYaScsIFs5MjZdXSwgWyd4aScsIFs5NThdXSwgWyd4bGFycicsIFsxMDIyOV1dLCBbJ3hsQXJyJywgWzEwMjMyXV0sIFsneG1hcCcsIFsxMDIzNl1dLCBbJ3huaXMnLCBbODk1NV1dLCBbJ3hvZG90JywgWzEwNzUyXV0sIFsnWG9wZicsIFsxMjAxNDNdXSwgWyd4b3BmJywgWzEyMDE2OV1dLCBbJ3hvcGx1cycsIFsxMDc1M11dLCBbJ3hvdGltZScsIFsxMDc1NF1dLCBbJ3hyYXJyJywgWzEwMjMwXV0sIFsneHJBcnInLCBbMTAyMzNdXSwgWydYc2NyJywgWzExOTk4N11dLCBbJ3hzY3InLCBbMTIwMDEzXV0sIFsneHNxY3VwJywgWzEwNzU4XV0sIFsneHVwbHVzJywgWzEwNzU2XV0sIFsneHV0cmknLCBbOTY1MV1dLCBbJ3h2ZWUnLCBbODg5N11dLCBbJ3h3ZWRnZScsIFs4ODk2XV0sIFsnWWFjdXRlJywgWzIyMV1dLCBbJ3lhY3V0ZScsIFsyNTNdXSwgWydZQWN5JywgWzEwNzFdXSwgWyd5YWN5JywgWzExMDNdXSwgWydZY2lyYycsIFszNzRdXSwgWyd5Y2lyYycsIFszNzVdXSwgWydZY3knLCBbMTA2N11dLCBbJ3ljeScsIFsxMDk5XV0sIFsneWVuJywgWzE2NV1dLCBbJ1lmcicsIFsxMjAwOTJdXSwgWyd5ZnInLCBbMTIwMTE4XV0sIFsnWUljeScsIFsxMDMxXV0sIFsneWljeScsIFsxMTExXV0sIFsnWW9wZicsIFsxMjAxNDRdXSwgWyd5b3BmJywgWzEyMDE3MF1dLCBbJ1lzY3InLCBbMTE5OTg4XV0sIFsneXNjcicsIFsxMjAwMTRdXSwgWydZVWN5JywgWzEwNzBdXSwgWyd5dWN5JywgWzExMDJdXSwgWyd5dW1sJywgWzI1NV1dLCBbJ1l1bWwnLCBbMzc2XV0sIFsnWmFjdXRlJywgWzM3N11dLCBbJ3phY3V0ZScsIFszNzhdXSwgWydaY2Fyb24nLCBbMzgxXV0sIFsnemNhcm9uJywgWzM4Ml1dLCBbJ1pjeScsIFsxMDQ3XV0sIFsnemN5JywgWzEwNzldXSwgWydaZG90JywgWzM3OV1dLCBbJ3pkb3QnLCBbMzgwXV0sIFsnemVldHJmJywgWzg0ODhdXSwgWydaZXJvV2lkdGhTcGFjZScsIFs4MjAzXV0sIFsnWmV0YScsIFs5MThdXSwgWyd6ZXRhJywgWzk1MF1dLCBbJ3pmcicsIFsxMjAxMTldXSwgWydaZnInLCBbODQ4OF1dLCBbJ1pIY3knLCBbMTA0Nl1dLCBbJ3poY3knLCBbMTA3OF1dLCBbJ3ppZ3JhcnInLCBbODY2OV1dLCBbJ3pvcGYnLCBbMTIwMTcxXV0sIFsnWm9wZicsIFs4NDg0XV0sIFsnWnNjcicsIFsxMTk5ODldXSwgWyd6c2NyJywgWzEyMDAxNV1dLCBbJ3p3aicsIFs4MjA1XV0sIFsnenduaicsIFs4MjA0XV1dO1xuXG52YXIgYWxwaGFJbmRleCA9IHt9O1xudmFyIGNoYXJJbmRleCA9IHt9O1xuXG5jcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEh0bWw1RW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uKHMsIGVudGl0eSkge1xuICAgICAgICB2YXIgY2hyO1xuICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLnRvTG93ZXJDYXNlKCksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG5cbiAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xuICAgICAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNoYXJJbmZvW3N0ci5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W2NdO1xuICAgICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNoYXJJbmZvW3N0ci5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrK1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYWxwaGFJbmRleCBQYXNzZWQgYnkgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtPYmplY3R9IGNoYXJJbmRleCBQYXNzZWQgYnkgcmVmZXJlbmNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCkge1xuICAgIHZhciBpID0gRU5USVRJRVMubGVuZ3RoO1xuICAgIHZhciBfcmVzdWx0cyA9IFtdO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIGUgPSBFTlRJVElFU1tpXTtcbiAgICAgICAgdmFyIGFscGhhID0gZVswXTtcbiAgICAgICAgdmFyIGNoYXJzID0gZVsxXTtcbiAgICAgICAgdmFyIGNociA9IGNoYXJzWzBdO1xuICAgICAgICB2YXIgYWRkQ2hhciA9IChjaHIgPCAzMiB8fCBjaHIgPiAxMjYpIHx8IGNociA9PT0gNjIgfHwgY2hyID09PSA2MCB8fCBjaHIgPT09IDM4IHx8IGNociA9PT0gMzQgfHwgY2hyID09PSAzOTtcbiAgICAgICAgdmFyIGNoYXJJbmZvO1xuICAgICAgICBpZiAoYWRkQ2hhcikge1xuICAgICAgICAgICAgY2hhckluZm8gPSBjaGFySW5kZXhbY2hyXSA9IGNoYXJJbmRleFtjaHJdIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyc1sxXSkge1xuICAgICAgICAgICAgdmFyIGNocjIgPSBjaGFyc1sxXTtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goYWRkQ2hhciAmJiAoY2hhckluZm9bY2hyMl0gPSBhbHBoYSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkZENoYXIgJiYgKGNoYXJJbmZvWycnXSA9IGFscGhhKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbDVFbnRpdGllcztcbiIsInZhciBBTFBIQV9JTkRFWCA9IHtcbiAgICAnJmx0JzogJzwnLFxuICAgICcmZ3QnOiAnPicsXG4gICAgJyZxdW90JzogJ1wiJyxcbiAgICAnJmFwb3MnOiAnXFwnJyxcbiAgICAnJmFtcCc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJmFwb3M7JzogJ1xcJycsXG4gICAgJyZhbXA7JzogJyYnXG59O1xuXG52YXIgQ0hBUl9JTkRFWCA9IHtcbiAgICA2MDogJ2x0JyxcbiAgICA2MjogJ2d0JyxcbiAgICAzNDogJ3F1b3QnLFxuICAgIDM5OiAnYXBvcycsXG4gICAgMzg6ICdhbXAnXG59O1xuXG52YXIgQ0hBUl9TX0lOREVYID0ge1xuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgICdcXCcnOiAnJmFwb3M7JyxcbiAgICAnJic6ICcmYW1wOydcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFhtbEVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzx8PnxcInwnfCYvZywgZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gQ0hBUl9TX0lOREVYW3NdO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIz9bMC05YS16QS1aXSs7Py9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmIChzLmNoYXJBdCgxKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHMuY2hhckF0KDIpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMyksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMikpO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQUxQSEFfSU5ERVhbc10gfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGFscGhhID0gQ0hBUl9JTkRFWFtjXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5naHQgPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5naHQpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gfTtcblxubW9kdWxlLmV4cG9ydHMgPSBYbWxFbnRpdGllcztcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIi8qXG4gKiBLb252YSBKYXZhU2NyaXB0IEZyYW1ld29yayB2Mi41LjFcbiAqIGh0dHA6Ly9rb252YWpzLmdpdGh1Yi5pby9cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVRcbiAqIERhdGU6IFRodSBOb3YgMDggMjAxOFxuICpcbiAqIE9yaWdpbmFsIHdvcmsgQ29weXJpZ2h0IChDKSAyMDExIC0gMjAxMyBieSBFcmljIFJvd2VsbCAoS2luZXRpY0pTKVxuICogTW9kaWZpZWQgd29yayBDb3B5cmlnaHQgKEMpIDIwMTQgLSBwcmVzZW50IGJ5IEFudG9uIExhdnJlbm92IChLb252YSlcbiAqXG4gKiBAbGljZW5zZVxuICovXG5cbi8vIHJ1bnRpbWUgY2hlY2sgZm9yIGFscmVhZHkgaW5jbHVkZWQgS29udmFcbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQG5hbWVzcGFjZSBLb252YVxuICAgKi9cblxuICB2YXIgUElfT1ZFUl8xODAgPSBNYXRoLlBJIC8gMTgwO1xuXG4gIHZhciBLb252YSA9IHtcbiAgICAvLyBwdWJsaWNcbiAgICB2ZXJzaW9uOiAnMi41LjEnLFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIHN0YWdlczogW10sXG4gICAgaWRDb3VudGVyOiAwLFxuICAgIGlkczoge30sXG4gICAgbmFtZXM6IHt9LFxuICAgIHNoYXBlczoge30sXG4gICAgbGlzdGVuQ2xpY2tUYXA6IGZhbHNlLFxuICAgIGluRGJsQ2xpY2tXaW5kb3c6IGZhbHNlLFxuXG4gICAgaXNCcm93c2VyOlxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIC8vIGJyb3dzZXIgY2FzZVxuICAgICAgKHt9LnRvU3RyaW5nLmNhbGwod2luZG93KSA9PT0gJ1tvYmplY3QgV2luZG93XScgfHxcbiAgICAgICAgLy8gZWxlY3Ryb24gY2FzZVxuICAgICAgICB7fS50b1N0cmluZy5jYWxsKHdpbmRvdykgPT09ICdbb2JqZWN0IGdsb2JhbF0nKSxcblxuICAgIGlzVW5taW5pZmllZDogL2NvbW1lbnQvLnRlc3QoZnVuY3Rpb24oKSB7XG4gICAgICAvKiBjb21tZW50ICovXG4gICAgfSksXG5cbiAgICAvLyBjb25maWd1cmF0aW9uc1xuICAgIGVuYWJsZVRyYWNlOiBmYWxzZSxcbiAgICB0cmFjZUFyck1heDogMTAwLFxuICAgIGRibENsaWNrV2luZG93OiA0MDAsXG4gICAgLyoqXG4gICAgICogR2xvYmFsIHBpeGVsIHJhdGlvIGNvbmZpZ3VyYXRpb24uIEtvbnZhSlMgYXV0b21hdGljYWxseSBkZXRlY3QgcGl4ZWwgcmF0aW8gb2YgY3VycmVudCBkZXZpY2UuXG4gICAgICogQnV0IHlvdSBtYXkgb3ZlcnJpZGUgc3VjaCBwcm9wZXJ0eSwgaWYgeW91IHdhbnQgdG8gdXNlIHlvdXIgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHBpeGVsUmF0aW9cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIEtvbnZhLnBpeGVsUmF0aW8gPSAxO1xuICAgICAqL1xuICAgIHBpeGVsUmF0aW86IHVuZGVmaW5lZCxcbiAgICAvKipcbiAgICAgKiBEcmFnIGRpc3RhbmNlIHByb3BlcnR5LiBJZiB5b3Ugc3RhcnQgdG8gZHJhZyBhIG5vZGUgeW91IG1heSB3YW50IHRvIHdhaXQgdW50aWwgcG9pbnRlciBpcyBtb3ZlZCB0byBzb21lIGRpc3RhbmNlIGZyb20gc3RhcnQgcG9pbnQsXG4gICAgICogb25seSB0aGVuIHN0YXJ0IGRyYWdnaW5nLiBEZWZhdWx0IGlzIDNweC5cbiAgICAgKiBAcHJvcGVydHkgZHJhZ0Rpc3RhbmNlXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogS29udmEuZHJhZ0Rpc3RhbmNlID0gMTA7XG4gICAgICovXG4gICAgZHJhZ0Rpc3RhbmNlOiAzLFxuICAgIC8qKlxuICAgICAqIFVzZSBkZWdyZWUgdmFsdWVzIGZvciBhbmdsZSBwcm9wZXJ0aWVzLiBZb3UgbWF5IHNldCB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIHVzZSByYWRpYW50IHZhbHVlcy5cbiAgICAgKiBAcHJvcGVydHkgYW5nbGVEZWdcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLnJvdGF0aW9uKDQ1KTsgLy8gNDUgZGVncmVlc1xuICAgICAqIEtvbnZhLmFuZ2xlRGVnID0gZmFsc2U7XG4gICAgICogbm9kZS5yb3RhdGlvbihNYXRoLlBJIC8gMik7IC8vIFBJLzIgcmFkaWFuXG4gICAgICovXG4gICAgYW5nbGVEZWc6IHRydWUsXG4gICAgLyoqXG4gICAgICogU2hvdyBkaWZmZXJlbnQgd2FybmluZ3MgYWJvdXQgZXJyb3JzIG9yIHdyb25nIEFQSSB1c2FnZVxuICAgICAqIEBwcm9wZXJ0eSBzaG93V2FybmluZ3NcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBLb252YS5zaG93V2FybmluZ3MgPSBmYWxzZTtcbiAgICAgKi9cbiAgICBzaG93V2FybmluZ3M6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlIEZpbHRlcnNcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKi9cbiAgICBGaWx0ZXJzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgd2hldGhlciBvciBub3QgZHJhZyBhbmQgZHJvcCBpcyBjdXJyZW50bHkgYWN0aXZlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqL1xuICAgIGlzRHJhZ2dpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRkID0gS29udmEuREQ7XG5cbiAgICAgIC8vIGlmIEREIGlzIG5vdCBpbmNsdWRlZCB3aXRoIHRoZSBidWlsZCwgdGhlblxuICAgICAgLy8gZHJhZyBhbmQgZHJvcCBpcyBub3QgZXZlbiBwb3NzaWJsZVxuICAgICAgaWYgKGRkKSB7XG4gICAgICAgIHJldHVybiBkZC5pc0RyYWdnaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIGRyYWcgYW5kIGRyb3Agb3BlcmF0aW9uIGlzIHJlYWR5LCBidXQgbWF5XG4gICAgICogIG5vdCBuZWNlc3NhcmlseSBoYXZlIHN0YXJ0ZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICovXG4gICAgaXNEcmFnUmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRkID0gS29udmEuREQ7XG5cbiAgICAgIC8vIGlmIEREIGlzIG5vdCBpbmNsdWRlZCB3aXRoIHRoZSBidWlsZCwgdGhlblxuICAgICAgLy8gZHJhZyBhbmQgZHJvcCBpcyBub3QgZXZlbiBwb3NzaWJsZVxuICAgICAgaWYgKGRkKSB7XG4gICAgICAgIHJldHVybiAhIWRkLm5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBfYWRkSWQ6IGZ1bmN0aW9uKG5vZGUsIGlkKSB7XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGRvIHdlIG5lZWQgdGhpcyB3YXJuaW5nP1xuICAgICAgLy8gaWYgKHRoaXMuaWRzW2lkXSkge1xuICAgICAgLy8gICBLb252YS5VdGlsLndhcm4oXG4gICAgICAvLyAgICAgJ0R1cGxpY2F0ZSBpZCBcIicgK1xuICAgICAgLy8gICAgICAgaWQgK1xuICAgICAgLy8gICAgICAgJ1wiLiBQbGVhc2UgZG9uIG5vdCB1c2Ugc2FtZSBpZCBzZXZlcmFsIHRpbWVzLiBJdCBtYXkgYnJlYWsgZmluZCgpIG1ldGhvZCBsb29rIHVwLidcbiAgICAgIC8vICAgKTtcbiAgICAgIC8vIH1cbiAgICAgIHRoaXMuaWRzW2lkXSA9IG5vZGU7XG4gICAgfSxcbiAgICBfcmVtb3ZlSWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5pZHNbaWRdO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FkZE5hbWU6IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5uYW1lc1tuYW1lXSkge1xuICAgICAgICAgIHRoaXMubmFtZXNbbmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWVzW25hbWVdLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfcmVtb3ZlTmFtZTogZnVuY3Rpb24obmFtZSwgX2lkKSB7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5uYW1lc1tuYW1lXTtcbiAgICAgIGlmICghbm9kZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbm8gPSBub2Rlc1tuXTtcbiAgICAgICAgaWYgKG5vLl9pZCA9PT0gX2lkKSB7XG4gICAgICAgICAgbm9kZXMuc3BsaWNlKG4sIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm5hbWVzW25hbWVdO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0QW5nbGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmdsZURlZyA/IGFuZ2xlICogUElfT1ZFUl8xODAgOiBhbmdsZTtcbiAgICB9LFxuICAgIF9kZXRlY3RJRTogZnVuY3Rpb24odWEpIHtcbiAgICAgIHZhciBtc2llID0gdWEuaW5kZXhPZignbXNpZSAnKTtcbiAgICAgIGlmIChtc2llID4gMCkge1xuICAgICAgICAvLyBJRSAxMCBvciBvbGRlciA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhtc2llICsgNSwgdWEuaW5kZXhPZignLicsIG1zaWUpKSwgMTApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJpZGVudCA9IHVhLmluZGV4T2YoJ3RyaWRlbnQvJyk7XG4gICAgICBpZiAodHJpZGVudCA+IDApIHtcbiAgICAgICAgLy8gSUUgMTEgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgIHZhciBydiA9IHVhLmluZGV4T2YoJ3J2OicpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKHJ2ICsgMywgdWEuaW5kZXhPZignLicsIHJ2KSksIDEwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2UgPSB1YS5pbmRleE9mKCdlZGdlLycpO1xuICAgICAgaWYgKGVkZ2UgPiAwKSB7XG4gICAgICAgIC8vIEVkZ2UgKElFIDEyKykgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcoZWRnZSArIDUsIHVhLmluZGV4T2YoJy4nLCBlZGdlKSksIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXIgYnJvd3NlclxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgX3BhcnNlVUE6IGZ1bmN0aW9uKHVzZXJBZ2VudCkge1xuICAgICAgdmFyIHVhID0gdXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG4gICAgICAgIC8vIGpRdWVyeSBVQSByZWdleFxuICAgICAgICBtYXRjaCA9XG4gICAgICAgICAgLyhjaHJvbWUpWyAvXShbXFx3Ll0rKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgICAvKHdlYmtpdClbIC9dKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgIC8ob3BlcmEpKD86Lip2ZXJzaW9ufClbIC9dKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgIC8obXNpZSkgKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgICh1YS5pbmRleE9mKCdjb21wYXRpYmxlJykgPCAwICYmXG4gICAgICAgICAgICAvKG1vemlsbGEpKD86Lio/IHJ2OihbXFx3Ll0rKXwpLy5leGVjKHVhKSkgfHxcbiAgICAgICAgICBbXSxcbiAgICAgICAgLy8gYWRkaW5nIG1vYmlsZSBmbGFnIGFzIHdlbGxcbiAgICAgICAgbW9iaWxlID0gISF1c2VyQWdlbnQubWF0Y2goXG4gICAgICAgICAgL0FuZHJvaWR8QmxhY2tCZXJyeXxpUGhvbmV8aVBhZHxpUG9kfE9wZXJhIE1pbml8SUVNb2JpbGUvaVxuICAgICAgICApLFxuICAgICAgICBpZU1vYmlsZSA9ICEhdXNlckFnZW50Lm1hdGNoKC9JRU1vYmlsZS9pKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnJvd3NlcjogbWF0Y2hbMV0gfHwgJycsXG4gICAgICAgIHZlcnNpb246IG1hdGNoWzJdIHx8ICcwJyxcbiAgICAgICAgaXNJRTogS29udmEuX2RldGVjdElFKHVhKSxcbiAgICAgICAgLy8gYWRkaW5nIG1vYmlsZSBmbGFiXG4gICAgICAgIG1vYmlsZTogbW9iaWxlLFxuICAgICAgICBpZU1vYmlsZTogaWVNb2JpbGUgLy8gSWYgdGhpcyBpcyB0cnVlIChpLmUuLCBXUDgpLCB0aGVuIEtvbnZhIHRvdWNoIGV2ZW50cyBhcmUgZXhlY3V0ZWQgaW5zdGVhZCBvZiBlcXVpdmFsZW50IEtvbnZhIG1vdXNlIGV2ZW50c1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIHVzZXIgYWdlbnRcbiAgICBVQTogdW5kZWZpbmVkXG4gIH07XG5cbiAgdmFyIGdsb2IgPVxuICAgIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IGdsb2JhbFxuICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICA/IHNlbGZcbiAgICAgICAgICA6IHt9O1xuXG4gIEtvbnZhLlVBID0gS29udmEuX3BhcnNlVUEoKGdsb2IubmF2aWdhdG9yICYmIGdsb2IubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgJycpO1xuXG4gIGlmIChnbG9iLktvbnZhKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgICdLb252YSBpbnN0YW5jZSBpcyBhbHJlYWR5IGV4aXN0IGluIGN1cnJlbnQgZXZpcm9tZW50LiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2Ugb25seSBvbmUgaW5zdGFuY2UuJ1xuICAgICk7XG4gIH1cbiAgZ2xvYi5Lb252YSA9IEtvbnZhO1xuICBLb252YS5nbG9iYWwgPSBnbG9iO1xuICBLb252YS53aW5kb3cgPSBnbG9iO1xuICBLb252YS5kb2N1bWVudCA9IGdsb2IuZG9jdW1lbnQ7XG5cbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gS29udmE7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBLb252YTtcbiAgICB9KTtcbiAgfVxufSkoKTtcblxuLyplc2xpbnQtZGlzYWJsZSAgZXFlcWVxLCBuby1jb25kLWFzc2lnbiwgbm8tZW1wdHkqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIGNvbnN0cnVjdG9yLiAgQ29sbGVjdGlvbiBleHRlbmRzXG4gICAqICBBcnJheS4gIFRoaXMgY2xhc3MgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHtAbGluayBLb252YS5Db250YWluZXIjZ2V0fVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqL1xuICBLb252YS5Db2xsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgIGkgPSAwO1xuXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGFyZ3NbaV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZSA9IFtdO1xuICAvKipcbiAgICogaXRlcmF0ZSB0aHJvdWdoIG5vZGUgYXJyYXkgYW5kIHJ1biBhIGZ1bmN0aW9uIGZvciBlYWNoIG5vZGUuXG4gICAqICBUaGUgbm9kZSBhbmQgaW5kZXggaXMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGFsbCBub2RlcyB3aXRoIG5hbWUgZm9vIGluc2lkZSBsYXllciwgYW5kIHNldCB4IHRvIDEwIGZvciBlYWNoXG4gICAqIGxheWVyLmdldCgnLmZvbycpLmVhY2goZnVuY3Rpb24oc2hhcGUsIG4pIHtcbiAgICogICBzaGFwZS5zZXRYKDEwKTtcbiAgICogfSk7XG4gICAqL1xuICBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oZnVuYykge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdGhpcy5sZW5ndGg7IG4rKykge1xuICAgICAgZnVuYyh0aGlzW25dLCBuKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBjb252ZXJ0IGNvbGxlY3Rpb24gaW50byBhbiBhcnJheVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZVxuICAgKi9cbiAgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcnIgPSBbXSxcbiAgICAgIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgbjtcblxuICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgYXJyLnB1c2godGhpc1tuXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH07XG4gIC8qKlxuICAgKiBjb252ZXJ0IGFycmF5IGludG8gYSBjb2xsZWN0aW9uXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkNvbGxlY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAqL1xuICBLb252YS5Db2xsZWN0aW9uLnRvQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKGFycikge1xuICAgIHZhciBjb2xsZWN0aW9uID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKSxcbiAgICAgIGxlbiA9IGFyci5sZW5ndGgsXG4gICAgICBuO1xuXG4gICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICBjb2xsZWN0aW9uLnB1c2goYXJyW25dKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG5cbiAgLy8gbWFwIG9uZSBtZXRob2QgYnkgaXQncyBuYW1lXG4gIEtvbnZhLkNvbGxlY3Rpb24uX21hcE1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgICBpO1xuXG4gICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzW2ldW21ldGhvZE5hbWVdLmFwcGx5KHRoaXNbaV0sIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9O1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyA9IGZ1bmN0aW9uKGNvbnN0cnVjdG9yKSB7XG4gICAgdmFyIHByb3QgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBwcm90KSB7XG4gICAgICBLb252YS5Db2xsZWN0aW9uLl9tYXBNZXRob2QobWV0aG9kTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAgKiBMYXN0IHVwZGF0ZWQgTm92ZW1iZXIgMjAxMVxuICAgICogQnkgU2ltb24gU2FycmlzXG4gICAgKiB3d3cuc2ltb25zYXJyaXMuY29tXG4gICAgKiBzYXJyaXNAYWNtLm9yZ1xuICAgICpcbiAgICAqIEZyZWUgdG8gdXNlIGFuZCBkaXN0cmlidXRlIGF0IHdpbGxcbiAgICAqIFNvIGxvbmcgYXMgeW91IGFyZSBuaWNlIHRvIHBlb3BsZSwgZXRjXG4gICAgKi9cblxuICAvKlxuICAgICogVGhlIHVzYWdlIG9mIHRoaXMgY2xhc3Mgd2FzIGluc3BpcmVkIGJ5IHNvbWUgb2YgdGhlIHdvcmsgZG9uZSBieSBhIGZvcmtlZFxuICAgICogcHJvamVjdCwgS2luZXRpY0pTLUV4dCBieSBXYXBwd29ya3MsIHdoaWNoIGlzIGJhc2VkIG9uIFNpbW9uJ3MgVHJhbnNmb3JtXG4gICAgKiBjbGFzcy4gIE1vZGlmaWVkIGJ5IEVyaWMgUm93ZWxsXG4gICAgKi9cblxuICAvKipcbiAgICogVHJhbnNmb3JtIGNvbnN0cnVjdG9yLiBUcmFuc2Zvcm0gb2JqZWN0IGlzIGEgcHJpdmF0ZSBjbGFzcyBvZiBLb252YSBmcmFtZXdvcmsuXG4gICAqIEluIG1vc3Qgb2YgdGhlIGNhc2VzIHlvdSBkb24ndCBuZWVkIHRvIHVzZSBpdCBpbiB5b3VyIGFwcC5cbiAgICogQnV0IHRoZXJlIGlzIGEgZG9jdW1lbnRhdGlvbiBmb3IgdGhhdCBjbGFzcyBpbiBjYXNlIHlvdSBzdGlsbCB3YW50XG4gICAqIHRvIG1ha2Ugc29tZSBtYW51YWwgY2FsY3VsYXRpb25zLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW21dIE9wdGlvbmFsIHNpeC1lbGVtZW50IG1hdHJpeFxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICovXG4gIEtvbnZhLlRyYW5zZm9ybSA9IGZ1bmN0aW9uKG0pIHtcbiAgICB0aGlzLm0gPSAobSAmJiBtLnNsaWNlKCkpIHx8IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgfTtcblxuICBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENvcHkgS29udmEuVHJhbnNmb3JtIG9iamVjdFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IEtvbnZhLlRyYW5zZm9ybSh0aGlzLm0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHBvaW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50IDJEIHBvaW50KHgsIHkpXG4gICAgICogQHJldHVybnMge09iamVjdH0gMkQgcG9pbnQoeCwgeSlcbiAgICAgKi9cbiAgICBwb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIHZhciBtID0gdGhpcy5tO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbVswXSAqIHBvaW50LnggKyBtWzJdICogcG9pbnQueSArIG1bNF0sXG4gICAgICAgIHk6IG1bMV0gKiBwb2ludC54ICsgbVszXSAqIHBvaW50LnkgKyBtWzVdXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQXBwbHkgdHJhbnNsYXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMubVs0XSArPSB0aGlzLm1bMF0gKiB4ICsgdGhpcy5tWzJdICogeTtcbiAgICAgIHRoaXMubVs1XSArPSB0aGlzLm1bMV0gKiB4ICsgdGhpcy5tWzNdICogeTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQXBwbHkgc2NhbGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3lcbiAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3kpIHtcbiAgICAgIHRoaXMubVswXSAqPSBzeDtcbiAgICAgIHRoaXMubVsxXSAqPSBzeDtcbiAgICAgIHRoaXMubVsyXSAqPSBzeTtcbiAgICAgIHRoaXMubVszXSAqPSBzeTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQXBwbHkgcm90YXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkICBBbmdsZSBpbiByYWRpYW5zXG4gICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uKHJhZCkge1xuICAgICAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgICAgdmFyIG0xMSA9IHRoaXMubVswXSAqIGMgKyB0aGlzLm1bMl0gKiBzO1xuICAgICAgdmFyIG0xMiA9IHRoaXMubVsxXSAqIGMgKyB0aGlzLm1bM10gKiBzO1xuICAgICAgdmFyIG0yMSA9IHRoaXMubVswXSAqIC1zICsgdGhpcy5tWzJdICogYztcbiAgICAgIHZhciBtMjIgPSB0aGlzLm1bMV0gKiAtcyArIHRoaXMubVszXSAqIGM7XG4gICAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgICB0aGlzLm1bMV0gPSBtMTI7XG4gICAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgICB0aGlzLm1bM10gPSBtMjI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH0gMkQgcG9pbnQoeCwgeSlcbiAgICAgKi9cbiAgICBnZXRUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLm1bNF0sXG4gICAgICAgIHk6IHRoaXMubVs1XVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFwcGx5IHNrZXdcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3lcbiAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHNrZXc6IGZ1bmN0aW9uKHN4LCBzeSkge1xuICAgICAgdmFyIG0xMSA9IHRoaXMubVswXSArIHRoaXMubVsyXSAqIHN5O1xuICAgICAgdmFyIG0xMiA9IHRoaXMubVsxXSArIHRoaXMubVszXSAqIHN5O1xuICAgICAgdmFyIG0yMSA9IHRoaXMubVsyXSArIHRoaXMubVswXSAqIHN4O1xuICAgICAgdmFyIG0yMiA9IHRoaXMubVszXSArIHRoaXMubVsxXSAqIHN4O1xuICAgICAgdGhpcy5tWzBdID0gbTExO1xuICAgICAgdGhpcy5tWzFdID0gbTEyO1xuICAgICAgdGhpcy5tWzJdID0gbTIxO1xuICAgICAgdGhpcy5tWzNdID0gbTIyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gbXVsdGlwbGljYXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0tvbnZhLlRyYW5zZm9ybX0gbWF0cml4XG4gICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICBtdWx0aXBseTogZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICB2YXIgbTExID0gdGhpcy5tWzBdICogbWF0cml4Lm1bMF0gKyB0aGlzLm1bMl0gKiBtYXRyaXgubVsxXTtcbiAgICAgIHZhciBtMTIgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVswXSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzFdO1xuXG4gICAgICB2YXIgbTIxID0gdGhpcy5tWzBdICogbWF0cml4Lm1bMl0gKyB0aGlzLm1bMl0gKiBtYXRyaXgubVszXTtcbiAgICAgIHZhciBtMjIgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVsyXSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzNdO1xuXG4gICAgICB2YXIgZHggPSB0aGlzLm1bMF0gKiBtYXRyaXgubVs0XSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzVdICsgdGhpcy5tWzRdO1xuICAgICAgdmFyIGR5ID0gdGhpcy5tWzFdICogbWF0cml4Lm1bNF0gKyB0aGlzLm1bM10gKiBtYXRyaXgubVs1XSArIHRoaXMubVs1XTtcblxuICAgICAgdGhpcy5tWzBdID0gbTExO1xuICAgICAgdGhpcy5tWzFdID0gbTEyO1xuICAgICAgdGhpcy5tWzJdID0gbTIxO1xuICAgICAgdGhpcy5tWzNdID0gbTIyO1xuICAgICAgdGhpcy5tWzRdID0gZHg7XG4gICAgICB0aGlzLm1bNV0gPSBkeTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSW52ZXJ0IHRoZSBtYXRyaXhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIGludmVydDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZCA9IDEgLyAodGhpcy5tWzBdICogdGhpcy5tWzNdIC0gdGhpcy5tWzFdICogdGhpcy5tWzJdKTtcbiAgICAgIHZhciBtMCA9IHRoaXMubVszXSAqIGQ7XG4gICAgICB2YXIgbTEgPSAtdGhpcy5tWzFdICogZDtcbiAgICAgIHZhciBtMiA9IC10aGlzLm1bMl0gKiBkO1xuICAgICAgdmFyIG0zID0gdGhpcy5tWzBdICogZDtcbiAgICAgIHZhciBtNCA9IGQgKiAodGhpcy5tWzJdICogdGhpcy5tWzVdIC0gdGhpcy5tWzNdICogdGhpcy5tWzRdKTtcbiAgICAgIHZhciBtNSA9IGQgKiAodGhpcy5tWzFdICogdGhpcy5tWzRdIC0gdGhpcy5tWzBdICogdGhpcy5tWzVdKTtcbiAgICAgIHRoaXMubVswXSA9IG0wO1xuICAgICAgdGhpcy5tWzFdID0gbTE7XG4gICAgICB0aGlzLm1bMl0gPSBtMjtcbiAgICAgIHRoaXMubVszXSA9IG0zO1xuICAgICAgdGhpcy5tWzRdID0gbTQ7XG4gICAgICB0aGlzLm1bNV0gPSBtNTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJuIG1hdHJpeFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldE1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2V0IHRvIGFic29sdXRlIHBvc2l0aW9uIHZpYSB0cmFuc2xhdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICogQGF1dGhvciBlcmljZHJvd2VsbFxuICAgICAqL1xuICAgIHNldEFic29sdXRlUG9zaXRpb246IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciBtMCA9IHRoaXMubVswXSxcbiAgICAgICAgbTEgPSB0aGlzLm1bMV0sXG4gICAgICAgIG0yID0gdGhpcy5tWzJdLFxuICAgICAgICBtMyA9IHRoaXMubVszXSxcbiAgICAgICAgbTQgPSB0aGlzLm1bNF0sXG4gICAgICAgIG01ID0gdGhpcy5tWzVdLFxuICAgICAgICB5dCA9IChtMCAqICh5IC0gbTUpIC0gbTEgKiAoeCAtIG00KSkgLyAobTAgKiBtMyAtIG0xICogbTIpLFxuICAgICAgICB4dCA9ICh4IC0gbTQgLSBtMiAqIHl0KSAvIG0wO1xuXG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoeHQsIHl0KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ09OU1RBTlRTXG4gIHZhciBDT05URVhUXzJEID0gJzJkJyxcbiAgICBPQkpFQ1RfQVJSQVkgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIE9CSkVDVF9OVU1CRVIgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgT0JKRUNUX0JPT0xFQU4gPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgUElfT1ZFUl9ERUcxODAgPSBNYXRoLlBJIC8gMTgwLFxuICAgIERFRzE4MF9PVkVSX1BJID0gMTgwIC8gTWF0aC5QSSxcbiAgICBIQVNIID0gJyMnLFxuICAgIEVNUFRZX1NUUklORyA9ICcnLFxuICAgIFpFUk8gPSAnMCcsXG4gICAgS09OVkFfV0FSTklORyA9ICdLb252YSB3YXJuaW5nOiAnLFxuICAgIEtPTlZBX0VSUk9SID0gJ0tvbnZhIGVycm9yOiAnLFxuICAgIFJHQl9QQVJFTiA9ICdyZ2IoJyxcbiAgICBDT0xPUlMgPSB7XG4gICAgICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcbiAgICAgIGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTVdLFxuICAgICAgYXF1YTogWzAsIDI1NSwgMjU1XSxcbiAgICAgIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcbiAgICAgIGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG4gICAgICBiZWlnZTogWzI0NSwgMjQ1LCAyMjBdLFxuICAgICAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG4gICAgICBibGFjazogWzAsIDAsIDBdLFxuICAgICAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1XSxcbiAgICAgIGJsdWU6IFswLCAwLCAyNTVdLFxuICAgICAgYmx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNl0sXG4gICAgICBicm93bjogWzE2NSwgNDIsIDQyXSxcbiAgICAgIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuICAgICAgY2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwXSxcbiAgICAgIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMF0sXG4gICAgICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuICAgICAgY29yYWw6IFsyNTUsIDEyNywgODBdLFxuICAgICAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3XSxcbiAgICAgIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG4gICAgICBjcmltc29uOiBbMjIwLCAyMCwgNjBdLFxuICAgICAgY3lhbjogWzAsIDI1NSwgMjU1XSxcbiAgICAgIGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcbiAgICAgIGRhcmtjeWFuOiBbMCwgMTM5LCAxMzldLFxuICAgICAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTMyLCAxMV0sXG4gICAgICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuICAgICAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgICAgIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OV0sXG4gICAgICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcbiAgICAgIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuICAgICAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0N10sXG4gICAgICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuICAgICAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG4gICAgICBkYXJrcmVkOiBbMTM5LCAwLCAwXSxcbiAgICAgIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcbiAgICAgIGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDNdLFxuICAgICAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5XSxcbiAgICAgIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcbiAgICAgIGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5XSxcbiAgICAgIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOV0sXG4gICAgICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuICAgICAgZGVlcHBpbms6IFsyNTUsIDIwLCAxNDddLFxuICAgICAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NV0sXG4gICAgICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgICBkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1XSxcbiAgICAgIGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcbiAgICAgIGZsb3JhbHdoaXRlOiBbMjU1LCAyNTUsIDI0MF0sXG4gICAgICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0XSxcbiAgICAgIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gICAgICBnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwXSxcbiAgICAgIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1XSxcbiAgICAgIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gICAgICBnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzJdLFxuICAgICAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICAgICAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICAgICAgZ3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDddLFxuICAgICAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxuICAgICAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcbiAgICAgIGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwXSxcbiAgICAgIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyXSxcbiAgICAgIGluZGlnbzogWzc1LCAwLCAxMzBdLFxuICAgICAgaXZvcnk6IFsyNTUsIDI1NSwgMjQwXSxcbiAgICAgIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXG4gICAgICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuICAgICAgbGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDVdLFxuICAgICAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDBdLFxuICAgICAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG4gICAgICBsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwXSxcbiAgICAgIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4XSxcbiAgICAgIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwXSxcbiAgICAgIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTFdLFxuICAgICAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICAgICAgbGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMV0sXG4gICAgICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzXSxcbiAgICAgIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG4gICAgICBsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwXSxcbiAgICAgIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTBdLFxuICAgICAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgICAgIGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1M10sXG4gICAgICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjJdLFxuICAgICAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcbiAgICAgIGxpbWU6IFswLCAyNTUsIDBdLFxuICAgICAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTBdLFxuICAgICAgbGluZW46IFsyNTAsIDI0MCwgMjMwXSxcbiAgICAgIG1hZ2VudGE6IFsyNTUsIDAsIDI1NV0sXG4gICAgICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICAgICAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuICAgICAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNV0sXG4gICAgICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTFdLFxuICAgICAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG4gICAgICBtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExM10sXG4gICAgICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4XSxcbiAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuICAgICAgbWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0XSxcbiAgICAgIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzM10sXG4gICAgICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG4gICAgICBtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwXSxcbiAgICAgIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjVdLFxuICAgICAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcbiAgICAgIG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3M10sXG4gICAgICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgICAgIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcbiAgICAgIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICAgICAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1XSxcbiAgICAgIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgICAgIG9yYW5nZXJlZDogWzI1NSwgNjksIDBdLFxuICAgICAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNF0sXG4gICAgICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG4gICAgICBwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyXSxcbiAgICAgIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4XSxcbiAgICAgIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcbiAgICAgIHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzXSxcbiAgICAgIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODVdLFxuICAgICAgcGVydTogWzIwNSwgMTMzLCA2M10sXG4gICAgICBwaW5rOiBbMjU1LCAxOTIsIDIwM10sXG4gICAgICBwbHVtOiBbMjIxLCAxNjAsIDIwM10sXG4gICAgICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG4gICAgICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gICAgICByZWJlY2NhcHVycGxlOiBbMTAyLCA1MSwgMTUzXSxcbiAgICAgIHJlZDogWzI1NSwgMCwgMF0sXG4gICAgICByb3N5YnJvd246IFsxODgsIDE0MywgMTQzXSxcbiAgICAgIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNV0sXG4gICAgICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcbiAgICAgIHNhbG1vbjogWzI1MCwgMTI4LCAxMTRdLFxuICAgICAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5Nl0sXG4gICAgICBzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcbiAgICAgIHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOF0sXG4gICAgICBzaWVubmE6IFsxNjAsIDgyLCA0NV0sXG4gICAgICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgICAgIHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1XSxcbiAgICAgIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNV0sXG4gICAgICBzbGF0ZWdyYXk6IFsxMTksIDEyOCwgMTQ0XSxcbiAgICAgIHNsYXRlZ3JleTogWzExOSwgMTI4LCAxNDRdLFxuICAgICAgc25vdzogWzI1NSwgMjU1LCAyNTBdLFxuICAgICAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG4gICAgICBzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODBdLFxuICAgICAgdGFuOiBbMjEwLCAxODAsIDE0MF0sXG4gICAgICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICAgICAgdGhpc3RsZTogWzIxNiwgMTkxLCAyMTZdLFxuICAgICAgdHJhbnNwYXJlbnQ6IFsyNTUsIDI1NSwgMjU1LCAwXSxcbiAgICAgIHRvbWF0bzogWzI1NSwgOTksIDcxXSxcbiAgICAgIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gICAgICB2aW9sZXQ6IFsyMzgsIDEzMCwgMjM4XSxcbiAgICAgIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG4gICAgICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICAgICAgd2hpdGVzbW9rZTogWzI0NSwgMjQ1LCAyNDVdLFxuICAgICAgeWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuICAgICAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNV1cbiAgICB9LFxuICAgIFJHQl9SRUdFWCA9IC9yZ2JcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KVxcKS87XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgVXRpbFxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICovXG4gIEtvbnZhLlV0aWwgPSB7XG4gICAgLypcbiAgICAqIGNoZXJyeS1waWNrZWQgdXRpbGl0aWVzIGZyb20gdW5kZXJzY29yZS5qc1xuICAgICovXG4gICAgX2lzRWxlbWVudDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PSAxKTtcbiAgICB9LFxuICAgIF9pc0Z1bmN0aW9uOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiAhIShvYmogJiYgb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jYWxsICYmIG9iai5hcHBseSk7XG4gICAgfSxcbiAgICBfaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuICEhb2JqICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICAgIH0sXG4gICAgX2lzQXJyYXk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfQVJSQVk7XG4gICAgfSxcbiAgICBfaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9OVU1CRVIgJiZcbiAgICAgICAgIWlzTmFOKG9iaikgJiZcbiAgICAgICAgaXNGaW5pdGUob2JqKVxuICAgICAgKTtcbiAgICB9LFxuICAgIF9pc1N0cmluZzogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkc7XG4gICAgfSxcbiAgICBfaXNCb29sZWFuOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX0JPT0xFQU47XG4gICAgfSxcbiAgICAvLyBhcnJheXMgYXJlIG9iamVjdHMgdG9vXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIE9iamVjdDtcbiAgICB9LFxuICAgIGlzVmFsaWRTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdENoYXIgPSBzZWxlY3RvclswXTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGZpcnN0Q2hhciA9PT0gJyMnIHx8XG4gICAgICAgIGZpcnN0Q2hhciA9PT0gJy4nIHx8XG4gICAgICAgIGZpcnN0Q2hhciA9PT0gZmlyc3RDaGFyLnRvVXBwZXJDYXNlKClcbiAgICAgICk7XG4gICAgfSxcbiAgICBfc2lnbjogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICBpZiAobnVtYmVyID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKG51bWJlciA+IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjYW52YXMgPSBLb252YS5pc0Jyb3dzZXJcbiAgICAgICAgPyBLb252YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICA6IG5ldyBLb252YS5fbm9kZUNhbnZhcygpO1xuICAgICAgLy8gb24gc29tZSBlbnZpcm9ubWVudHMgY2FudmFzLnN0eWxlIGlzIHJlYWRvbmx5XG4gICAgICB0cnkge1xuICAgICAgICBjYW52YXMuc3R5bGUgPSBjYW52YXMuc3R5bGUgfHwge307XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9LFxuICAgIF9pc0luRG9jdW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB3aGlsZSAoKGVsID0gZWwucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgaWYgKGVsID09IEtvbnZhLmRvY3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIF9zaW1wbGlmeUFycmF5OiBmdW5jdGlvbihhcnIpIHtcbiAgICAgIHZhciByZXRBcnIgPSBbXSxcbiAgICAgICAgbGVuID0gYXJyLmxlbmd0aCxcbiAgICAgICAgdXRpbCA9IEtvbnZhLlV0aWwsXG4gICAgICAgIG4sXG4gICAgICAgIHZhbDtcblxuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIHZhbCA9IGFycltuXTtcbiAgICAgICAgaWYgKHV0aWwuX2lzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICB2YWwgPSBNYXRoLnJvdW5kKHZhbCAqIDEwMDApIC8gMTAwMDtcbiAgICAgICAgfSBlbHNlIGlmICghdXRpbC5faXNTdHJpbmcodmFsKSkge1xuICAgICAgICAgIHZhbCA9IHZhbC50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0QXJyLnB1c2godmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9LFxuICAgIC8qXG4gICAgKiBhcmcgY2FuIGJlIGFuIGltYWdlIG9iamVjdCBvciBpbWFnZSBkYXRhXG4gICAgKi9cbiAgICBfZ2V0SW1hZ2U6IGZ1bmN0aW9uKGFyZywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBpbWFnZU9iaiwgY2FudmFzO1xuXG4gICAgICAvLyBpZiBhcmcgaXMgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgIGlmICghYXJnKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0VsZW1lbnQoYXJnKSkge1xuICAgICAgICAvLyBpZiBhcmcgaXMgYWxyZWFkeSBhbiBpbWFnZSBvYmplY3RcbiAgICAgICAgY2FsbGJhY2soYXJnKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNTdHJpbmcoYXJnKSkge1xuICAgICAgICAvLyBpZiBhcmcgaXMgYSBzdHJpbmcsIHRoZW4gaXQncyBhIGRhdGEgdXJsXG4gICAgICAgIGltYWdlT2JqID0gbmV3IEtvbnZhLndpbmRvdy5JbWFnZSgpO1xuICAgICAgICBpbWFnZU9iai5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjYWxsYmFjayhpbWFnZU9iaik7XG4gICAgICAgIH07XG4gICAgICAgIGltYWdlT2JqLnNyYyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnLmRhdGEpIHtcbiAgICAgICAgLy9pZiBhcmcgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgcHJvcGVydHksIGl0J3MgYW4gaW1hZ2Ugb2JqZWN0XG4gICAgICAgIGNhbnZhcyA9IEtvbnZhLlV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBhcmcud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBhcmcuaGVpZ2h0O1xuICAgICAgICB2YXIgX2NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChDT05URVhUXzJEKTtcbiAgICAgICAgX2NvbnRleHQucHV0SW1hZ2VEYXRhKGFyZywgMCwgMCk7XG4gICAgICAgIHRoaXMuX2dldEltYWdlKGNhbnZhcy50b0RhdGFVUkwoKSwgY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0UkdCQVN0cmluZzogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgcmVkID0gb2JqLnJlZCB8fCAwLFxuICAgICAgICBncmVlbiA9IG9iai5ncmVlbiB8fCAwLFxuICAgICAgICBibHVlID0gb2JqLmJsdWUgfHwgMCxcbiAgICAgICAgYWxwaGEgPSBvYmouYWxwaGEgfHwgMTtcblxuICAgICAgcmV0dXJuIFsncmdiYSgnLCByZWQsICcsJywgZ3JlZW4sICcsJywgYmx1ZSwgJywnLCBhbHBoYSwgJyknXS5qb2luKFxuICAgICAgICBFTVBUWV9TVFJJTkdcbiAgICAgICk7XG4gICAgfSxcbiAgICBfcmdiVG9IZXg6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHJldHVybiAoKDEgPDwgMjQpICsgKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgfSxcbiAgICBfaGV4VG9SZ2I6IGZ1bmN0aW9uKGhleCkge1xuICAgICAgaGV4ID0gaGV4LnJlcGxhY2UoSEFTSCwgRU1QVFlfU1RSSU5HKTtcbiAgICAgIHZhciBiaWdpbnQgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IChiaWdpbnQgPj4gMTYpICYgMjU1LFxuICAgICAgICBnOiAoYmlnaW50ID4+IDgpICYgMjU1LFxuICAgICAgICBiOiBiaWdpbnQgJiAyNTVcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm4gcmFuZG9tIGhleCBjb2xvclxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVXRpbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRSYW5kb21Db2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFuZENvbG9yID0gKChNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYpIDw8IDApLnRvU3RyaW5nKDE2KTtcbiAgICAgIHdoaWxlIChyYW5kQ29sb3IubGVuZ3RoIDwgNikge1xuICAgICAgICByYW5kQ29sb3IgPSBaRVJPICsgcmFuZENvbG9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEhBU0ggKyByYW5kQ29sb3I7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm4gdmFsdWUgd2l0aCBkZWZhdWx0IGZhbGxiYWNrXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24odmFsLCBkZWYpIHtcbiAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBSR0IgY29tcG9uZW50cyBvZiBhIGNvbG9yXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZWFjaCBvZiB0aGUgZm9sbG93aW5nIGV4YW1wbGVzIHJldHVybiB7cjowLCBnOjAsIGI6MjU1fVxuICAgICAqIHZhciByZ2IgPSBLb252YS5VdGlsLmdldFJHQignYmx1ZScpO1xuICAgICAqIHZhciByZ2IgPSBLb252YS5VdGlsLmdldFJHQignIzAwMDBmZicpO1xuICAgICAqIHZhciByZ2IgPSBLb252YS5VdGlsLmdldFJHQigncmdiKDAsMCwyNTUpJyk7XG4gICAgICovXG4gICAgZ2V0UkdCOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgdmFyIHJnYjtcbiAgICAgIC8vIGNvbG9yIHN0cmluZ1xuICAgICAgaWYgKGNvbG9yIGluIENPTE9SUykge1xuICAgICAgICByZ2IgPSBDT0xPUlNbY29sb3JdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IHJnYlswXSxcbiAgICAgICAgICBnOiByZ2JbMV0sXG4gICAgICAgICAgYjogcmdiWzJdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGNvbG9yWzBdID09PSBIQVNIKSB7XG4gICAgICAgIC8vIGhleFxuICAgICAgICByZXR1cm4gdGhpcy5faGV4VG9SZ2IoY29sb3Iuc3Vic3RyaW5nKDEpKTtcbiAgICAgIH0gZWxzZSBpZiAoY29sb3Iuc3Vic3RyKDAsIDQpID09PSBSR0JfUEFSRU4pIHtcbiAgICAgICAgLy8gcmdiIHN0cmluZ1xuICAgICAgICByZ2IgPSBSR0JfUkVHRVguZXhlYyhjb2xvci5yZXBsYWNlKC8gL2csICcnKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogcGFyc2VJbnQocmdiWzFdLCAxMCksXG4gICAgICAgICAgZzogcGFyc2VJbnQocmdiWzJdLCAxMCksXG4gICAgICAgICAgYjogcGFyc2VJbnQocmdiWzNdLCAxMClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiAwLFxuICAgICAgICAgIGc6IDAsXG4gICAgICAgICAgYjogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gY29udmVydCBhbnkgY29sb3Igc3RyaW5nIHRvIFJHQkEgb2JqZWN0XG4gICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY29tcG9uZW50L2NvbG9yLXBhcnNlclxuICAgIGNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHN0ciA9IHN0ciB8fCAnYmxhY2snO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgS29udmEuVXRpbC5fbmFtZWRDb2xvclRvUkJBKHN0cikgfHxcbiAgICAgICAgS29udmEuVXRpbC5faGV4M0NvbG9yVG9SR0JBKHN0cikgfHxcbiAgICAgICAgS29udmEuVXRpbC5faGV4NkNvbG9yVG9SR0JBKHN0cikgfHxcbiAgICAgICAgS29udmEuVXRpbC5fcmdiQ29sb3JUb1JHQkEoc3RyKSB8fFxuICAgICAgICBLb252YS5VdGlsLl9yZ2JhQ29sb3JUb1JHQkEoc3RyKVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8vIFBhcnNlIG5hbWVkIGNzcyBjb2xvci4gTGlrZSBcImdyZWVuXCJcbiAgICBfbmFtZWRDb2xvclRvUkJBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciBjID0gQ09MT1JTW3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmICghYykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IGNbMF0sXG4gICAgICAgIGc6IGNbMV0sXG4gICAgICAgIGI6IGNbMl0sXG4gICAgICAgIGE6IDFcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBQYXJzZSByZ2IobiwgbiwgbilcbiAgICBfcmdiQ29sb3JUb1JHQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHN0ci5pbmRleE9mKCdyZ2IoJykgPT09IDApIHtcbiAgICAgICAgc3RyID0gc3RyLm1hdGNoKC9yZ2JcXCgoW14pXSspXFwpLylbMV07XG4gICAgICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICosICovKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiBwYXJ0c1swXSxcbiAgICAgICAgICBnOiBwYXJ0c1sxXSxcbiAgICAgICAgICBiOiBwYXJ0c1syXSxcbiAgICAgICAgICBhOiAxXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBQYXJzZSByZ2JhKG4sIG4sIG4sIG4pXG4gICAgX3JnYmFDb2xvclRvUkdCQTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ3JnYmEoJykgPT09IDApIHtcbiAgICAgICAgc3RyID0gc3RyLm1hdGNoKC9yZ2JhXFwoKFteKV0rKVxcKS8pWzFdO1xuICAgICAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqLCAqLykubWFwKE51bWJlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogcGFydHNbMF0sXG4gICAgICAgICAgZzogcGFydHNbMV0sXG4gICAgICAgICAgYjogcGFydHNbMl0sXG4gICAgICAgICAgYTogcGFydHNbM11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFBhcnNlICNubm5ubm5cbiAgICBfaGV4NkNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChzdHJbMF0gPT09ICcjJyAmJiBzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogcGFyc2VJbnQoc3RyLnNsaWNlKDEsIDMpLCAxNiksXG4gICAgICAgICAgZzogcGFyc2VJbnQoc3RyLnNsaWNlKDMsIDUpLCAxNiksXG4gICAgICAgICAgYjogcGFyc2VJbnQoc3RyLnNsaWNlKDUsIDcpLCAxNiksXG4gICAgICAgICAgYTogMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gUGFyc2UgI25ublxuICAgIF9oZXgzQ29sb3JUb1JHQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHN0clswXSA9PT0gJyMnICYmIHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiBwYXJzZUludChzdHJbMV0gKyBzdHJbMV0sIDE2KSxcbiAgICAgICAgICBnOiBwYXJzZUludChzdHJbMl0gKyBzdHJbMl0sIDE2KSxcbiAgICAgICAgICBiOiBwYXJzZUludChzdHJbM10gKyBzdHJbM10sIDE2KSxcbiAgICAgICAgICBhOiAxXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBvMSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgbzJcbiAgICBfbWVyZ2U6IGZ1bmN0aW9uKG8xLCBvMikge1xuICAgICAgdmFyIHJldE9iaiA9IHRoaXMuX2Nsb25lKG8yKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvMSkge1xuICAgICAgICBpZiAodGhpcy5faXNPYmplY3QobzFba2V5XSkpIHtcbiAgICAgICAgICByZXRPYmpba2V5XSA9IHRoaXMuX21lcmdlKG8xW2tleV0sIHJldE9ialtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRPYmpba2V5XSA9IG8xW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRPYmo7XG4gICAgfSxcbiAgICB0cmltUmlnaHQ6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICB9LFxuICAgIHRyaW1MZWZ0OiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjaGVjayBpbnRlcnNlY3Rpb24gb2YgdHdvIGNsaWVudCByZWN0YW5nbGVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhdmVJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKHIxLCByMikge1xuICAgICAgcmV0dXJuICEoXG4gICAgICAgIHIyLnggPiByMS54ICsgcjEud2lkdGggfHxcbiAgICAgICAgcjIueCArIHIyLndpZHRoIDwgcjEueCB8fFxuICAgICAgICByMi55ID4gcjEueSArIHIxLmhlaWdodCB8fFxuICAgICAgICByMi55ICsgcjIuaGVpZ2h0IDwgcjEueVxuICAgICAgKTtcbiAgICB9LFxuICAgIGNsb25lT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciByZXRPYmogPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzT2JqZWN0KG9ialtrZXldKSkge1xuICAgICAgICAgIHJldE9ialtrZXldID0gdGhpcy5jbG9uZU9iamVjdChvYmpba2V5XSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNBcnJheShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXRPYmpba2V5XSA9IHRoaXMuY2xvbmVBcnJheShvYmpba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldE9iajtcbiAgICB9LFxuICAgIGNsb25lQXJyYXk6IGZ1bmN0aW9uKGFycikge1xuICAgICAgcmV0dXJuIGFyci5zbGljZSgwKTtcbiAgICB9LFxuICAgIF9kZWdUb1JhZDogZnVuY3Rpb24oZGVnKSB7XG4gICAgICByZXR1cm4gZGVnICogUElfT1ZFUl9ERUcxODA7XG4gICAgfSxcbiAgICBfcmFkVG9EZWc6IGZ1bmN0aW9uKHJhZCkge1xuICAgICAgcmV0dXJuIHJhZCAqIERFRzE4MF9PVkVSX1BJO1xuICAgIH0sXG4gICAgX2NhcGl0YWxpemU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgICB9LFxuICAgIHRocm93OiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihLT05WQV9FUlJPUiArIHN0cik7XG4gICAgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKEtPTlZBX0VSUk9SICsgc3RyKTtcbiAgICB9LFxuICAgIHdhcm46IGZ1bmN0aW9uKHN0cikge1xuICAgICAgLypcbiAgICAgICAgICAgICAqIElFOSBvbiBXaW5kb3dzNyA2NGJpdCB3aWxsIHRocm93IGEgSlMgZXJyb3JcbiAgICAgICAgICAgICAqIGlmIHdlIGRvbid0IHVzZSB3aW5kb3cuY29uc29sZSBpbiB0aGUgY29uZGl0aW9uYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgaWYgKEtvbnZhLmdsb2JhbC5jb25zb2xlICYmIGNvbnNvbGUud2FybiAmJiBLb252YS5zaG93V2FybmluZ3MpIHtcbiAgICAgICAgY29uc29sZS53YXJuKEtPTlZBX1dBUk5JTkcgKyBzdHIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZW5kOiBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7XG4gICAgICBmdW5jdGlvbiBDdG9yKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgICB9XG4gICAgICBDdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICB2YXIgb2xkUHJvdG8gPSBjaGlsZC5wcm90b3R5cGU7XG4gICAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgQ3RvcigpO1xuICAgICAgZm9yICh2YXIga2V5IGluIG9sZFByb3RvKSB7XG4gICAgICAgIGlmIChvbGRQcm90by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY2hpbGQucHJvdG90eXBlW2tleV0gPSBvbGRQcm90b1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAgLy8gY3JlYXRlIHJlZmVyZW5jZSB0byBwYXJlbnRcbiAgICAgIGNoaWxkLnN1cGVyID0gcGFyZW50O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogYWRkcyBtZXRob2RzIHRvIGEgY29uc3RydWN0b3IgcHJvdG90eXBlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGhvZHNcbiAgICAgKi9cbiAgICBhZGRNZXRob2RzOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgbWV0aG9kcykge1xuICAgICAgdmFyIGtleTtcblxuICAgICAgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRDb250cm9sUG9pbnRzOiBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB0KSB7XG4gICAgICB2YXIgZDAxID0gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDAsIDIpICsgTWF0aC5wb3coeTEgLSB5MCwgMikpLFxuICAgICAgICBkMTIgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDIgLSB4MSwgMikgKyBNYXRoLnBvdyh5MiAtIHkxLCAyKSksXG4gICAgICAgIGZhID0gdCAqIGQwMSAvIChkMDEgKyBkMTIpLFxuICAgICAgICBmYiA9IHQgKiBkMTIgLyAoZDAxICsgZDEyKSxcbiAgICAgICAgcDF4ID0geDEgLSBmYSAqICh4MiAtIHgwKSxcbiAgICAgICAgcDF5ID0geTEgLSBmYSAqICh5MiAtIHkwKSxcbiAgICAgICAgcDJ4ID0geDEgKyBmYiAqICh4MiAtIHgwKSxcbiAgICAgICAgcDJ5ID0geTEgKyBmYiAqICh5MiAtIHkwKTtcblxuICAgICAgcmV0dXJuIFtwMXgsIHAxeSwgcDJ4LCBwMnldO1xuICAgIH0sXG4gICAgX2V4cGFuZFBvaW50czogZnVuY3Rpb24ocCwgdGVuc2lvbikge1xuICAgICAgdmFyIGxlbiA9IHAubGVuZ3RoLFxuICAgICAgICBhbGxQb2ludHMgPSBbXSxcbiAgICAgICAgbixcbiAgICAgICAgY3A7XG5cbiAgICAgIGZvciAobiA9IDI7IG4gPCBsZW4gLSAyOyBuICs9IDIpIHtcbiAgICAgICAgY3AgPSBLb252YS5VdGlsLl9nZXRDb250cm9sUG9pbnRzKFxuICAgICAgICAgIHBbbiAtIDJdLFxuICAgICAgICAgIHBbbiAtIDFdLFxuICAgICAgICAgIHBbbl0sXG4gICAgICAgICAgcFtuICsgMV0sXG4gICAgICAgICAgcFtuICsgMl0sXG4gICAgICAgICAgcFtuICsgM10sXG4gICAgICAgICAgdGVuc2lvblxuICAgICAgICApO1xuICAgICAgICBhbGxQb2ludHMucHVzaChjcFswXSk7XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzFdKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2gocFtuXSk7XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKHBbbiArIDFdKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goY3BbMl0pO1xuICAgICAgICBhbGxQb2ludHMucHVzaChjcFszXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGxQb2ludHM7XG4gICAgfSxcbiAgICBfcmVtb3ZlTGFzdExldHRlcjogZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgfSxcbiAgICBlYWNoOiBmdW5jdGlvbihvYmosIGZ1bmMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgZnVuYyhrZXksIG9ialtrZXldKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9pblJhbmdlOiBmdW5jdGlvbih2YWwsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICByZXR1cm4gbGVmdCA8PSB2YWwgJiYgdmFsIDwgcmlnaHQ7XG4gICAgfSxcbiAgICBfZ2V0UHJvamVjdGlvblRvU2VnbWVudDogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgdmFyIHgsIHksIGRpc3Q7XG5cbiAgICAgIHZhciBwZDIgPSAoeDEgLSB4MikgKiAoeDEgLSB4MikgKyAoeTEgLSB5MikgKiAoeTEgLSB5Mik7XG4gICAgICBpZiAocGQyID09IDApIHtcbiAgICAgICAgeCA9IHgxO1xuICAgICAgICB5ID0geTE7XG4gICAgICAgIGRpc3QgPSAoeDMgLSB4MikgKiAoeDMgLSB4MikgKyAoeTMgLSB5MikgKiAoeTMgLSB5Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdSA9ICgoeDMgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTMgLSB5MSkgKiAoeTIgLSB5MSkpIC8gcGQyO1xuICAgICAgICBpZiAodSA8IDApIHtcbiAgICAgICAgICB4ID0geDE7XG4gICAgICAgICAgeSA9IHkxO1xuICAgICAgICAgIGRpc3QgPSAoeDEgLSB4MykgKiAoeDEgLSB4MykgKyAoeTEgLSB5MykgKiAoeTEgLSB5Myk7XG4gICAgICAgIH0gZWxzZSBpZiAodSA+IDEuMCkge1xuICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICB5ID0geTI7XG4gICAgICAgICAgZGlzdCA9ICh4MiAtIHgzKSAqICh4MiAtIHgzKSArICh5MiAtIHkzKSAqICh5MiAtIHkzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ID0geDEgKyB1ICogKHgyIC0geDEpO1xuICAgICAgICAgIHkgPSB5MSArIHUgKiAoeTIgLSB5MSk7XG4gICAgICAgICAgZGlzdCA9ICh4IC0geDMpICogKHggLSB4MykgKyAoeSAtIHkzKSAqICh5IC0geTMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW3gsIHksIGRpc3RdO1xuICAgIH0sXG4gICAgLy8gbGluZSBhcyBhcnJheSBvZiBwb2ludHMuXG4gICAgLy8gbGluZSBtaWdodCBiZSBjbG9zZWRcbiAgICBfZ2V0UHJvamVjdGlvblRvTGluZTogZnVuY3Rpb24ocHQsIGxpbmUsIGlzQ2xvc2VkKSB7XG4gICAgICB2YXIgcGMgPSBLb252YS5VdGlsLmNsb25lT2JqZWN0KHB0KTtcbiAgICAgIHZhciBkaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGxpbmUuZm9yRWFjaChmdW5jdGlvbihwMSwgaSkge1xuICAgICAgICBpZiAoIWlzQ2xvc2VkICYmIGkgPT09IGxpbmUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcDIgPSBsaW5lWyhpICsgMSkgJSBsaW5lLmxlbmd0aF07XG4gICAgICAgIHZhciBwcm9qID0gS29udmEuVXRpbC5fZ2V0UHJvamVjdGlvblRvU2VnbWVudChcbiAgICAgICAgICBwMS54LFxuICAgICAgICAgIHAxLnksXG4gICAgICAgICAgcDIueCxcbiAgICAgICAgICBwMi55LFxuICAgICAgICAgIHB0LngsXG4gICAgICAgICAgcHQueVxuICAgICAgICApO1xuICAgICAgICB2YXIgcHggPSBwcm9qWzBdLFxuICAgICAgICAgIHB5ID0gcHJvalsxXSxcbiAgICAgICAgICBwZGlzdCA9IHByb2pbMl07XG4gICAgICAgIGlmIChwZGlzdCA8IGRpc3QpIHtcbiAgICAgICAgICBwYy54ID0gcHg7XG4gICAgICAgICAgcGMueSA9IHB5O1xuICAgICAgICAgIGRpc3QgPSBwZGlzdDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGM7XG4gICAgfSxcbiAgICBfcHJlcGFyZUFycmF5Rm9yVHdlZW46IGZ1bmN0aW9uKHN0YXJ0QXJyYXksIGVuZEFycmF5LCBpc0Nsb3NlZCkge1xuICAgICAgdmFyIG4sXG4gICAgICAgIHN0YXJ0ID0gW10sXG4gICAgICAgIGVuZCA9IFtdO1xuICAgICAgaWYgKHN0YXJ0QXJyYXkubGVuZ3RoID4gZW5kQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0ZW1wID0gZW5kQXJyYXk7XG4gICAgICAgIGVuZEFycmF5ID0gc3RhcnRBcnJheTtcbiAgICAgICAgc3RhcnRBcnJheSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBmb3IgKG4gPSAwOyBuIDwgc3RhcnRBcnJheS5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICBzdGFydC5wdXNoKHtcbiAgICAgICAgICB4OiBzdGFydEFycmF5W25dLFxuICAgICAgICAgIHk6IHN0YXJ0QXJyYXlbbiArIDFdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm9yIChuID0gMDsgbiA8IGVuZEFycmF5Lmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgIGVuZC5wdXNoKHtcbiAgICAgICAgICB4OiBlbmRBcnJheVtuXSxcbiAgICAgICAgICB5OiBlbmRBcnJheVtuICsgMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdTdGFydCA9IFtdO1xuICAgICAgZW5kLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdmFyIHByID0gS29udmEuVXRpbC5fZ2V0UHJvamVjdGlvblRvTGluZShwb2ludCwgc3RhcnQsIGlzQ2xvc2VkKTtcbiAgICAgICAgbmV3U3RhcnQucHVzaChwci54KTtcbiAgICAgICAgbmV3U3RhcnQucHVzaChwci55KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ld1N0YXJ0O1xuICAgIH0sXG4gICAgX3ByZXBhcmVUb1N0cmluZ2lmeTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgZGVzYztcblxuICAgICAgb2JqLnZpc2l0ZWRCeUNpcmN1bGFyUmVmZXJlbmNlUmVtb3ZhbCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICEob2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqW2tleV0gJiYgdHlwZW9mIG9ialtrZXldID09ICdvYmplY3QnKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBvYmpba2V5XS52aXNpdGVkQnlDaXJjdWxhclJlZmVyZW5jZVJlbW92YWwgfHxcbiAgICAgICAgICBLb252YS5VdGlsLl9pc0VsZW1lbnQob2JqW2tleV0pXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoS29udmEuVXRpbC5fcHJlcGFyZVRvU3RyaW5naWZ5KG9ialtrZXldKSA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGVsZXRlIG9iai52aXNpdGVkQnlDaXJjdWxhclJlZmVyZW5jZVJlbW92YWw7XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIGNhbGN1bGF0ZSBwaXhlbCByYXRpb1xuXG4gIHZhciBfcGl4ZWxSYXRpbztcbiAgZnVuY3Rpb24gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICBpZiAoX3BpeGVsUmF0aW8pIHtcbiAgICAgIHJldHVybiBfcGl4ZWxSYXRpbztcbiAgICB9XG4gICAgdmFyIGNhbnZhcyA9IEtvbnZhLlV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgX3BpeGVsUmF0aW8gPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IEtvbnZhLndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG4gICAgICAgIGJhY2tpbmdTdG9yZVJhdGlvID1cbiAgICAgICAgICBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgIGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAxO1xuICAgICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcbiAgICB9KSgpO1xuICAgIHJldHVybiBfcGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW52YXMgUmVuZGVyZXIgY29uc3RydWN0b3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLndpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaGVpZ2h0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucGl4ZWxSYXRpbyBLb252YUpTIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBwaXhlbCByYXRpbyBhZGp1c3RtZW50cyBpbiBvcmRlciB0byByZW5kZXIgY3Jpc3AgZHJhd2luZ3NcbiAgICogIG9uIGFsbCBkZXZpY2VzLiBNb3N0IGRlc2t0b3BzLCBsb3cgZW5kIHRhYmxldHMsIGFuZCBsb3cgZW5kIHBob25lcywgaGF2ZSBkZXZpY2UgcGl4ZWwgcmF0aW9zXG4gICAqICBvZiAxLiAgU29tZSBoaWdoIGVuZCB0YWJsZXRzIGFuZCBwaG9uZXMsIGxpa2UgaVBob25lcyBhbmQgaVBhZHMgKG5vdCB0aGUgbWluaSkgaGF2ZSBhIGRldmljZSBwaXhlbCByYXRpb1xuICAgKiAgb2YgMi4gIFNvbWUgTWFjYm9vayBQcm9zLCBhbmQgaU1hY3MgYWxzbyBoYXZlIGEgZGV2aWNlIHBpeGVsIHJhdGlvIG9mIDIuICBTb21lIGhpZ2ggZW5kIEFuZHJvaWQgZGV2aWNlcyBoYXZlIHBpeGVsXG4gICAqICByYXRpb3Mgb2YgMiBvciAzLiAgU29tZSBicm93c2VycyBsaWtlIEZpcmVmb3ggYWxsb3cgeW91IHRvIGNvbmZpZ3VyZSB0aGUgcGl4ZWwgcmF0aW8gb2YgdGhlIHZpZXdwb3J0LiAgVW5sZXNzIG90aGVyd2lzZVxuICAgKiAgc3BlY2lmaWVkLCB0aGUgcGl4ZWwgcmF0aW8gd2lsbCBiZSBkZWZhdWx0ZWQgdG8gdGhlIGFjdHVhbCBkZXZpY2UgcGl4ZWwgcmF0aW8uICBZb3UgY2FuIG92ZXJyaWRlIHRoZSBkZXZpY2UgcGl4ZWxcbiAgICogIHJhdGlvIGZvciBzcGVjaWFsIHNpdHVhdGlvbnMsIG9yLCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgcGl4ZWwgcmF0aW8gdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LCB5b3UgY2FuIHNldCBpdCB0byAxLlxuICAgKi9cbiAgS29udmEuQ2FudmFzID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuQ2FudmFzLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9XG4gICAgICAgIGNvbmYucGl4ZWxSYXRpbyB8fCBLb252YS5waXhlbFJhdGlvIHx8IGdldERldmljZVBpeGVsUmF0aW8oKTtcblxuICAgICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICAgIHRoaXMuX2NhbnZhcyA9IEtvbnZhLlV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuXG4gICAgICAvLyBzZXQgaW5saW5lIHN0eWxlc1xuICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnBhZGRpbmcgPSAwO1xuICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLm1hcmdpbiA9IDA7XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUuYm9yZGVyID0gMDtcbiAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUudG9wID0gMDtcbiAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5sZWZ0ID0gMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBjYW52YXMgY29udGV4dFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtDYW52YXNDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IHBpeGVsIHJhdGlvXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcn0gcGl4ZWwgcmF0aW9cbiAgICAgKi9cbiAgICBnZXRQaXhlbFJhdGlvOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBpeGVsUmF0aW87XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgcGl4ZWwgcmF0aW9cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGl4ZWxSYXRpbyBLb252YUpTIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBwaXhlbCByYXRpbyBhZHVzdG1lbnRzIGluIG9yZGVyIHRvIHJlbmRlciBjcmlzcCBkcmF3aW5nc1xuICAgICAqICBvbiBhbGwgZGV2aWNlcy4gTW9zdCBkZXNrdG9wcywgbG93IGVuZCB0YWJsZXRzLCBhbmQgbG93IGVuZCBwaG9uZXMsIGhhdmUgZGV2aWNlIHBpeGVsIHJhdGlvc1xuICAgICAqICBvZiAxLiAgU29tZSBoaWdoIGVuZCB0YWJsZXRzIGFuZCBwaG9uZXMsIGxpa2UgaVBob25lcyBhbmQgaVBhZHMgaGF2ZSBhIGRldmljZSBwaXhlbCByYXRpb1xuICAgICAqICBvZiAyLiAgU29tZSBNYWNib29rIFByb3MsIGFuZCBpTWFjcyBhbHNvIGhhdmUgYSBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgMi4gIFNvbWUgaGlnaCBlbmQgQW5kcm9pZCBkZXZpY2VzIGhhdmUgcGl4ZWxcbiAgICAgKiAgcmF0aW9zIG9mIDIgb3IgMy4gIFNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94IGFsbG93IHlvdSB0byBjb25maWd1cmUgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSB2aWV3cG9ydC4gIFVubGVzcyBvdGhlcndpc2VcbiAgICAgKiAgc3BlY2lmaWNlZCwgdGhlIHBpeGVsIHJhdGlvIHdpbGwgYmUgZGVmYXVsdGVkIHRvIHRoZSBhY3R1YWwgZGV2aWNlIHBpeGVsIHJhdGlvLiAgWW91IGNhbiBvdmVycmlkZSB0aGUgZGV2aWNlIHBpeGVsXG4gICAgICogIHJhdGlvIGZvciBzcGVjaWFsIHNpdHVhdGlvbnMsIG9yLCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgcGl4ZWwgcmF0aW8gdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LCB5b3UgY2FuIHNldCBpdCB0byAxLlxuICAgICAqL1xuICAgIHNldFBpeGVsUmF0aW86IGZ1bmN0aW9uKHBpeGVsUmF0aW8pIHtcbiAgICAgIHZhciBwcmV2aW91c1JhdGlvID0gdGhpcy5waXhlbFJhdGlvO1xuICAgICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICAgIHRoaXMuc2V0U2l6ZShcbiAgICAgICAgdGhpcy5nZXRXaWR0aCgpIC8gcHJldmlvdXNSYXRpbyxcbiAgICAgICAgdGhpcy5nZXRIZWlnaHQoKSAvIHByZXZpb3VzUmF0aW9cbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXQgd2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKi9cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IHBpeGVsIHJhdGlvXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fY2FudmFzLndpZHRoID0gd2lkdGggKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cbiAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICBfY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLl9jb250ZXh0O1xuICAgICAgX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXQgaGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBwaXhlbCByYXRpb1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgX2NvbnRleHQgPSB0aGlzLmdldENvbnRleHQoKS5fY29udGV4dDtcbiAgICAgIF9jb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IHdpZHRoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcn0gd2lkdGhcbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBoZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2V0IHNpemVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5zZXRXaWR0aCh3aWR0aCk7XG4gICAgICB0aGlzLnNldEhlaWdodChoZWlnaHQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogdG8gZGF0YSB1cmxcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbGl0eSBiZXR3ZWVuIDAgYW5kIDEgZm9yIGpwZyBtaW1lIHR5cGVzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gZGF0YSB1cmwgc3RyaW5nXG4gICAgICovXG4gICAgdG9EYXRhVVJMOiBmdW5jdGlvbihtaW1lVHlwZSwgcXVhbGl0eSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgdGhpcyBjYWxsIGZhaWxzIChkdWUgdG8gYnJvd3NlciBidWcsIGxpa2UgaW4gRmlyZWZveCAzLjYpLFxuICAgICAgICAvLyB0aGVuIHJldmVydCB0byBwcmV2aW91cyBuby1wYXJhbWV0ZXIgaW1hZ2UvcG5nIGJlaGF2aW9yXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlLCBxdWFsaXR5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ1VuYWJsZSB0byBnZXQgZGF0YSBVUkwuICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLlNjZW5lQ2FudmFzID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdmFyIGNvbmYgPSBjb25maWcgfHwge307XG4gICAgdmFyIHdpZHRoID0gY29uZi53aWR0aCB8fCAwLFxuICAgICAgaGVpZ2h0ID0gY29uZi5oZWlnaHQgfHwgMDtcblxuICAgIEtvbnZhLkNhbnZhcy5jYWxsKHRoaXMsIGNvbmYpO1xuICAgIHRoaXMuY29udGV4dCA9IG5ldyBLb252YS5TY2VuZUNvbnRleHQodGhpcyk7XG4gICAgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuXG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlNjZW5lQ2FudmFzLCBLb252YS5DYW52YXMpO1xuXG4gIEtvbnZhLkhpdENhbnZhcyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuICAgIHZhciB3aWR0aCA9IGNvbmYud2lkdGggfHwgMCxcbiAgICAgIGhlaWdodCA9IGNvbmYuaGVpZ2h0IHx8IDA7XG5cbiAgICBLb252YS5DYW52YXMuY2FsbCh0aGlzLCBjb25mKTtcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgS29udmEuSGl0Q29udGV4dCh0aGlzKTtcbiAgICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5oaXRDYW52YXMgPSB0cnVlO1xuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5IaXRDYW52YXMsIEtvbnZhLkNhbnZhcyk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIENPTU1BID0gJywnLFxuICAgIE9QRU5fUEFSRU4gPSAnKCcsXG4gICAgQ0xPU0VfUEFSRU4gPSAnKScsXG4gICAgT1BFTl9QQVJFTl9CUkFDS0VUID0gJyhbJyxcbiAgICBDTE9TRV9CUkFDS0VUX1BBUkVOID0gJ10pJyxcbiAgICBTRU1JQ09MT04gPSAnOycsXG4gICAgRE9VQkxFX1BBUkVOID0gJygpJyxcbiAgICAvLyBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICBFUVVBTFMgPSAnPScsXG4gICAgLy8gU0VUID0gJ3NldCcsXG4gICAgQ09OVEVYVF9NRVRIT0RTID0gW1xuICAgICAgJ2FyYycsXG4gICAgICAnYXJjVG8nLFxuICAgICAgJ2JlZ2luUGF0aCcsXG4gICAgICAnYmV6aWVyQ3VydmVUbycsXG4gICAgICAnY2xlYXJSZWN0JyxcbiAgICAgICdjbGlwJyxcbiAgICAgICdjbG9zZVBhdGgnLFxuICAgICAgJ2NyZWF0ZUxpbmVhckdyYWRpZW50JyxcbiAgICAgICdjcmVhdGVQYXR0ZXJuJyxcbiAgICAgICdjcmVhdGVSYWRpYWxHcmFkaWVudCcsXG4gICAgICAnZHJhd0ltYWdlJyxcbiAgICAgICdmaWxsJyxcbiAgICAgICdmaWxsVGV4dCcsXG4gICAgICAnZ2V0SW1hZ2VEYXRhJyxcbiAgICAgICdjcmVhdGVJbWFnZURhdGEnLFxuICAgICAgJ2xpbmVUbycsXG4gICAgICAnbW92ZVRvJyxcbiAgICAgICdwdXRJbWFnZURhdGEnLFxuICAgICAgJ3F1YWRyYXRpY0N1cnZlVG8nLFxuICAgICAgJ3JlY3QnLFxuICAgICAgJ3Jlc3RvcmUnLFxuICAgICAgJ3JvdGF0ZScsXG4gICAgICAnc2F2ZScsXG4gICAgICAnc2NhbGUnLFxuICAgICAgJ3NldExpbmVEYXNoJyxcbiAgICAgICdzZXRUcmFuc2Zvcm0nLFxuICAgICAgJ3N0cm9rZScsXG4gICAgICAnc3Ryb2tlVGV4dCcsXG4gICAgICAndHJhbnNmb3JtJyxcbiAgICAgICd0cmFuc2xhdGUnXG4gICAgXTtcblxuICB2YXIgQ09OVEVYVF9QUk9QRVJUSUVTID0gW1xuICAgICdmaWxsU3R5bGUnLFxuICAgICdzdHJva2VTdHlsZScsXG4gICAgJ3NoYWRvd0NvbG9yJyxcbiAgICAnc2hhZG93Qmx1cicsXG4gICAgJ3NoYWRvd09mZnNldFgnLFxuICAgICdzaGFkb3dPZmZzZXRZJyxcbiAgICAnbGluZUNhcCcsXG4gICAgJ2xpbmVEYXNoT2Zmc2V0JyxcbiAgICAnbGluZUpvaW4nLFxuICAgICdsaW5lV2lkdGgnLFxuICAgICdtaXRlckxpbWl0JyxcbiAgICAnZm9udCcsXG4gICAgJ3RleHRBbGlnbicsXG4gICAgJ3RleHRCYXNlbGluZScsXG4gICAgJ2dsb2JhbEFscGhhJyxcbiAgICAnZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uJ1xuICBdO1xuXG4gIC8qKlxuICAgKiBDYW52YXMgQ29udGV4dCBjb25zdHJ1Y3RvclxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGFic3RyYWN0XG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKi9cbiAgS29udmEuQ29udGV4dCA9IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIHRoaXMuaW5pdChjYW52YXMpO1xuICB9O1xuXG4gIEtvbnZhLkNvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gY2FudmFzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgaWYgKEtvbnZhLmVuYWJsZVRyYWNlKSB7XG4gICAgICAgIHRoaXMudHJhY2VBcnIgPSBbXTtcbiAgICAgICAgdGhpcy5fZW5hYmxlVHJhY2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGZpbGwgc2hhcGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtLb252YS5TaGFwZX0gc2hhcGVcbiAgICAgKi9cbiAgICBmaWxsU2hhcGU6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICBpZiAoc2hhcGUuZ2V0RmlsbEVuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLl9maWxsKHNoYXBlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHN0cm9rZSBzaGFwZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0tvbnZhLlNoYXBlfSBzaGFwZVxuICAgICAqL1xuICAgIHN0cm9rZVNoYXBlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgaWYgKHNoYXBlLmdldFN0cm9rZUVuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLl9zdHJva2Uoc2hhcGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogZmlsbCB0aGVuIHN0cm9rZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0tvbnZhLlNoYXBlfSBzaGFwZVxuICAgICAqL1xuICAgIGZpbGxTdHJva2VTaGFwZTogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciBmaWxsRW5hYmxlZCA9IHNoYXBlLmdldEZpbGxFbmFibGVkKCk7XG4gICAgICBpZiAoZmlsbEVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fZmlsbChzaGFwZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGUuZ2V0U3Ryb2tlRW5hYmxlZCgpKSB7XG4gICAgICAgIHRoaXMuX3N0cm9rZShzaGFwZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgY29udGV4dCB0cmFjZSBpZiB0cmFjZSBpcyBlbmFibGVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVsYXhlZCBpZiBmYWxzZSwgcmV0dXJuIHN0cmljdCBjb250ZXh0IHRyYWNlLCB3aGljaCBpbmNsdWRlcyBtZXRob2QgbmFtZXMsIG1ldGhvZCBwYXJhbWV0ZXJzXG4gICAgICogIHByb3BlcnRpZXMsIGFuZCBwcm9wZXJ0eSB2YWx1ZXMuICBJZiB0cnVlLCByZXR1cm4gcmVsYXhlZCBjb250ZXh0IHRyYWNlLCB3aGljaCBvbmx5IHJldHVybnMgbWV0aG9kIG5hbWVzIGFuZFxuICAgICAqICBwcm9wZXJpdGVzLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0VHJhY2U6IGZ1bmN0aW9uKHJlbGF4ZWQpIHtcbiAgICAgIHZhciB0cmFjZUFyciA9IHRoaXMudHJhY2VBcnIsXG4gICAgICAgIGxlbiA9IHRyYWNlQXJyLmxlbmd0aCxcbiAgICAgICAgc3RyID0gJycsXG4gICAgICAgIG4sXG4gICAgICAgIHRyYWNlLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGFyZ3M7XG5cbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICB0cmFjZSA9IHRyYWNlQXJyW25dO1xuICAgICAgICBtZXRob2QgPSB0cmFjZS5tZXRob2Q7XG5cbiAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgYXJncyA9IHRyYWNlLmFyZ3M7XG4gICAgICAgICAgc3RyICs9IG1ldGhvZDtcbiAgICAgICAgICBpZiAocmVsYXhlZCkge1xuICAgICAgICAgICAgc3RyICs9IERPVUJMRV9QQVJFTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgc3RyICs9XG4gICAgICAgICAgICAgICAgT1BFTl9QQVJFTl9CUkFDS0VUICsgYXJncy5qb2luKENPTU1BKSArIENMT1NFX0JSQUNLRVRfUEFSRU47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgKz0gT1BFTl9QQVJFTiArIGFyZ3Muam9pbihDT01NQSkgKyBDTE9TRV9QQVJFTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICAgIHN0ciArPSB0cmFjZS5wcm9wZXJ0eTtcbiAgICAgICAgICBpZiAoIXJlbGF4ZWQpIHtcbiAgICAgICAgICAgIHN0ciArPSBFUVVBTFMgKyB0cmFjZS52YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IFNFTUlDT0xPTjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNsZWFyIHRyYWNlIGlmIHRyYWNlIGlzIGVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJUcmFjZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRyYWNlQXJyID0gW107XG4gICAgfSxcbiAgICBfdHJhY2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIHRyYWNlQXJyID0gdGhpcy50cmFjZUFycixcbiAgICAgICAgbGVuO1xuXG4gICAgICB0cmFjZUFyci5wdXNoKHN0cik7XG4gICAgICBsZW4gPSB0cmFjZUFyci5sZW5ndGg7XG5cbiAgICAgIGlmIChsZW4gPj0gS29udmEudHJhY2VBcnJNYXgpIHtcbiAgICAgICAgdHJhY2VBcnIuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHJlc2V0IGNhbnZhcyBjb250ZXh0IHRyYW5zZm9ybVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMuZ2V0Q2FudmFzKCkuZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oMSAqIHBpeGVsUmF0aW8sIDAsIDAsIDEgKiBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBjYW52YXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLkNhbnZhc31cbiAgICAgKi9cbiAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY2xlYXIgY2FudmFzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYm91bmRzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy5oZWlnaHRdXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG5cbiAgICAgIGlmIChib3VuZHMpIHtcbiAgICAgICAgdGhpcy5jbGVhclJlY3QoXG4gICAgICAgICAgYm91bmRzLnggfHwgMCxcbiAgICAgICAgICBib3VuZHMueSB8fCAwLFxuICAgICAgICAgIGJvdW5kcy53aWR0aCB8fCAwLFxuICAgICAgICAgIGJvdW5kcy5oZWlnaHQgfHwgMFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbGVhclJlY3QoXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNhbnZhcy5nZXRXaWR0aCgpIC8gY2FudmFzLnBpeGVsUmF0aW8sXG4gICAgICAgICAgY2FudmFzLmdldEhlaWdodCgpIC8gY2FudmFzLnBpeGVsUmF0aW9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9hcHBseUxpbmVDYXA6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgbGluZUNhcCA9IHNoYXBlLmdldExpbmVDYXAoKTtcbiAgICAgIGlmIChsaW5lQ2FwKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cignbGluZUNhcCcsIGxpbmVDYXApO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FwcGx5T3BhY2l0eTogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciBhYnNPcGFjaXR5ID0gc2hhcGUuZ2V0QWJzb2x1dGVPcGFjaXR5KCk7XG4gICAgICBpZiAoYWJzT3BhY2l0eSAhPT0gMSkge1xuICAgICAgICB0aGlzLnNldEF0dHIoJ2dsb2JhbEFscGhhJywgYWJzT3BhY2l0eSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfYXBwbHlMaW5lSm9pbjogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciBsaW5lSm9pbiA9IHNoYXBlLmdldExpbmVKb2luKCk7XG4gICAgICBpZiAobGluZUpvaW4pIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyKCdsaW5lSm9pbicsIGxpbmVKb2luKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldEF0dHI6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgICAgdGhpcy5fY29udGV4dFthdHRyXSA9IHZhbDtcbiAgICB9LFxuXG4gICAgLy8gY29udGV4dCBwYXNzIHRocm91Z2ggbWV0aG9kc1xuICAgIGFyYzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQuYXJjKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgIH0sXG4gICAgYmVnaW5QYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfSxcbiAgICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgIH0sXG4gICAgY2xlYXJSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5jbGVhclJlY3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgfSxcbiAgICBjbGlwOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQuY2xpcCgpO1xuICAgIH0sXG4gICAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICBpZiAoYS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKGFbMF0sIGFbMV0pO1xuICAgICAgfSBlbHNlIGlmIChhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVJbWFnZURhdGEoYVswXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVMaW5lYXJHcmFkaWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgIH0sXG4gICAgY3JlYXRlUGF0dGVybjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZVBhdHRlcm4oYVswXSwgYVsxXSk7XG4gICAgfSxcbiAgICBjcmVhdGVSYWRpYWxHcmFkaWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICBhWzBdLFxuICAgICAgICBhWzFdLFxuICAgICAgICBhWzJdLFxuICAgICAgICBhWzNdLFxuICAgICAgICBhWzRdLFxuICAgICAgICBhWzVdXG4gICAgICApO1xuICAgIH0sXG4gICAgZHJhd0ltYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzLFxuICAgICAgICBfY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICAgIGlmIChhLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBfY29udGV4dC5kcmF3SW1hZ2UoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgICB9IGVsc2UgaWYgKGEubGVuZ3RoID09PSA1KSB7XG4gICAgICAgIF9jb250ZXh0LmRyYXdJbWFnZShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdKTtcbiAgICAgIH0gZWxzZSBpZiAoYS5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgIGFbMF0sXG4gICAgICAgICAgYVsxXSxcbiAgICAgICAgICBhWzJdLFxuICAgICAgICAgIGFbM10sXG4gICAgICAgICAgYVs0XSxcbiAgICAgICAgICBhWzVdLFxuICAgICAgICAgIGFbNl0sXG4gICAgICAgICAgYVs3XSxcbiAgICAgICAgICBhWzhdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1BvaW50SW5QYXRoOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5pc1BvaW50SW5QYXRoKHgsIHkpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmZpbGwoKTtcbiAgICB9LFxuICAgIGZpbGxSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgc3Ryb2tlUmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5fY29udGV4dC5zdHJva2VSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgZmlsbFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgIH0sXG4gICAgbWVhc3VyZVRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgIH0sXG4gICAgZ2V0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW1hZ2VEYXRhKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgIH0sXG4gICAgbGluZVRvOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oYVswXSwgYVsxXSk7XG4gICAgfSxcbiAgICBtb3ZlVG86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyhhWzBdLCBhWzFdKTtcbiAgICB9LFxuICAgIHJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LnJlY3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgfSxcbiAgICBwdXRJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LnB1dEltYWdlRGF0YShhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICB9LFxuICAgIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgfSxcbiAgICByZXN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgcm90YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5yb3RhdGUoYVswXSk7XG4gICAgfSxcbiAgICBzYXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQuc2F2ZSgpO1xuICAgIH0sXG4gICAgc2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LnNjYWxlKGFbMF0sIGFbMV0pO1xuICAgIH0sXG4gICAgc2V0TGluZURhc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHMsXG4gICAgICAgIF9jb250ZXh0ID0gdGhpcy5fY29udGV4dDtcblxuICAgICAgLy8gd29ya3MgZm9yIENocm9tZSBhbmQgSUUxMVxuICAgICAgaWYgKHRoaXMuX2NvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgX2NvbnRleHQuc2V0TGluZURhc2goYVswXSk7XG4gICAgICB9IGVsc2UgaWYgKCdtb3pEYXNoJyBpbiBfY29udGV4dCkge1xuICAgICAgICAvLyB2ZXJpZmllZCB0aGF0IHRoaXMgd29ya3MgaW4gZmlyZWZveFxuICAgICAgICBfY29udGV4dC5tb3pEYXNoID0gYVswXTtcbiAgICAgIH0gZWxzZSBpZiAoJ3dlYmtpdExpbmVEYXNoJyBpbiBfY29udGV4dCkge1xuICAgICAgICAvLyBkb2VzIG5vdCBjdXJyZW50bHkgd29yayBmb3IgU2FmYXJpXG4gICAgICAgIF9jb250ZXh0LndlYmtpdExpbmVEYXNoID0gYVswXTtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gc3VwcG9ydCBmb3IgSUU5IGFuZCBJRTEwXG4gICAgfSxcbiAgICBnZXRMaW5lRGFzaDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRMaW5lRGFzaCgpO1xuICAgIH0sXG4gICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5zZXRUcmFuc2Zvcm0oYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XG4gICAgfSxcbiAgICBzdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY29udGV4dC5zdHJva2UoKTtcbiAgICB9LFxuICAgIHN0cm9rZVRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZVRleHQoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LnRyYW5zZm9ybShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcbiAgICB9LFxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQudHJhbnNsYXRlKGFbMF0sIGFbMV0pO1xuICAgIH0sXG4gICAgX2VuYWJsZVRyYWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgbGVuID0gQ09OVEVYVF9NRVRIT0RTLmxlbmd0aCxcbiAgICAgICAgX3NpbXBsaWZ5QXJyYXkgPSBLb252YS5VdGlsLl9zaW1wbGlmeUFycmF5LFxuICAgICAgICBvcmlnU2V0dGVyID0gdGhpcy5zZXRBdHRyLFxuICAgICAgICBuLFxuICAgICAgICBhcmdzO1xuXG4gICAgICAvLyB0byBwcmV2ZW50IGNyZWF0aW5nIHNjb3BlIGZ1bmN0aW9uIGF0IGVhY2ggbG9vcFxuICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBvcmlnTWV0aG9kID0gdGhhdFttZXRob2ROYW1lXSxcbiAgICAgICAgICByZXQ7XG5cbiAgICAgICAgdGhhdFttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGFyZ3MgPSBfc2ltcGxpZnlBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgICByZXQgPSBvcmlnTWV0aG9kLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICB0aGF0Ll90cmFjZSh7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIC8vIG1ldGhvZHNcbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICBmdW5jKENPTlRFWFRfTUVUSE9EU1tuXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGF0dHJzXG4gICAgICB0aGF0LnNldEF0dHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgb3JpZ1NldHRlci5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcHJvcCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AgPT09ICdzaGFkb3dPZmZzZXRYJyB8fFxuICAgICAgICAgIHByb3AgPT09ICdzaGFkb3dPZmZzZXRZJyB8fFxuICAgICAgICAgIHByb3AgPT09ICdzaGFkb3dCbHVyJ1xuICAgICAgICApIHtcbiAgICAgICAgICB2YWwgPSB2YWwgLyB0aGlzLmNhbnZhcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fdHJhY2Uoe1xuICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgIHZhbDogdmFsXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgQ09OVEVYVF9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLb252YS5Db250ZXh0LnByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHRbcHJvcF07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dFtwcm9wXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgS29udmEuU2NlbmVDb250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgS29udmEuQ29udGV4dC5jYWxsKHRoaXMsIGNhbnZhcyk7XG4gIH07XG5cbiAgS29udmEuU2NlbmVDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBfZmlsbENvbG9yOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIGZpbGwgPSBzaGFwZS5maWxsKCk7XG5cbiAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgZmlsbCk7XG4gICAgICBzaGFwZS5fZmlsbEZ1bmModGhpcyk7XG4gICAgfSxcbiAgICBfZmlsbFBhdHRlcm46IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgZmlsbFBhdHRlcm5YID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5YKCksXG4gICAgICAgIGZpbGxQYXR0ZXJuWSA9IHNoYXBlLmdldEZpbGxQYXR0ZXJuWSgpLFxuICAgICAgICBmaWxsUGF0dGVyblNjYWxlID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5TY2FsZSgpLFxuICAgICAgICBmaWxsUGF0dGVyblJvdGF0aW9uID0gS29udmEuZ2V0QW5nbGUoc2hhcGUuZ2V0RmlsbFBhdHRlcm5Sb3RhdGlvbigpKSxcbiAgICAgICAgZmlsbFBhdHRlcm5PZmZzZXQgPSBzaGFwZS5nZXRGaWxsUGF0dGVybk9mZnNldCgpO1xuXG4gICAgICBpZiAoZmlsbFBhdHRlcm5YIHx8IGZpbGxQYXR0ZXJuWSkge1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZShmaWxsUGF0dGVyblggfHwgMCwgZmlsbFBhdHRlcm5ZIHx8IDApO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxQYXR0ZXJuUm90YXRpb24pIHtcbiAgICAgICAgdGhpcy5yb3RhdGUoZmlsbFBhdHRlcm5Sb3RhdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFBhdHRlcm5TY2FsZSkge1xuICAgICAgICB0aGlzLnNjYWxlKGZpbGxQYXR0ZXJuU2NhbGUueCwgZmlsbFBhdHRlcm5TY2FsZS55KTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsUGF0dGVybk9mZnNldCkge1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZSgtMSAqIGZpbGxQYXR0ZXJuT2Zmc2V0LngsIC0xICogZmlsbFBhdHRlcm5PZmZzZXQueSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0QXR0cihcbiAgICAgICAgJ2ZpbGxTdHlsZScsXG4gICAgICAgIHRoaXMuY3JlYXRlUGF0dGVybihcbiAgICAgICAgICBzaGFwZS5nZXRGaWxsUGF0dGVybkltYWdlKCksXG4gICAgICAgICAgc2hhcGUuZ2V0RmlsbFBhdHRlcm5SZXBlYXQoKSB8fCAncmVwZWF0J1xuICAgICAgICApXG4gICAgICApO1xuICAgICAgdGhpcy5maWxsKCk7XG4gICAgfSxcbiAgICBfZmlsbExpbmVhckdyYWRpZW50OiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIHN0YXJ0ID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCgpLFxuICAgICAgICBlbmQgPSBzaGFwZS5nZXRGaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludCgpLFxuICAgICAgICBjb2xvclN0b3BzID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcygpLFxuICAgICAgICBncmQgPSB0aGlzLmNyZWF0ZUxpbmVhckdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIGVuZC54LCBlbmQueSk7XG5cbiAgICAgIGlmIChjb2xvclN0b3BzKSB7XG4gICAgICAgIC8vIGJ1aWxkIGNvbG9yIHN0b3BzXG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY29sb3JTdG9wcy5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wc1tuXSwgY29sb3JTdG9wc1tuICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgZ3JkKTtcbiAgICAgICAgc2hhcGUuX2ZpbGxGdW5jKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2ZpbGxSYWRpYWxHcmFkaWVudDogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciBzdGFydCA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoKSxcbiAgICAgICAgZW5kID0gc2hhcGUuZ2V0RmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQoKSxcbiAgICAgICAgc3RhcnRSYWRpdXMgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1cygpLFxuICAgICAgICBlbmRSYWRpdXMgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMoKSxcbiAgICAgICAgY29sb3JTdG9wcyA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKSxcbiAgICAgICAgZ3JkID0gdGhpcy5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgICBzdGFydC54LFxuICAgICAgICAgIHN0YXJ0LnksXG4gICAgICAgICAgc3RhcnRSYWRpdXMsXG4gICAgICAgICAgZW5kLngsXG4gICAgICAgICAgZW5kLnksXG4gICAgICAgICAgZW5kUmFkaXVzXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGJ1aWxkIGNvbG9yIHN0b3BzXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNvbG9yU3RvcHMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgZ3JkLmFkZENvbG9yU3RvcChjb2xvclN0b3BzW25dLCBjb2xvclN0b3BzW24gKyAxXSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIGdyZCk7XG4gICAgICB0aGlzLmZpbGwoKTtcbiAgICB9LFxuICAgIF9maWxsOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIGhhc0NvbG9yID0gc2hhcGUuZmlsbCgpLFxuICAgICAgICBmaWxsUHJpb3JpdHkgPSBzaGFwZS5nZXRGaWxsUHJpb3JpdHkoKTtcblxuICAgICAgLy8gcHJpb3JpdHkgZmlsbHNcbiAgICAgIGlmIChoYXNDb2xvciAmJiBmaWxsUHJpb3JpdHkgPT09ICdjb2xvcicpIHtcbiAgICAgICAgdGhpcy5fZmlsbENvbG9yKHNoYXBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzUGF0dGVybiA9IHNoYXBlLmdldEZpbGxQYXR0ZXJuSW1hZ2UoKTtcbiAgICAgIGlmIChoYXNQYXR0ZXJuICYmIGZpbGxQcmlvcml0eSA9PT0gJ3BhdHRlcm4nKSB7XG4gICAgICAgIHRoaXMuX2ZpbGxQYXR0ZXJuKHNoYXBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzTGluZWFyR3JhZGllbnQgPSBzaGFwZS5nZXRGaWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAgICBpZiAoaGFzTGluZWFyR3JhZGllbnQgJiYgZmlsbFByaW9yaXR5ID09PSAnbGluZWFyLWdyYWRpZW50Jykge1xuICAgICAgICB0aGlzLl9maWxsTGluZWFyR3JhZGllbnQoc2hhcGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNSYWRpYWxHcmFkaWVudCA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKTtcbiAgICAgIGlmIChoYXNSYWRpYWxHcmFkaWVudCAmJiBmaWxsUHJpb3JpdHkgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgICAgIHRoaXMuX2ZpbGxSYWRpYWxHcmFkaWVudChzaGFwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbm93IGp1c3QgdHJ5IGFuZCBmaWxsIHdpdGggd2hhdGV2ZXIgaXMgYXZhaWxhYmxlXG4gICAgICBpZiAoaGFzQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fZmlsbENvbG9yKHNoYXBlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzUGF0dGVybikge1xuICAgICAgICB0aGlzLl9maWxsUGF0dGVybihzaGFwZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0xpbmVhckdyYWRpZW50KSB7XG4gICAgICAgIHRoaXMuX2ZpbGxMaW5lYXJHcmFkaWVudChzaGFwZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc1JhZGlhbEdyYWRpZW50KSB7XG4gICAgICAgIHRoaXMuX2ZpbGxSYWRpYWxHcmFkaWVudChzaGFwZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfc3Ryb2tlTGluZWFyR3JhZGllbnQ6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgc3RhcnQgPSBzaGFwZS5nZXRTdHJva2VMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQoKSxcbiAgICAgICAgZW5kID0gc2hhcGUuZ2V0U3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludCgpLFxuICAgICAgICBjb2xvclN0b3BzID0gc2hhcGUuZ2V0U3Ryb2tlTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCksXG4gICAgICAgIGdyZCA9IHRoaXMuY3JlYXRlTGluZWFyR3JhZGllbnQoc3RhcnQueCwgc3RhcnQueSwgZW5kLngsIGVuZC55KTtcblxuICAgICAgaWYgKGNvbG9yU3RvcHMpIHtcbiAgICAgICAgLy8gYnVpbGQgY29sb3Igc3RvcHNcbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjb2xvclN0b3BzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcChjb2xvclN0b3BzW25dLCBjb2xvclN0b3BzW24gKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdHRyKCdzdHJva2VTdHlsZScsIGdyZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfc3Ryb2tlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIGRhc2ggPSBzaGFwZS5kYXNoKCksXG4gICAgICAgIC8vIGlnbm9yZSBzdHJva2VTY2FsZUVuYWJsZWQgZm9yIFRleHRcbiAgICAgICAgc3Ryb2tlU2NhbGVFbmFibGVkID1cbiAgICAgICAgICBzaGFwZS5nZXRTdHJva2VTY2FsZUVuYWJsZWQoKSB8fCBzaGFwZSBpbnN0YW5jZW9mIEtvbnZhLlRleHQ7XG5cbiAgICAgIGlmIChzaGFwZS5oYXNTdHJva2UoKSkge1xuICAgICAgICBpZiAoIXN0cm9rZVNjYWxlRW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXBwbHlMaW5lQ2FwKHNoYXBlKTtcbiAgICAgICAgaWYgKGRhc2ggJiYgc2hhcGUuZGFzaEVuYWJsZWQoKSkge1xuICAgICAgICAgIHRoaXMuc2V0TGluZURhc2goZGFzaCk7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyKCdsaW5lRGFzaE9mZnNldCcsIHNoYXBlLmRhc2hPZmZzZXQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVXaWR0aCcsIHNoYXBlLnN0cm9rZVdpZHRoKCkpO1xuXG4gICAgICAgIGlmICghc2hhcGUuZ2V0U2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dDb2xvcicsICdyZ2JhKDAsMCwwLDApJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIC0gZG8gd2UgbmVlZCB0byBtYWtlIGxpa2UgYSBmaWxsIGZ1bmN0aW9uP1xuXG4gICAgICAgIHZhciBoYXNMaW5lYXJHcmFkaWVudCA9IHNoYXBlLmdldFN0cm9rZUxpbmVhckdyYWRpZW50Q29sb3JTdG9wcygpO1xuICAgICAgICBpZiAoaGFzTGluZWFyR3JhZGllbnQpIHtcbiAgICAgICAgICB0aGlzLl9zdHJva2VMaW5lYXJHcmFkaWVudChzaGFwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyKCdzdHJva2VTdHlsZScsIHNoYXBlLnN0cm9rZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNoYXBlLl9zdHJva2VGdW5jKHRoaXMpO1xuXG4gICAgICAgIGlmICghc3Ryb2tlU2NhbGVFbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF9hcHBseVNoYWRvdzogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciB1dGlsID0gS29udmEuVXRpbCxcbiAgICAgICAgY29sb3IgPSB1dGlsLmdldChzaGFwZS5nZXRTaGFkb3dSR0JBKCksICdibGFjaycpLFxuICAgICAgICBibHVyID0gdXRpbC5nZXQoc2hhcGUuZ2V0U2hhZG93Qmx1cigpLCA1KSxcbiAgICAgICAgb2Zmc2V0ID0gdXRpbC5nZXQoc2hhcGUuZ2V0U2hhZG93T2Zmc2V0KCksIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSksXG4gICAgICAgIHNjYWxlID0gc2hhcGUuZ2V0QWJzb2x1dGVTY2FsZSgpLFxuICAgICAgICByYXRpbyA9IHRoaXMuY2FudmFzLmdldFBpeGVsUmF0aW8oKSxcbiAgICAgICAgc2NhbGVYID0gc2NhbGUueCAqIHJhdGlvLFxuICAgICAgICBzY2FsZVkgPSBzY2FsZS55ICogcmF0aW87XG5cbiAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93Q29sb3InLCBjb2xvcik7XG4gICAgICB0aGlzLnNldEF0dHIoXG4gICAgICAgICdzaGFkb3dCbHVyJyxcbiAgICAgICAgYmx1ciAqIE1hdGgubWluKE1hdGguYWJzKHNjYWxlWCksIE1hdGguYWJzKHNjYWxlWSkpXG4gICAgICApO1xuICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dPZmZzZXRYJywgb2Zmc2V0LnggKiBzY2FsZVgpO1xuICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dPZmZzZXRZJywgb2Zmc2V0LnkgKiBzY2FsZVkpO1xuICAgIH0sXG4gICAgX2FwcGx5R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHNoYXBlLmdldEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbigpO1xuICAgICAgaWYgKGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiAhPT0gJ3NvdXJjZS1vdmVyJykge1xuICAgICAgICB0aGlzLnNldEF0dHIoJ2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbicsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5TY2VuZUNvbnRleHQsIEtvbnZhLkNvbnRleHQpO1xuXG4gIEtvbnZhLkhpdENvbnRleHQgPSBmdW5jdGlvbihjYW52YXMpIHtcbiAgICBLb252YS5Db250ZXh0LmNhbGwodGhpcywgY2FudmFzKTtcbiAgfTtcblxuICBLb252YS5IaXRDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBfZmlsbDogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgdGhpcy5zZXRBdHRyKCdmaWxsU3R5bGUnLCBzaGFwZS5jb2xvcktleSk7XG4gICAgICBzaGFwZS5fZmlsbEZ1bmNIaXQodGhpcyk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIF9zdHJva2U6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICBpZiAoc2hhcGUuaGFzU3Ryb2tlKCkgJiYgc2hhcGUuc3Ryb2tlSGl0RW5hYmxlZCgpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBzdHJva2VTY2FsZUVuYWJsZWQgZm9yIFRleHRcbiAgICAgICAgdmFyIHN0cm9rZVNjYWxlRW5hYmxlZCA9XG4gICAgICAgICAgc2hhcGUuZ2V0U3Ryb2tlU2NhbGVFbmFibGVkKCkgfHwgc2hhcGUgaW5zdGFuY2VvZiBLb252YS5UZXh0O1xuICAgICAgICBpZiAoIXN0cm9rZVNjYWxlRW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FwcGx5TGluZUNhcChzaGFwZSk7XG4gICAgICAgIHRoaXMuc2V0QXR0cignbGluZVdpZHRoJywgc2hhcGUuc3Ryb2tlV2lkdGgoKSk7XG4gICAgICAgIHRoaXMuc2V0QXR0cignc3Ryb2tlU3R5bGUnLCBzaGFwZS5jb2xvcktleSk7XG4gICAgICAgIHNoYXBlLl9zdHJva2VGdW5jSGl0KHRoaXMpO1xuICAgICAgICBpZiAoIXN0cm9rZVNjYWxlRW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5IaXRDb250ZXh0LCBLb252YS5Db250ZXh0KTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBDT05TVEFOVFNcbiAgdmFyIEdFVCA9ICdnZXQnLFxuICAgIFNFVCA9ICdzZXQnO1xuXG4gIEtvbnZhLkZhY3RvcnkgPSB7XG4gICAgYWRkR2V0dGVyU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmLCB2YWxpZGF0b3IsIGFmdGVyKSB7XG4gICAgICB0aGlzLmFkZEdldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmKTtcbiAgICAgIHRoaXMuYWRkU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyLCB2YWxpZGF0b3IsIGFmdGVyKTtcbiAgICAgIHRoaXMuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihjb25zdHJ1Y3RvciwgYXR0cik7XG4gICAgfSxcbiAgICBhZGRHZXR0ZXI6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBhdHRyLCBkZWYpIHtcbiAgICAgIHZhciBtZXRob2QgPSBHRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpO1xuXG4gICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5hdHRyc1thdHRyXTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmIDogdmFsO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIHZhbGlkYXRvciwgYWZ0ZXIpIHtcbiAgICAgIC8vIGlmICghdmFsaWRhdG9yICYmIHZhbGlkYXRvciAhPT0gbnVsbCkge1xuICAgICAgLy8gICBjb25zb2xlLmVycm9yKGNvbnN0cnVjdG9yLCBhdHRyLCAnaGFzIG5vIHZhbGlkYXRvci4nKTtcbiAgICAgIC8vIH1cbiAgICAgIHZhciBtZXRob2QgPSBTRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpO1xuXG4gICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAodmFsaWRhdG9yICYmIHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhbCA9IHZhbGlkYXRvci5jYWxsKHRoaXMsIHZhbCwgYXR0cik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRBdHRyKGF0dHIsIHZhbCk7XG5cbiAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgYWZ0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXI6IGZ1bmN0aW9uKFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBhdHRyLFxuICAgICAgY29tcG9uZW50cyxcbiAgICAgIHZhbGlkYXRvcixcbiAgICAgIGFmdGVyXG4gICAgKSB7XG4gICAgICB2YXIgbGVuID0gY29tcG9uZW50cy5sZW5ndGgsXG4gICAgICAgIGNhcGl0YWxpemUgPSBLb252YS5VdGlsLl9jYXBpdGFsaXplLFxuICAgICAgICBnZXR0ZXIgPSBHRVQgKyBjYXBpdGFsaXplKGF0dHIpLFxuICAgICAgICBzZXR0ZXIgPSBTRVQgKyBjYXBpdGFsaXplKGF0dHIpLFxuICAgICAgICBuLFxuICAgICAgICBjb21wb25lbnQ7XG5cbiAgICAgIC8vIGdldHRlclxuICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW2dldHRlcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuXG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbbl07XG4gICAgICAgICAgcmV0W2NvbXBvbmVudF0gPSB0aGlzLmdldEF0dHIoYXR0ciArIGNhcGl0YWxpemUoY29tcG9uZW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcblxuICAgICAgLy8gc2V0dGVyXG4gICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbc2V0dGVyXSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YXIgb2xkVmFsID0gdGhpcy5hdHRyc1thdHRyXSxcbiAgICAgICAgICBrZXk7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgIHZhbCA9IHZhbGlkYXRvci5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiB2YWwpIHtcbiAgICAgICAgICBpZiAoIXZhbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2V0QXR0cihhdHRyICsgY2FwaXRhbGl6ZShrZXkpLCB2YWxba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9maXJlQ2hhbmdlRXZlbnQoYXR0ciwgb2xkVmFsLCB2YWwpO1xuXG4gICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgIGFmdGVyLmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihjb25zdHJ1Y3RvciwgYXR0cik7XG4gICAgfSxcbiAgICBhZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0cikge1xuICAgICAgdmFyIGNhcGl0YWxpemVkQXR0ciA9IEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0ciksXG4gICAgICAgIHNldHRlciA9IFNFVCArIGNhcGl0YWxpemVkQXR0cixcbiAgICAgICAgZ2V0dGVyID0gR0VUICsgY2FwaXRhbGl6ZWRBdHRyO1xuXG4gICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbYXR0cl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2V0dGluZ1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXNbc2V0dGVyXShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgcmV0dXJuIHRoaXNbZ2V0dGVyXSgpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXI6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBhdHRyLCBkZWYsIHZhbGlkYXRvcikge1xuICAgICAgS29udmEuVXRpbC5lcnJvcignQWRkaW5nIGRlcHJlY2F0ZWQgJyArIGF0dHIpO1xuXG4gICAgICB2YXIgbWV0aG9kID0gR0VUICsgS29udmEuVXRpbC5fY2FwaXRhbGl6ZShhdHRyKTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPVxuICAgICAgICBhdHRyICtcbiAgICAgICAgJyBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbi4gTG9vayBhdCBLb252YSBjaGFuZ2UgbG9nIGZvciBtb3JlIGluZm9ybWF0aW9uLic7XG4gICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBLb252YS5VdGlsLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5hdHRyc1thdHRyXTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmIDogdmFsO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyLCB2YWxpZGF0b3IsIGZ1bmN0aW9uKCkge1xuICAgICAgICBLb252YS5VdGlsLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIpO1xuICAgIH0sXG4gICAgYmFja0NvbXBhdDogZnVuY3Rpb24oY29uc3RydWN0b3IsIG1ldGhvZHMpIHtcbiAgICAgIEtvbnZhLlV0aWwuZWFjaChtZXRob2RzLCBmdW5jdGlvbihvbGRNZXRob2ROYW1lLCBuZXdNZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbmV3TWV0aG9kTmFtZV07XG4gICAgICAgIHZhciBvbGRHZXR0ZXIgPSBHRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKG9sZE1ldGhvZE5hbWUpO1xuICAgICAgICB2YXIgb2xkU2V0dGVyID0gU0VUICsgS29udmEuVXRpbC5fY2FwaXRhbGl6ZShvbGRNZXRob2ROYW1lKTtcblxuICAgICAgICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgICAgICAgIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIEtvbnZhLlV0aWwuZXJyb3IoXG4gICAgICAgICAgICAnXCInICtcbiAgICAgICAgICAgICAgb2xkTWV0aG9kTmFtZSArXG4gICAgICAgICAgICAgICdcIiBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24uIFVzZSBcIlwiJyArXG4gICAgICAgICAgICAgIG5ld01ldGhvZE5hbWUgK1xuICAgICAgICAgICAgICAnXCIgaW5zdGVhZC4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtvbGRNZXRob2ROYW1lXSA9IGRlcHJlY2F0ZWQ7XG4gICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtvbGRHZXR0ZXJdID0gZGVwcmVjYXRlZDtcbiAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW29sZFNldHRlcl0gPSBkZXByZWNhdGVkO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhZnRlclNldEZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBLb252YS5WYWxpZGF0b3JzID0ge1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBSR0JDb21wb25lbnQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICByZXR1cm4gMjU1O1xuICAgICAgfSBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICB9LFxuICAgIGFscGhhQ29tcG9uZW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIGlmICh2YWwgPiAxKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPCAwLjAwMDEpIHtcbiAgICAgICAgLy8gY2hyb21lIGRvZXMgbm90IGhvbm9yIGFscGhhIHZhbHVlcyBvZiAwXG4gICAgICAgIHJldHVybiAwLjAwMDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcbiAgICBfZm9ybWF0VmFsdWU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB2YWwgKyAnXCInO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzQm9vbGVhbih2YWwpKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCk7XG4gICAgfSxcbiAgICBnZXROdW1iZXJWYWxpZGF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKEtvbnZhLmlzVW5taW5pZmllZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsLCBhdHRyKSB7XG4gICAgICAgICAgaWYgKCFLb252YS5VdGlsLl9pc051bWJlcih2YWwpKSB7XG4gICAgICAgICAgICBLb252YS5VdGlsLndhcm4oXG4gICAgICAgICAgICAgIEtvbnZhLlZhbGlkYXRvcnMuX2Zvcm1hdFZhbHVlKHZhbCkgK1xuICAgICAgICAgICAgICAgICcgaXMgYSBub3QgdmFsaWQgdmFsdWUgZm9yIFwiJyArXG4gICAgICAgICAgICAgICAgYXR0ciArXG4gICAgICAgICAgICAgICAgJ1wiIGF0dHJpYnV0ZS4gVGhlIHZhbHVlIHNob3VsZCBiZSBhIG51bWJlci4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TnVtYmVyT3JBdXRvVmFsaWRhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChLb252YS5pc1VubWluaWZpZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbCwgYXR0cikge1xuICAgICAgICAgIHZhciBpc051bWJlciA9IEtvbnZhLlV0aWwuX2lzTnVtYmVyKHZhbCk7XG4gICAgICAgICAgdmFyIGlzQXV0byA9IHZhbCA9PT0gJ2F1dG8nO1xuXG4gICAgICAgICAgaWYgKCEoaXNOdW1iZXIgfHwgaXNBdXRvKSkge1xuICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKFxuICAgICAgICAgICAgICBLb252YS5WYWxpZGF0b3JzLl9mb3JtYXRWYWx1ZSh2YWwpICtcbiAgICAgICAgICAgICAgICAnIGlzIGEgbm90IHZhbGlkIHZhbHVlIGZvciBcIicgK1xuICAgICAgICAgICAgICAgIGF0dHIgK1xuICAgICAgICAgICAgICAgICdcIiBhdHRyaWJ1dGUuIFRoZSB2YWx1ZSBzaG91bGQgYmUgYSBudW1iZXIgb3IgXCJhdXRvXCIuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFN0cmluZ1ZhbGlkYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoS29udmEuaXNVbm1pbmlmaWVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWwsIGF0dHIpIHtcbiAgICAgICAgICBpZiAoIUtvbnZhLlV0aWwuX2lzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgICAgICAgS29udmEuVmFsaWRhdG9ycy5fZm9ybWF0VmFsdWUodmFsKSArXG4gICAgICAgICAgICAgICAgJyBpcyBhIG5vdCB2YWxpZCB2YWx1ZSBmb3IgXCInICtcbiAgICAgICAgICAgICAgICBhdHRyICtcbiAgICAgICAgICAgICAgICAnXCIgYXR0cmlidXRlLiBUaGUgdmFsdWUgc2hvdWxkIGJlIGEgc3RyaW5nLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRGdW5jdGlvblZhbGlkYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoS29udmEuaXNVbm1pbmlmaWVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWwsIGF0dHIpIHtcbiAgICAgICAgICBpZiAoIUtvbnZhLlV0aWwuX2lzRnVuY3Rpb24odmFsKSkge1xuICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKFxuICAgICAgICAgICAgICBLb252YS5WYWxpZGF0b3JzLl9mb3JtYXRWYWx1ZSh2YWwpICtcbiAgICAgICAgICAgICAgICAnIGlzIGEgbm90IHZhbGlkIHZhbHVlIGZvciBcIicgK1xuICAgICAgICAgICAgICAgIGF0dHIgK1xuICAgICAgICAgICAgICAgICdcIiBhdHRyaWJ1dGUuIFRoZSB2YWx1ZSBzaG91bGQgYmUgYSBmdW5jdGlvbi4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TnVtYmVyQXJyYXlWYWxpZGF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKEtvbnZhLmlzVW5taW5pZmllZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsLCBhdHRyKSB7XG4gICAgICAgICAgaWYgKCFLb252YS5VdGlsLl9pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgICAgICAgS29udmEuVmFsaWRhdG9ycy5fZm9ybWF0VmFsdWUodmFsKSArXG4gICAgICAgICAgICAgICAgJyBpcyBhIG5vdCB2YWxpZCB2YWx1ZSBmb3IgXCInICtcbiAgICAgICAgICAgICAgICBhdHRyICtcbiAgICAgICAgICAgICAgICAnXCIgYXR0cmlidXRlLiBUaGUgdmFsdWUgc2hvdWxkIGJlIGEgYXJyYXkgb2YgbnVtYmVycy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgIGlmICghS29udmEuVXRpbC5faXNOdW1iZXIoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oXG4gICAgICAgICAgICAgICAgICAnXCInICtcbiAgICAgICAgICAgICAgICAgICAgYXR0ciArXG4gICAgICAgICAgICAgICAgICAgICdcIiBhdHRyaWJ1dGUgaGFzIG5vbiBudW1lcmljIGVsZW1lbnQgJyArXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gK1xuICAgICAgICAgICAgICAgICAgICAnLiBNYWtlIHN1cmUgdGhhdCBhbGwgZWxlbWVudHMgYXJlIG51bWJlcnMuJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Qm9vbGVhblZhbGlkYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoS29udmEuaXNVbm1pbmlmaWVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWwsIGF0dHIpIHtcbiAgICAgICAgICB2YXIgaXNCb29sID0gdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFpc0Jvb2wpIHtcbiAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgICAgICAgS29udmEuVmFsaWRhdG9ycy5fZm9ybWF0VmFsdWUodmFsKSArXG4gICAgICAgICAgICAgICAgJyBpcyBhIG5vdCB2YWxpZCB2YWx1ZSBmb3IgXCInICtcbiAgICAgICAgICAgICAgICBhdHRyICtcbiAgICAgICAgICAgICAgICAnXCIgYXR0cmlidXRlLiBUaGUgdmFsdWUgc2hvdWxkIGJlIGEgYm9vbGVhbi4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIENPTlNUQU5UU1xuICB2YXIgQUJTT0xVVEVfT1BBQ0lUWSA9ICdhYnNvbHV0ZU9wYWNpdHknLFxuICAgIEFCU09MVVRFX1RSQU5TRk9STSA9ICdhYnNvbHV0ZVRyYW5zZm9ybScsXG4gICAgQUJTT0xVVEVfU0NBTEUgPSAnYWJzb2x1dGVTY2FsZScsXG4gICAgQ0hBTkdFID0gJ0NoYW5nZScsXG4gICAgQ0hJTERSRU4gPSAnY2hpbGRyZW4nLFxuICAgIERPVCA9ICcuJyxcbiAgICBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICBHRVQgPSAnZ2V0JyxcbiAgICBJRCA9ICdpZCcsXG4gICAgS09OVkEgPSAna29udmEnLFxuICAgIExJU1RFTklORyA9ICdsaXN0ZW5pbmcnLFxuICAgIE1PVVNFRU5URVIgPSAnbW91c2VlbnRlcicsXG4gICAgTU9VU0VMRUFWRSA9ICdtb3VzZWxlYXZlJyxcbiAgICBOQU1FID0gJ25hbWUnLFxuICAgIFNFVCA9ICdzZXQnLFxuICAgIFNIQVBFID0gJ1NoYXBlJyxcbiAgICBTUEFDRSA9ICcgJyxcbiAgICBTVEFHRSA9ICdzdGFnZScsXG4gICAgVFJBTlNGT1JNID0gJ3RyYW5zZm9ybScsXG4gICAgVVBQRVJfU1RBR0UgPSAnU3RhZ2UnLFxuICAgIFZJU0lCTEUgPSAndmlzaWJsZScsXG4gICAgQ0xPTkVfQkxBQ0tfTElTVCA9IFsnaWQnXSxcbiAgICBUUkFOU0ZPUk1fQ0hBTkdFX1NUUiA9IFtcbiAgICAgICd4Q2hhbmdlLmtvbnZhJyxcbiAgICAgICd5Q2hhbmdlLmtvbnZhJyxcbiAgICAgICdzY2FsZVhDaGFuZ2Uua29udmEnLFxuICAgICAgJ3NjYWxlWUNoYW5nZS5rb252YScsXG4gICAgICAnc2tld1hDaGFuZ2Uua29udmEnLFxuICAgICAgJ3NrZXdZQ2hhbmdlLmtvbnZhJyxcbiAgICAgICdyb3RhdGlvbkNoYW5nZS5rb252YScsXG4gICAgICAnb2Zmc2V0WENoYW5nZS5rb252YScsXG4gICAgICAnb2Zmc2V0WUNoYW5nZS5rb252YScsXG4gICAgICAndHJhbnNmb3Jtc0VuYWJsZWRDaGFuZ2Uua29udmEnXG4gICAgXS5qb2luKFNQQUNFKSxcbiAgICBTQ0FMRV9DSEFOR0VfU1RSID0gWydzY2FsZVhDaGFuZ2Uua29udmEnLCAnc2NhbGVZQ2hhbmdlLmtvbnZhJ10uam9pbihTUEFDRSk7XG5cbiAgLyoqXG4gICAqIE5vZGUgY29uc3RydWN0b3IuIE5vZGVzIGFyZSBlbnRpdGllcyB0aGF0IGNhbiBiZSB0cmFuc2Zvcm1lZCwgbGF5ZXJlZCxcbiAgICogYW5kIGhhdmUgYm91bmQgZXZlbnRzLiBUaGUgc3RhZ2UsIGxheWVycywgZ3JvdXBzLCBhbmQgc2hhcGVzIGFsbCBleHRlbmQgTm9kZS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKi9cbiAgS29udmEuTm9kZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuTm9kZSwge1xuICAgIF9pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMuX2lkID0gS29udmEuaWRDb3VudGVyKys7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0ge307XG4gICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzVW5kZXJDYWNoZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZXRBdHRycyhjb25maWcpO1xuXG4gICAgICAvLyBldmVudCBiaW5kaW5ncyBmb3IgY2FjaGUgaGFuZGxpbmdcbiAgICAgIHRoaXMub24oVFJBTlNGT1JNX0NIQU5HRV9TVFIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMub24oU0NBTEVfQ0hBTkdFX1NUUiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9TQ0FMRSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5vbigndmlzaWJsZUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoVklTSUJMRSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2xpc3RlbmluZ0NoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoTElTVEVOSU5HKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignb3BhY2l0eUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfT1BBQ0lUWSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIF9jbGVhckNhY2hlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoYXR0cikge1xuICAgICAgICBkZWxldGUgdGhpcy5fY2FjaGVbYXR0cl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldENhY2hlOiBmdW5jdGlvbihhdHRyLCBwcml2YXRlR2V0dGVyKSB7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZVthdHRyXTtcblxuICAgICAgLy8gaWYgbm90IGNhY2hlZCwgd2UgbmVlZCB0byBzZXQgaXQgdXNpbmcgdGhlIHByaXZhdGUgZ2V0dGVyIG1ldGhvZC5cbiAgICAgIGlmIChjYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlW2F0dHJdID0gcHJpdmF0ZUdldHRlci5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVbYXR0cl07XG4gICAgfSxcbiAgICAvKlxuICAgICAgICAgKiB3aGVuIHRoZSBsb2dpYyBmb3IgYSBjYWNoZWQgcmVzdWx0IGRlcGVuZHMgb24gYW5jZXN0b3IgcHJvcGFnYXRpb24sIHVzZSB0aGlzXG4gICAgICAgICAqIG1ldGhvZCB0byBjbGVhciBzZWxmIGFuZCBjaGlsZHJlbiBjYWNoZVxuICAgICAgICAgKi9cbiAgICBfY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKGF0dHIpO1xuXG4gICAgICBpZiAodGhpcy5jaGlsZHJlbikge1xuICAgICAgICB0aGlzLmdldENoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgbm9kZS5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKGF0dHIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNsZWFyIGNhY2hlZCBjYW52YXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNsZWFyQ2FjaGUoKTtcbiAgICAgKi9cbiAgICBjbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZS5jYW52YXM7XG4gICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAgY2FjaGUgbm9kZSB0byBpbXByb3ZlIGRyYXdpbmcgcGVyZm9ybWFuY2UsIGFwcGx5IGZpbHRlcnMsIG9yIGNyZWF0ZSBtb3JlIGFjY3VyYXRlXG4gICAgICogIGhpdCByZWdpb25zLiBGb3IgYWxsIGJhc2ljIHNoYXBlcyBzaXplIG9mIGNhY2hlIGNhbnZhcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQuXG4gICAgICogIElmIHlvdSBuZWVkIHRvIGNhY2hlIHlvdXIgY3VzdG9tIGBLb252YS5TaGFwZWAgaW5zdGFuY2UgeW91IGhhdmUgdG8gcGFzcyBzaGFwZSdzIGJvdW5kaW5nIGJveFxuICAgICAqICBwcm9wZXJ0aWVzLiBMb29rIGF0IFtodHRwczovL2tvbnZhanMuZ2l0aHViLmlvL2RvY3MvcGVyZm9ybWFuY2UvU2hhcGVfQ2FjaGluZy5odG1sXShsaW5rIHRvIGRlbW8gcGFnZSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0XSAgaW5jcmVhc2UgY2FudmFzIHNpemUgYnkgYG9mZnNldGAgcGl4ZWwgaW4gYWxsIGRpcmVjdGlvbnMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYXdCb3JkZXJdIHdoZW4gc2V0IHRvIHRydWUsIGEgcmVkIGJvcmRlciB3aWxsIGJlIGRyYXduIGFyb3VuZCB0aGUgY2FjaGVkXG4gICAgICogIHJlZ2lvbiBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucGl4ZWxSYXRpb10gY2hhbmdlIHF1YWxpdHkgKG9yIHBpeGVsIHJhdGlvKSBvZiBjYWNoZWQgaW1hZ2UuIHBpeGVsUmF0aW8gPSAyIHdpbGwgcHJvZHVjZSAyeCBzaXplZCBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGNhY2hlIGEgc2hhcGUgd2l0aCB0aGUgeCx5IHBvc2l0aW9uIG9mIHRoZSBib3VuZGluZyBib3ggYXQgdGhlIGNlbnRlciBhbmRcbiAgICAgKiAvLyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgYm94IGVxdWFsIHRvIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mXG4gICAgICogLy8gdGhlIHNoYXBlIG9idGFpbmVkIGZyb20gc2hhcGUud2lkdGgoKSBhbmQgc2hhcGUuaGVpZ2h0KClcbiAgICAgKiBpbWFnZS5jYWNoZSgpO1xuICAgICAqXG4gICAgICogLy8gY2FjaGUgYSBub2RlIGFuZCBkZWZpbmUgdGhlIGJvdW5kaW5nIGJveCBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgICAqIG5vZGUuY2FjaGUoe1xuICAgICAqICAgeDogLTMwLFxuICAgICAqICAgeTogLTMwLFxuICAgICAqICAgd2lkdGg6IDEwMCxcbiAgICAgKiAgIGhlaWdodDogMjAwXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBjYWNoZSBhIG5vZGUgYW5kIGRyYXcgYSByZWQgYm9yZGVyIGFyb3VuZCB0aGUgYm91bmRpbmcgYm94XG4gICAgICogLy8gZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAqIG5vZGUuY2FjaGUoe1xuICAgICAqICAgeDogLTMwLFxuICAgICAqICAgeTogLTMwLFxuICAgICAqICAgd2lkdGg6IDEwMCxcbiAgICAgKiAgIGhlaWdodDogMjAwLFxuICAgICAqICAgb2Zmc2V0IDogMTAsXG4gICAgICogICBkcmF3Qm9yZGVyOiB0cnVlXG4gICAgICogfSk7XG4gICAgICovXG4gICAgY2FjaGU6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdmFyIGNvbmYgPSBjb25maWcgfHwge307XG4gICAgICB2YXIgcmVjdCA9IHt9O1xuXG4gICAgICAvLyBkb24ndCBjYWxsIGdldENsaWVudFJlY3QgaWYgd2UgaGF2ZSBhbGwgYXR0cmlidXRlc1xuICAgICAgLy8gaXQgbWVhbnMgY2FsbCBpdCBvbmx5IGlmIGhhdmUgb25lIHVuZGVmaW5lZFxuICAgICAgaWYgKFxuICAgICAgICBjb25mLnggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBjb25mLnkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBjb25mLndpZHRoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgY29uZi5oZWlnaHQgPT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIHJlY3QgPSB0aGlzLmdldENsaWVudFJlY3Qoe1xuICAgICAgICAgIHNraXBUcmFuc2Zvcm06IHRydWUsXG4gICAgICAgICAgcmVsYXRpdmVUbzogdGhpcy5nZXRQYXJlbnQoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciB3aWR0aCA9IGNvbmYud2lkdGggfHwgcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gY29uZi5oZWlnaHQgfHwgcmVjdC5oZWlnaHQsXG4gICAgICAgIHBpeGVsUmF0aW8gPSBjb25mLnBpeGVsUmF0aW8sXG4gICAgICAgIHggPSBjb25mLnggPT09IHVuZGVmaW5lZCA/IHJlY3QueCA6IGNvbmYueCxcbiAgICAgICAgeSA9IGNvbmYueSA9PT0gdW5kZWZpbmVkID8gcmVjdC55IDogY29uZi55LFxuICAgICAgICBvZmZzZXQgPSBjb25mLm9mZnNldCB8fCAwLFxuICAgICAgICBkcmF3Qm9yZGVyID0gY29uZi5kcmF3Qm9yZGVyIHx8IGZhbHNlO1xuXG4gICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgS29udmEuVXRpbC5lcnJvcihcbiAgICAgICAgICAnQ2FuIG5vdCBjYWNoZSB0aGUgbm9kZS4gV2lkdGggb3IgaGVpZ2h0IG9mIHRoZSBub2RlIGVxdWFscyAwLiBDYWNoaW5nIGlzIHNraXBwZWQuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdpZHRoICs9IG9mZnNldCAqIDI7XG4gICAgICBoZWlnaHQgKz0gb2Zmc2V0ICogMjtcblxuICAgICAgeCAtPSBvZmZzZXQ7XG4gICAgICB5IC09IG9mZnNldDtcblxuICAgICAgdmFyIGNhY2hlZFNjZW5lQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KSxcbiAgICAgICAgY2FjaGVkRmlsdGVyQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KSxcbiAgICAgICAgY2FjaGVkSGl0Q2FudmFzID0gbmV3IEtvbnZhLkhpdENhbnZhcyh7XG4gICAgICAgICAgcGl4ZWxSYXRpbzogMSxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSksXG4gICAgICAgIHNjZW5lQ29udGV4dCA9IGNhY2hlZFNjZW5lQ2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgaGl0Q29udGV4dCA9IGNhY2hlZEhpdENhbnZhcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGNhY2hlZEhpdENhbnZhcy5pc0NhY2hlID0gdHJ1ZTtcblxuICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG5cbiAgICAgIHNjZW5lQ29udGV4dC5zYXZlKCk7XG4gICAgICBoaXRDb250ZXh0LnNhdmUoKTtcblxuICAgICAgc2NlbmVDb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgICAgaGl0Q29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcblxuICAgICAgLy8gZXh0cmEgZmxhZyB0byBza2lwIG9uIGdldEFic29sdXRlIG9wYWNpdHkgY2FsY1xuICAgICAgdGhpcy5faXNVbmRlckNhY2hlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9PUEFDSVRZKTtcbiAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9TQ0FMRSk7XG5cbiAgICAgIHRoaXMuZHJhd1NjZW5lKGNhY2hlZFNjZW5lQ2FudmFzLCB0aGlzLCB0cnVlKTtcbiAgICAgIHRoaXMuZHJhd0hpdChjYWNoZWRIaXRDYW52YXMsIHRoaXMsIHRydWUpO1xuICAgICAgdGhpcy5faXNVbmRlckNhY2hlID0gZmFsc2U7XG5cbiAgICAgIHNjZW5lQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICBoaXRDb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgLy8gdGhpcyB3aWxsIGRyYXcgYSByZWQgYm9yZGVyIGFyb3VuZCB0aGUgY2FjaGVkIGJveCBmb3JcbiAgICAgIC8vIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgaWYgKGRyYXdCb3JkZXIpIHtcbiAgICAgICAgc2NlbmVDb250ZXh0LnNhdmUoKTtcbiAgICAgICAgc2NlbmVDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBzY2VuZUNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgc2NlbmVDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBzY2VuZUNvbnRleHQuc2V0QXR0cignc3Ryb2tlU3R5bGUnLCAncmVkJyk7XG4gICAgICAgIHNjZW5lQ29udGV4dC5zZXRBdHRyKCdsaW5lV2lkdGgnLCA1KTtcbiAgICAgICAgc2NlbmVDb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICBzY2VuZUNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYWNoZS5jYW52YXMgPSB7XG4gICAgICAgIHNjZW5lOiBjYWNoZWRTY2VuZUNhbnZhcyxcbiAgICAgICAgZmlsdGVyOiBjYWNoZWRGaWx0ZXJDYW52YXMsXG4gICAgICAgIGhpdDogY2FjaGVkSGl0Q2FudmFzLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBjbGllbnQgcmVjdGFuZ2xlIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBvZiBub2RlLiBUaGlzIHJlY3RhbmdsZSBhbHNvIGluY2x1ZGUgYWxsIHN0eWxpbmcgKHN0cm9rZXMsIHNoYWRvd3MsIGV0YykuXG4gICAgICogVGhlIHJlY3RhbmdsZSBwb3NpdGlvbiBpcyByZWxhdGl2ZSB0byBwYXJlbnQgY29udGFpbmVyLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNraXBUcmFuc2Zvcm1dIHNob3VsZCB3ZSBhcHBseSB0cmFuc2Zvcm0gdG8gbm9kZSBmb3IgY2FsY3VsYXRpbmcgcmVjdD9cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2tpcFNoYWRvd10gc2hvdWxkIHdlIGFwcGx5IHNoYWRvdyB0byB0aGUgbm9kZSBmb3IgY2FsY3VsYXRpbmcgYm91bmQgYm94P1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnJlbGF0aXZlVG9dIGNhbGN1bGF0ZSBjbGllbnQgcmVjdCByZWxhdGl2ZSB0byBvbmUgb2YgdGhlIHBhcmVudHNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZWN0IHdpdGgge3gsIHksIHdpZHRoLCBoZWlnaHR9IHByb3BlcnRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciByZWN0ID0gbmV3IEtvbnZhLlJlY3Qoe1xuICAgICAqICAgICAgd2lkdGggOiAxMDAsXG4gICAgICogICAgICBoZWlnaHQgOiAxMDAsXG4gICAgICogICAgICB4IDogNTAsXG4gICAgICogICAgICB5IDogNTAsXG4gICAgICogICAgICBzdHJva2VXaWR0aCA6IDQsXG4gICAgICogICAgICBzdHJva2UgOiAnYmxhY2snLFxuICAgICAqICAgICAgb2Zmc2V0WCA6IDUwLFxuICAgICAqICAgICAgc2NhbGVZIDogMlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gZ2V0IGNsaWVudCByZWN0IHdpdGhvdXQgdGhpbmsgb2ZmIHRyYW5zZm9ybWF0aW9ucyAocG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZSwgb2Zmc2V0LCBldGMpXG4gICAgICogcmVjdC5nZXRDbGllbnRSZWN0KHsgc2tpcFRyYW5zZm9ybTogdHJ1ZX0pO1xuICAgICAqIC8vIHJldHVybnMge1xuICAgICAqIC8vICAgICB4IDogLTIsICAgLy8gdHdvIHBpeGVscyBmb3Igc3Ryb2tlIC8gMlxuICAgICAqIC8vICAgICB5IDogLTIsXG4gICAgICogLy8gICAgIHdpZHRoIDogMTA0LCAvLyBpbmNyZWFzZWQgYnkgNCBmb3Igc3Ryb2tlXG4gICAgICogLy8gICAgIGhlaWdodCA6IDEwNFxuICAgICAqIC8vfVxuICAgICAqXG4gICAgICogLy8gZ2V0IGNsaWVudCByZWN0IHdpdGggdHJhbnNmb3JtYXRpb24gYXBwbGllZFxuICAgICAqIHJlY3QuZ2V0Q2xpZW50UmVjdCgpO1xuICAgICAqIC8vIHJldHVybnMgT2JqZWN0IHt4OiAtMiwgeTogNDYsIHdpZHRoOiAxMDQsIGhlaWdodDogMjA4fVxuICAgICAqL1xuICAgIGdldENsaWVudFJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYWJzdHJhY3QgbWV0aG9kXG4gICAgICAvLyByZWRlZmluZSBpbiBDb250YWluZXIgYW5kIFNoYXBlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fic3RyYWN0IFwiZ2V0Q2xpZW50UmVjdFwiIG1ldGhvZCBjYWxsJyk7XG4gICAgfSxcbiAgICBfdHJhbnNmb3JtZWRSZWN0OiBmdW5jdGlvbihyZWN0LCB0b3ApIHtcbiAgICAgIHZhciBwb2ludHMgPSBbXG4gICAgICAgIHsgeDogcmVjdC54LCB5OiByZWN0LnkgfSxcbiAgICAgICAgeyB4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0LnkgfSxcbiAgICAgICAgeyB4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0LnkgKyByZWN0LmhlaWdodCB9LFxuICAgICAgICB7IHg6IHJlY3QueCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgfVxuICAgICAgXTtcbiAgICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuICAgICAgdmFyIHRyYW5zID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApO1xuICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdHJhbnMucG9pbnQocG9pbnQpO1xuICAgICAgICBpZiAobWluWCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbWluWCA9IG1heFggPSB0cmFuc2Zvcm1lZC54O1xuICAgICAgICAgIG1pblkgPSBtYXhZID0gdHJhbnNmb3JtZWQueTtcbiAgICAgICAgfVxuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgdHJhbnNmb3JtZWQueCk7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB0cmFuc2Zvcm1lZC55KTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHRyYW5zZm9ybWVkLngpO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgdHJhbnNmb3JtZWQueSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IG1pblgsXG4gICAgICAgIHk6IG1pblksXG4gICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICAgICAgfTtcbiAgICB9LFxuICAgIF9kcmF3Q2FjaGVkU2NlbmVDYW52YXM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgY29udGV4dC5fYXBwbHlHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24odGhpcyk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSh0aGlzLl9jYWNoZS5jYW52YXMueCwgdGhpcy5fY2FjaGUuY2FudmFzLnkpO1xuXG4gICAgICB2YXIgY2FjaGVDYW52YXMgPSB0aGlzLl9nZXRDYWNoZWRTY2VuZUNhbnZhcygpO1xuICAgICAgdmFyIHJhdGlvID0gY2FjaGVDYW52YXMucGl4ZWxSYXRpbztcblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgIGNhY2hlQ2FudmFzLl9jYW52YXMsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGNhY2hlQ2FudmFzLndpZHRoIC8gcmF0aW8sXG4gICAgICAgIGNhY2hlQ2FudmFzLmhlaWdodCAvIHJhdGlvXG4gICAgICApO1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBfZHJhd0NhY2hlZEhpdENhbnZhczogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgaGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzLmhpdDtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUodGhpcy5fY2FjaGUuY2FudmFzLngsIHRoaXMuX2NhY2hlLmNhbnZhcy55KTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGhpdENhbnZhcy5fY2FudmFzLCAwLCAwKTtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgX2dldENhY2hlZFNjZW5lQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzKCksXG4gICAgICAgIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgc2NlbmVDYW52YXMgPSBjYWNoZWRDYW52YXMuc2NlbmUsXG4gICAgICAgIGZpbHRlckNhbnZhcyA9IGNhY2hlZENhbnZhcy5maWx0ZXIsXG4gICAgICAgIGZpbHRlckNvbnRleHQgPSBmaWx0ZXJDYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICBsZW4sXG4gICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgbixcbiAgICAgICAgZmlsdGVyO1xuXG4gICAgICBpZiAoZmlsdGVycykge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlclVwVG9EYXRlKSB7XG4gICAgICAgICAgdmFyIHJhdGlvID0gc2NlbmVDYW52YXMucGl4ZWxSYXRpbztcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZW4gPSBmaWx0ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGZpbHRlckNvbnRleHQuY2xlYXIoKTtcblxuICAgICAgICAgICAgLy8gY29weSBjYWNoZWQgY2FudmFzIG9udG8gZmlsdGVyIGNvbnRleHRcbiAgICAgICAgICAgIGZpbHRlckNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgICBzY2VuZUNhbnZhcy5fY2FudmFzLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBzY2VuZUNhbnZhcy5nZXRXaWR0aCgpIC8gcmF0aW8sXG4gICAgICAgICAgICAgIHNjZW5lQ2FudmFzLmdldEhlaWdodCgpIC8gcmF0aW9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpbWFnZURhdGEgPSBmaWx0ZXJDb250ZXh0LmdldEltYWdlRGF0YShcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgZmlsdGVyQ2FudmFzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgIGZpbHRlckNhbnZhcy5nZXRIZWlnaHQoKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gYXBwbHkgZmlsdGVycyB0byBmaWx0ZXIgY29udGV4dFxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlcnNbbl07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdGaWx0ZXIgc2hvdWxkIGJlIHR5cGUgb2YgZnVuY3Rpb24sIGJ1dCBnb3QgJyArXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBmaWx0ZXIgK1xuICAgICAgICAgICAgICAgICAgICAnIGluc3RlZC4gUGxlYXNlIGNoZWNrIGNvcnJlY3QgZmlsdGVycydcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZpbHRlci5jYWxsKHRoaXMsIGltYWdlRGF0YSk7XG4gICAgICAgICAgICAgIGZpbHRlckNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgS29udmEuVXRpbC5lcnJvcignVW5hYmxlIHRvIGFwcGx5IGZpbHRlci4gJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlckNhbnZhcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2VuZUNhbnZhcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGJpbmQgZXZlbnRzIHRvIHRoZSBub2RlLiBLb252YUpTIHN1cHBvcnRzIG1vdXNlb3ZlciwgbW91c2Vtb3ZlLFxuICAgICAqICBtb3VzZW91dCwgbW91c2VlbnRlciwgbW91c2VsZWF2ZSwgbW91c2Vkb3duLCBtb3VzZXVwLCB3aGVlbCwgY29udGV4dG1lbnUsIGNsaWNrLCBkYmxjbGljaywgdG91Y2hzdGFydCwgdG91Y2htb3ZlLFxuICAgICAqICB0b3VjaGVuZCwgdGFwLCBkYmx0YXAsIGRyYWdzdGFydCwgZHJhZ21vdmUsIGFuZCBkcmFnZW5kIGV2ZW50cy4gVGhlIEtvbnZhIFN0YWdlIHN1cHBvcnRzXG4gICAgICogIGNvbnRlbnRNb3VzZW92ZXIsIGNvbnRlbnRNb3VzZW1vdmUsIGNvbnRlbnRNb3VzZW91dCwgY29udGVudE1vdXNlZG93biwgY29udGVudE1vdXNldXAsIGNvbnRlbnRXaGVlbCwgY29udGVudENvbnRleHRtZW51XG4gICAgICogIGNvbnRlbnRDbGljaywgY29udGVudERibGNsaWNrLCBjb250ZW50VG91Y2hzdGFydCwgY29udGVudFRvdWNobW92ZSwgY29udGVudFRvdWNoZW5kLCBjb250ZW50VGFwLFxuICAgICAqICBhbmQgY29udGVudERibFRhcC4gIFBhc3MgaW4gYSBzdHJpbmcgb2YgZXZlbnRzIGRlbGltaXRlZCBieSBhIHNwYWNlIHRvIGJpbmQgbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAgICAgKiAgc3VjaCBhcyAnbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlJy4gSW5jbHVkZSBhIG5hbWVzcGFjZSB0byBiaW5kIGFuXG4gICAgICogIGV2ZW50IGJ5IG5hbWUgc3VjaCBhcyAnY2xpY2suZm9vYmFyJy5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dFN0ciBlLmcuICdjbGljaycsICdtb3VzZWRvd24gdG91Y2hzdGFydCcsICdtb3VzZWRvd24uZm9vIHRvdWNoc3RhcnQuZm9vJ1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIGhhbmRsZXIgZnVuY3Rpb24gaXMgcGFzc2VkIGFuIGV2ZW50IG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gYWRkIGNsaWNrIGxpc3RlbmVyXG4gICAgICogbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCd5b3UgY2xpY2tlZCBtZSEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGdldCB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBub2RlLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAqICAgY29uc29sZS5sb2coZXZ0LnRhcmdldCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uXG4gICAgICogbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbihldnQpIHtcbiAgICAgKiAgIGV2dC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gYmluZCBtdWx0aXBsZSBsaXN0ZW5lcnNcbiAgICAgKiBub2RlLm9uKCdjbGljayB0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygneW91IGNsaWNrZWQvdG91Y2hlZCBtZSEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIG5hbWVzcGFjZSBsaXN0ZW5lclxuICAgICAqIG5vZGUub24oJ2NsaWNrLmZvbycsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ3lvdSBjbGlja2VkL3RvdWNoZWQgbWUhJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBnZXQgdGhlIGV2ZW50IHR5cGVcbiAgICAgKiBub2RlLm9uKCdjbGljayB0YXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgKiAgIHZhciBldmVudFR5cGUgPSBldnQudHlwZTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGdldCBuYXRpdmUgZXZlbnQgb2JqZWN0XG4gICAgICogbm9kZS5vbignY2xpY2sgdGFwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICogICB2YXIgbmF0aXZlRXZlbnQgPSBldnQuZXZ0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gZm9yIGNoYW5nZSBldmVudHMsIGdldCB0aGUgb2xkIGFuZCBuZXcgdmFsXG4gICAgICogbm9kZS5vbigneENoYW5nZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAqICAgdmFyIG9sZFZhbCA9IGV2dC5vbGRWYWw7XG4gICAgICogICB2YXIgbmV3VmFsID0gZXZ0Lm5ld1ZhbDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGdldCBldmVudCB0YXJnZXRzXG4gICAgICogLy8gd2l0aCBldmVudCBkZWxlZ2F0aW9uc1xuICAgICAqIGxheWVyLm9uKCdjbGljaycsICdHcm91cCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAqICAgdmFyIHNoYXBlID0gZXZ0LnRhcmdldDtcbiAgICAgKiAgIHZhciBncm91cCA9IGV2dG4uY3VycmVudFRhcmdlcjtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24oZXZ0U3RyLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHZhciBldmVudHMgPSBldnRTdHIuc3BsaXQoU1BBQ0UpLFxuICAgICAgICBsZW4gPSBldmVudHMubGVuZ3RoLFxuICAgICAgICBuLFxuICAgICAgICBldmVudCxcbiAgICAgICAgcGFydHMsXG4gICAgICAgIGJhc2VFdmVudCxcbiAgICAgICAgbmFtZTtcblxuICAgICAgLypcbiAgICAgICAgICAgICAqIGxvb3AgdGhyb3VnaCB0eXBlcyBhbmQgYXR0YWNoIGV2ZW50IGxpc3RlbmVycyB0b1xuICAgICAgICAgICAgICogZWFjaCBvbmUuICBlZy4gJ2NsaWNrIG1vdXNlb3Zlci5uYW1lc3BhY2UgbW91c2VvdXQnXG4gICAgICAgICAgICAgKiB3aWxsIGNyZWF0ZSB0aHJlZSBldmVudCBiaW5kaW5nc1xuICAgICAgICAgICAgICovXG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgZXZlbnQgPSBldmVudHNbbl07XG4gICAgICAgIHBhcnRzID0gZXZlbnQuc3BsaXQoRE9UKTtcbiAgICAgICAgYmFzZUV2ZW50ID0gcGFydHNbMF07XG4gICAgICAgIG5hbWUgPSBwYXJ0c1sxXSB8fCBFTVBUWV9TVFJJTkc7XG5cbiAgICAgICAgLy8gY3JlYXRlIGV2ZW50cyBhcnJheSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgIGlmICghdGhpcy5ldmVudExpc3RlbmVyc1tiYXNlRXZlbnRdKSB7XG4gICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tiYXNlRXZlbnRdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2Jhc2VFdmVudF0ucHVzaCh7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBldmVudCBiaW5kaW5ncyBmcm9tIHRoZSBub2RlLiBQYXNzIGluIGEgc3RyaW5nIG9mXG4gICAgICogIGV2ZW50IHR5cGVzIGRlbGltbWl0ZWQgYnkgYSBzcGFjZSB0byByZW1vdmUgbXVsdGlwbGUgZXZlbnRcbiAgICAgKiAgYmluZGluZ3MgYXQgb25jZSBzdWNoIGFzICdtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUnLlxuICAgICAqICBpbmNsdWRlIGEgbmFtZXNwYWNlIHRvIHJlbW92ZSBhbiBldmVudCBiaW5kaW5nIGJ5IG5hbWVcbiAgICAgKiAgc3VjaCBhcyAnY2xpY2suZm9vYmFyJy4gSWYgeW91IG9ubHkgZ2l2ZSBhIG5hbWUgbGlrZSAnLmZvb2JhcicsXG4gICAgICogIGFsbCBldmVudHMgaW4gdGhhdCBuYW1lc3BhY2Ugd2lsbCBiZSByZW1vdmVkLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZ0U3RyIGUuZy4gJ2NsaWNrJywgJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgJy5mb29iYXInXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICAgKiBub2RlLm9mZignY2xpY2snKTtcbiAgICAgKlxuICAgICAqIC8vIHJlbW92ZSBtdWx0aXBsZSBsaXN0ZW5lcnNcbiAgICAgKiBub2RlLm9mZignY2xpY2sgdG91Y2hzdGFydCcpO1xuICAgICAqXG4gICAgICogLy8gcmVtb3ZlIGxpc3RlbmVyIGJ5IG5hbWVcbiAgICAgKiBub2RlLm9mZignY2xpY2suZm9vJyk7XG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldnRTdHIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZXZlbnRzID0gKGV2dFN0ciB8fCAnJykuc3BsaXQoU1BBQ0UpLFxuICAgICAgICBsZW4gPSBldmVudHMubGVuZ3RoLFxuICAgICAgICBuLFxuICAgICAgICB0LFxuICAgICAgICBldmVudCxcbiAgICAgICAgcGFydHMsXG4gICAgICAgIGJhc2VFdmVudCxcbiAgICAgICAgbmFtZTtcblxuICAgICAgaWYgKCFldnRTdHIpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudHNcbiAgICAgICAgZm9yICh0IGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICB0aGlzLl9vZmYodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICBldmVudCA9IGV2ZW50c1tuXTtcbiAgICAgICAgcGFydHMgPSBldmVudC5zcGxpdChET1QpO1xuICAgICAgICBiYXNlRXZlbnQgPSBwYXJ0c1swXTtcbiAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xuXG4gICAgICAgIGlmIChiYXNlRXZlbnQpIHtcbiAgICAgICAgICBpZiAodGhpcy5ldmVudExpc3RlbmVyc1tiYXNlRXZlbnRdKSB7XG4gICAgICAgICAgICB0aGlzLl9vZmYoYmFzZUV2ZW50LCBuYW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodCBpbiB0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9vZmYodCwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBzb21lIGV2ZW50IGFsaWFzZXMgZm9yIHRoaXJkIHBhcnR5IGludGVncmF0aW9uIGxpa2UgSGFtbWVySlNcbiAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBlID0ge1xuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgIHR5cGU6IGV2dC50eXBlLFxuICAgICAgICBldnQ6IGV2dFxuICAgICAgfTtcbiAgICAgIHRoaXMuZmlyZShldnQudHlwZSwgZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIC8vIHdlIGhhdmUgdG8gcGFzcyBuYXRpdmUgZXZlbnQgdG8gaGFuZGxlclxuICAgICAgdGhpcy5vbih0eXBlLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGV2dC5ldnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHRoaXMub2ZmKHR5cGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBsaWtlIG5vZGUub25cbiAgICBfZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50LCBzZWxlY3RvciwgaGFuZGxlcikge1xuICAgICAgdmFyIHN0b3BOb2RlID0gdGhpcztcbiAgICAgIHRoaXMub24oZXZlbnQsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgdGFyZ2V0cyA9IGV2dC50YXJnZXQuZmluZEFuY2VzdG9ycyhzZWxlY3RvciwgdHJ1ZSwgc3RvcE5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBldnQgPSBLb252YS5VdGlsLmNsb25lT2JqZWN0KGV2dCk7XG4gICAgICAgICAgZXZ0LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0YXJnZXRzW2ldLCBldnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50LCBidXQgZG9uJ3QgZGVzdHJveS4gWW91IGNhbiByZXVzZSBub2RlIGxhdGVyLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUucmVtb3ZlKCk7XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgsIDEpO1xuICAgICAgICBwYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICBkZWxldGUgdGhpcy5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGV2ZXJ5IGNhY2hlZCBhdHRyIHRoYXQgaXMgY2FsY3VsYXRlZCB2aWEgbm9kZSB0cmVlXG4gICAgICAvLyB0cmF2ZXJzYWwgbXVzdCBiZSBjbGVhcmVkIHdoZW4gcmVtb3ZpbmcgYSBub2RlXG4gICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoU1RBR0UpO1xuICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSk7XG4gICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoVklTSUJMRSk7XG4gICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoTElTVEVOSU5HKTtcbiAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9PUEFDSVRZKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZW1vdmUgYW5kIGRlc3Ryb3kgYSBub2RlLiBLaWxsIGl0IGZvcmV2ZXIhIFlvdSBzaG91bGQgbm90IHJldXNlIG5vZGUgYWZ0ZXIgZGVzdHJveSgpLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuZGVzdHJveSgpO1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gcmVtb3ZlIGZyb20gaWRzIGFuZCBuYW1lcyBoYXNoZXNcbiAgICAgIEtvbnZhLl9yZW1vdmVJZCh0aGlzLmdldElkKCkpO1xuXG4gICAgICAvLyByZW1vdmUgYWxsIG5hbWVzXG4gICAgICB2YXIgbmFtZXMgPSAodGhpcy5nZXROYW1lKCkgfHwgJycpLnNwbGl0KC9cXHMvZyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdWJuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIEtvbnZhLl9yZW1vdmVOYW1lKHN1Ym5hbWUsIHRoaXMuX2lkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGF0dHJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcnxTdHJpbmd8T2JqZWN0fEFycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHggPSBub2RlLmdldEF0dHIoJ3gnKTtcbiAgICAgKi9cbiAgICBnZXRBdHRyOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICB2YXIgbWV0aG9kID0gR0VUICsgS29udmEuVXRpbC5fY2FwaXRhbGl6ZShhdHRyKTtcbiAgICAgIGlmIChLb252YS5VdGlsLl9pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXSgpO1xuICAgICAgfVxuICAgICAgLy8gb3RoZXJ3aXNlIGdldCBkaXJlY3RseVxuICAgICAgcmV0dXJuIHRoaXMuYXR0cnNbYXR0cl07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgYW5jZXN0b3JzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5Db2xsZWN0aW9ufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogc2hhcGUuZ2V0QW5jZXN0b3JzKCkuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhub2RlLmdldElkKCkpO1xuICAgICAqIH0pXG4gICAgICovXG4gICAgZ2V0QW5jZXN0b3JzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpLFxuICAgICAgICBhbmNlc3RvcnMgPSBuZXcgS29udmEuQ29sbGVjdGlvbigpO1xuXG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBhdHRycyBvYmplY3QgbGl0ZXJhbFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldEF0dHJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJzIHx8IHt9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2V0IG11bHRpcGxlIGF0dHJzIGF0IG9uY2UgdXNpbmcgYW4gb2JqZWN0IGxpdGVyYWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBvYmplY3QgY29udGFpbmluZyBrZXkgdmFsdWUgcGFpcnNcbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuc2V0QXR0cnMoe1xuICAgICAqICAgeDogNSxcbiAgICAgKiAgIGZpbGw6ICdyZWQnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0QXR0cnM6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdmFyIGtleSwgbWV0aG9kO1xuXG4gICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGZvciAoa2V5IGluIGNvbmZpZykge1xuICAgICAgICBpZiAoa2V5ID09PSBDSElMRFJFTikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1ldGhvZCA9IFNFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoa2V5KTtcbiAgICAgICAgLy8gdXNlIHNldHRlciBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzRnVuY3Rpb24odGhpc1ttZXRob2RdKSkge1xuICAgICAgICAgIHRoaXNbbWV0aG9kXShjb25maWdba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCBkaXJlY3RseVxuICAgICAgICAgIHRoaXMuX3NldEF0dHIoa2V5LCBjb25maWdba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZGV0ZXJtaW5lIGlmIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHMgYnkgdGFraW5nIGludG8gYWNjb3VudCBhbmNlc3RvcnMuXG4gICAgICpcbiAgICAgKiBQYXJlbnQgICAgfCBTZWxmICAgICAgfCBpc0xpc3RlbmluZ1xuICAgICAqIGxpc3RlbmluZyB8IGxpc3RlbmluZyB8XG4gICAgICogLS0tLS0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS1cbiAgICAgKiBUICAgICAgICAgfCBUICAgICAgICAgfCBUXG4gICAgICogVCAgICAgICAgIHwgRiAgICAgICAgIHwgRlxuICAgICAqIEYgICAgICAgICB8IFQgICAgICAgICB8IFRcbiAgICAgKiBGICAgICAgICAgfCBGICAgICAgICAgfCBGXG4gICAgICogLS0tLS0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS1cbiAgICAgKiBUICAgICAgICAgfCBJICAgICAgICAgfCBUXG4gICAgICogRiAgICAgICAgIHwgSSAgICAgICAgIHwgRlxuICAgICAqIEkgICAgICAgICB8IEkgICAgICAgICB8IFRcbiAgICAgKlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0xpc3RlbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoTElTVEVOSU5HLCB0aGlzLl9pc0xpc3RlbmluZyk7XG4gICAgfSxcbiAgICBfaXNMaXN0ZW5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpc3RlbmluZyA9IHRoaXMuZ2V0TGlzdGVuaW5nKCksXG4gICAgICAgIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cbiAgICAgIC8vIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgYSBzaW1wbGlmaWNhdGlvbiBvZiB0aGUgdHJ1dGggdGFibGUgYWJvdmUuXG4gICAgICAvLyBwbGVhc2UgbW9kaWZ5IGNhcmVmdWxseVxuICAgICAgaWYgKGxpc3RlbmluZyA9PT0gJ2luaGVyaXQnKSB7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmlzTGlzdGVuaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5pbmc7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBpcyB2aXNpYmxlIGJ5IHRha2luZyBpbnRvIGFjY291bnQgYW5jZXN0b3JzLlxuICAgICAqXG4gICAgICogUGFyZW50ICAgIHwgU2VsZiAgICAgIHwgaXNWaXNpYmxlXG4gICAgICogdmlzaWJsZSAgIHwgdmlzaWJsZSAgIHxcbiAgICAgKiAtLS0tLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLVxuICAgICAqIFQgICAgICAgICB8IFQgICAgICAgICB8IFRcbiAgICAgKiBUICAgICAgICAgfCBGICAgICAgICAgfCBGXG4gICAgICogRiAgICAgICAgIHwgVCAgICAgICAgIHwgVFxuICAgICAqIEYgICAgICAgICB8IEYgICAgICAgICB8IEZcbiAgICAgKiAtLS0tLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLVxuICAgICAqIFQgICAgICAgICB8IEkgICAgICAgICB8IFRcbiAgICAgKiBGICAgICAgICAgfCBJICAgICAgICAgfCBGXG4gICAgICogSSAgICAgICAgIHwgSSAgICAgICAgIHwgVFxuXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgKi9cbiAgICBpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFZJU0lCTEUsIHRoaXMuX2lzVmlzaWJsZSk7XG4gICAgfSxcbiAgICBfaXNWaXNpYmxlOiBmdW5jdGlvbihyZWxhdGl2ZVRvKSB7XG4gICAgICB2YXIgdmlzaWJsZSA9IHRoaXMuZ2V0VmlzaWJsZSgpLFxuICAgICAgICBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAocmVsYXRpdmVUbyA9PT0gcGFyZW50ICYmIHZpc2libGUgPT09ICdpbmhlcml0Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocmVsYXRpdmVUbyA9PT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgICAgfVxuICAgICAgLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBhIHNpbXBsaWZpY2F0aW9uIG9mIHRoZSB0cnV0aCB0YWJsZSBhYm92ZS5cbiAgICAgIC8vIHBsZWFzZSBtb2RpZnkgY2FyZWZ1bGx5XG4gICAgICBpZiAodmlzaWJsZSA9PT0gJ2luaGVyaXQnKSB7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50Ll9pc1Zpc2libGUocmVsYXRpdmVUbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogZGV0ZXJtaW5lIGlmIGxpc3RlbmluZyBpcyBlbmFibGVkIGJ5IHRha2luZyBpbnRvIGFjY291bnQgZGVzY2VuZGFudHMuICBJZiBzZWxmIG9yIGFueSBjaGlsZHJlblxuICAgICAqIGhhdmUgX2lzTGlzdGVuaW5nRW5hYmxlZCBzZXQgdG8gdHJ1ZSwgdGhlbiBzZWxmIGFsc28gaGFzIGxpc3RlbmluZyBlbmFibGVkLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGREcmF3SGl0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKCFsYXllciAmJiB0aGlzLmlzTGlzdGVuaW5nKCkgJiYgdGhpcy5pc1Zpc2libGUoKSkgfHxcbiAgICAgICAgKGxheWVyICYmXG4gICAgICAgICAgbGF5ZXIuaGl0R3JhcGhFbmFibGVkKCkgJiZcbiAgICAgICAgICB0aGlzLmlzTGlzdGVuaW5nKCkgJiZcbiAgICAgICAgICB0aGlzLmlzVmlzaWJsZSgpKVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNob3cgbm9kZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKi9cbiAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogaGlkZSBub2RlLiAgSGlkZGVuIG5vZGVzIGFyZSBubyBsb25nZXIgZGV0ZWN0YWJsZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKi9cbiAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCB6SW5kZXggcmVsYXRpdmUgdG8gdGhlIG5vZGUncyBzaWJsaW5ncyB3aG8gc2hhcmUgdGhlIHNhbWUgcGFyZW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAqL1xuICAgIGdldFpJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleCB8fCAwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGFic29sdXRlIHotaW5kZXggd2hpY2ggdGFrZXMgaW50byBhY2NvdW50IHNpYmxpbmdcbiAgICAgKiAgYW5kIGFuY2VzdG9yIGluZGljZXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgICovXG4gICAgZ2V0QWJzb2x1dGVaSW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRlcHRoID0gdGhpcy5nZXREZXB0aCgpLFxuICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICBub2RlcyxcbiAgICAgICAgbGVuLFxuICAgICAgICBuLFxuICAgICAgICBjaGlsZDtcblxuICAgICAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW25dO1xuICAgICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgIT09IFNIQVBFKSB7XG4gICAgICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZC5nZXRDaGlsZHJlbigpLnRvQXJyYXkoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoaWxkLl9pZCA9PT0gdGhhdC5faWQpIHtcbiAgICAgICAgICAgIG4gPSBsZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDAgJiYgbm9kZXNbMF0uZ2V0RGVwdGgoKSA8PSBkZXB0aCkge1xuICAgICAgICAgIGFkZENoaWxkcmVuKG5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoYXQubm9kZVR5cGUgIT09IFVQUEVSX1NUQUdFKSB7XG4gICAgICAgIGFkZENoaWxkcmVuKHRoYXQuZ2V0U3RhZ2UoKS5nZXRDaGlsZHJlbigpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IG5vZGUgZGVwdGggaW4gbm9kZSB0cmVlLiAgUmV0dXJucyBhbiBpbnRlZ2VyLlxuICAgICAqICBlLmcuIFN0YWdlIGRlcHRoIHdpbGwgYWx3YXlzIGJlIDAuICBMYXllcnMgd2lsbCBhbHdheXMgYmUgMS4gIEdyb3VwcyBhbmQgU2hhcGVzIHdpbGwgYWx3YXlzXG4gICAgICogIGJlID49IDJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgICovXG4gICAgZ2V0RGVwdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRlcHRoID0gMCxcbiAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXB0aDtcbiAgICB9LFxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIHRoaXMuc2V0WChwb3MueCk7XG4gICAgICB0aGlzLnNldFkocG9zLnkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLmdldFgoKSxcbiAgICAgICAgeTogdGhpcy5nZXRZKClcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgYWJzb2x1dGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgc3RhZ2UgY29udGFpbmVyIGRpdlxuICAgICAqIG9yIHJlbGF0aXZlIHRvIHBhc3NlZCBub2RlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdG9wXSBvcHRpb25hbCBwYXJlbnQgbm9kZVxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24odG9wKSB7XG4gICAgICB2YXIgYWJzb2x1dGVNYXRyaXggPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCksXG4gICAgICAgIGFic29sdXRlVHJhbnNmb3JtID0gbmV3IEtvbnZhLlRyYW5zZm9ybSgpLFxuICAgICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG4gICAgICAvLyBjbG9uZSB0aGUgbWF0cml4IGFycmF5XG4gICAgICBhYnNvbHV0ZVRyYW5zZm9ybS5tID0gYWJzb2x1dGVNYXRyaXguc2xpY2UoKTtcbiAgICAgIGFic29sdXRlVHJhbnNmb3JtLnRyYW5zbGF0ZShvZmZzZXQueCwgb2Zmc2V0LnkpO1xuXG4gICAgICByZXR1cm4gYWJzb2x1dGVUcmFuc2Zvcm0uZ2V0VHJhbnNsYXRpb24oKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNldCBhYnNvbHV0ZSBwb3NpdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICovXG4gICAgc2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24ocG9zKSB7XG4gICAgICB2YXIgb3JpZ1RyYW5zID0gdGhpcy5fY2xlYXJUcmFuc2Zvcm0oKSxcbiAgICAgICAgaXQ7XG5cbiAgICAgIC8vIGRvbid0IGNsZWFyIHRyYW5zbGF0aW9uXG4gICAgICB0aGlzLmF0dHJzLnggPSBvcmlnVHJhbnMueDtcbiAgICAgIHRoaXMuYXR0cnMueSA9IG9yaWdUcmFucy55O1xuICAgICAgZGVsZXRlIG9yaWdUcmFucy54O1xuICAgICAgZGVsZXRlIG9yaWdUcmFucy55O1xuXG4gICAgICAvLyB1bnJhdmVsIHRyYW5zZm9ybVxuICAgICAgaXQgPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgIGl0LmludmVydCgpO1xuICAgICAgaXQudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG4gICAgICBwb3MgPSB7XG4gICAgICAgIHg6IHRoaXMuYXR0cnMueCArIGl0LmdldFRyYW5zbGF0aW9uKCkueCxcbiAgICAgICAgeTogdGhpcy5hdHRycy55ICsgaXQuZ2V0VHJhbnNsYXRpb24oKS55XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNldFBvc2l0aW9uKHsgeDogcG9zLngsIHk6IHBvcy55IH0pO1xuICAgICAgdGhpcy5fc2V0VHJhbnNmb3JtKG9yaWdUcmFucyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX3NldFRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnMpIHtcbiAgICAgIHZhciBrZXk7XG5cbiAgICAgIGZvciAoa2V5IGluIHRyYW5zKSB7XG4gICAgICAgIHRoaXMuYXR0cnNba2V5XSA9IHRyYW5zW2tleV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoVFJBTlNGT1JNKTtcbiAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xuICAgIH0sXG4gICAgX2NsZWFyVHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0cmFucyA9IHtcbiAgICAgICAgeDogdGhpcy5nZXRYKCksXG4gICAgICAgIHk6IHRoaXMuZ2V0WSgpLFxuICAgICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgICBzY2FsZVg6IHRoaXMuZ2V0U2NhbGVYKCksXG4gICAgICAgIHNjYWxlWTogdGhpcy5nZXRTY2FsZVkoKSxcbiAgICAgICAgb2Zmc2V0WDogdGhpcy5nZXRPZmZzZXRYKCksXG4gICAgICAgIG9mZnNldFk6IHRoaXMuZ2V0T2Zmc2V0WSgpLFxuICAgICAgICBza2V3WDogdGhpcy5nZXRTa2V3WCgpLFxuICAgICAgICBza2V3WTogdGhpcy5nZXRTa2V3WSgpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmF0dHJzLnggPSAwO1xuICAgICAgdGhpcy5hdHRycy55ID0gMDtcbiAgICAgIHRoaXMuYXR0cnMucm90YXRpb24gPSAwO1xuICAgICAgdGhpcy5hdHRycy5zY2FsZVggPSAxO1xuICAgICAgdGhpcy5hdHRycy5zY2FsZVkgPSAxO1xuICAgICAgdGhpcy5hdHRycy5vZmZzZXRYID0gMDtcbiAgICAgIHRoaXMuYXR0cnMub2Zmc2V0WSA9IDA7XG4gICAgICB0aGlzLmF0dHJzLnNrZXdYID0gMDtcbiAgICAgIHRoaXMuYXR0cnMuc2tld1kgPSAwO1xuXG4gICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNKTtcblxuICAgICAgLy8gcmV0dXJuIG9yaWdpbmFsIHRyYW5zZm9ybVxuICAgICAgcmV0dXJuIHRyYW5zO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogbW92ZSBub2RlIGJ5IGFuIGFtb3VudCByZWxhdGl2ZSB0byBpdHMgY3VycmVudCBwb3NpdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZS54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZS55XG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBtb3ZlIG5vZGUgaW4geCBkaXJlY3Rpb24gYnkgMXB4IGFuZCB5IGRpcmVjdGlvbiBieSAycHhcbiAgICAgKiBub2RlLm1vdmUoe1xuICAgICAqICAgeDogMSxcbiAgICAgKiAgIHk6IDIpXG4gICAgICogfSk7XG4gICAgICovXG4gICAgbW92ZTogZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICB2YXIgY2hhbmdlWCA9IGNoYW5nZS54LFxuICAgICAgICBjaGFuZ2VZID0gY2hhbmdlLnksXG4gICAgICAgIHggPSB0aGlzLmdldFgoKSxcbiAgICAgICAgeSA9IHRoaXMuZ2V0WSgpO1xuXG4gICAgICBpZiAoY2hhbmdlWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHggKz0gY2hhbmdlWDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZVkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB5ICs9IGNoYW5nZVk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0UG9zaXRpb24oeyB4OiB4LCB5OiB5IH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfZWFjaEFuY2VzdG9yUmV2ZXJzZTogZnVuY3Rpb24oZnVuYywgdG9wKSB7XG4gICAgICB2YXIgZmFtaWx5ID0gW10sXG4gICAgICAgIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCksXG4gICAgICAgIGxlbixcbiAgICAgICAgbjtcblxuICAgICAgLy8gaWYgdG9wIG5vZGUgaXMgZGVmaW5lZCwgYW5kIHRoaXMgbm9kZSBpcyB0b3Agbm9kZSxcbiAgICAgIC8vIHRoZXJlJ3Mgbm8gbmVlZCB0byBidWlsZCBhIGZhbWlseSB0cmVlLiAganVzdCBleGVjdXRlXG4gICAgICAvLyBmdW5jIHdpdGggdGhpcyBiZWNhdXNlIGl0IHdpbGwgYmUgdGhlIG9ubHkgbm9kZVxuICAgICAgaWYgKHRvcCAmJiB0b3AuX2lkID09PSB0aGlzLl9pZCkge1xuICAgICAgICBmdW5jKHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZhbWlseS51bnNoaWZ0KHRoaXMpO1xuXG4gICAgICB3aGlsZSAocGFyZW50ICYmICghdG9wIHx8IHBhcmVudC5faWQgIT09IHRvcC5faWQpKSB7XG4gICAgICAgIGZhbWlseS51bnNoaWZ0KHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGxlbiA9IGZhbWlseS5sZW5ndGg7XG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgZnVuYyhmYW1pbHlbbl0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogcm90YXRlIG5vZGUgYnkgYW4gYW1vdW50IGluIGRlZ3JlZXMgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgcm90YXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRoZXRhXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICovXG4gICAgcm90YXRlOiBmdW5jdGlvbih0aGV0YSkge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbih0aGlzLmdldFJvdGF0aW9uKCkgKyB0aGV0YSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIG1vdmUgbm9kZSB0byB0aGUgdG9wIG9mIGl0cyBzaWJsaW5nc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBtb3ZlVG9Ub3A6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gbW92ZVRvVG9wIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogbW92ZSBub2RlIHVwXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBmbGFnIGlzIG1vdmVkIG9yIG5vdFxuICAgICAqL1xuICAgIG1vdmVVcDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgIEtvbnZhLlV0aWwud2FybignTm9kZSBoYXMgbm8gcGFyZW50LiBtb3ZlVXAgZnVuY3Rpb24gaXMgaWdub3JlZC4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCxcbiAgICAgICAgbGVuID0gdGhpcy5wYXJlbnQuZ2V0Q2hpbGRyZW4oKS5sZW5ndGg7XG4gICAgICBpZiAoaW5kZXggPCBsZW4gLSAxKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCArIDEsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnBhcmVudC5fc2V0Q2hpbGRyZW5JbmRpY2VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogbW92ZSBub2RlIGRvd25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgbW92ZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gbW92ZURvd24gZnVuY3Rpb24gaXMgaWdub3JlZC4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4IC0gMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBtb3ZlIG5vZGUgdG8gdGhlIGJvdHRvbSBvZiBpdHMgc2libGluZ3NcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgbW92ZVRvQm90dG9tOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgS29udmEuVXRpbC53YXJuKFxuICAgICAgICAgICdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVUb0JvdHRvbSBmdW5jdGlvbiBpcyBpZ25vcmVkLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4udW5zaGlmdCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNldCB6SW5kZXggcmVsYXRpdmUgdG8gc2libGluZ3NcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB6SW5kZXhcbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKi9cbiAgICBzZXRaSW5kZXg6IGZ1bmN0aW9uKHpJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gekluZGV4IHBhcmFtZXRlciBpcyBpZ25vcmVkLicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZSh6SW5kZXgsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgYWJzb2x1dGUgb3BhY2l0eVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEFic29sdXRlT3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoQUJTT0xVVEVfT1BBQ0lUWSwgdGhpcy5fZ2V0QWJzb2x1dGVPcGFjaXR5KTtcbiAgICB9LFxuICAgIF9nZXRBYnNvbHV0ZU9wYWNpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFic09wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc1VuZGVyQ2FjaGUpIHtcbiAgICAgICAgYWJzT3BhY2l0eSAqPSB0aGlzLmdldFBhcmVudCgpLmdldEFic29sdXRlT3BhY2l0eSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFic09wYWNpdHk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBtb3ZlIG5vZGUgdG8gYW5vdGhlciBjb250YWluZXJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtDb250YWluZXJ9IG5ld0NvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbW92ZSBub2RlIGZyb20gY3VycmVudCBsYXllciBpbnRvIGxheWVyMlxuICAgICAqIG5vZGUubW92ZVRvKGxheWVyMik7XG4gICAgICovXG4gICAgbW92ZVRvOiBmdW5jdGlvbihuZXdDb250YWluZXIpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgbmV3IGNvbnRhaW5lciBpcyBhbHJlYWR5IHBhcmVudFxuICAgICAgaWYgKHRoaXMuZ2V0UGFyZW50KCkgIT09IG5ld0NvbnRhaW5lcikge1xuICAgICAgICAvLyB0aGlzLnJlbW92ZSBteSBiZSBvdmVycmlkZWQgYnkgZHJhZyBhbmQgZHJvcFxuICAgICAgICAvLyBidXkgd2UgbmVlZCBvcmlnaW5hbFxuICAgICAgICAodGhpcy5fX29yaWdpbmFsUmVtb3ZlIHx8IHRoaXMucmVtb3ZlKS5jYWxsKHRoaXMpO1xuICAgICAgICBuZXdDb250YWluZXIuYWRkKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IE5vZGUgaW50byBhbiBvYmplY3QgZm9yIHNlcmlhbGl6YXRpb24uICBSZXR1cm5zIGFuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0ge30sXG4gICAgICAgIGF0dHJzID0gdGhpcy5nZXRBdHRycygpLFxuICAgICAgICBrZXksXG4gICAgICAgIHZhbCxcbiAgICAgICAgZ2V0dGVyLFxuICAgICAgICBkZWZhdWx0VmFsdWU7XG5cbiAgICAgIG9iai5hdHRycyA9IHt9O1xuXG4gICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICB2YWwgPSBhdHRyc1trZXldO1xuICAgICAgICBnZXR0ZXIgPSB0eXBlb2YgdGhpc1trZXldID09PSAnZnVuY3Rpb24nICYmIHRoaXNba2V5XTtcbiAgICAgICAgLy8gcmVtb3ZlIGF0dHIgdmFsdWUgc28gdGhhdCB3ZSBjYW4gZXh0cmFjdCB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBnZXR0ZXJcbiAgICAgICAgZGVsZXRlIGF0dHJzW2tleV07XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKHRoaXMpIDogbnVsbDtcbiAgICAgICAgLy8gcmVzdG9yZSBhdHRyIHZhbHVlXG4gICAgICAgIGF0dHJzW2tleV0gPSB2YWw7XG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IHZhbCkge1xuICAgICAgICAgIG9iai5hdHRyc1trZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9iai5jbGFzc05hbWUgPSB0aGlzLmdldENsYXNzTmFtZSgpO1xuICAgICAgcmV0dXJuIEtvbnZhLlV0aWwuX3ByZXBhcmVUb1N0cmluZ2lmeShvYmopO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY29udmVydCBOb2RlIGludG8gYSBKU09OIHN0cmluZy4gIFJldHVybnMgYSBKU09OIHN0cmluZy5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1N0cmluZ319XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvT2JqZWN0KCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IHBhcmVudCBjb250YWluZXJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICovXG4gICAgZ2V0UGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBhbGwgYW5jZXN0cm9zIChwYXJlbnQgdGhlbiBwYXJlbnQgb2YgdGhlIHBhcmVudCwgZXRjKSBvZiB0aGUgbm9kZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yXSBzZWxlY3RvciBmb3Igc2VhcmNoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5jbHVkZVNlbGZdIHNob3cgd2UgdGhpbmsgdGhhdCBub2RlIGlzIGFuY2VzdHJvIGl0c2VsZj9cbiAgICAgKiBAcGFyYW0ge0tvbnZhLk5vZGV9IFtzdG9wTm9kZV0gb3B0aW9uYWwgbm9kZSB3aGVyZSB3ZSBuZWVkIHRvIHN0b3Agc2VhcmNoaW5nIChvbmUgb2YgYW5jZXN0b3JzKVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gW2FuY2VzdG9yc11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvbmUgb2YgdGhlIHBhcmVudCBncm91cFxuICAgICAqIHZhciBwYXJlbnRHcm91cHMgPSBub2RlLmZpbmRBbmNlc3RvcnMoJ0dyb3VwJyk7XG4gICAgICovXG4gICAgZmluZEFuY2VzdG9yczogZnVuY3Rpb24oc2VsZWN0b3IsIGluY2x1ZGVTZWxmLCBzdG9wTm9kZSkge1xuICAgICAgdmFyIHJlcyA9IFtdO1xuXG4gICAgICBpZiAoaW5jbHVkZVNlbGYgJiYgdGhpcy5faXNNYXRjaChzZWxlY3RvcikpIHtcbiAgICAgICAgcmVzLnB1c2godGhpcyk7XG4gICAgICB9XG4gICAgICB2YXIgYW5jZXN0b3IgPSB0aGlzLnBhcmVudDtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBpZiAoYW5jZXN0b3IgPT09IHN0b3BOb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jZXN0b3IuX2lzTWF0Y2goc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmVzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBhbmNlc3RvciAocGFyZW50IG9yIHBhcmVudCBvZiB0aGUgcGFyZW50LCBldGMpIG9mIHRoZSBub2RlIHRoYXQgbWF0Y2ggcGFzc2VkIHNlbGVjdG9yXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdIHNlbGVjdG9yIGZvciBzZWFyY2hcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbmNsdWRlU2VsZl0gc2hvdyB3ZSB0aGluayB0aGF0IG5vZGUgaXMgYW5jZXN0cm8gaXRzZWxmP1xuICAgICAqIEBwYXJhbSB7S29udmEuTm9kZX0gW3N0b3BOb2RlXSBvcHRpb25hbCBub2RlIHdoZXJlIHdlIG5lZWQgdG8gc3RvcCBzZWFyY2hpbmcgKG9uZSBvZiBhbmNlc3RvcnMpXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9IGFuY2VzdG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgb25lIG9mIHRoZSBwYXJlbnQgZ3JvdXBcbiAgICAgKiB2YXIgZ3JvdXAgPSBub2RlLmZpbmRBbmNlc3RvcnMoJy5teWdyb3VwJyk7XG4gICAgICovXG4gICAgZmluZEFuY2VzdG9yOiBmdW5jdGlvbihzZWxlY3RvciwgaW5jbHVkZVNlbGYsIHN0b3BOb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kQW5jZXN0b3JzKHNlbGVjdG9yLCBpbmNsdWRlU2VsZiwgc3RvcE5vZGUpWzBdO1xuICAgIH0sXG4gICAgLy8gaXMgY3VycmVudCBub2RlIG1hdGNoIHBhc3NlZCBzZWxlY3Rvcj9cbiAgICBfaXNNYXRjaDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGVjdG9yQXJyID0gc2VsZWN0b3IucmVwbGFjZSgvIC9nLCAnJykuc3BsaXQoJywnKSxcbiAgICAgICAgbGVuID0gc2VsZWN0b3JBcnIubGVuZ3RoLFxuICAgICAgICBuLFxuICAgICAgICBzZWw7XG5cbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICBzZWwgPSBzZWxlY3RvckFycltuXTtcbiAgICAgICAgaWYgKCFLb252YS5VdGlsLmlzVmFsaWRTZWxlY3RvcihzZWwpKSB7XG4gICAgICAgICAgS29udmEuVXRpbC53YXJuKFxuICAgICAgICAgICAgJ1NlbGVjdG9yIFwiJyArXG4gICAgICAgICAgICAgIHNlbCArXG4gICAgICAgICAgICAgICdcIiBpcyBpbnZhbGlkLiBBbGxvd2VkIHNlbGVjdG9ycyBleGFtcGxlcyBhcmUgXCIjZm9vXCIsIFwiLmJhclwiIG9yIFwiR3JvdXBcIi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBLb252YS5VdGlsLndhcm4oXG4gICAgICAgICAgICAnSWYgeW91IGhhdmUgYSBjdXN0b20gc2hhcGUgd2l0aCBzdWNoIGNsYXNzTmFtZSwgcGxlYXNlIGNoYW5nZSBpdCB0byBzdGFydCB3aXRoIHVwcGVyIGxldHRlciBsaWtlIFwiVHJpYW5nbGVcIi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ0tvbnZhIGlzIGF3ZXNvbWUsIHJpZ2h0PycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlkIHNlbGVjdG9yXG4gICAgICAgIGlmIChzZWwuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICBpZiAodGhpcy5pZCgpID09PSBzZWwuc2xpY2UoMSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZWwuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgICAvLyBuYW1lIHNlbGVjdG9yXG4gICAgICAgICAgaWYgKHRoaXMuaGFzTmFtZShzZWwuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZ2V0KHNlbCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBsYXllciBhbmNlc3RvclxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuTGF5ZXJ9XG4gICAgICovXG4gICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICByZXR1cm4gcGFyZW50ID8gcGFyZW50LmdldExheWVyKCkgOiBudWxsO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IHN0YWdlIGFuY2VzdG9yXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5TdGFnZX1cbiAgICAgKi9cbiAgICBnZXRTdGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoU1RBR0UsIHRoaXMuX2dldFN0YWdlKTtcbiAgICB9LFxuICAgIF9nZXRTdGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5nZXRTdGFnZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGZpcmUgZXZlbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBldmVudCB0eXBlLiAgY2FuIGJlIGEgcmVndWxhciBldmVudCwgbGlrZSBjbGljaywgbW91c2VvdmVyLCBvciBtb3VzZW91dCwgb3IgaXQgY2FuIGJlIGEgY3VzdG9tIGV2ZW50LCBsaWtlIG15Q3VzdG9tRXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZXZ0XSBldmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVdIHNldHRpbmcgdGhlIHZhbHVlIHRvIGZhbHNlLCBvciBsZWF2aW5nIGl0IHVuZGVmaW5lZCwgd2lsbCByZXN1bHQgaW4gdGhlIGV2ZW50XG4gICAgICogIG5vdCBidWJibGluZy4gIFNldHRpbmcgdGhlIHZhbHVlIHRvIHRydWUgd2lsbCByZXN1bHQgaW4gdGhlIGV2ZW50IGJ1YmJsaW5nLlxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbWFudWFsbHkgZmlyZSBjbGljayBldmVudFxuICAgICAqIG5vZGUuZmlyZSgnY2xpY2snKTtcbiAgICAgKlxuICAgICAqIC8vIGZpcmUgY3VzdG9tIGV2ZW50XG4gICAgICogbm9kZS5maXJlKCdmb28nKTtcbiAgICAgKlxuICAgICAqIC8vIGZpcmUgY3VzdG9tIGV2ZW50IHdpdGggY3VzdG9tIGV2ZW50IG9iamVjdFxuICAgICAqIG5vZGUuZmlyZSgnZm9vJywge1xuICAgICAqICAgYmFyOiAxMFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gZmlyZSBjbGljayBldmVudCB0aGF0IGJ1YmJsZXNcbiAgICAgKiBub2RlLmZpcmUoJ2NsaWNrJywgbnVsbCwgdHJ1ZSk7XG4gICAgICovXG4gICAgZmlyZTogZnVuY3Rpb24oZXZlbnRUeXBlLCBldnQsIGJ1YmJsZSkge1xuICAgICAgZXZ0ID0gZXZ0IHx8IHt9O1xuICAgICAgZXZ0LnRhcmdldCA9IGV2dC50YXJnZXQgfHwgdGhpcztcbiAgICAgIC8vIGJ1YmJsZVxuICAgICAgaWYgKGJ1YmJsZSkge1xuICAgICAgICB0aGlzLl9maXJlQW5kQnViYmxlKGV2ZW50VHlwZSwgZXZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIGJ1YmJsZVxuICAgICAgICB0aGlzLl9maXJlKGV2ZW50VHlwZSwgZXZ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGFic29sdXRlIHRyYW5zZm9ybSBvZiB0aGUgbm9kZSB3aGljaCB0YWtlcyBpbnRvXG4gICAgICogIGFjY291bnQgaXRzIGFuY2VzdG9yIHRyYW5zZm9ybXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICBnZXRBYnNvbHV0ZVRyYW5zZm9ybTogZnVuY3Rpb24odG9wKSB7XG4gICAgICAvLyBpZiB1c2luZyBhbiBhcmd1bWVudCwgd2UgY2FuJ3QgY2FjaGUgdGhlIHJlc3VsdC5cbiAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFic29sdXRlVHJhbnNmb3JtKHRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBubyBhcmd1bWVudCwgd2UgY2FuIGNhY2hlIHRoZSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSwgdGhpcy5fZ2V0QWJzb2x1dGVUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldEFic29sdXRlVHJhbnNmb3JtOiBmdW5jdGlvbih0b3ApIHtcbiAgICAgIHZhciBhdCA9IG5ldyBLb252YS5UcmFuc2Zvcm0oKTtcblxuICAgICAgLy8gc3RhcnQgd2l0aCBzdGFnZSBhbmQgdHJhdmVyc2UgZG93bndhcmRzIHRvIHNlbGZcbiAgICAgIHRoaXMuX2VhY2hBbmNlc3RvclJldmVyc2UoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgdHJhbnNmb3Jtc0VuYWJsZWQgPSBub2RlLnRyYW5zZm9ybXNFbmFibGVkKCk7XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybXNFbmFibGVkID09PSAnYWxsJykge1xuICAgICAgICAgIGF0Lm11bHRpcGx5KG5vZGUuZ2V0VHJhbnNmb3JtKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybXNFbmFibGVkID09PSAncG9zaXRpb24nKSB7XG4gICAgICAgICAgYXQudHJhbnNsYXRlKFxuICAgICAgICAgICAgbm9kZS5nZXRYKCkgLSBub2RlLmdldE9mZnNldFgoKSxcbiAgICAgICAgICAgIG5vZGUuZ2V0WSgpIC0gbm9kZS5nZXRPZmZzZXRZKClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCB0b3ApO1xuICAgICAgcmV0dXJuIGF0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGFic29sdXRlIHNjYWxlIG9mIHRoZSBub2RlIHdoaWNoIHRha2VzIGludG9cbiAgICAgKiAgYWNjb3VudCBpdHMgYW5jZXN0b3Igc2NhbGVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgZ2V0QWJzb2x1dGVTY2FsZTogZnVuY3Rpb24odG9wKSB7XG4gICAgICAvLyBpZiB1c2luZyBhbiBhcmd1bWVudCwgd2UgY2FuJ3QgY2FjaGUgdGhlIHJlc3VsdC5cbiAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFic29sdXRlU2NhbGUodG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vIGFyZ3VtZW50LCB3ZSBjYW4gY2FjaGUgdGhlIHJlc3VsdFxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoQUJTT0xVVEVfU0NBTEUsIHRoaXMuX2dldEFic29sdXRlU2NhbGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldEFic29sdXRlU2NhbGU6IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgLy8gdGhpcyBpcyBzcGVjaWFsIGxvZ2ljIGZvciBjYWNoaW5nIHdpdGggc29tZSBzaGFwZXMgd2l0aCBzaGFkb3dcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50Ll9pc1VuZGVyQ2FjaGUpIHtcbiAgICAgICAgICB0b3AgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2NhbGVYID0gMSxcbiAgICAgICAgc2NhbGVZID0gMTtcblxuICAgICAgLy8gc3RhcnQgd2l0aCBzdGFnZSBhbmQgdHJhdmVyc2UgZG93bndhcmRzIHRvIHNlbGZcbiAgICAgIHRoaXMuX2VhY2hBbmNlc3RvclJldmVyc2UoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBzY2FsZVggKj0gbm9kZS5zY2FsZVgoKTtcbiAgICAgICAgc2NhbGVZICo9IG5vZGUuc2NhbGVZKCk7XG4gICAgICB9LCB0b3ApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogc2NhbGVYLFxuICAgICAgICB5OiBzY2FsZVlcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgdHJhbnNmb3JtIG9mIHRoZSBub2RlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgZ2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShUUkFOU0ZPUk0sIHRoaXMuX2dldFRyYW5zZm9ybSk7XG4gICAgfSxcbiAgICBfZ2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtID0gbmV3IEtvbnZhLlRyYW5zZm9ybSgpLFxuICAgICAgICB4ID0gdGhpcy5nZXRYKCksXG4gICAgICAgIHkgPSB0aGlzLmdldFkoKSxcbiAgICAgICAgcm90YXRpb24gPSBLb252YS5nZXRBbmdsZSh0aGlzLmdldFJvdGF0aW9uKCkpLFxuICAgICAgICBzY2FsZVggPSB0aGlzLmdldFNjYWxlWCgpLFxuICAgICAgICBzY2FsZVkgPSB0aGlzLmdldFNjYWxlWSgpLFxuICAgICAgICBza2V3WCA9IHRoaXMuZ2V0U2tld1goKSxcbiAgICAgICAgc2tld1kgPSB0aGlzLmdldFNrZXdZKCksXG4gICAgICAgIG9mZnNldFggPSB0aGlzLmdldE9mZnNldFgoKSxcbiAgICAgICAgb2Zmc2V0WSA9IHRoaXMuZ2V0T2Zmc2V0WSgpO1xuXG4gICAgICBpZiAoeCAhPT0gMCB8fCB5ICE9PSAwKSB7XG4gICAgICAgIG0udHJhbnNsYXRlKHgsIHkpO1xuICAgICAgfVxuICAgICAgaWYgKHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgIG0ucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChza2V3WCAhPT0gMCB8fCBza2V3WSAhPT0gMCkge1xuICAgICAgICBtLnNrZXcoc2tld1gsIHNrZXdZKTtcbiAgICAgIH1cbiAgICAgIGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG4gICAgICAgIG0uc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldFggIT09IDAgfHwgb2Zmc2V0WSAhPT0gMCkge1xuICAgICAgICBtLnRyYW5zbGF0ZSgtMSAqIG9mZnNldFgsIC0xICogb2Zmc2V0WSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY2xvbmUgbm9kZS4gIFJldHVybnMgYSBuZXcgTm9kZSBpbnN0YW5jZSB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzLiAgWW91IGNhbiBhbHNvIG92ZXJyaWRlXG4gICAgICogIHRoZSBub2RlIHByb3BlcnRpZXMgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbCwgZW5hYmxpbmcgeW91IHRvIHVzZSBhbiBleGlzdGluZyBub2RlIGFzIGEgdGVtcGxhdGVcbiAgICAgKiAgZm9yIGFub3RoZXIgbm9kZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIG92ZXJyaWRlIGF0dHJzXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBzaW1wbGUgY2xvbmVcbiAgICAgKiB2YXIgY2xvbmUgPSBub2RlLmNsb25lKCk7XG4gICAgICpcbiAgICAgKiAvLyBjbG9uZSBhIG5vZGUgYW5kIG92ZXJyaWRlIHRoZSB4IHBvc2l0aW9uXG4gICAgICogdmFyIGNsb25lID0gcmVjdC5jbG9uZSh7XG4gICAgICogICB4OiA1XG4gICAgICogfSk7XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgLy8gaW5zdGFudGlhdGUgbmV3IG5vZGVcbiAgICAgIHZhciBhdHRycyA9IEtvbnZhLlV0aWwuY2xvbmVPYmplY3QodGhpcy5hdHRycyksXG4gICAgICAgIGtleSxcbiAgICAgICAgYWxsTGlzdGVuZXJzLFxuICAgICAgICBsZW4sXG4gICAgICAgIG4sXG4gICAgICAgIGxpc3RlbmVyO1xuICAgICAgLy8gZmlsdGVyIGJsYWNrIGF0dHJzXG4gICAgICBmb3IgKHZhciBpIGluIENMT05FX0JMQUNLX0xJU1QpIHtcbiAgICAgICAgdmFyIGJsb2NrQXR0ciA9IENMT05FX0JMQUNLX0xJU1RbaV07XG4gICAgICAgIGRlbGV0ZSBhdHRyc1tibG9ja0F0dHJdO1xuICAgICAgfVxuICAgICAgLy8gYXBwbHkgYXR0ciBvdmVycmlkZXNcbiAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICBhdHRyc1trZXldID0gb2JqW2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoYXR0cnMpO1xuICAgICAgLy8gY29weSBvdmVyIGxpc3RlbmVyc1xuICAgICAgZm9yIChrZXkgaW4gdGhpcy5ldmVudExpc3RlbmVycykge1xuICAgICAgICBhbGxMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2tleV07XG4gICAgICAgIGxlbiA9IGFsbExpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgIGxpc3RlbmVyID0gYWxsTGlzdGVuZXJzW25dO1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIGRvbid0IGluY2x1ZGUga29udmEgbmFtZXNwYWNlZCBsaXN0ZW5lcnMgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgKiAgdGhlc2UgYXJlIGdlbmVyYXRlZCBieSB0aGUgY29uc3RydWN0b3JzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChsaXN0ZW5lci5uYW1lLmluZGV4T2YoS09OVkEpIDwgMCkge1xuICAgICAgICAgICAgLy8gaWYgbGlzdGVuZXJzIGFycmF5IGRvZXNuJ3QgZXhpc3QsIHRoZW4gY3JlYXRlIGl0XG4gICAgICAgICAgICBpZiAoIW5vZGUuZXZlbnRMaXN0ZW5lcnNba2V5XSkge1xuICAgICAgICAgICAgICBub2RlLmV2ZW50TGlzdGVuZXJzW2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuZXZlbnRMaXN0ZW5lcnNba2V5XS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgX3RvS29udmFDYW52YXM6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICB2YXIgYm94ID0gdGhpcy5nZXRDbGllbnRSZWN0KCk7XG5cbiAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKSxcbiAgICAgICAgeCA9IGNvbmZpZy54ICE9PSB1bmRlZmluZWQgPyBjb25maWcueCA6IGJveC54LFxuICAgICAgICB5ID0gY29uZmlnLnkgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy55IDogYm94LnksXG4gICAgICAgIHBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICBjYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoe1xuICAgICAgICAgIHdpZHRoOiBjb25maWcud2lkdGggfHwgYm94LndpZHRoIHx8IChzdGFnZSA/IHN0YWdlLmdldFdpZHRoKCkgOiAwKSxcbiAgICAgICAgICBoZWlnaHQ6XG4gICAgICAgICAgICBjb25maWcuaGVpZ2h0IHx8IGJveC5oZWlnaHQgfHwgKHN0YWdlID8gc3RhZ2UuZ2V0SGVpZ2h0KCkgOiAwKSxcbiAgICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvXG4gICAgICAgIH0pLFxuICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoKTtcblxuICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgIGlmICh4IHx8IHkpIHtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLTEgKiB4LCAtMSAqIHkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRyYXdTY2VuZShjYW52YXMpO1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBub2RlIGludG8gYW4gY2FudmFzIGVsZW1lbnQuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcuY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgY29tcG9zaXRlIGhhcyBjb21wbGV0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV0geSBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSB3aWR0aCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmVtdCB7TnVtYmVyfSBbY29uZmlnLnBpeGVsUmF0aW9dIHBpeGVsUmF0aW8gb2Ygb3VwdXQgaW1hZ2UuICBEZWZhdWx0IGlzIDEuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgY2FudmFzID0gbm9kZS50b0NhbnZhcygpO1xuICAgICAqL1xuICAgIHRvQ2FudmFzOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b0tvbnZhQ2FudmFzKGNvbmZpZykuX2NhbnZhcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgZGF0YSBVUkwuIElmIE1JTUUgdHlwZSBpcyBub3RcbiAgICAgKiBzcGVjaWZpZWQsIHRoZW4gXCJpbWFnZS9wbmdcIiB3aWxsIHJlc3VsdC4gRm9yIFwiaW1hZ2UvanBlZ1wiLCBzcGVjaWZ5IGEgcXVhbGl0eVxuICAgICAqIGxldmVsIGFzIHF1YWxpdHkgKHJhbmdlIDAuMCAtIDEuMClcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm1pbWVUeXBlXSBjYW4gYmUgXCJpbWFnZS9wbmdcIiBvciBcImltYWdlL2pwZWdcIi5cbiAgICAgKiAgXCJpbWFnZS9wbmdcIiBpcyB0aGUgZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdIHggcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XSB5IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XSBoZWlnaHQgb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5xdWFsaXR5XSBqcGVnIHF1YWxpdHkuICBJZiB1c2luZyBhbiBcImltYWdlL2pwZWdcIiBtaW1lVHlwZSxcbiAgICAgKiAgeW91IGNhbiBzcGVjaWZ5IHRoZSBxdWFsaXR5IGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHZlcnkgcG9vciBxdWFsaXR5IGFuZCAxXG4gICAgICogIGlzIHZlcnkgaGlnaCBxdWFsaXR5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucGl4ZWxSYXRpb10gcGl4ZWxSYXRpbyBvZiBvdXRwdXQgaW1hZ2UgdXJsLiBEZWZhdWx0IGlzIDFcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICB2YXIgbWltZVR5cGUgPSBjb25maWcubWltZVR5cGUgfHwgbnVsbCxcbiAgICAgICAgcXVhbGl0eSA9IGNvbmZpZy5xdWFsaXR5IHx8IG51bGw7XG4gICAgICB2YXIgdXJsID0gdGhpcy5fdG9Lb252YUNhbnZhcyhjb25maWcpLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSk7XG4gICAgICBpZiAoY29uZmlnLmNhbGxiYWNrKSB7XG4gICAgICAgIGNvbmZpZy5jYWxsYmFjayh1cmwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIG5vZGUgaW50byBhbiBpbWFnZS4gIFNpbmNlIHRoZSB0b0ltYWdlXG4gICAgICogIG1ldGhvZCBpcyBhc3luY2hyb25vdXMsIGEgY2FsbGJhY2sgaXMgcmVxdWlyZWQuICB0b0ltYWdlIGlzIG1vc3QgY29tbW9ubHkgdXNlZFxuICAgICAqICB0byBjYWNoZSBjb21wbGV4IGRyYXdpbmdzIGFzIGFuIGltYWdlIHNvIHRoYXQgdGhleSBkb24ndCBoYXZlIHRvIGNvbnN0YW50bHkgYmUgcmVkcmF3blxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLmNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIGNvbXBvc2l0ZSBoYXMgY29tcGxldGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubWltZVR5cGVdIGNhbiBiZSBcImltYWdlL3BuZ1wiIG9yIFwiaW1hZ2UvanBlZ1wiLlxuICAgICAqICBcImltYWdlL3BuZ1wiIGlzIHRoZSBkZWZhdWx0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF0geCBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldIHkgcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF0gd2lkdGggb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdIGhlaWdodCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnF1YWxpdHldIGpwZWcgcXVhbGl0eS4gIElmIHVzaW5nIGFuIFwiaW1hZ2UvanBlZ1wiIG1pbWVUeXBlLFxuICAgICAqICB5b3UgY2FuIHNwZWNpZnkgdGhlIHF1YWxpdHkgZnJvbSAwIHRvIDEsIHdoZXJlIDAgaXMgdmVyeSBwb29yIHF1YWxpdHkgYW5kIDFcbiAgICAgKiAgaXMgdmVyeSBoaWdoIHF1YWxpdHlcbiAgICAgKiBAcGFyZW10IHtOdW1iZXJ9IFtjb25maWcucGl4ZWxSYXRpb10gcGl4ZWxSYXRpbyBvZiBvdXB1dCBpbWFnZS4gIERlZmF1bHQgaXMgMS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBpbWFnZSA9IG5vZGUudG9JbWFnZSh7XG4gICAgICogICBjYWxsYmFjazogZnVuY3Rpb24oaW1nKSB7XG4gICAgICogICAgIC8vIGRvIHN0dWZmIHdpdGggaW1nXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICovXG4gICAgdG9JbWFnZTogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICBpZiAoIWNvbmZpZyB8fCAhY29uZmlnLmNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93ICdjYWxsYmFjayByZXF1aXJlZCBmb3IgdG9JbWFnZSBtZXRob2QgY29uZmlnIGFyZ3VtZW50JztcbiAgICAgIH1cbiAgICAgIHZhciBjYWxsYmFjayA9IGNvbmZpZy5jYWxsYmFjaztcbiAgICAgIGRlbGV0ZSBjb25maWcuY2FsbGJhY2s7XG4gICAgICBLb252YS5VdGlsLl9nZXRJbWFnZSh0aGlzLnRvRGF0YVVSTChjb25maWcpLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgY2FsbGJhY2soaW1nKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdGhpcy5zZXRXaWR0aChzaXplLndpZHRoKTtcbiAgICAgIHRoaXMuc2V0SGVpZ2h0KHNpemUuaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuZ2V0SGVpZ2h0KClcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRycy53aWR0aCB8fCAwO1xuICAgIH0sXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJzLmhlaWdodCB8fCAwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGNsYXNzIG5hbWUsIHdoaWNoIG1heSByZXR1cm4gU3RhZ2UsIExheWVyLCBHcm91cCwgb3Igc2hhcGUgY2xhc3MgbmFtZXMgbGlrZSBSZWN0LCBDaXJjbGUsIFRleHQsIGV0Yy5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xhc3NOYW1lIHx8IHRoaXMubm9kZVR5cGU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG5vZGUgdHlwZSwgd2hpY2ggbWF5IHJldHVybiBTdGFnZSwgTGF5ZXIsIEdyb3VwLCBvciBOb2RlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlVHlwZTtcbiAgICB9LFxuICAgIGdldERyYWdEaXN0YW5jZTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBjb21wYXJlIHdpdGggdW5kZWZpbmVkIGJlY2F1c2Ugd2UgbmVlZCB0byB0cmFjayAwIHZhbHVlXG4gICAgICBpZiAodGhpcy5hdHRycy5kcmFnRGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5kcmFnRGlzdGFuY2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXREcmFnRGlzdGFuY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBLb252YS5kcmFnRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0OiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMuY2xhc3NOYW1lID09PSBzZWxlY3RvciB8fCB0aGlzLm5vZGVUeXBlID09PSBzZWxlY3RvclxuICAgICAgICA/IFt0aGlzXVxuICAgICAgICA6IFtdO1xuICAgIH0sXG4gICAgX29mZjogZnVuY3Rpb24odHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBldnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW3R5cGVdLFxuICAgICAgICBpLFxuICAgICAgICBldnROYW1lLFxuICAgICAgICBoYW5kbGVyO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZXZ0TGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV2dE5hbWUgPSBldnRMaXN0ZW5lcnNbaV0ubmFtZTtcbiAgICAgICAgaGFuZGxlciA9IGV2dExpc3RlbmVyc1tpXS5oYW5kbGVyO1xuXG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdHdvIGNvbmRpdGlvbnMgbXVzdCBiZSB0cnVlIGluIG9yZGVyIHRvIHJlbW92ZSBhIGhhbmRsZXI6XG4gICAgICAgIC8vIDEpIHRoZSBjdXJyZW50IGV2ZW50IG5hbWUgY2Fubm90IGJlIGtvbnZhIHVubGVzcyB0aGUgZXZlbnQgbmFtZSBpcyBrb252YVxuICAgICAgICAvLyAgICB0aGlzIGVuYWJsZXMgZGV2ZWxvcGVycyB0byBmb3JjZSByZW1vdmUgYSBrb252YSBzcGVjaWZpYyBsaXN0ZW5lciBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgICAgIC8vIDIpIGFuIGV2ZW50IG5hbWUgaXMgbm90IHNwZWNpZmllZCwgb3IgaWYgb25lIGlzIHNwZWNpZmllZCwgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBldmVudCBuYW1lXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoZXZ0TmFtZSAhPT0gJ2tvbnZhJyB8fCBuYW1lID09PSAna29udmEnKSAmJlxuICAgICAgICAgICghbmFtZSB8fCBldnROYW1lID09PSBuYW1lKSAmJlxuICAgICAgICAgICghY2FsbGJhY2sgfHwgY2FsbGJhY2sgPT09IGhhbmRsZXIpXG4gICAgICAgICkge1xuICAgICAgICAgIGV2dExpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgaWYgKGV2dExpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50TGlzdGVuZXJzW3R5cGVdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX2ZpcmVDaGFuZ2VFdmVudDogZnVuY3Rpb24oYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgIHRoaXMuX2ZpcmUoYXR0ciArIENIQU5HRSwge1xuICAgICAgICBvbGRWYWw6IG9sZFZhbCxcbiAgICAgICAgbmV3VmFsOiBuZXdWYWxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0SWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgb2xkSWQgPSB0aGlzLmdldElkKCk7XG5cbiAgICAgIEtvbnZhLl9yZW1vdmVJZChvbGRJZCk7XG4gICAgICBLb252YS5fYWRkSWQodGhpcywgaWQpO1xuICAgICAgdGhpcy5fc2V0QXR0cihJRCwgaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXROYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgb2xkTmFtZXMgPSAodGhpcy5nZXROYW1lKCkgfHwgJycpLnNwbGl0KC9cXHMvZyk7XG4gICAgICB2YXIgbmV3TmFtZXMgPSAobmFtZSB8fCAnJykuc3BsaXQoL1xccy9nKTtcbiAgICAgIHZhciBzdWJuYW1lLCBpO1xuICAgICAgLy8gcmVtb3ZlIGFsbCBzdWJuYW1lc1xuICAgICAgZm9yIChpID0gMDsgaSA8IG9sZE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1Ym5hbWUgPSBvbGROYW1lc1tpXTtcbiAgICAgICAgaWYgKG5ld05hbWVzLmluZGV4T2Yoc3VibmFtZSkgPT09IC0xICYmIHN1Ym5hbWUpIHtcbiAgICAgICAgICBLb252YS5fcmVtb3ZlTmFtZShzdWJuYW1lLCB0aGlzLl9pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYWRkIG5ldyBuYW1lc1xuICAgICAgZm9yIChpID0gMDsgaSA8IG5ld05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1Ym5hbWUgPSBuZXdOYW1lc1tpXTtcbiAgICAgICAgaWYgKG9sZE5hbWVzLmluZGV4T2Yoc3VibmFtZSkgPT09IC0xICYmIHN1Ym5hbWUpIHtcbiAgICAgICAgICBLb252YS5fYWRkTmFtZSh0aGlzLCBzdWJuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRBdHRyKE5BTUUsIG5hbWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBuYW1pbmcgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIGFkZCBuYW1lIHRvIG5vZGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUubmFtZSgncmVkJyk7XG4gICAgICogbm9kZS5hZGROYW1lKCdzZWxlY3RlZCcpO1xuICAgICAqIG5vZGUubmFtZSgpOyAvLyByZXR1cm4gJ3JlZCBzZWxlY3RlZCdcbiAgICAgKi9cbiAgICBhZGROYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzTmFtZShuYW1lKSkge1xuICAgICAgICB2YXIgb2xkTmFtZSA9IHRoaXMubmFtZSgpO1xuICAgICAgICB2YXIgbmV3TmFtZSA9IG9sZE5hbWUgPyBvbGROYW1lICsgJyAnICsgbmFtZSA6IG5hbWU7XG4gICAgICAgIHRoaXMuc2V0TmFtZShuZXdOYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY2hlY2sgaXMgbm9kZSBoYXMgbmFtZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5uYW1lKCdyZWQnKTtcbiAgICAgKiBub2RlLmhhc05hbWUoJ3JlZCcpOyAgIC8vIHJldHVybiB0cnVlXG4gICAgICogbm9kZS5oYXNOYW1lKCdzZWxlY3RlZCcpOyAvLyByZXR1cm4gZmFsc2VcbiAgICAgKi9cbiAgICBoYXNOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgbmFtZXMgPSAodGhpcy5uYW1lKCkgfHwgJycpLnNwbGl0KC9cXHMvZyk7XG4gICAgICByZXR1cm4gbmFtZXMuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZW1vdmUgbmFtZSBmcm9tIG5vZGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUubmFtZSgncmVkIHNlbGVjdGVkJyk7XG4gICAgICogbm9kZS5yZW1vdmVOYW1lKCdzZWxlY3RlZCcpO1xuICAgICAqIG5vZGUuaGFzTmFtZSgnc2VsZWN0ZWQnKTsgLy8gcmV0dXJuIGZhbHNlXG4gICAgICogbm9kZS5uYW1lKCk7IC8vIHJldHVybiAncmVkJ1xuICAgICAqL1xuICAgIHJlbW92ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBuYW1lcyA9ICh0aGlzLm5hbWUoKSB8fCAnJykuc3BsaXQoL1xccy9nKTtcbiAgICAgIHZhciBpbmRleCA9IG5hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG5hbWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuc2V0TmFtZShuYW1lcy5qb2luKCcgJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXQgYXR0clxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLnNldEF0dHIoJ3gnLCA1KTtcbiAgICAgKi9cbiAgICBzZXRBdHRyOiBmdW5jdGlvbihhdHRyLCB2YWwpIHtcbiAgICAgIHZhciBtZXRob2QgPSBTRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpLFxuICAgICAgICBmdW5jID0gdGhpc1ttZXRob2RdO1xuXG4gICAgICBpZiAoS29udmEuVXRpbC5faXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICBmdW5jLmNhbGwodGhpcywgdmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBzZXQgZGlyZWN0bHlcbiAgICAgICAgdGhpcy5fc2V0QXR0cihhdHRyLCB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfc2V0QXR0cjogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgIHZhciBvbGRWYWw7XG4gICAgICBvbGRWYWwgPSB0aGlzLmF0dHJzW2tleV07XG4gICAgICB2YXIgc2FtZSA9IG9sZFZhbCA9PT0gdmFsO1xuICAgICAgaWYgKHNhbWUgJiYgIUtvbnZhLlV0aWwuaXNPYmplY3QodmFsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJzW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHJzW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgICB0aGlzLl9maXJlQ2hhbmdlRXZlbnQoa2V5LCBvbGRWYWwsIHZhbCk7XG4gICAgfSxcbiAgICBfc2V0Q29tcG9uZW50QXR0cjogZnVuY3Rpb24oa2V5LCBjb21wb25lbnQsIHZhbCkge1xuICAgICAgdmFyIG9sZFZhbDtcbiAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbGRWYWwgPSB0aGlzLmF0dHJzW2tleV07XG5cbiAgICAgICAgaWYgKCFvbGRWYWwpIHtcbiAgICAgICAgICAvLyBzZXQgdmFsdWUgdG8gZGVmYXVsdCB2YWx1ZSB1c2luZyBnZXRBdHRyXG4gICAgICAgICAgdGhpcy5hdHRyc1trZXldID0gdGhpcy5nZXRBdHRyKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmF0dHJzW2tleV1bY29tcG9uZW50XSA9IHZhbDtcbiAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KGtleSwgb2xkVmFsLCB2YWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2ZpcmVBbmRCdWJibGU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZ0LCBjb21wYXJlU2hhcGUpIHtcbiAgICAgIHZhciBva2F5VG9SdW4gPSB0cnVlO1xuXG4gICAgICBpZiAoZXZ0ICYmIHRoaXMubm9kZVR5cGUgPT09IFNIQVBFKSB7XG4gICAgICAgIGV2dC50YXJnZXQgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50VHlwZSA9PT0gTU9VU0VFTlRFUiAmJlxuICAgICAgICBjb21wYXJlU2hhcGUgJiZcbiAgICAgICAgKHRoaXMuX2lkID09PSBjb21wYXJlU2hhcGUuX2lkIHx8XG4gICAgICAgICAgKHRoaXMuaXNBbmNlc3Rvck9mICYmIHRoaXMuaXNBbmNlc3Rvck9mKGNvbXBhcmVTaGFwZSkpKVxuICAgICAgKSB7XG4gICAgICAgIG9rYXlUb1J1biA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgZXZlbnRUeXBlID09PSBNT1VTRUxFQVZFICYmXG4gICAgICAgIGNvbXBhcmVTaGFwZSAmJlxuICAgICAgICAodGhpcy5faWQgPT09IGNvbXBhcmVTaGFwZS5faWQgfHxcbiAgICAgICAgICAodGhpcy5pc0FuY2VzdG9yT2YgJiYgdGhpcy5pc0FuY2VzdG9yT2YoY29tcGFyZVNoYXBlKSkpXG4gICAgICApIHtcbiAgICAgICAgb2theVRvUnVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob2theVRvUnVuKSB7XG4gICAgICAgIHRoaXMuX2ZpcmUoZXZlbnRUeXBlLCBldnQpO1xuXG4gICAgICAgIC8vIHNpbXVsYXRlIGV2ZW50IGJ1YmJsaW5nXG4gICAgICAgIHZhciBzdG9wQnViYmxlID1cbiAgICAgICAgICAoZXZlbnRUeXBlID09PSBNT1VTRUVOVEVSIHx8IGV2ZW50VHlwZSA9PT0gTU9VU0VMRUFWRSkgJiZcbiAgICAgICAgICAoY29tcGFyZVNoYXBlICYmXG4gICAgICAgICAgICBjb21wYXJlU2hhcGUuaXNBbmNlc3Rvck9mICYmXG4gICAgICAgICAgICBjb21wYXJlU2hhcGUuaXNBbmNlc3Rvck9mKHRoaXMpICYmXG4gICAgICAgICAgICAhY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZih0aGlzLnBhcmVudCkpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKChldnQgJiYgIWV2dC5jYW5jZWxCdWJibGUpIHx8ICFldnQpICYmXG4gICAgICAgICAgdGhpcy5wYXJlbnQgJiZcbiAgICAgICAgICB0aGlzLnBhcmVudC5pc0xpc3RlbmluZygpICYmXG4gICAgICAgICAgIXN0b3BCdWJibGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVTaGFwZSAmJiBjb21wYXJlU2hhcGUucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlQW5kQnViYmxlLmNhbGwoXG4gICAgICAgICAgICAgIHRoaXMucGFyZW50LFxuICAgICAgICAgICAgICBldmVudFR5cGUsXG4gICAgICAgICAgICAgIGV2dCxcbiAgICAgICAgICAgICAgY29tcGFyZVNoYXBlLnBhcmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmlyZUFuZEJ1YmJsZS5jYWxsKHRoaXMucGFyZW50LCBldmVudFR5cGUsIGV2dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfZmlyZTogZnVuY3Rpb24oZXZlbnRUeXBlLCBldnQpIHtcbiAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50VHlwZV0sXG4gICAgICAgIGk7XG5cbiAgICAgIGV2dCA9IGV2dCB8fCB7fTtcbiAgICAgIGV2dC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcbiAgICAgIGV2dC50eXBlID0gZXZlbnRUeXBlO1xuXG4gICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBldmVudHNbaV0uaGFuZGxlci5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRyYXcgYm90aCBzY2VuZSBhbmQgaGl0IGdyYXBocy4gIElmIHRoZSBub2RlIGJlaW5nIGRyYXduIGlzIHRoZSBzdGFnZSwgYWxsIG9mIHRoZSBsYXllcnMgd2lsbCBiZSBjbGVhcmVkIGFuZCByZWRyYXduXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAqL1xuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kcmF3U2NlbmUoKTtcbiAgICAgIHRoaXMuZHJhd0hpdCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogY3JlYXRlIG5vZGUgd2l0aCBKU09OIHN0cmluZyBvciBhbiBPYmplY3QuICBEZS1zZXJpYWxpenRpb24gZG9lcyBub3QgZ2VuZXJhdGUgY3VzdG9tXG4gICAqICBzaGFwZSBkcmF3aW5nIGZ1bmN0aW9ucywgaW1hZ2VzLCBvciBldmVudCBoYW5kbGVycyAodGhpcyB3b3VsZCBtYWtlIHRoZVxuICAgKiAgc2VyaWFsaXplZCBvYmplY3QgaHVnZSkuICBJZiB5b3VyIGFwcCB1c2VzIGN1c3RvbSBzaGFwZXMsIGltYWdlcywgYW5kXG4gICAqICBldmVudCBoYW5kbGVycyAoaXQgcHJvYmFibHkgZG9lcyksIHRoZW4geW91IG5lZWQgdG8gc2VsZWN0IHRoZSBhcHByb3ByaWF0ZVxuICAgKiAgc2hhcGVzIGFmdGVyIGxvYWRpbmcgdGhlIHN0YWdlIGFuZCBzZXQgdGhlc2UgcHJvcGVydGllcyB2aWEgb24oKSwgc2V0U2NlbmVGdW5jKCksXG4gICAqICBhbmQgc2V0SW1hZ2UoKSBtZXRob2RzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGVcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIHN0cmluZyBvciBvYmplY3RcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbY29udGFpbmVyXSBvcHRpb25hbCBjb250YWluZXIgZG9tIGVsZW1lbnQgdXNlZCBvbmx5IGlmIHlvdSdyZVxuICAgKiAgY3JlYXRpbmcgYSBzdGFnZSBub2RlXG4gICAqL1xuICBLb252YS5Ob2RlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGNvbnRhaW5lcikge1xuICAgIGlmIChLb252YS5VdGlsLl9pc1N0cmluZyhkYXRhKSkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVOb2RlKGRhdGEsIGNvbnRhaW5lcik7XG4gIH07XG4gIEtvbnZhLk5vZGUuX2NyZWF0ZU5vZGUgPSBmdW5jdGlvbihvYmosIGNvbnRhaW5lcikge1xuICAgIHZhciBjbGFzc05hbWUgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5nZXRDbGFzc05hbWUuY2FsbChvYmopLFxuICAgICAgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW4sXG4gICAgICBubyxcbiAgICAgIGxlbixcbiAgICAgIG47XG5cbiAgICAvLyBpZiBjb250YWluZXIgd2FzIHBhc3NlZCBpbiwgYWRkIGl0IHRvIGF0dHJzXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgb2JqLmF0dHJzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBubyA9IG5ldyBLb252YVtjbGFzc05hbWVdKG9iai5hdHRycyk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgbm8uYWRkKHRoaXMuX2NyZWF0ZU5vZGUoY2hpbGRyZW5bbl0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm87XG4gIH07XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09IGFkZCBnZXR0ZXJzIHNldHRlcnMgPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdwb3NpdGlvbicpO1xuICAvKipcbiAgICogZ2V0L3NldCBub2RlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHBhcmVudFxuICAgKiBAbmFtZSBwb3NpdGlvblxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnlcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHBvc2l0aW9uXG4gICAqIHZhciBwb3NpdGlvbiA9IG5vZGUucG9zaXRpb24oKTtcbiAgICpcbiAgICogLy8gc2V0IHBvc2l0aW9uXG4gICAqIG5vZGUucG9zaXRpb24oe1xuICAgKiAgIHg6IDVcbiAgICogICB5OiAxMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAneCcsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgeCBwb3NpdGlvblxuICAgKiBAbmFtZSB4XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB4XG4gICAqIHZhciB4ID0gbm9kZS54KCk7XG4gICAqXG4gICAqIC8vIHNldCB4XG4gICAqIG5vZGUueCg1KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAneScsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgeSBwb3NpdGlvblxuICAgKiBAbmFtZSB5XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgeVxuICAgKiB2YXIgeSA9IG5vZGUueSgpO1xuICAgKlxuICAgKiAvLyBzZXQgeVxuICAgKiBub2RlLnkoNSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbicsXG4gICAgJ3NvdXJjZS1vdmVyJyxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldFN0cmluZ1ZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIG9mIGEgc2hhcGVcbiAgICogQG5hbWUgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICogdmFyIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHNoYXBlLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbigpO1xuICAgKlxuICAgKiAvLyBzZXQgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAqIHNoYXBlLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbignc291cmNlLWluJyk7XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdvcGFjaXR5JyxcbiAgICAxLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBvcGFjaXR5LiAgT3BhY2l0eSB2YWx1ZXMgcmFuZ2UgZnJvbSAwIHRvIDEuXG4gICAqICBBIG5vZGUgd2l0aCBhbiBvcGFjaXR5IG9mIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQsIGFuZCBhIG5vZGVcbiAgICogIHdpdGggYW4gb3BhY2l0eSBvZiAxIGlzIGZ1bGx5IG9wYXF1ZVxuICAgKiBAbmFtZSBvcGFjaXR5XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcGFjaXR5XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBvcGFjaXR5XG4gICAqIHZhciBvcGFjaXR5ID0gbm9kZS5vcGFjaXR5KCk7XG4gICAqXG4gICAqIC8vIHNldCBvcGFjaXR5XG4gICAqIG5vZGUub3BhY2l0eSgwLjUpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5Ob2RlLCAnbmFtZScpO1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ25hbWUnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBuYW1lXG4gICAqIEBuYW1lIG5hbWVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IG5hbWVcbiAgICogdmFyIG5hbWUgPSBub2RlLm5hbWUoKTtcbiAgICpcbiAgICogLy8gc2V0IG5hbWVcbiAgICogbm9kZS5uYW1lKCdmb28nKTtcbiAgICpcbiAgICogLy8gYWxzbyBub2RlIG1heSBoYXZlIG11bHRpcGxlIG5hbWVzIChhcyBjc3MgY2xhc3NlcylcbiAgICogbm9kZS5uYW1lKCdmb28gYmFyJyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLk5vZGUsICdpZCcpO1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2lkJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgaWQuIElkIGlzIGdsb2JhbCBmb3Igd2hvbGUgcGFnZS5cbiAgICogQG5hbWUgaWRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBpZFxuICAgKiB2YXIgbmFtZSA9IG5vZGUuaWQoKTtcbiAgICpcbiAgICogLy8gc2V0IGlkXG4gICAqIG5vZGUuaWQoJ2ZvbycpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdyb3RhdGlvbicsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgcm90YXRpb24gaW4gZGVncmVlc1xuICAgKiBAbmFtZSByb3RhdGlvblxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICogdmFyIHJvdGF0aW9uID0gbm9kZS5yb3RhdGlvbigpO1xuICAgKlxuICAgKiAvLyBzZXQgcm90YXRpb24gaW4gZGVncmVlc1xuICAgKiBub2RlLnJvdGF0aW9uKDQ1KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzY2FsZScsIFsneCcsICd5J10pO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNjYWxlXG4gICAqIEBuYW1lIHNjYWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2FsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUueFxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUueVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc2NhbGVcbiAgICogdmFyIHNjYWxlID0gbm9kZS5zY2FsZSgpO1xuICAgKlxuICAgKiAvLyBzZXQgc2NhbGVcbiAgICogc2hhcGUuc2NhbGUoe1xuICAgKiAgIHg6IDJcbiAgICogICB5OiAzXG4gICAqIH0pO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdzY2FsZVgnLFxuICAgIDEsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNjYWxlIHhcbiAgICogQG5hbWUgc2NhbGVYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzY2FsZSB4XG4gICAqIHZhciBzY2FsZVggPSBub2RlLnNjYWxlWCgpO1xuICAgKlxuICAgKiAvLyBzZXQgc2NhbGUgeFxuICAgKiBub2RlLnNjYWxlWCgyKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnc2NhbGVZJyxcbiAgICAxLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzY2FsZSB5XG4gICAqIEBuYW1lIHNjYWxlWVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc2NhbGUgeVxuICAgKiB2YXIgc2NhbGVZID0gbm9kZS5zY2FsZVkoKTtcbiAgICpcbiAgICogLy8gc2V0IHNjYWxlIHlcbiAgICogbm9kZS5zY2FsZVkoMik7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2tldycsIFsneCcsICd5J10pO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNrZXdcbiAgICogQG5hbWUgc2tld1xuICAgKiBAcGFyYW0ge09iamVjdH0gc2tld1xuICAgKiBAcGFyYW0ge051bWJlcn0gc2tldy54XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBza2V3LnlcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHNrZXdcbiAgICogdmFyIHNrZXcgPSBub2RlLnNrZXcoKTtcbiAgICpcbiAgICogLy8gc2V0IHNrZXdcbiAgICogbm9kZS5za2V3KHtcbiAgICogICB4OiAyMFxuICAgKiAgIHk6IDEwXG4gICAqIH0pO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdza2V3WCcsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc2tldyB4XG4gICAqIEBuYW1lIHNrZXdYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBza2V3IHhcbiAgICogdmFyIHNrZXdYID0gbm9kZS5za2V3WCgpO1xuICAgKlxuICAgKiAvLyBzZXQgc2tldyB4XG4gICAqIG5vZGUuc2tld1goMyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ3NrZXdZJyxcbiAgICAwLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBza2V3IHlcbiAgICogQG5hbWUgc2tld1lcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHNrZXcgeVxuICAgKiB2YXIgc2tld1kgPSBub2RlLnNrZXdZKCk7XG4gICAqXG4gICAqIC8vIHNldCBza2V3IHlcbiAgICogbm9kZS5za2V3WSgzKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdvZmZzZXQnLCBbJ3gnLCAneSddKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBvZmZzZXQuICBPZmZzZXRzIHRoZSBkZWZhdWx0IHBvc2l0aW9uIGFuZCByb3RhdGlvbiBwb2ludFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnlcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IG9mZnNldFxuICAgKiB2YXIgb2Zmc2V0ID0gbm9kZS5vZmZzZXQoKTtcbiAgICpcbiAgICogLy8gc2V0IG9mZnNldFxuICAgKiBub2RlLm9mZnNldCh7XG4gICAqICAgeDogMjBcbiAgICogICB5OiAxMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnb2Zmc2V0WCcsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgb2Zmc2V0IHhcbiAgICogQG5hbWUgb2Zmc2V0WFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgb2Zmc2V0IHhcbiAgICogdmFyIG9mZnNldFggPSBub2RlLm9mZnNldFgoKTtcbiAgICpcbiAgICogLy8gc2V0IG9mZnNldCB4XG4gICAqIG5vZGUub2Zmc2V0WCgzKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnb2Zmc2V0WScsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgb2Zmc2V0IHlcbiAgICogQG5hbWUgb2Zmc2V0WVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgb2Zmc2V0IHlcbiAgICogdmFyIG9mZnNldFkgPSBub2RlLm9mZnNldFkoKTtcbiAgICpcbiAgICogLy8gc2V0IG9mZnNldCB5XG4gICAqIG5vZGUub2Zmc2V0WSgzKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnZHJhZ0Rpc3RhbmNlJyxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG4gIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZHJhZ0Rpc3RhbmNlJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZHJhZyBkaXN0YW5jZVxuICAgKiBAbmFtZSBkcmFnRGlzdGFuY2VcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBkcmFnIGRpc3RhbmNlXG4gICAqIHZhciBkcmFnRGlzdGFuY2UgPSBub2RlLmRyYWdEaXN0YW5jZSgpO1xuICAgKlxuICAgKiAvLyBzZXQgZGlzdGFuY2VcbiAgICogLy8gbm9kZSBzdGFydHMgZHJhZ2dpbmcgb25seSBpZiBwb2ludGVyIG1vdmVkIG1vcmUgdGhlbiAzIHBpeGVsc1xuICAgKiBub2RlLmRyYWdEaXN0YW5jZSgzKTtcbiAgICogLy8gb3Igc2V0IGdsb2JhbGx5XG4gICAqIEtvbnZhLmRyYWdEaXN0YW5jZSA9IDM7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ3dpZHRoJyxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG4gIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnd2lkdGgnKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgd2lkdGhcbiAgICogQG5hbWUgd2lkdGhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB3aWR0aFxuICAgKiB2YXIgd2lkdGggPSBub2RlLndpZHRoKCk7XG4gICAqXG4gICAqIC8vIHNldCB3aWR0aFxuICAgKiBub2RlLndpZHRoKDEwMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2hlaWdodCcsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2hlaWdodCcpO1xuICAvKipcbiAgICogZ2V0L3NldCBoZWlnaHRcbiAgICogQG5hbWUgaGVpZ2h0XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGhlaWdodFxuICAgKiB2YXIgaGVpZ2h0ID0gbm9kZS5oZWlnaHQoKTtcbiAgICpcbiAgICogLy8gc2V0IGhlaWdodFxuICAgKiBub2RlLmhlaWdodCgxMDApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnbGlzdGVuaW5nJywgJ2luaGVyaXQnLCBmdW5jdGlvbihcbiAgICB2YWxcbiAgKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSB8fCB2YWwgPT09ICdpbmhlcml0JztcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgdmFsICtcbiAgICAgICAgICAnIGlzIGEgbm90IHZhbGlkIHZhbHVlIGZvciBcImxpc3RlbmluZ1wiIGF0dHJpYnV0ZS4gVGhlIHZhbHVlIG1heSBiZSB0cnVlLCBmYWxzZSBvciBcImluaGVyaXRcIi4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9KTtcbiAgLyoqXG4gICAqIGdldC9zZXQgbGlzdGVuaWcgYXR0ci4gIElmIHlvdSBuZWVkIHRvIGRldGVybWluZSBpZiBhIG5vZGUgaXMgbGlzdGVuaW5nIG9yIG5vdFxuICAgKiAgIGJ5IHRha2luZyBpbnRvIGFjY291bnQgaXRzIHBhcmVudHMsIHVzZSB0aGUgaXNMaXN0ZW5pbmcoKSBtZXRob2RcbiAgICogQG5hbWUgbGlzdGVuaW5nXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IGxpc3RlbmluZyBDYW4gYmUgXCJpbmhlcml0XCIsIHRydWUsIG9yIGZhbHNlLiAgVGhlIGRlZmF1bHQgaXMgXCJpbmhlcml0XCIuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufFN0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGxpc3RlbmluZyBhdHRyXG4gICAqIHZhciBsaXN0ZW5pbmcgPSBub2RlLmxpc3RlbmluZygpO1xuICAgKlxuICAgKiAvLyBzdG9wIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAqIG5vZGUubGlzdGVuaW5nKGZhbHNlKTtcbiAgICpcbiAgICogLy8gbGlzdGVuIGZvciBldmVudHNcbiAgICogbm9kZS5saXN0ZW5pbmcodHJ1ZSk7XG4gICAqXG4gICAqIC8vIGxpc3RlbiB0byBldmVudHMgYWNjb3JkaW5nIHRvIHRoZSBwYXJlbnRcbiAgICogbm9kZS5saXN0ZW5pbmcoJ2luaGVyaXQnKTtcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldC9zZXQgcHJldmVudERlZmF1bHRcbiAgICogQnkgZGVmYXVsdCBhbGwgc2hhcGVzIHdpbGwgcHJldmVudCBkZWZhdWx0IGJlaGF2aW91clxuICAgKiBvZiBhIGJyb3dzZXIgb24gYSBwb2ludGVyIG1vdmUgb3IgdGFwLlxuICAgKiB0aGF0IHdpbGwgcHJldmVudCBuYXRpdmUgc2Nyb2xsaW5nIHdoZW4geW91IGFyZSB0cnlpbmcgdG8gZHJhZyZkcm9wIGEgbm9kZVxuICAgKiBidXQgc29tZXRpbWVzIHlvdSBtYXkgbmVlZCB0byBlbmFibGUgZGVmYXVsdCBhY3Rpb25zXG4gICAqIGluIHRoYXQgY2FzZSB5b3UgY2FuIHNldCB0aGUgcHJvcGVydHkgdG8gZmFsc2VcbiAgICogQG5hbWUgcHJldmVudERlZmF1bHRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHByZXZlbnREZWZhdWx0XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBwcmV2ZW50RGVmYXVsdFxuICAgKiB2YXIgc2hvdWxkUHJldmVudCA9IHNoYXBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAqXG4gICAqIC8vIHNldCBwcmV2ZW50RGVmYXVsdFxuICAgKiBzaGFwZS5wcmV2ZW50RGVmYXVsdChmYWxzZSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ3ByZXZlbnREZWZhdWx0JyxcbiAgICB0cnVlLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0Qm9vbGVhblZhbGlkYXRvcigpXG4gICk7XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2ZpbHRlcnMnLCBudWxsLCBmdW5jdGlvbih2YWwpIHtcbiAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiB2YWw7XG4gIH0pO1xuICAvKipcbiAgICogZ2V0L3NldCBmaWx0ZXJzLiAgRmlsdGVycyBhcmUgYXBwbGllZCB0byBjYWNoZWQgY2FudmFzZXNcbiAgICogQG5hbWUgZmlsdGVyc1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIGFycmF5IG9mIGZpbHRlcnNcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsdGVyc1xuICAgKiB2YXIgZmlsdGVycyA9IG5vZGUuZmlsdGVycygpO1xuICAgKlxuICAgKiAvLyBzZXQgYSBzaW5nbGUgZmlsdGVyXG4gICAqIG5vZGUuY2FjaGUoKTtcbiAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkJsdXJdKTtcbiAgICpcbiAgICogLy8gc2V0IG11bHRpcGxlIGZpbHRlcnNcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW1xuICAgKiAgIEtvbnZhLkZpbHRlcnMuQmx1cixcbiAgICogICBLb252YS5GaWx0ZXJzLlNlcGlhLFxuICAgKiAgIEtvbnZhLkZpbHRlcnMuSW52ZXJ0XG4gICAqIF0pO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAndmlzaWJsZScsICdpbmhlcml0JywgZnVuY3Rpb24oXG4gICAgdmFsXG4gICkge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHwgdmFsID09PSAnaW5oZXJpdCc7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBLb252YS5VdGlsLndhcm4oXG4gICAgICAgIHZhbCArXG4gICAgICAgICAgJyBpcyBhIG5vdCB2YWxpZCB2YWx1ZSBmb3IgXCJ2aXNpYmxlXCIgYXR0cmlidXRlLiBUaGUgdmFsdWUgbWF5IGJlIHRydWUsIGZhbHNlIG9yIFwiaW5oZXJpdFwiLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH0pO1xuICAvKipcbiAgICogZ2V0L3NldCB2aXNpYmxlIGF0dHIuICBDYW4gYmUgXCJpbmhlcml0XCIsIHRydWUsIG9yIGZhbHNlLiAgVGhlIGRlZmF1bHQgaXMgXCJpbmhlcml0XCIuXG4gICAqICAgSWYgeW91IG5lZWQgdG8gZGV0ZXJtaW5lIGlmIGEgbm9kZSBpcyB2aXNpYmxlIG9yIG5vdFxuICAgKiAgIGJ5IHRha2luZyBpbnRvIGFjY291bnQgaXRzIHBhcmVudHMsIHVzZSB0aGUgaXNWaXNpYmxlKCkgbWV0aG9kXG4gICAqIEBuYW1lIHZpc2libGVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gdmlzaWJsZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB2aXNpYmxlIGF0dHJcbiAgICogdmFyIHZpc2libGUgPSBub2RlLnZpc2libGUoKTtcbiAgICpcbiAgICogLy8gbWFrZSBpbnZpc2libGVcbiAgICogbm9kZS52aXNpYmxlKGZhbHNlKTtcbiAgICpcbiAgICogLy8gbWFrZSB2aXNpYmxlXG4gICAqIG5vZGUudmlzaWJsZSh0cnVlKTtcbiAgICpcbiAgICogLy8gbWFrZSB2aXNpYmxlIGFjY29yZGluZyB0byB0aGUgcGFyZW50XG4gICAqIG5vZGUudmlzaWJsZSgnaW5oZXJpdCcpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICd0cmFuc2Zvcm1zRW5hYmxlZCcsXG4gICAgJ2FsbCcsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXRTdHJpbmdWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHRyYW5zZm9ybXMgdGhhdCBhcmUgZW5hYmxlZC4gIENhbiBiZSBcImFsbFwiLCBcIm5vbmVcIiwgb3IgXCJwb3NpdGlvblwiLiAgVGhlIGRlZmF1bHRcbiAgICogIGlzIFwiYWxsXCJcbiAgICogQG5hbWUgdHJhbnNmb3Jtc0VuYWJsZWRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVuYWJsZWRcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZW5hYmxlIHBvc2l0aW9uIHRyYW5zZm9ybSBvbmx5IHRvIGltcHJvdmUgZHJhdyBwZXJmb3JtYW5jZVxuICAgKiBub2RlLnRyYW5zZm9ybXNFbmFibGVkKCdwb3NpdGlvbicpO1xuICAgKlxuICAgKiAvLyBlbmFibGUgYWxsIHRyYW5zZm9ybXNcbiAgICogbm9kZS50cmFuc2Zvcm1zRW5hYmxlZCgnYWxsJyk7XG4gICAqL1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IG5vZGUgc2l6ZVxuICAgKiBAbmFtZSBzaXplXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzaXplXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLndpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLmhlaWdodFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgbm9kZSBzaXplXG4gICAqIHZhciBzaXplID0gbm9kZS5zaXplKCk7XG4gICAqIHZhciB4ID0gc2l6ZS54O1xuICAgKiB2YXIgeSA9IHNpemUueTtcbiAgICpcbiAgICogLy8gc2V0IHNpemVcbiAgICogbm9kZS5zaXplKHtcbiAgICogICB3aWR0aDogMTAwLFxuICAgKiAgIGhlaWdodDogMjAwXG4gICAqIH0pO1xuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzaXplJyk7XG5cbiAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLk5vZGUsIHtcbiAgICByb3RhdGVEZWc6ICdyb3RhdGUnLFxuICAgIHNldFJvdGF0aW9uRGVnOiAnc2V0Um90YXRpb24nLFxuICAgIGdldFJvdGF0aW9uRGVnOiAnZ2V0Um90YXRpb24nXG4gIH0pO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5Ob2RlKTtcbn0pKEtvbnZhKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBHcmF5c2NhbGUgRmlsdGVyXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAqIEBleGFtcGxlXG4gICAqIG5vZGUuY2FjaGUoKTtcbiAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkdyYXlzY2FsZV0pO1xuICAgKi9cbiAgS29udmEuRmlsdGVycy5HcmF5c2NhbGUgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBpLFxuICAgICAgYnJpZ2h0bmVzcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgYnJpZ2h0bmVzcyA9IDAuMzQgKiBkYXRhW2ldICsgMC41ICogZGF0YVtpICsgMV0gKyAwLjE2ICogZGF0YVtpICsgMl07XG4gICAgICAvLyByZWRcbiAgICAgIGRhdGFbaV0gPSBicmlnaHRuZXNzO1xuICAgICAgLy8gZ3JlZW5cbiAgICAgIGRhdGFbaSArIDFdID0gYnJpZ2h0bmVzcztcbiAgICAgIC8vIGJsdWVcbiAgICAgIGRhdGFbaSArIDJdID0gYnJpZ2h0bmVzcztcbiAgICB9XG4gIH07XG59KSgpO1xuXG4oZnVuY3Rpb24oS29udmEpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQnJpZ2h0ZW4gRmlsdGVyLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAZXhhbXBsZVxuICAgKiBub2RlLmNhY2hlKCk7XG4gICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5CcmlnaHRlbl0pO1xuICAgKiBub2RlLmJyaWdodG5lc3MoMC44KTtcbiAgICovXG4gIEtvbnZhLkZpbHRlcnMuQnJpZ2h0ZW4gPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgYnJpZ2h0bmVzcyA9IHRoaXMuYnJpZ2h0bmVzcygpICogMjU1LFxuICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAvLyByZWRcbiAgICAgIGRhdGFbaV0gKz0gYnJpZ2h0bmVzcztcbiAgICAgIC8vIGdyZWVuXG4gICAgICBkYXRhW2kgKyAxXSArPSBicmlnaHRuZXNzO1xuICAgICAgLy8gYmx1ZVxuICAgICAgZGF0YVtpICsgMl0gKz0gYnJpZ2h0bmVzcztcbiAgICB9XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnYnJpZ2h0bmVzcycsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsdGVyIGJyaWdodG5lc3MuICBUaGUgYnJpZ2h0bmVzcyBpcyBhIG51bWJlciBiZXR3ZWVuIC0xIGFuZCAxLiZuYnNwOyBQb3NpdGl2ZSB2YWx1ZXNcbiAgICogIGJyaWdodGVuIHRoZSBwaXhlbHMgYW5kIG5lZ2F0aXZlIHZhbHVlcyBkYXJrZW4gdGhlbS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuQnJpZ2h0ZW59IGZpbHRlci5cbiAgICogQG5hbWUgYnJpZ2h0bmVzc1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYnJpZ2h0bmVzcyB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xufSkoS29udmEpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEludmVydCBGaWx0ZXJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuSW52ZXJ0XSk7XG4gICAqL1xuICBLb252YS5GaWx0ZXJzLkludmVydCA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgIC8vIHJlZFxuICAgICAgZGF0YVtpXSA9IDI1NSAtIGRhdGFbaV07XG4gICAgICAvLyBncmVlblxuICAgICAgZGF0YVtpICsgMV0gPSAyNTUgLSBkYXRhW2kgKyAxXTtcbiAgICAgIC8vIGJsdWVcbiAgICAgIGRhdGFbaSArIDJdID0gMjU1IC0gZGF0YVtpICsgMl07XG4gICAgfVxuICB9O1xufSkoKTtcblxuLypcbiB0aGUgR2F1c3MgZmlsdGVyXG4gbWFzdGVyIHJlcG86IGh0dHBzOi8vZ2l0aHViLmNvbS9wYXZlbHBvd2VyL2tpbmV0aWNqc0dhdXNzRmlsdGVyXG4qL1xuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLypcblxuICAgICBTdGFja0JsdXIgLSBhIGZhc3QgYWxtb3N0IEdhdXNzaWFuIEJsdXIgRm9yIENhbnZhc1xuXG4gICAgIFZlcnNpb246ICAgMC41XG4gICAgIEF1dGhvcjogICAgTWFyaW8gS2xpbmdlbWFublxuICAgICBDb250YWN0OiAgIG1hcmlvQHF1YXNpbW9uZG8uY29tXG4gICAgIFdlYnNpdGU6ICAgaHR0cDovL3d3dy5xdWFzaW1vbmRvLmNvbS9TdGFja0JsdXJGb3JDYW52YXNcbiAgICAgVHdpdHRlcjogICBAcXVhc2ltb25kb1xuXG4gICAgIEluIGNhc2UgeW91IGZpbmQgdGhpcyBjbGFzcyB1c2VmdWwgLSBlc3BlY2lhbGx5IGluIGNvbW1lcmNpYWwgcHJvamVjdHMgLVxuICAgICBJIGFtIG5vdCB0b3RhbGx5IHVuaGFwcHkgZm9yIGEgc21hbGwgZG9uYXRpb24gdG8gbXkgUGF5UGFsIGFjY291bnRcbiAgICAgbWFyaW9AcXVhc2ltb25kby5kZVxuXG4gICAgIE9yIHN1cHBvcnQgbWUgb24gZmxhdHRyOlxuICAgICBodHRwczovL2ZsYXR0ci5jb20vdGhpbmcvNzI3OTEvU3RhY2tCbHVyLWEtZmFzdC1hbG1vc3QtR2F1c3NpYW4tQmx1ci1FZmZlY3QtZm9yLUNhbnZhc0phdmFzY3JpcHRcblxuICAgICBDb3B5cmlnaHQgKGMpIDIwMTAgTWFyaW8gS2xpbmdlbWFublxuXG4gICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gICAgIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICAgICByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAgICAgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gICAgIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gICAgIGNvbmRpdGlvbnM6XG5cbiAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gICAgIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gICAgIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICAgICBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAgICAgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICAgICBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gICAgICovXG5cbiAgZnVuY3Rpb24gQmx1clN0YWNrKCkge1xuICAgIHRoaXMuciA9IDA7XG4gICAgdGhpcy5nID0gMDtcbiAgICB0aGlzLmIgPSAwO1xuICAgIHRoaXMuYSA9IDA7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBtdWxfdGFibGUgPSBbXG4gICAgNTEyLFxuICAgIDUxMixcbiAgICA0NTYsXG4gICAgNTEyLFxuICAgIDMyOCxcbiAgICA0NTYsXG4gICAgMzM1LFxuICAgIDUxMixcbiAgICA0MDUsXG4gICAgMzI4LFxuICAgIDI3MSxcbiAgICA0NTYsXG4gICAgMzg4LFxuICAgIDMzNSxcbiAgICAyOTIsXG4gICAgNTEyLFxuICAgIDQ1NCxcbiAgICA0MDUsXG4gICAgMzY0LFxuICAgIDMyOCxcbiAgICAyOTgsXG4gICAgMjcxLFxuICAgIDQ5NixcbiAgICA0NTYsXG4gICAgNDIwLFxuICAgIDM4OCxcbiAgICAzNjAsXG4gICAgMzM1LFxuICAgIDMxMixcbiAgICAyOTIsXG4gICAgMjczLFxuICAgIDUxMixcbiAgICA0ODIsXG4gICAgNDU0LFxuICAgIDQyOCxcbiAgICA0MDUsXG4gICAgMzgzLFxuICAgIDM2NCxcbiAgICAzNDUsXG4gICAgMzI4LFxuICAgIDMxMixcbiAgICAyOTgsXG4gICAgMjg0LFxuICAgIDI3MSxcbiAgICAyNTksXG4gICAgNDk2LFxuICAgIDQ3NSxcbiAgICA0NTYsXG4gICAgNDM3LFxuICAgIDQyMCxcbiAgICA0MDQsXG4gICAgMzg4LFxuICAgIDM3NCxcbiAgICAzNjAsXG4gICAgMzQ3LFxuICAgIDMzNSxcbiAgICAzMjMsXG4gICAgMzEyLFxuICAgIDMwMixcbiAgICAyOTIsXG4gICAgMjgyLFxuICAgIDI3MyxcbiAgICAyNjUsXG4gICAgNTEyLFxuICAgIDQ5NyxcbiAgICA0ODIsXG4gICAgNDY4LFxuICAgIDQ1NCxcbiAgICA0NDEsXG4gICAgNDI4LFxuICAgIDQxNyxcbiAgICA0MDUsXG4gICAgMzk0LFxuICAgIDM4MyxcbiAgICAzNzMsXG4gICAgMzY0LFxuICAgIDM1NCxcbiAgICAzNDUsXG4gICAgMzM3LFxuICAgIDMyOCxcbiAgICAzMjAsXG4gICAgMzEyLFxuICAgIDMwNSxcbiAgICAyOTgsXG4gICAgMjkxLFxuICAgIDI4NCxcbiAgICAyNzgsXG4gICAgMjcxLFxuICAgIDI2NSxcbiAgICAyNTksXG4gICAgNTA3LFxuICAgIDQ5NixcbiAgICA0ODUsXG4gICAgNDc1LFxuICAgIDQ2NSxcbiAgICA0NTYsXG4gICAgNDQ2LFxuICAgIDQzNyxcbiAgICA0MjgsXG4gICAgNDIwLFxuICAgIDQxMixcbiAgICA0MDQsXG4gICAgMzk2LFxuICAgIDM4OCxcbiAgICAzODEsXG4gICAgMzc0LFxuICAgIDM2NyxcbiAgICAzNjAsXG4gICAgMzU0LFxuICAgIDM0NyxcbiAgICAzNDEsXG4gICAgMzM1LFxuICAgIDMyOSxcbiAgICAzMjMsXG4gICAgMzE4LFxuICAgIDMxMixcbiAgICAzMDcsXG4gICAgMzAyLFxuICAgIDI5NyxcbiAgICAyOTIsXG4gICAgMjg3LFxuICAgIDI4MixcbiAgICAyNzgsXG4gICAgMjczLFxuICAgIDI2OSxcbiAgICAyNjUsXG4gICAgMjYxLFxuICAgIDUxMixcbiAgICA1MDUsXG4gICAgNDk3LFxuICAgIDQ4OSxcbiAgICA0ODIsXG4gICAgNDc1LFxuICAgIDQ2OCxcbiAgICA0NjEsXG4gICAgNDU0LFxuICAgIDQ0NyxcbiAgICA0NDEsXG4gICAgNDM1LFxuICAgIDQyOCxcbiAgICA0MjIsXG4gICAgNDE3LFxuICAgIDQxMSxcbiAgICA0MDUsXG4gICAgMzk5LFxuICAgIDM5NCxcbiAgICAzODksXG4gICAgMzgzLFxuICAgIDM3OCxcbiAgICAzNzMsXG4gICAgMzY4LFxuICAgIDM2NCxcbiAgICAzNTksXG4gICAgMzU0LFxuICAgIDM1MCxcbiAgICAzNDUsXG4gICAgMzQxLFxuICAgIDMzNyxcbiAgICAzMzIsXG4gICAgMzI4LFxuICAgIDMyNCxcbiAgICAzMjAsXG4gICAgMzE2LFxuICAgIDMxMixcbiAgICAzMDksXG4gICAgMzA1LFxuICAgIDMwMSxcbiAgICAyOTgsXG4gICAgMjk0LFxuICAgIDI5MSxcbiAgICAyODcsXG4gICAgMjg0LFxuICAgIDI4MSxcbiAgICAyNzgsXG4gICAgMjc0LFxuICAgIDI3MSxcbiAgICAyNjgsXG4gICAgMjY1LFxuICAgIDI2MixcbiAgICAyNTksXG4gICAgMjU3LFxuICAgIDUwNyxcbiAgICA1MDEsXG4gICAgNDk2LFxuICAgIDQ5MSxcbiAgICA0ODUsXG4gICAgNDgwLFxuICAgIDQ3NSxcbiAgICA0NzAsXG4gICAgNDY1LFxuICAgIDQ2MCxcbiAgICA0NTYsXG4gICAgNDUxLFxuICAgIDQ0NixcbiAgICA0NDIsXG4gICAgNDM3LFxuICAgIDQzMyxcbiAgICA0MjgsXG4gICAgNDI0LFxuICAgIDQyMCxcbiAgICA0MTYsXG4gICAgNDEyLFxuICAgIDQwOCxcbiAgICA0MDQsXG4gICAgNDAwLFxuICAgIDM5NixcbiAgICAzOTIsXG4gICAgMzg4LFxuICAgIDM4NSxcbiAgICAzODEsXG4gICAgMzc3LFxuICAgIDM3NCxcbiAgICAzNzAsXG4gICAgMzY3LFxuICAgIDM2MyxcbiAgICAzNjAsXG4gICAgMzU3LFxuICAgIDM1NCxcbiAgICAzNTAsXG4gICAgMzQ3LFxuICAgIDM0NCxcbiAgICAzNDEsXG4gICAgMzM4LFxuICAgIDMzNSxcbiAgICAzMzIsXG4gICAgMzI5LFxuICAgIDMyNixcbiAgICAzMjMsXG4gICAgMzIwLFxuICAgIDMxOCxcbiAgICAzMTUsXG4gICAgMzEyLFxuICAgIDMxMCxcbiAgICAzMDcsXG4gICAgMzA0LFxuICAgIDMwMixcbiAgICAyOTksXG4gICAgMjk3LFxuICAgIDI5NCxcbiAgICAyOTIsXG4gICAgMjg5LFxuICAgIDI4NyxcbiAgICAyODUsXG4gICAgMjgyLFxuICAgIDI4MCxcbiAgICAyNzgsXG4gICAgMjc1LFxuICAgIDI3MyxcbiAgICAyNzEsXG4gICAgMjY5LFxuICAgIDI2NyxcbiAgICAyNjUsXG4gICAgMjYzLFxuICAgIDI2MSxcbiAgICAyNTlcbiAgXTtcblxuICB2YXIgc2hnX3RhYmxlID0gW1xuICAgIDksXG4gICAgMTEsXG4gICAgMTIsXG4gICAgMTMsXG4gICAgMTMsXG4gICAgMTQsXG4gICAgMTQsXG4gICAgMTUsXG4gICAgMTUsXG4gICAgMTUsXG4gICAgMTUsXG4gICAgMTYsXG4gICAgMTYsXG4gICAgMTYsXG4gICAgMTYsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTcsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTgsXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMTksXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjAsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjEsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjIsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjMsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjQsXG4gICAgMjRcbiAgXTtcblxuICBmdW5jdGlvbiBmaWx0ZXJHYXVzc0JsdXJSR0JBKGltYWdlRGF0YSwgcmFkaXVzKSB7XG4gICAgdmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgd2lkdGggPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuXG4gICAgdmFyIHgsXG4gICAgICB5LFxuICAgICAgaSxcbiAgICAgIHAsXG4gICAgICB5cCxcbiAgICAgIHlpLFxuICAgICAgeXcsXG4gICAgICByX3N1bSxcbiAgICAgIGdfc3VtLFxuICAgICAgYl9zdW0sXG4gICAgICBhX3N1bSxcbiAgICAgIHJfb3V0X3N1bSxcbiAgICAgIGdfb3V0X3N1bSxcbiAgICAgIGJfb3V0X3N1bSxcbiAgICAgIGFfb3V0X3N1bSxcbiAgICAgIHJfaW5fc3VtLFxuICAgICAgZ19pbl9zdW0sXG4gICAgICBiX2luX3N1bSxcbiAgICAgIGFfaW5fc3VtLFxuICAgICAgcHIsXG4gICAgICBwZyxcbiAgICAgIHBiLFxuICAgICAgcGEsXG4gICAgICByYnM7XG5cbiAgICB2YXIgZGl2ID0gcmFkaXVzICsgcmFkaXVzICsgMSxcbiAgICAgIHdpZHRoTWludXMxID0gd2lkdGggLSAxLFxuICAgICAgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMSxcbiAgICAgIHJhZGl1c1BsdXMxID0gcmFkaXVzICsgMSxcbiAgICAgIHN1bUZhY3RvciA9IHJhZGl1c1BsdXMxICogKHJhZGl1c1BsdXMxICsgMSkgLyAyLFxuICAgICAgc3RhY2tTdGFydCA9IG5ldyBCbHVyU3RhY2soKSxcbiAgICAgIHN0YWNrRW5kID0gbnVsbCxcbiAgICAgIHN0YWNrID0gc3RhY2tTdGFydCxcbiAgICAgIHN0YWNrSW4gPSBudWxsLFxuICAgICAgc3RhY2tPdXQgPSBudWxsLFxuICAgICAgbXVsX3N1bSA9IG11bF90YWJsZVtyYWRpdXNdLFxuICAgICAgc2hnX3N1bSA9IHNoZ190YWJsZVtyYWRpdXNdO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IGRpdjsgaSsrKSB7XG4gICAgICBzdGFjayA9IHN0YWNrLm5leHQgPSBuZXcgQmx1clN0YWNrKCk7XG4gICAgICBpZiAoaSA9PT0gcmFkaXVzUGx1czEpIHtcbiAgICAgICAgc3RhY2tFbmQgPSBzdGFjaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFjay5uZXh0ID0gc3RhY2tTdGFydDtcblxuICAgIHl3ID0geWkgPSAwO1xuXG4gICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICByX2luX3N1bSA9IGdfaW5fc3VtID0gYl9pbl9zdW0gPSBhX2luX3N1bSA9IHJfc3VtID0gZ19zdW0gPSBiX3N1bSA9IGFfc3VtID0gMDtcblxuICAgICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocHIgPSBwaXhlbHNbeWldKTtcbiAgICAgIGdfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBnID0gcGl4ZWxzW3lpICsgMV0pO1xuICAgICAgYl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGIgPSBwaXhlbHNbeWkgKyAyXSk7XG4gICAgICBhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwYSA9IHBpeGVsc1t5aSArIDNdKTtcblxuICAgICAgcl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XG4gICAgICBnX3N1bSArPSBzdW1GYWN0b3IgKiBwZztcbiAgICAgIGJfc3VtICs9IHN1bUZhY3RvciAqIHBiO1xuICAgICAgYV9zdW0gKz0gc3VtRmFjdG9yICogcGE7XG5cbiAgICAgIHN0YWNrID0gc3RhY2tTdGFydDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKyspIHtcbiAgICAgICAgc3RhY2suciA9IHByO1xuICAgICAgICBzdGFjay5nID0gcGc7XG4gICAgICAgIHN0YWNrLmIgPSBwYjtcbiAgICAgICAgc3RhY2suYSA9IHBhO1xuICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCByYWRpdXNQbHVzMTsgaSsrKSB7XG4gICAgICAgIHAgPSB5aSArICgod2lkdGhNaW51czEgPCBpID8gd2lkdGhNaW51czEgOiBpKSA8PCAyKTtcbiAgICAgICAgcl9zdW0gKz0gKHN0YWNrLnIgPSBwciA9IHBpeGVsc1twXSkgKiAocmJzID0gcmFkaXVzUGx1czEgLSBpKTtcbiAgICAgICAgZ19zdW0gKz0gKHN0YWNrLmcgPSBwZyA9IHBpeGVsc1twICsgMV0pICogcmJzO1xuICAgICAgICBiX3N1bSArPSAoc3RhY2suYiA9IHBiID0gcGl4ZWxzW3AgKyAyXSkgKiByYnM7XG4gICAgICAgIGFfc3VtICs9IChzdGFjay5hID0gcGEgPSBwaXhlbHNbcCArIDNdKSAqIHJicztcblxuICAgICAgICByX2luX3N1bSArPSBwcjtcbiAgICAgICAgZ19pbl9zdW0gKz0gcGc7XG4gICAgICAgIGJfaW5fc3VtICs9IHBiO1xuICAgICAgICBhX2luX3N1bSArPSBwYTtcblxuICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuICAgICAgc3RhY2tPdXQgPSBzdGFja0VuZDtcbiAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIHBpeGVsc1t5aSArIDNdID0gcGEgPSAoYV9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtO1xuICAgICAgICBpZiAocGEgIT09IDApIHtcbiAgICAgICAgICBwYSA9IDI1NSAvIHBhO1xuICAgICAgICAgIHBpeGVsc1t5aV0gPSAoKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICBwaXhlbHNbeWkgKyAxXSA9ICgoZ19zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICAgIHBpeGVsc1t5aSArIDJdID0gKChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGl4ZWxzW3lpXSA9IHBpeGVsc1t5aSArIDFdID0gcGl4ZWxzW3lpICsgMl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgICBnX3N1bSAtPSBnX291dF9zdW07XG4gICAgICAgIGJfc3VtIC09IGJfb3V0X3N1bTtcbiAgICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xuXG4gICAgICAgIHJfb3V0X3N1bSAtPSBzdGFja0luLnI7XG4gICAgICAgIGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG4gICAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICAgIGFfb3V0X3N1bSAtPSBzdGFja0luLmE7XG5cbiAgICAgICAgcCA9ICh5dyArICgocCA9IHggKyByYWRpdXMgKyAxKSA8IHdpZHRoTWludXMxID8gcCA6IHdpZHRoTWludXMxKSkgPDwgMjtcblxuICAgICAgICByX2luX3N1bSArPSBzdGFja0luLnIgPSBwaXhlbHNbcF07XG4gICAgICAgIGdfaW5fc3VtICs9IHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV07XG4gICAgICAgIGJfaW5fc3VtICs9IHN0YWNrSW4uYiA9IHBpeGVsc1twICsgMl07XG4gICAgICAgIGFfaW5fc3VtICs9IHN0YWNrSW4uYSA9IHBpeGVsc1twICsgM107XG5cbiAgICAgICAgcl9zdW0gKz0gcl9pbl9zdW07XG4gICAgICAgIGdfc3VtICs9IGdfaW5fc3VtO1xuICAgICAgICBiX3N1bSArPSBiX2luX3N1bTtcbiAgICAgICAgYV9zdW0gKz0gYV9pbl9zdW07XG5cbiAgICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgICByX291dF9zdW0gKz0gcHIgPSBzdGFja091dC5yO1xuICAgICAgICBnX291dF9zdW0gKz0gcGcgPSBzdGFja091dC5nO1xuICAgICAgICBiX291dF9zdW0gKz0gcGIgPSBzdGFja091dC5iO1xuICAgICAgICBhX291dF9zdW0gKz0gcGEgPSBzdGFja091dC5hO1xuXG4gICAgICAgIHJfaW5fc3VtIC09IHByO1xuICAgICAgICBnX2luX3N1bSAtPSBwZztcbiAgICAgICAgYl9pbl9zdW0gLT0gcGI7XG4gICAgICAgIGFfaW5fc3VtIC09IHBhO1xuXG4gICAgICAgIHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcblxuICAgICAgICB5aSArPSA0O1xuICAgICAgfVxuICAgICAgeXcgKz0gd2lkdGg7XG4gICAgfVxuXG4gICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgIGdfaW5fc3VtID0gYl9pbl9zdW0gPSBhX2luX3N1bSA9IHJfaW5fc3VtID0gZ19zdW0gPSBiX3N1bSA9IGFfc3VtID0gcl9zdW0gPSAwO1xuXG4gICAgICB5aSA9IHggPDwgMjtcbiAgICAgIHJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHByID0gcGl4ZWxzW3lpXSk7XG4gICAgICBnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwZyA9IHBpeGVsc1t5aSArIDFdKTtcbiAgICAgIGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBiID0gcGl4ZWxzW3lpICsgMl0pO1xuICAgICAgYV9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGEgPSBwaXhlbHNbeWkgKyAzXSk7XG5cbiAgICAgIHJfc3VtICs9IHN1bUZhY3RvciAqIHByO1xuICAgICAgZ19zdW0gKz0gc3VtRmFjdG9yICogcGc7XG4gICAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICAgIGFfc3VtICs9IHN1bUZhY3RvciAqIHBhO1xuXG4gICAgICBzdGFjayA9IHN0YWNrU3RhcnQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrKSB7XG4gICAgICAgIHN0YWNrLnIgPSBwcjtcbiAgICAgICAgc3RhY2suZyA9IHBnO1xuICAgICAgICBzdGFjay5iID0gcGI7XG4gICAgICAgIHN0YWNrLmEgPSBwYTtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgICAgfVxuXG4gICAgICB5cCA9IHdpZHRoO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDw9IHJhZGl1czsgaSsrKSB7XG4gICAgICAgIHlpID0gKHlwICsgeCkgPDwgMjtcblxuICAgICAgICByX3N1bSArPSAoc3RhY2suciA9IHByID0gcGl4ZWxzW3lpXSkgKiAocmJzID0gcmFkaXVzUGx1czEgLSBpKTtcbiAgICAgICAgZ19zdW0gKz0gKHN0YWNrLmcgPSBwZyA9IHBpeGVsc1t5aSArIDFdKSAqIHJicztcbiAgICAgICAgYl9zdW0gKz0gKHN0YWNrLmIgPSBwYiA9IHBpeGVsc1t5aSArIDJdKSAqIHJicztcbiAgICAgICAgYV9zdW0gKz0gKHN0YWNrLmEgPSBwYSA9IHBpeGVsc1t5aSArIDNdKSAqIHJicztcblxuICAgICAgICByX2luX3N1bSArPSBwcjtcbiAgICAgICAgZ19pbl9zdW0gKz0gcGc7XG4gICAgICAgIGJfaW5fc3VtICs9IHBiO1xuICAgICAgICBhX2luX3N1bSArPSBwYTtcblxuICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG5cbiAgICAgICAgaWYgKGkgPCBoZWlnaHRNaW51czEpIHtcbiAgICAgICAgICB5cCArPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB5aSA9IHg7XG4gICAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG4gICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgcCA9IHlpIDw8IDI7XG4gICAgICAgIHBpeGVsc1twICsgM10gPSBwYSA9IChhX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG4gICAgICAgIGlmIChwYSA+IDApIHtcbiAgICAgICAgICBwYSA9IDI1NSAvIHBhO1xuICAgICAgICAgIHBpeGVsc1twXSA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICAgIHBpeGVsc1twICsgMV0gPSAoKGdfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICBwaXhlbHNbcCArIDJdID0gKChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGl4ZWxzW3BdID0gcGl4ZWxzW3AgKyAxXSA9IHBpeGVsc1twICsgMl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgICBnX3N1bSAtPSBnX291dF9zdW07XG4gICAgICAgIGJfc3VtIC09IGJfb3V0X3N1bTtcbiAgICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xuXG4gICAgICAgIHJfb3V0X3N1bSAtPSBzdGFja0luLnI7XG4gICAgICAgIGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG4gICAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICAgIGFfb3V0X3N1bSAtPSBzdGFja0luLmE7XG5cbiAgICAgICAgcCA9XG4gICAgICAgICAgKHggK1xuICAgICAgICAgICAgKChwID0geSArIHJhZGl1c1BsdXMxKSA8IGhlaWdodE1pbnVzMSA/IHAgOiBoZWlnaHRNaW51czEpICpcbiAgICAgICAgICAgICAgd2lkdGgpIDw8XG4gICAgICAgICAgMjtcblxuICAgICAgICByX3N1bSArPSByX2luX3N1bSArPSBzdGFja0luLnIgPSBwaXhlbHNbcF07XG4gICAgICAgIGdfc3VtICs9IGdfaW5fc3VtICs9IHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV07XG4gICAgICAgIGJfc3VtICs9IGJfaW5fc3VtICs9IHN0YWNrSW4uYiA9IHBpeGVsc1twICsgMl07XG4gICAgICAgIGFfc3VtICs9IGFfaW5fc3VtICs9IHN0YWNrSW4uYSA9IHBpeGVsc1twICsgM107XG5cbiAgICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgICByX291dF9zdW0gKz0gcHIgPSBzdGFja091dC5yO1xuICAgICAgICBnX291dF9zdW0gKz0gcGcgPSBzdGFja091dC5nO1xuICAgICAgICBiX291dF9zdW0gKz0gcGIgPSBzdGFja091dC5iO1xuICAgICAgICBhX291dF9zdW0gKz0gcGEgPSBzdGFja091dC5hO1xuXG4gICAgICAgIHJfaW5fc3VtIC09IHByO1xuICAgICAgICBnX2luX3N1bSAtPSBwZztcbiAgICAgICAgYl9pbl9zdW0gLT0gcGI7XG4gICAgICAgIGFfaW5fc3VtIC09IHBhO1xuXG4gICAgICAgIHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcblxuICAgICAgICB5aSArPSB3aWR0aDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQmx1ciBGaWx0ZXJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIEJsdXJcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAZXhhbXBsZVxuICAgKiBub2RlLmNhY2hlKCk7XG4gICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5CbHVyXSk7XG4gICAqIG5vZGUuYmx1clJhZGl1cygxMCk7XG4gICAqL1xuICBLb252YS5GaWx0ZXJzLkJsdXIgPSBmdW5jdGlvbiBCbHVyKGltYWdlRGF0YSkge1xuICAgIHZhciByYWRpdXMgPSBNYXRoLnJvdW5kKHRoaXMuYmx1clJhZGl1cygpKTtcblxuICAgIGlmIChyYWRpdXMgPiAwKSB7XG4gICAgICBmaWx0ZXJHYXVzc0JsdXJSR0JBKGltYWdlRGF0YSwgcmFkaXVzKTtcbiAgICB9XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnYmx1clJhZGl1cycsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBibHVyIHJhZGl1cy4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuQmx1cn0gZmlsdGVyXG4gICAqIEBuYW1lIGJsdXJSYWRpdXNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSByYWRpdXNcbiAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAqL1xufSkoS29udmEpO1xuXG4vKmVzbGludC1kaXNhYmxlICBtYXgtZGVwdGggKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBmdW5jdGlvbiBwaXhlbEF0KGlkYXRhLCB4LCB5KSB7XG4gICAgdmFyIGlkeCA9ICh5ICogaWRhdGEud2lkdGggKyB4KSAqIDQ7XG4gICAgdmFyIGQgPSBbXTtcbiAgICBkLnB1c2goXG4gICAgICBpZGF0YS5kYXRhW2lkeCsrXSxcbiAgICAgIGlkYXRhLmRhdGFbaWR4KytdLFxuICAgICAgaWRhdGEuZGF0YVtpZHgrK10sXG4gICAgICBpZGF0YS5kYXRhW2lkeCsrXVxuICAgICk7XG4gICAgcmV0dXJuIGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZ2JEaXN0YW5jZShwMSwgcDIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgTWF0aC5wb3cocDFbMF0gLSBwMlswXSwgMikgK1xuICAgICAgICBNYXRoLnBvdyhwMVsxXSAtIHAyWzFdLCAyKSArXG4gICAgICAgIE1hdGgucG93KHAxWzJdIC0gcDJbMl0sIDIpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJnYk1lYW4ocFRhYikge1xuICAgIHZhciBtID0gWzAsIDAsIDBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwVGFiLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtWzBdICs9IHBUYWJbaV1bMF07XG4gICAgICBtWzFdICs9IHBUYWJbaV1bMV07XG4gICAgICBtWzJdICs9IHBUYWJbaV1bMl07XG4gICAgfVxuXG4gICAgbVswXSAvPSBwVGFiLmxlbmd0aDtcbiAgICBtWzFdIC89IHBUYWIubGVuZ3RoO1xuICAgIG1bMl0gLz0gcFRhYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhY2tncm91bmRNYXNrKGlkYXRhLCB0aHJlc2hvbGQpIHtcbiAgICB2YXIgcmdidl9ubyA9IHBpeGVsQXQoaWRhdGEsIDAsIDApO1xuICAgIHZhciByZ2J2X25lID0gcGl4ZWxBdChpZGF0YSwgaWRhdGEud2lkdGggLSAxLCAwKTtcbiAgICB2YXIgcmdidl9zbyA9IHBpeGVsQXQoaWRhdGEsIDAsIGlkYXRhLmhlaWdodCAtIDEpO1xuICAgIHZhciByZ2J2X3NlID0gcGl4ZWxBdChpZGF0YSwgaWRhdGEud2lkdGggLSAxLCBpZGF0YS5oZWlnaHQgLSAxKTtcblxuICAgIHZhciB0aHJlcyA9IHRocmVzaG9sZCB8fCAxMDtcbiAgICBpZiAoXG4gICAgICByZ2JEaXN0YW5jZShyZ2J2X25vLCByZ2J2X25lKSA8IHRocmVzICYmXG4gICAgICByZ2JEaXN0YW5jZShyZ2J2X25lLCByZ2J2X3NlKSA8IHRocmVzICYmXG4gICAgICByZ2JEaXN0YW5jZShyZ2J2X3NlLCByZ2J2X3NvKSA8IHRocmVzICYmXG4gICAgICByZ2JEaXN0YW5jZShyZ2J2X3NvLCByZ2J2X25vKSA8IHRocmVzXG4gICAgKSB7XG4gICAgICAvLyBNZWFuIGNvbG9yXG4gICAgICB2YXIgbWVhbiA9IHJnYk1lYW4oW3JnYnZfbmUsIHJnYnZfbm8sIHJnYnZfc2UsIHJnYnZfc29dKTtcblxuICAgICAgLy8gTWFzayBiYXNlZCBvbiBjb2xvciBkaXN0YW5jZVxuICAgICAgdmFyIG1hc2sgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRhdGEud2lkdGggKiBpZGF0YS5oZWlnaHQ7IGkrKykge1xuICAgICAgICB2YXIgZCA9IHJnYkRpc3RhbmNlKG1lYW4sIFtcbiAgICAgICAgICBpZGF0YS5kYXRhW2kgKiA0XSxcbiAgICAgICAgICBpZGF0YS5kYXRhW2kgKiA0ICsgMV0sXG4gICAgICAgICAgaWRhdGEuZGF0YVtpICogNCArIDJdXG4gICAgICAgIF0pO1xuICAgICAgICBtYXNrW2ldID0gZCA8IHRocmVzID8gMCA6IDI1NTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hc2s7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlNYXNrKGlkYXRhLCBtYXNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZGF0YS53aWR0aCAqIGlkYXRhLmhlaWdodDsgaSsrKSB7XG4gICAgICBpZGF0YS5kYXRhWzQgKiBpICsgM10gPSBtYXNrW2ldO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVyb2RlTWFzayhtYXNrLCBzdywgc2gpIHtcbiAgICB2YXIgd2VpZ2h0cyA9IFsxLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAxXTtcbiAgICB2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XG4gICAgdmFyIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMik7XG5cbiAgICB2YXIgbWFza1Jlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2g7IHkrKykge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzdzsgeCsrKSB7XG4gICAgICAgIHZhciBzbyA9IHkgKiBzdyArIHg7XG4gICAgICAgIHZhciBhID0gMDtcbiAgICAgICAgZm9yICh2YXIgY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcbiAgICAgICAgICBmb3IgKHZhciBjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xuICAgICAgICAgICAgdmFyIHNjeSA9IHkgKyBjeSAtIGhhbGZTaWRlO1xuICAgICAgICAgICAgdmFyIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG4gICAgICAgICAgICBpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcbiAgICAgICAgICAgICAgdmFyIHNyY09mZiA9IHNjeSAqIHN3ICsgc2N4O1xuICAgICAgICAgICAgICB2YXIgd3QgPSB3ZWlnaHRzW2N5ICogc2lkZSArIGN4XTtcblxuICAgICAgICAgICAgICBhICs9IG1hc2tbc3JjT2ZmXSAqIHd0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1hc2tSZXN1bHRbc29dID0gYSA9PT0gMjU1ICogOCA/IDI1NSA6IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hc2tSZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBkaWxhdGVNYXNrKG1hc2ssIHN3LCBzaCkge1xuICAgIHZhciB3ZWlnaHRzID0gWzEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDFdO1xuICAgIHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcbiAgICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcblxuICAgIHZhciBtYXNrUmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHN3OyB4KyspIHtcbiAgICAgICAgdmFyIHNvID0geSAqIHN3ICsgeDtcbiAgICAgICAgdmFyIGEgPSAwO1xuICAgICAgICBmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuICAgICAgICAgIGZvciAodmFyIGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG4gICAgICAgICAgICB2YXIgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICB2YXIgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XG5cbiAgICAgICAgICAgIGlmIChzY3kgPj0gMCAmJiBzY3kgPCBzaCAmJiBzY3ggPj0gMCAmJiBzY3ggPCBzdykge1xuICAgICAgICAgICAgICB2YXIgc3JjT2ZmID0gc2N5ICogc3cgKyBzY3g7XG4gICAgICAgICAgICAgIHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuXG4gICAgICAgICAgICAgIGEgKz0gbWFza1tzcmNPZmZdICogd3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFza1Jlc3VsdFtzb10gPSBhID49IDI1NSAqIDQgPyAyNTUgOiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXNrUmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc21vb3RoRWRnZU1hc2sobWFzaywgc3csIHNoKSB7XG4gICAgdmFyIHdlaWdodHMgPSBbXG4gICAgICAxIC8gOSxcbiAgICAgIDEgLyA5LFxuICAgICAgMSAvIDksXG4gICAgICAxIC8gOSxcbiAgICAgIDEgLyA5LFxuICAgICAgMSAvIDksXG4gICAgICAxIC8gOSxcbiAgICAgIDEgLyA5LFxuICAgICAgMSAvIDlcbiAgICBdO1xuICAgIHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcbiAgICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcblxuICAgIHZhciBtYXNrUmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHN3OyB4KyspIHtcbiAgICAgICAgdmFyIHNvID0geSAqIHN3ICsgeDtcbiAgICAgICAgdmFyIGEgPSAwO1xuICAgICAgICBmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuICAgICAgICAgIGZvciAodmFyIGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG4gICAgICAgICAgICB2YXIgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICB2YXIgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XG5cbiAgICAgICAgICAgIGlmIChzY3kgPj0gMCAmJiBzY3kgPCBzaCAmJiBzY3ggPj0gMCAmJiBzY3ggPCBzdykge1xuICAgICAgICAgICAgICB2YXIgc3JjT2ZmID0gc2N5ICogc3cgKyBzY3g7XG4gICAgICAgICAgICAgIHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuXG4gICAgICAgICAgICAgIGEgKz0gbWFza1tzcmNPZmZdICogd3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFza1Jlc3VsdFtzb10gPSBhO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXNrUmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1hc2sgRmlsdGVyXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBNYXNrXG4gICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuTWFza10pO1xuICAgKiBub2RlLnRocmVzaG9sZCgyMDApO1xuICAgKi9cbiAgS29udmEuRmlsdGVycy5NYXNrID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgLy8gRGV0ZWN0IHBpeGVscyBjbG9zZSB0byB0aGUgYmFja2dyb3VuZCBjb2xvclxuICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZCgpLFxuICAgICAgbWFzayA9IGJhY2tncm91bmRNYXNrKGltYWdlRGF0YSwgdGhyZXNob2xkKTtcbiAgICBpZiAobWFzaykge1xuICAgICAgLy8gRXJvZGVcbiAgICAgIG1hc2sgPSBlcm9kZU1hc2sobWFzaywgaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcblxuICAgICAgLy8gRGlsYXRlXG4gICAgICBtYXNrID0gZGlsYXRlTWFzayhtYXNrLCBpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuXG4gICAgICAvLyBHcmFkaWVudFxuICAgICAgbWFzayA9IHNtb290aEVkZ2VNYXNrKG1hc2ssIGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XG5cbiAgICAgIC8vIEFwcGx5IG1hc2tcbiAgICAgIGFwcGx5TWFzayhpbWFnZURhdGEsIG1hc2spO1xuXG4gICAgICAvLyB0b2RvIDogVXBkYXRlIGhpdCByZWdpb24gZnVuY3Rpb24gYWNjb3JkaW5nIHRvIG1hc2tcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VEYXRhO1xuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ3RocmVzaG9sZCcsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogUkdCIEZpbHRlclxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgUkdCXG4gICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICogQGF1dGhvciBpcHBvNjE1XG4gICAqIEBleGFtcGxlXG4gICAqIG5vZGUuY2FjaGUoKTtcbiAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlJHQl0pO1xuICAgKiBub2RlLmJsdWUoMTIwKTtcbiAgICogbm9kZS5ncmVlbigyMDApO1xuICAgKi9cbiAgS29udmEuRmlsdGVycy5SR0IgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgcmVkID0gdGhpcy5yZWQoKSxcbiAgICAgIGdyZWVuID0gdGhpcy5ncmVlbigpLFxuICAgICAgYmx1ZSA9IHRoaXMuYmx1ZSgpLFxuICAgICAgaSxcbiAgICAgIGJyaWdodG5lc3M7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XG4gICAgICBicmlnaHRuZXNzID1cbiAgICAgICAgKDAuMzQgKiBkYXRhW2ldICsgMC41ICogZGF0YVtpICsgMV0gKyAwLjE2ICogZGF0YVtpICsgMl0pIC8gMjU1O1xuICAgICAgZGF0YVtpXSA9IGJyaWdodG5lc3MgKiByZWQ7IC8vIHJcbiAgICAgIGRhdGFbaSArIDFdID0gYnJpZ2h0bmVzcyAqIGdyZWVuOyAvLyBnXG4gICAgICBkYXRhW2kgKyAyXSA9IGJyaWdodG5lc3MgKiBibHVlOyAvLyBiXG4gICAgICBkYXRhW2kgKyAzXSA9IGRhdGFbaSArIDNdOyAvLyBhbHBoYVxuICAgIH1cbiAgfTtcblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAncmVkJywgMCwgZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsID4gMjU1KSB7XG4gICAgICByZXR1cm4gMjU1O1xuICAgIH0gZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsdGVyIHJlZCB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCfSBmaWx0ZXIuXG4gICAqIEBuYW1lIHJlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IHJlZCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2dyZWVuJywgMCwgZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsID4gMjU1KSB7XG4gICAgICByZXR1cm4gMjU1O1xuICAgIH0gZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsdGVyIGdyZWVuIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0J9IGZpbHRlci5cbiAgICogQG5hbWUgZ3JlZW5cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBncmVlbiB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnYmx1ZScsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbHRlciBibHVlIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0J9IGZpbHRlci5cbiAgICogQG5hbWUgYmx1ZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IGJsdWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBSR0JBIEZpbHRlclxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgUkdCQVxuICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAqIEBhdXRob3IgY29kZWZvXG4gICAqIEBleGFtcGxlXG4gICAqIG5vZGUuY2FjaGUoKTtcbiAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlJHQkFdKTtcbiAgICogbm9kZS5ibHVlKDEyMCk7XG4gICAqIG5vZGUuZ3JlZW4oMjAwKTtcbiAgICogbm9kZS5hbHBoYSgwLjMpO1xuICAgKi9cbiAgS29udmEuRmlsdGVycy5SR0JBID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIG5QaXhlbHMgPSBkYXRhLmxlbmd0aCxcbiAgICAgIHJlZCA9IHRoaXMucmVkKCksXG4gICAgICBncmVlbiA9IHRoaXMuZ3JlZW4oKSxcbiAgICAgIGJsdWUgPSB0aGlzLmJsdWUoKSxcbiAgICAgIGFscGhhID0gdGhpcy5hbHBoYSgpLFxuICAgICAgaSxcbiAgICAgIGlhO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgaWEgPSAxIC0gYWxwaGE7XG5cbiAgICAgIGRhdGFbaV0gPSByZWQgKiBhbHBoYSArIGRhdGFbaV0gKiBpYTsgLy8gclxuICAgICAgZGF0YVtpICsgMV0gPSBncmVlbiAqIGFscGhhICsgZGF0YVtpICsgMV0gKiBpYTsgLy8gZ1xuICAgICAgZGF0YVtpICsgMl0gPSBibHVlICogYWxwaGEgKyBkYXRhW2kgKyAyXSAqIGlhOyAvLyBiXG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdyZWQnLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgIGlmICh2YWwgPiAyNTUpIHtcbiAgICAgIHJldHVybiAyNTU7XG4gICAgfSBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogZ2V0L3NldCBmaWx0ZXIgcmVkIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0JBfSBmaWx0ZXIuXG4gICAqIEBuYW1lIHJlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IHJlZCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2dyZWVuJywgMCwgZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsID4gMjU1KSB7XG4gICAgICByZXR1cm4gMjU1O1xuICAgIH0gZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsdGVyIGdyZWVuIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0JBfSBmaWx0ZXIuXG4gICAqIEBuYW1lIGdyZWVuXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gZ3JlZW4gdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2JsdWUnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBmaWx0ZXIgYmx1ZSB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgKiBAbmFtZSBibHVlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gYmx1ZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2FscGhhJywgMSwgZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsID4gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogZ2V0L3NldCBmaWx0ZXIgYWxwaGEgdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlJHQkF9IGZpbHRlci5cbiAgICogQG5hbWUgYWxwaGFcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtGbG9hdH0gYWxwaGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxXG4gICAqIEByZXR1cm5zIHtGbG9hdH1cbiAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEhTViBGaWx0ZXIuIEFkanVzdHMgdGhlIGh1ZSwgc2F0dXJhdGlvbiBhbmQgdmFsdWVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIEhTVlxuICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAqIEBhdXRob3IgaXBwbzYxNVxuICAgKiBAZXhhbXBsZVxuICAgKiBpbWFnZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkhTVl0pO1xuICAgKiBpbWFnZS52YWx1ZSgyMDApO1xuICAgKi9cblxuICBLb252YS5GaWx0ZXJzLkhTViA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICB2ID0gTWF0aC5wb3coMiwgdGhpcy52YWx1ZSgpKSxcbiAgICAgIHMgPSBNYXRoLnBvdygyLCB0aGlzLnNhdHVyYXRpb24oKSksXG4gICAgICBoID0gTWF0aC5hYnModGhpcy5odWUoKSArIDM2MCkgJSAzNjAsXG4gICAgICBpO1xuXG4gICAgLy8gQmFzaXMgZm9yIHRoZSB0ZWNobmlxdWUgdXNlZDpcbiAgICAvLyBodHRwOi8vYmVlc2J1enouYml6L2NvZGUvaHN2X2NvbG9yX3RyYW5zZm9ybXMucGhwXG4gICAgLy8gViBpcyB0aGUgdmFsdWUgbXVsdGlwbGllciAoMSBmb3Igbm9uZSwgMiBmb3IgZG91YmxlLCAwLjUgZm9yIGhhbGYpXG4gICAgLy8gUyBpcyB0aGUgc2F0dXJhdGlvbiBtdWx0aXBsaWVyICgxIGZvciBub25lLCAyIGZvciBkb3VibGUsIDAuNSBmb3IgaGFsZilcbiAgICAvLyBIIGlzIHRoZSBodWUgc2hpZnQgaW4gZGVncmVlcyAoMCB0byAzNjApXG4gICAgLy8gdnN1ID0gVipTKmNvcyhIKlBJLzE4MCk7XG4gICAgLy8gdnN3ID0gVipTKnNpbihIKlBJLzE4MCk7XG4gICAgLy9bIC4yOTlWKy43MDF2c3UrLjE2OHZzdyAgICAuNTg3Vi0uNTg3dnN1Ky4zMzB2c3cgICAgLjExNFYtLjExNHZzdS0uNDk3dnN3IF0gW1JdXG4gICAgLy9bIC4yOTlWLS4yOTl2c3UtLjMyOHZzdyAgICAuNTg3VisuNDEzdnN1Ky4wMzV2c3cgICAgLjExNFYtLjExNHZzdSsuMjkydnN3IF0qW0ddXG4gICAgLy9bIC4yOTlWLS4zMDB2c3UrMS4yNXZzdyAgICAuNTg3Vi0uNTg4dnN1LTEuMDV2c3cgICAgLjExNFYrLjg4NnZzdS0uMjAzdnN3IF0gW0JdXG5cbiAgICAvLyBQcmVjb21wdXRlIHRoZSB2YWx1ZXMgaW4gdGhlIG1hdHJpeDpcbiAgICB2YXIgdnN1ID0gdiAqIHMgKiBNYXRoLmNvcyhoICogTWF0aC5QSSAvIDE4MCksXG4gICAgICB2c3cgPSB2ICogcyAqIE1hdGguc2luKGggKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAvLyAocmVzdWx0IHNwb3QpKHNvdXJjZSBzcG90KVxuICAgIHZhciByciA9IDAuMjk5ICogdiArIDAuNzAxICogdnN1ICsgMC4xNjcgKiB2c3csXG4gICAgICByZyA9IDAuNTg3ICogdiAtIDAuNTg3ICogdnN1ICsgMC4zMyAqIHZzdyxcbiAgICAgIHJiID0gMC4xMTQgKiB2IC0gMC4xMTQgKiB2c3UgLSAwLjQ5NyAqIHZzdztcbiAgICB2YXIgZ3IgPSAwLjI5OSAqIHYgLSAwLjI5OSAqIHZzdSAtIDAuMzI4ICogdnN3LFxuICAgICAgZ2cgPSAwLjU4NyAqIHYgKyAwLjQxMyAqIHZzdSArIDAuMDM1ICogdnN3LFxuICAgICAgZ2IgPSAwLjExNCAqIHYgLSAwLjExNCAqIHZzdSArIDAuMjkzICogdnN3O1xuICAgIHZhciBiciA9IDAuMjk5ICogdiAtIDAuMyAqIHZzdSArIDEuMjUgKiB2c3csXG4gICAgICBiZyA9IDAuNTg3ICogdiAtIDAuNTg2ICogdnN1IC0gMS4wNSAqIHZzdyxcbiAgICAgIGJiID0gMC4xMTQgKiB2ICsgMC44ODYgKiB2c3UgLSAwLjIgKiB2c3c7XG5cbiAgICB2YXIgciwgZywgYiwgYTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgIHIgPSBkYXRhW2kgKyAwXTtcbiAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgIGEgPSBkYXRhW2kgKyAzXTtcblxuICAgICAgZGF0YVtpICsgMF0gPSByciAqIHIgKyByZyAqIGcgKyByYiAqIGI7XG4gICAgICBkYXRhW2kgKyAxXSA9IGdyICogciArIGdnICogZyArIGdiICogYjtcbiAgICAgIGRhdGFbaSArIDJdID0gYnIgKiByICsgYmcgKiBnICsgYmIgKiBiO1xuICAgICAgZGF0YVtpICsgM10gPSBhOyAvLyBhbHBoYVxuICAgIH1cbiAgfTtcblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdodWUnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKSxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGhzdiBodWUgaW4gZGVncmVlcy4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cbiAgICogQG5hbWUgaHVlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBodWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAzNTlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnc2F0dXJhdGlvbicsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgaHN2IHNhdHVyYXRpb24uIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTVn0gb3Ige0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNMfSBmaWx0ZXIuXG4gICAqIEBuYW1lIHNhdHVyYXRpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb24gMCBpcyBubyBjaGFuZ2UsIC0xLjAgaGFsdmVzIHRoZSBzYXR1cmF0aW9uLCAxLjAgZG91YmxlcywgZXRjLi5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAndmFsdWUnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKSxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGhzdiB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBmaWx0ZXIuXG4gICAqIEBuYW1lIHZhbHVlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHZhbHVlLCAxLjAgZG91YmxlcywgZXRjLi5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnaHVlJyxcbiAgICAwLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKCksXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBoc3YgaHVlIGluIGRlZ3JlZXMuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTVn0gb3Ige0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNMfSBmaWx0ZXIuXG4gICAqIEBuYW1lIGh1ZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaHVlIHZhbHVlIGJldHdlZW4gMCBhbmQgMzU5XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ3NhdHVyYXRpb24nLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKSxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGhzdiBzYXR1cmF0aW9uLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgKiBAbmFtZSBzYXR1cmF0aW9uXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uIDAgaXMgbm8gY2hhbmdlLCAtMS4wIGhhbHZlcyB0aGUgc2F0dXJhdGlvbiwgMS4wIGRvdWJsZXMsIGV0Yy4uXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2x1bWluYW5jZScsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgaHNsIGx1bWluYW5jZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNMfSBmaWx0ZXIuXG4gICAqIEBuYW1lIHZhbHVlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBmcm9tIC0xIHRvIDFcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG5cbiAgLyoqXG4gICAqIEhTTCBGaWx0ZXIuIEFkanVzdHMgdGhlIGh1ZSwgc2F0dXJhdGlvbiBhbmQgbHVtaW5hbmNlIChvciBsaWdodG5lc3MpXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAqIEBhdXRob3IgaXBwbzYxNVxuICAgKiBAZXhhbXBsZVxuICAgKiBpbWFnZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkhTTF0pO1xuICAgKiBpbWFnZS5sdW1pbmFuY2UoMjAwKTtcbiAgICovXG5cbiAgS29udmEuRmlsdGVycy5IU0wgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgdiA9IDEsXG4gICAgICBzID0gTWF0aC5wb3coMiwgdGhpcy5zYXR1cmF0aW9uKCkpLFxuICAgICAgaCA9IE1hdGguYWJzKHRoaXMuaHVlKCkgKyAzNjApICUgMzYwLFxuICAgICAgbCA9IHRoaXMubHVtaW5hbmNlKCkgKiAxMjcsXG4gICAgICBpO1xuXG4gICAgLy8gQmFzaXMgZm9yIHRoZSB0ZWNobmlxdWUgdXNlZDpcbiAgICAvLyBodHRwOi8vYmVlc2J1enouYml6L2NvZGUvaHN2X2NvbG9yX3RyYW5zZm9ybXMucGhwXG4gICAgLy8gViBpcyB0aGUgdmFsdWUgbXVsdGlwbGllciAoMSBmb3Igbm9uZSwgMiBmb3IgZG91YmxlLCAwLjUgZm9yIGhhbGYpXG4gICAgLy8gUyBpcyB0aGUgc2F0dXJhdGlvbiBtdWx0aXBsaWVyICgxIGZvciBub25lLCAyIGZvciBkb3VibGUsIDAuNSBmb3IgaGFsZilcbiAgICAvLyBIIGlzIHRoZSBodWUgc2hpZnQgaW4gZGVncmVlcyAoMCB0byAzNjApXG4gICAgLy8gdnN1ID0gVipTKmNvcyhIKlBJLzE4MCk7XG4gICAgLy8gdnN3ID0gVipTKnNpbihIKlBJLzE4MCk7XG4gICAgLy9bIC4yOTlWKy43MDF2c3UrLjE2OHZzdyAgICAuNTg3Vi0uNTg3dnN1Ky4zMzB2c3cgICAgLjExNFYtLjExNHZzdS0uNDk3dnN3IF0gW1JdXG4gICAgLy9bIC4yOTlWLS4yOTl2c3UtLjMyOHZzdyAgICAuNTg3VisuNDEzdnN1Ky4wMzV2c3cgICAgLjExNFYtLjExNHZzdSsuMjkydnN3IF0qW0ddXG4gICAgLy9bIC4yOTlWLS4zMDB2c3UrMS4yNXZzdyAgICAuNTg3Vi0uNTg4dnN1LTEuMDV2c3cgICAgLjExNFYrLjg4NnZzdS0uMjAzdnN3IF0gW0JdXG5cbiAgICAvLyBQcmVjb21wdXRlIHRoZSB2YWx1ZXMgaW4gdGhlIG1hdHJpeDpcbiAgICB2YXIgdnN1ID0gdiAqIHMgKiBNYXRoLmNvcyhoICogTWF0aC5QSSAvIDE4MCksXG4gICAgICB2c3cgPSB2ICogcyAqIE1hdGguc2luKGggKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAvLyAocmVzdWx0IHNwb3QpKHNvdXJjZSBzcG90KVxuICAgIHZhciByciA9IDAuMjk5ICogdiArIDAuNzAxICogdnN1ICsgMC4xNjcgKiB2c3csXG4gICAgICByZyA9IDAuNTg3ICogdiAtIDAuNTg3ICogdnN1ICsgMC4zMyAqIHZzdyxcbiAgICAgIHJiID0gMC4xMTQgKiB2IC0gMC4xMTQgKiB2c3UgLSAwLjQ5NyAqIHZzdztcbiAgICB2YXIgZ3IgPSAwLjI5OSAqIHYgLSAwLjI5OSAqIHZzdSAtIDAuMzI4ICogdnN3LFxuICAgICAgZ2cgPSAwLjU4NyAqIHYgKyAwLjQxMyAqIHZzdSArIDAuMDM1ICogdnN3LFxuICAgICAgZ2IgPSAwLjExNCAqIHYgLSAwLjExNCAqIHZzdSArIDAuMjkzICogdnN3O1xuICAgIHZhciBiciA9IDAuMjk5ICogdiAtIDAuMyAqIHZzdSArIDEuMjUgKiB2c3csXG4gICAgICBiZyA9IDAuNTg3ICogdiAtIDAuNTg2ICogdnN1IC0gMS4wNSAqIHZzdyxcbiAgICAgIGJiID0gMC4xMTQgKiB2ICsgMC44ODYgKiB2c3UgLSAwLjIgKiB2c3c7XG5cbiAgICB2YXIgciwgZywgYiwgYTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgIHIgPSBkYXRhW2kgKyAwXTtcbiAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgIGEgPSBkYXRhW2kgKyAzXTtcblxuICAgICAgZGF0YVtpICsgMF0gPSByciAqIHIgKyByZyAqIGcgKyByYiAqIGIgKyBsO1xuICAgICAgZGF0YVtpICsgMV0gPSBnciAqIHIgKyBnZyAqIGcgKyBnYiAqIGIgKyBsO1xuICAgICAgZGF0YVtpICsgMl0gPSBiciAqIHIgKyBiZyAqIGcgKyBiYiAqIGIgKyBsO1xuICAgICAgZGF0YVtpICsgM10gPSBhOyAvLyBhbHBoYVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogRW1ib3NzIEZpbHRlci5cbiAgICogUGl4YXN0aWMgTGliIC0gRW1ib3NzIGZpbHRlciAtIHYwLjEuMFxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMDggSmFjb2IgU2VpZGVsaW4sIGpzZWlkZWxpbkBuaWhpbG9naWMuZGssIGh0dHA6Ly9ibG9nLm5paGlsb2dpYy5kay9cbiAgICogTGljZW5zZTogW2h0dHA6Ly93d3cucGl4YXN0aWMuY29tL2xpYi9saWNlbnNlLnR4dF1cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuRW1ib3NzXSk7XG4gICAqIG5vZGUuZW1ib3NzU3RyZW5ndGgoMC44KTtcbiAgICogbm9kZS5lbWJvc3NXaGl0ZUxldmVsKDAuMyk7XG4gICAqIG5vZGUuZW1ib3NzRGlyZWN0aW9uKCdyaWdodCcpO1xuICAgKiBub2RlLmVtYm9zc0JsZW5kKHRydWUpO1xuICAgKi9cbiAgS29udmEuRmlsdGVycy5FbWJvc3MgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAvLyBwaXhhc3RpYyBzdHJlbmd0aCBpcyBiZXR3ZWVuIDAgYW5kIDEwLiAgSSB3YW50IGl0IGJldHdlZW4gMCBhbmQgMVxuICAgIC8vIHBpeGFzdGljIGdyZXlMZXZlbCBpcyBiZXR3ZWVuIDAgYW5kIDI1NS4gIEkgd2FudCBpdCBiZXR3ZWVuIDAgYW5kIDEuICBBbHNvLFxuICAgIC8vIGEgbWF4IHZhbHVlIG9mIGdyZXlMZXZlbCB5aWVsZHMgYSB3aGl0ZSBlbWJvc3MsIGFuZCB0aGUgbWluIHZhbHVlIHlpZWxkcyBhIGJsYWNrXG4gICAgLy8gZW1ib3NzLiAgVGhlcmVmb3JlLCBJIGNoYW5nZWQgZ3JleUxldmVsIHRvIHdoaXRlTGV2ZWxcbiAgICB2YXIgc3RyZW5ndGggPSB0aGlzLmVtYm9zc1N0cmVuZ3RoKCkgKiAxMCxcbiAgICAgIGdyZXlMZXZlbCA9IHRoaXMuZW1ib3NzV2hpdGVMZXZlbCgpICogMjU1LFxuICAgICAgZGlyZWN0aW9uID0gdGhpcy5lbWJvc3NEaXJlY3Rpb24oKSxcbiAgICAgIGJsZW5kID0gdGhpcy5lbWJvc3NCbGVuZCgpLFxuICAgICAgZGlyWSA9IDAsXG4gICAgICBkaXJYID0gMCxcbiAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIHcgPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICBoID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgIHc0ID0gdyAqIDQsXG4gICAgICB5ID0gaDtcblxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgICAgIGRpclkgPSAtMTtcbiAgICAgICAgZGlyWCA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIGRpclkgPSAtMTtcbiAgICAgICAgZGlyWCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgZGlyWSA9IC0xO1xuICAgICAgICBkaXJYID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGRpclkgPSAwO1xuICAgICAgICBkaXJYID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICBkaXJZID0gMTtcbiAgICAgICAgZGlyWCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgZGlyWSA9IDE7XG4gICAgICAgIGRpclggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgZGlyWSA9IDE7XG4gICAgICAgIGRpclggPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgZGlyWSA9IDA7XG4gICAgICAgIGRpclggPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBLb252YS5VdGlsLmVycm9yKCdVbmtub3duIGVtYm9zcyBkaXJlY3Rpb246ICcgKyBkaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHZhciBvZmZzZXRZID0gKHkgLSAxKSAqIHc0O1xuXG4gICAgICB2YXIgb3RoZXJZID0gZGlyWTtcbiAgICAgIGlmICh5ICsgb3RoZXJZIDwgMSkge1xuICAgICAgICBvdGhlclkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHkgKyBvdGhlclkgPiBoKSB7XG4gICAgICAgIG90aGVyWSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXRZT3RoZXIgPSAoeSAtIDEgKyBvdGhlclkpICogdyAqIDQ7XG5cbiAgICAgIHZhciB4ID0gdztcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldFkgKyAoeCAtIDEpICogNDtcblxuICAgICAgICB2YXIgb3RoZXJYID0gZGlyWDtcbiAgICAgICAgaWYgKHggKyBvdGhlclggPCAxKSB7XG4gICAgICAgICAgb3RoZXJYID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCArIG90aGVyWCA+IHcpIHtcbiAgICAgICAgICBvdGhlclggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldE90aGVyID0gb2Zmc2V0WU90aGVyICsgKHggLSAxICsgb3RoZXJYKSAqIDQ7XG5cbiAgICAgICAgdmFyIGRSID0gZGF0YVtvZmZzZXRdIC0gZGF0YVtvZmZzZXRPdGhlcl07XG4gICAgICAgIHZhciBkRyA9IGRhdGFbb2Zmc2V0ICsgMV0gLSBkYXRhW29mZnNldE90aGVyICsgMV07XG4gICAgICAgIHZhciBkQiA9IGRhdGFbb2Zmc2V0ICsgMl0gLSBkYXRhW29mZnNldE90aGVyICsgMl07XG5cbiAgICAgICAgdmFyIGRpZiA9IGRSO1xuICAgICAgICB2YXIgYWJzRGlmID0gZGlmID4gMCA/IGRpZiA6IC1kaWY7XG5cbiAgICAgICAgdmFyIGFic0cgPSBkRyA+IDAgPyBkRyA6IC1kRztcbiAgICAgICAgdmFyIGFic0IgPSBkQiA+IDAgPyBkQiA6IC1kQjtcblxuICAgICAgICBpZiAoYWJzRyA+IGFic0RpZikge1xuICAgICAgICAgIGRpZiA9IGRHO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhYnNCID4gYWJzRGlmKSB7XG4gICAgICAgICAgZGlmID0gZEI7XG4gICAgICAgIH1cblxuICAgICAgICBkaWYgKj0gc3RyZW5ndGg7XG5cbiAgICAgICAgaWYgKGJsZW5kKSB7XG4gICAgICAgICAgdmFyIHIgPSBkYXRhW29mZnNldF0gKyBkaWY7XG4gICAgICAgICAgdmFyIGcgPSBkYXRhW29mZnNldCArIDFdICsgZGlmO1xuICAgICAgICAgIHZhciBiID0gZGF0YVtvZmZzZXQgKyAyXSArIGRpZjtcblxuICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHIgPiAyNTUgPyAyNTUgOiByIDwgMCA/IDAgOiByO1xuICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSBnID4gMjU1ID8gMjU1IDogZyA8IDAgPyAwIDogZztcbiAgICAgICAgICBkYXRhW29mZnNldCArIDJdID0gYiA+IDI1NSA/IDI1NSA6IGIgPCAwID8gMCA6IGI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGdyZXkgPSBncmV5TGV2ZWwgLSBkaWY7XG4gICAgICAgICAgaWYgKGdyZXkgPCAwKSB7XG4gICAgICAgICAgICBncmV5ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGdyZXkgPiAyNTUpIHtcbiAgICAgICAgICAgIGdyZXkgPSAyNTU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YVtvZmZzZXRdID0gZGF0YVtvZmZzZXQgKyAxXSA9IGRhdGFbb2Zmc2V0ICsgMl0gPSBncmV5O1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXgpO1xuICAgIH0gd2hpbGUgKC0teSk7XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnZW1ib3NzU3RyZW5ndGgnLFxuICAgIDAuNSxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgZW1ib3NzIHN0cmVuZ3RoLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5FbWJvc3N9IGZpbHRlci5cbiAgICogQG5hbWUgZW1ib3NzU3RyZW5ndGhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIGJldHdlZW4gMCBhbmQgMS4gIERlZmF1bHQgaXMgMC41XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2VtYm9zc1doaXRlTGV2ZWwnLFxuICAgIDAuNSxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgZW1ib3NzIHdoaXRlIGxldmVsLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5FbWJvc3N9IGZpbHRlci5cbiAgICogQG5hbWUgZW1ib3NzV2hpdGVMZXZlbFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZW1ib3NzV2hpdGVMZXZlbCBiZXR3ZWVuIDAgYW5kIDEuICBEZWZhdWx0IGlzIDAuNVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdlbWJvc3NEaXJlY3Rpb24nLFxuICAgICd0b3AtbGVmdCcsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGVtYm9zcyBkaXJlY3Rpb24uIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxuICAgKiBAbmFtZSBlbWJvc3NEaXJlY3Rpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVtYm9zc0RpcmVjdGlvbiBjYW4gYmUgdG9wLWxlZnQsIHRvcCwgdG9wLXJpZ2h0LCByaWdodCwgYm90dG9tLXJpZ2h0LCBib3R0b20sIGJvdHRvbS1sZWZ0IG9yIGxlZnRcbiAgICogICBUaGUgZGVmYXVsdCBpcyB0b3AtbGVmdFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdlbWJvc3NCbGVuZCcsXG4gICAgZmFsc2UsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGVtYm9zcyBibGVuZC4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuRW1ib3NzfSBmaWx0ZXIuXG4gICAqIEBuYW1lIGVtYm9zc0JsZW5kXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW1ib3NzQmxlbmRcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIGZ1bmN0aW9uIHJlbWFwKGZyb21WYWx1ZSwgZnJvbU1pbiwgZnJvbU1heCwgdG9NaW4sIHRvTWF4KSB7XG4gICAgLy8gQ29tcHV0ZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAgICB2YXIgZnJvbVJhbmdlID0gZnJvbU1heCAtIGZyb21NaW4sXG4gICAgICB0b1JhbmdlID0gdG9NYXggLSB0b01pbixcbiAgICAgIHRvVmFsdWU7XG5cbiAgICAvLyBJZiBlaXRoZXIgcmFuZ2UgaXMgMCwgdGhlbiB0aGUgdmFsdWUgY2FuIG9ubHkgYmUgbWFwcGVkIHRvIDEgdmFsdWVcbiAgICBpZiAoZnJvbVJhbmdlID09PSAwKSB7XG4gICAgICByZXR1cm4gdG9NaW4gKyB0b1JhbmdlIC8gMjtcbiAgICB9XG4gICAgaWYgKHRvUmFuZ2UgPT09IDApIHtcbiAgICAgIHJldHVybiB0b01pbjtcbiAgICB9XG5cbiAgICAvLyAoMSkgdW50cmFuc2xhdGUsICgyKSB1bnNjYWxlLCAoMykgcmVzY2FsZSwgKDQpIHJldHJhbnNsYXRlXG4gICAgdG9WYWx1ZSA9IChmcm9tVmFsdWUgLSBmcm9tTWluKSAvIGZyb21SYW5nZTtcbiAgICB0b1ZhbHVlID0gdG9SYW5nZSAqIHRvVmFsdWUgKyB0b01pbjtcblxuICAgIHJldHVybiB0b1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuaGFuY2UgRmlsdGVyLiBBZGp1c3RzIHRoZSBjb2xvcnMgc28gdGhhdCB0aGV5IHNwYW4gdGhlIHdpZGVzdFxuICAgKiAgcG9zc2libGUgcmFuZ2UgKGllIDAtMjU1KS4gUGVyZm9ybXMgdypoIHBpeGVsIHJlYWRzIGFuZCB3KmggcGl4ZWxcbiAgICogIHdyaXRlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIEVuaGFuY2VcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuRW5oYW5jZV0pO1xuICAgKiBub2RlLmVuaGFuY2UoMC40KTtcbiAgICovXG4gIEtvbnZhLkZpbHRlcnMuRW5oYW5jZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICBuU3ViUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICByTWluID0gZGF0YVswXSxcbiAgICAgIHJNYXggPSByTWluLFxuICAgICAgcixcbiAgICAgIGdNaW4gPSBkYXRhWzFdLFxuICAgICAgZ01heCA9IGdNaW4sXG4gICAgICBnLFxuICAgICAgYk1pbiA9IGRhdGFbMl0sXG4gICAgICBiTWF4ID0gYk1pbixcbiAgICAgIGIsXG4gICAgICBpO1xuXG4gICAgLy8gSWYgd2UgYXJlIG5vdCBlbmhhbmNpbmcgYW55dGhpbmcgLSBkb24ndCBkbyBhbnkgY29tcHV0YXRpb25cbiAgICB2YXIgZW5oYW5jZUFtb3VudCA9IHRoaXMuZW5oYW5jZSgpO1xuICAgIGlmIChlbmhhbmNlQW1vdW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gMXN0IFBhc3MgLSBmaW5kIHRoZSBtaW4gYW5kIG1heCBmb3IgZWFjaCBjaGFubmVsOlxuICAgIGZvciAoaSA9IDA7IGkgPCBuU3ViUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgIHIgPSBkYXRhW2kgKyAwXTtcbiAgICAgIGlmIChyIDwgck1pbikge1xuICAgICAgICByTWluID0gcjtcbiAgICAgIH0gZWxzZSBpZiAociA+IHJNYXgpIHtcbiAgICAgICAgck1heCA9IHI7XG4gICAgICB9XG4gICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICBpZiAoZyA8IGdNaW4pIHtcbiAgICAgICAgZ01pbiA9IGc7XG4gICAgICB9IGVsc2UgaWYgKGcgPiBnTWF4KSB7XG4gICAgICAgIGdNYXggPSBnO1xuICAgICAgfVxuICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgaWYgKGIgPCBiTWluKSB7XG4gICAgICAgIGJNaW4gPSBiO1xuICAgICAgfSBlbHNlIGlmIChiID4gYk1heCkge1xuICAgICAgICBiTWF4ID0gYjtcbiAgICAgIH1cbiAgICAgIC8vYSA9IGRhdGFbaSArIDNdO1xuICAgICAgLy9pZiAoYSA8IGFNaW4pIHsgYU1pbiA9IGE7IH0gZWxzZVxuICAgICAgLy9pZiAoYSA+IGFNYXgpIHsgYU1heCA9IGE7IH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IDEgbGV2ZWwgLSBkb24ndCByZW1hcFxuICAgIGlmIChyTWF4ID09PSByTWluKSB7XG4gICAgICByTWF4ID0gMjU1O1xuICAgICAgck1pbiA9IDA7XG4gICAgfVxuICAgIGlmIChnTWF4ID09PSBnTWluKSB7XG4gICAgICBnTWF4ID0gMjU1O1xuICAgICAgZ01pbiA9IDA7XG4gICAgfVxuICAgIGlmIChiTWF4ID09PSBiTWluKSB7XG4gICAgICBiTWF4ID0gMjU1O1xuICAgICAgYk1pbiA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHJNaWQsXG4gICAgICByR29hbE1heCxcbiAgICAgIHJHb2FsTWluLFxuICAgICAgZ01pZCxcbiAgICAgIGdHb2FsTWF4LFxuICAgICAgZ0dvYWxNaW4sXG4gICAgICBiTWlkLFxuICAgICAgYkdvYWxNYXgsXG4gICAgICBiR29hbE1pbjtcblxuICAgIC8vIElmIHRoZSBlbmhhbmNlbWVudCBpcyBwb3NpdGl2ZSAtIHN0cmV0Y2ggdGhlIGhpc3RvZ3JhbVxuICAgIGlmIChlbmhhbmNlQW1vdW50ID4gMCkge1xuICAgICAgckdvYWxNYXggPSByTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSByTWF4KTtcbiAgICAgIHJHb2FsTWluID0gck1pbiAtIGVuaGFuY2VBbW91bnQgKiAock1pbiAtIDApO1xuICAgICAgZ0dvYWxNYXggPSBnTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSBnTWF4KTtcbiAgICAgIGdHb2FsTWluID0gZ01pbiAtIGVuaGFuY2VBbW91bnQgKiAoZ01pbiAtIDApO1xuICAgICAgYkdvYWxNYXggPSBiTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSBiTWF4KTtcbiAgICAgIGJHb2FsTWluID0gYk1pbiAtIGVuaGFuY2VBbW91bnQgKiAoYk1pbiAtIDApO1xuICAgICAgLy8gSWYgdGhlIGVuaGFuY2VtZW50IGlzIG5lZ2F0aXZlIC0gICBjb21wcmVzcyB0aGUgaGlzdG9ncmFtXG4gICAgfSBlbHNlIHtcbiAgICAgIHJNaWQgPSAock1heCArIHJNaW4pICogMC41O1xuICAgICAgckdvYWxNYXggPSByTWF4ICsgZW5oYW5jZUFtb3VudCAqIChyTWF4IC0gck1pZCk7XG4gICAgICByR29hbE1pbiA9IHJNaW4gKyBlbmhhbmNlQW1vdW50ICogKHJNaW4gLSByTWlkKTtcbiAgICAgIGdNaWQgPSAoZ01heCArIGdNaW4pICogMC41O1xuICAgICAgZ0dvYWxNYXggPSBnTWF4ICsgZW5oYW5jZUFtb3VudCAqIChnTWF4IC0gZ01pZCk7XG4gICAgICBnR29hbE1pbiA9IGdNaW4gKyBlbmhhbmNlQW1vdW50ICogKGdNaW4gLSBnTWlkKTtcbiAgICAgIGJNaWQgPSAoYk1heCArIGJNaW4pICogMC41O1xuICAgICAgYkdvYWxNYXggPSBiTWF4ICsgZW5oYW5jZUFtb3VudCAqIChiTWF4IC0gYk1pZCk7XG4gICAgICBiR29hbE1pbiA9IGJNaW4gKyBlbmhhbmNlQW1vdW50ICogKGJNaW4gLSBiTWlkKTtcbiAgICB9XG5cbiAgICAvLyBQYXNzIDIgLSByZW1hcCBldmVyeXRoaW5nLCBleGNlcHQgdGhlIGFscGhhXG4gICAgZm9yIChpID0gMDsgaSA8IG5TdWJQaXhlbHM7IGkgKz0gNCkge1xuICAgICAgZGF0YVtpICsgMF0gPSByZW1hcChkYXRhW2kgKyAwXSwgck1pbiwgck1heCwgckdvYWxNaW4sIHJHb2FsTWF4KTtcbiAgICAgIGRhdGFbaSArIDFdID0gcmVtYXAoZGF0YVtpICsgMV0sIGdNaW4sIGdNYXgsIGdHb2FsTWluLCBnR29hbE1heCk7XG4gICAgICBkYXRhW2kgKyAyXSA9IHJlbWFwKGRhdGFbaSArIDJdLCBiTWluLCBiTWF4LCBiR29hbE1pbiwgYkdvYWxNYXgpO1xuICAgICAgLy9kYXRhW2kgKyAzXSA9IHJlbWFwKGRhdGFbaSArIDNdLCBhTWluLCBhTWF4LCBhR29hbE1pbiwgYUdvYWxNYXgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZ2V0L3NldCBlbmhhbmNlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5FbmhhbmNlfSBmaWx0ZXIuIC0xIHRvIDEgdmFsdWVzXG4gICAqIEBuYW1lIGVuaGFuY2VcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtGbG9hdH0gYW1vdW50XG4gICAqIEByZXR1cm5zIHtGbG9hdH1cbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2VuaGFuY2UnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKSxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIFBvc3Rlcml6ZSBGaWx0ZXIuIEFkanVzdHMgdGhlIGNoYW5uZWxzIHNvIHRoYXQgdGhlcmUgYXJlIG5vIG1vcmVcbiAgICogIHRoYW4gbiBkaWZmZXJlbnQgdmFsdWVzIGZvciB0aGF0IGNoYW5uZWwuIFRoaXMgaXMgYWxzbyBhcHBsaWVkXG4gICAqICB0byB0aGUgYWxwaGEgY2hhbm5lbC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIFBvc3Rlcml6ZVxuICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAZXhhbXBsZVxuICAgKiBub2RlLmNhY2hlKCk7XG4gICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5Qb3N0ZXJpemVdKTtcbiAgICogbm9kZS5sZXZlbHMoMC44KTsgLy8gYmV0d2VlbiAwIGFuZCAxXG4gICAqL1xuXG4gIEtvbnZhLkZpbHRlcnMuUG9zdGVyaXplID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgLy8gbGV2ZWwgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDI1NVxuICAgIHZhciBsZXZlbHMgPSBNYXRoLnJvdW5kKHRoaXMubGV2ZWxzKCkgKiAyNTQpICsgMSxcbiAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgc2NhbGUgPSAyNTUgLyBsZXZlbHMsXG4gICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBkYXRhW2ldID0gTWF0aC5mbG9vcihkYXRhW2ldIC8gc2NhbGUpICogc2NhbGU7XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2xldmVscycsXG4gICAgMC41LFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKCksXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGxldmVscy4gIE11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLiAgVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUG9zdGVyaXplfSBmaWx0ZXIuXG4gICAqIEBuYW1lIGxldmVsc1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgYmV0d2VlbiAwIGFuZCAxXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBOb2lzZSBGaWx0ZXIuIFJhbmRvbWx5IGFkZHMgb3Igc3Vic3RyYWN0cyB0byB0aGUgY29sb3IgY2hhbm5lbHNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIE5vaXNlXG4gICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICogQGF1dGhvciBpcHBvNjE1XG4gICAqIEBleGFtcGxlXG4gICAqIG5vZGUuY2FjaGUoKTtcbiAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLk5vaXNlXSk7XG4gICAqIG5vZGUubm9pc2UoMC44KTtcbiAgICovXG4gIEtvbnZhLkZpbHRlcnMuTm9pc2UgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgYW1vdW50ID0gdGhpcy5ub2lzZSgpICogMjU1LFxuICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgaGFsZiA9IGFtb3VudCAvIDIsXG4gICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgZGF0YVtpICsgMF0gKz0gaGFsZiAtIDIgKiBoYWxmICogTWF0aC5yYW5kb20oKTtcbiAgICAgIGRhdGFbaSArIDFdICs9IGhhbGYgLSAyICogaGFsZiAqIE1hdGgucmFuZG9tKCk7XG4gICAgICBkYXRhW2kgKyAyXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xuICAgIH1cbiAgfTtcblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdub2lzZScsXG4gICAgMC4yLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKCksXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBub2lzZSBhbW91bnQuICBNdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5Ob2lzZX0gZmlsdGVyLlxuICAgKiBAbmFtZSBub2lzZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbm9pc2VcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBQaXhlbGF0ZSBGaWx0ZXIuIEF2ZXJhZ2VzIGdyb3VwcyBvZiBwaXhlbHMgYW5kIHJlZHJhd3NcbiAgICogIHRoZW0gYXMgbGFyZ2VyIHBpeGVsc1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgUGl4ZWxhdGVcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuUGl4ZWxhdGVdKTtcbiAgICogbm9kZS5waXhlbFNpemUoMTApO1xuICAgKi9cblxuICBLb252YS5GaWx0ZXJzLlBpeGVsYXRlID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIHBpeGVsU2l6ZSA9IE1hdGguY2VpbCh0aGlzLnBpeGVsU2l6ZSgpKSxcbiAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaSxcbiAgICAgIC8vcGl4ZWxzUGVyQmluID0gcGl4ZWxTaXplICogcGl4ZWxTaXplLFxuICAgICAgcmVkLFxuICAgICAgZ3JlZW4sXG4gICAgICBibHVlLFxuICAgICAgYWxwaGEsXG4gICAgICBuQmluc1ggPSBNYXRoLmNlaWwod2lkdGggLyBwaXhlbFNpemUpLFxuICAgICAgbkJpbnNZID0gTWF0aC5jZWlsKGhlaWdodCAvIHBpeGVsU2l6ZSksXG4gICAgICB4QmluU3RhcnQsXG4gICAgICB4QmluRW5kLFxuICAgICAgeUJpblN0YXJ0LFxuICAgICAgeUJpbkVuZCxcbiAgICAgIHhCaW4sXG4gICAgICB5QmluLFxuICAgICAgcGl4ZWxzSW5CaW47XG4gICAgaW1hZ2VEYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgICBpZiAocGl4ZWxTaXplIDw9IDApIHtcbiAgICAgIEtvbnZhLlV0aWwuZXJyb3IoJ3BpeGVsU2l6ZSB2YWx1ZSBjYW4gbm90IGJlIDw9IDAnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHhCaW4gPSAwOyB4QmluIDwgbkJpbnNYOyB4QmluICs9IDEpIHtcbiAgICAgIGZvciAoeUJpbiA9IDA7IHlCaW4gPCBuQmluc1k7IHlCaW4gKz0gMSkge1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBjb2xvciBhY2N1bWxhdG9ycyB0byAwXG4gICAgICAgIHJlZCA9IDA7XG4gICAgICAgIGdyZWVuID0gMDtcbiAgICAgICAgYmx1ZSA9IDA7XG4gICAgICAgIGFscGhhID0gMDtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggcGl4ZWxzIGFyZSBpbmNsdWRlZCBpbiB0aGlzIGJpblxuICAgICAgICB4QmluU3RhcnQgPSB4QmluICogcGl4ZWxTaXplO1xuICAgICAgICB4QmluRW5kID0geEJpblN0YXJ0ICsgcGl4ZWxTaXplO1xuICAgICAgICB5QmluU3RhcnQgPSB5QmluICogcGl4ZWxTaXplO1xuICAgICAgICB5QmluRW5kID0geUJpblN0YXJ0ICsgcGl4ZWxTaXplO1xuXG4gICAgICAgIC8vIEFkZCBhbGwgb2YgdGhlIHBpeGVscyB0byB0aGlzIGJpbiFcbiAgICAgICAgcGl4ZWxzSW5CaW4gPSAwO1xuICAgICAgICBmb3IgKHggPSB4QmluU3RhcnQ7IHggPCB4QmluRW5kOyB4ICs9IDEpIHtcbiAgICAgICAgICBpZiAoeCA+PSB3aWR0aCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoeSA9IHlCaW5TdGFydDsgeSA8IHlCaW5FbmQ7IHkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHkgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9ICh3aWR0aCAqIHkgKyB4KSAqIDQ7XG4gICAgICAgICAgICByZWQgKz0gaW1hZ2VEYXRhW2kgKyAwXTtcbiAgICAgICAgICAgIGdyZWVuICs9IGltYWdlRGF0YVtpICsgMV07XG4gICAgICAgICAgICBibHVlICs9IGltYWdlRGF0YVtpICsgMl07XG4gICAgICAgICAgICBhbHBoYSArPSBpbWFnZURhdGFbaSArIDNdO1xuICAgICAgICAgICAgcGl4ZWxzSW5CaW4gKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNoYW5uZWxzIGFyZSBiZXR3ZWVuIDAtMjU1XG4gICAgICAgIHJlZCA9IHJlZCAvIHBpeGVsc0luQmluO1xuICAgICAgICBncmVlbiA9IGdyZWVuIC8gcGl4ZWxzSW5CaW47XG4gICAgICAgIGJsdWUgPSBibHVlIC8gcGl4ZWxzSW5CaW47XG4gICAgICAgIGFscGhhID0gYWxwaGEgLyBwaXhlbHNJbkJpbjtcblxuICAgICAgICAvLyBEcmF3IHRoaXMgYmluXG4gICAgICAgIGZvciAoeCA9IHhCaW5TdGFydDsgeCA8IHhCaW5FbmQ7IHggKz0gMSkge1xuICAgICAgICAgIGlmICh4ID49IHdpZHRoKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh5ID0geUJpblN0YXJ0OyB5IDwgeUJpbkVuZDsgeSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoeSA+PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gKHdpZHRoICogeSArIHgpICogNDtcbiAgICAgICAgICAgIGltYWdlRGF0YVtpICsgMF0gPSByZWQ7XG4gICAgICAgICAgICBpbWFnZURhdGFbaSArIDFdID0gZ3JlZW47XG4gICAgICAgICAgICBpbWFnZURhdGFbaSArIDJdID0gYmx1ZTtcbiAgICAgICAgICAgIGltYWdlRGF0YVtpICsgM10gPSBhbHBoYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAncGl4ZWxTaXplJyxcbiAgICA4LFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKCksXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBwaXhlbCBzaXplLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5QaXhlbGF0ZX0gZmlsdGVyLlxuICAgKiBAbmFtZSBwaXhlbFNpemVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBwaXhlbFNpemVcbiAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBUaHJlc2hvbGQgRmlsdGVyLiBQdXNoZXMgYW55IHZhbHVlIGFib3ZlIHRoZSBtaWQgcG9pbnQgdG9cbiAgICogIHRoZSBtYXggYW5kIGFueSB2YWx1ZSBiZWxvdyB0aGUgbWlkIHBvaW50IHRvIHRoZSBtaW4uXG4gICAqICBUaGlzIGFmZmVjdHMgdGhlIGFscGhhIGNoYW5uZWwuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBUaHJlc2hvbGRcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuVGhyZXNob2xkXSk7XG4gICAqIG5vZGUudGhyZXNob2xkKDAuMSk7XG4gICAqL1xuXG4gIEtvbnZhLkZpbHRlcnMuVGhyZXNob2xkID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy50aHJlc2hvbGQoKSAqIDI1NSxcbiAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZGF0YVtpXSA9IGRhdGFbaV0gPCBsZXZlbCA/IDAgOiAyNTU7XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ3RocmVzaG9sZCcsXG4gICAgMC41LFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKCksXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCB0aHJlc2hvbGQuICBNdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5UaHJlc2hvbGR9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLk1hc2t9IGZpbHRlci5cbiAgICogQG5hbWUgdGhyZXNob2xkXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGRcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIFNlcGlhIEZpbHRlclxuICAgKiBCYXNlZCBvbjogUGl4YXN0aWMgTGliIC0gU2VwaWEgZmlsdGVyIC0gdjAuMS4wXG4gICAqIENvcHlyaWdodCAoYykgMjAwOCBKYWNvYiBTZWlkZWxpbiwganNlaWRlbGluQG5paGlsb2dpYy5kaywgaHR0cDovL2Jsb2cubmloaWxvZ2ljLmRrL1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgU2VwaWFcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAYXV0aG9yIEphY29iIFNlaWRlbGluIDxqc2VpZGVsaW5AbmloaWxvZ2ljLmRrPlxuICAgKiBAbGljZW5zZSBNUEwgdjEuMSBbaHR0cDovL3d3dy5waXhhc3RpYy5jb20vbGliL2xpY2Vuc2UudHh0XVxuICAgKiBAZXhhbXBsZVxuICAgKiBub2RlLmNhY2hlKCk7XG4gICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5TZXBpYV0pO1xuICAgKi9cbiAgS29udmEuRmlsdGVycy5TZXBpYSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICB3ID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgeSA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICB3NCA9IHcgKiA0LFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIHgsXG4gICAgICBvZmZzZXQsXG4gICAgICBvcixcbiAgICAgIG9nLFxuICAgICAgb2IsXG4gICAgICByLFxuICAgICAgZyxcbiAgICAgIGI7XG5cbiAgICBkbyB7XG4gICAgICBvZmZzZXRZID0gKHkgLSAxKSAqIHc0O1xuICAgICAgeCA9IHc7XG4gICAgICBkbyB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldFkgKyAoeCAtIDEpICogNDtcblxuICAgICAgICBvciA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgb2cgPSBkYXRhW29mZnNldCArIDFdO1xuICAgICAgICBvYiA9IGRhdGFbb2Zmc2V0ICsgMl07XG5cbiAgICAgICAgciA9IG9yICogMC4zOTMgKyBvZyAqIDAuNzY5ICsgb2IgKiAwLjE4OTtcbiAgICAgICAgZyA9IG9yICogMC4zNDkgKyBvZyAqIDAuNjg2ICsgb2IgKiAwLjE2ODtcbiAgICAgICAgYiA9IG9yICogMC4yNzIgKyBvZyAqIDAuNTM0ICsgb2IgKiAwLjEzMTtcblxuICAgICAgICBkYXRhW29mZnNldF0gPSByID4gMjU1ID8gMjU1IDogcjtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IGcgPiAyNTUgPyAyNTUgOiBnO1xuICAgICAgICBkYXRhW29mZnNldCArIDJdID0gYiA+IDI1NSA/IDI1NSA6IGI7XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgM10gPSBkYXRhW29mZnNldCArIDNdO1xuICAgICAgfSB3aGlsZSAoLS14KTtcbiAgICB9IHdoaWxlICgtLXkpO1xuICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBTb2xhcml6ZSBGaWx0ZXJcbiAgICogUGl4YXN0aWMgTGliIC0gU29sYXJpemUgZmlsdGVyIC0gdjAuMS4wXG4gICAqIENvcHlyaWdodCAoYykgMjAwOCBKYWNvYiBTZWlkZWxpbiwganNlaWRlbGluQG5paGlsb2dpYy5kaywgaHR0cDovL2Jsb2cubmloaWxvZ2ljLmRrL1xuICAgKiBMaWNlbnNlOiBbaHR0cDovL3d3dy5waXhhc3RpYy5jb20vbGliL2xpY2Vuc2UudHh0XVxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgU29sYXJpemVcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAZXhhbXBsZVxuICAgKiBub2RlLmNhY2hlKCk7XG4gICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5Tb2xhcml6ZV0pO1xuICAgKi9cbiAgS29udmEuRmlsdGVycy5Tb2xhcml6ZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICB3ID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgaCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICB3NCA9IHcgKiA0LFxuICAgICAgeSA9IGg7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgb2Zmc2V0WSA9ICh5IC0gMSkgKiB3NDtcbiAgICAgIHZhciB4ID0gdztcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldFkgKyAoeCAtIDEpICogNDtcbiAgICAgICAgdmFyIHIgPSBkYXRhW29mZnNldF07XG4gICAgICAgIHZhciBnID0gZGF0YVtvZmZzZXQgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBkYXRhW29mZnNldCArIDJdO1xuXG4gICAgICAgIGlmIChyID4gMTI3KSB7XG4gICAgICAgICAgciA9IDI1NSAtIHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGcgPiAxMjcpIHtcbiAgICAgICAgICBnID0gMjU1IC0gZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiA+IDEyNykge1xuICAgICAgICAgIGIgPSAyNTUgLSBiO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtvZmZzZXRdID0gcjtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IGc7XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSBiO1xuICAgICAgfSB3aGlsZSAoLS14KTtcbiAgICB9IHdoaWxlICgtLXkpO1xuICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qXG4gICAqIFRvUG9sYXIgRmlsdGVyLiBDb252ZXJ0cyBpbWFnZSBkYXRhIHRvIHBvbGFyIGNvb3JkaW5hdGVzLiBQZXJmb3Jtc1xuICAgKiAgdypoKjQgcGl4ZWwgcmVhZHMgYW5kIHcqaCBwaXhlbCB3cml0ZXMuIFRoZSByIGF4aXMgaXMgcGxhY2VkIGFsb25nXG4gICAqICB3aGF0IHdvdWxkIGJlIHRoZSB5IGF4aXMgYW5kIHRoZSB0aGV0YSBheGlzIGFsb25nIHRoZSB4IGF4aXMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtJbWFnZURhdGF9IHNyYywgdGhlIHNvdXJjZSBpbWFnZSBkYXRhICh3aGF0IHdpbGwgYmUgdHJhbnNmb3JtZWQpXG4gICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBkc3QsIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBkYXRhICh3aGVyZSBpdCB3aWxsIGJlIHNhdmVkKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyQ2VudGVyWF0gaG9yaXpvbnRhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxuICAgKiAgZGVmYXVsdCBpcyBpbiB0aGUgbWlkZGxlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyQ2VudGVyWV0gdmVydGljYWwgbG9jYXRpb24gZm9yIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSxcbiAgICogIGRlZmF1bHQgaXMgaW4gdGhlIG1pZGRsZVxuICAgKi9cblxuICB2YXIgVG9Qb2xhciA9IGZ1bmN0aW9uKHNyYywgZHN0LCBvcHQpIHtcbiAgICB2YXIgc3JjUGl4ZWxzID0gc3JjLmRhdGEsXG4gICAgICBkc3RQaXhlbHMgPSBkc3QuZGF0YSxcbiAgICAgIHhTaXplID0gc3JjLndpZHRoLFxuICAgICAgeVNpemUgPSBzcmMuaGVpZ2h0LFxuICAgICAgeE1pZCA9IG9wdC5wb2xhckNlbnRlclggfHwgeFNpemUgLyAyLFxuICAgICAgeU1pZCA9IG9wdC5wb2xhckNlbnRlclkgfHwgeVNpemUgLyAyLFxuICAgICAgaSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgciA9IDAsXG4gICAgICBnID0gMCxcbiAgICAgIGIgPSAwLFxuICAgICAgYSA9IDA7XG5cbiAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHJhZGl1c1xuICAgIHZhciByYWQsXG4gICAgICByTWF4ID0gTWF0aC5zcXJ0KHhNaWQgKiB4TWlkICsgeU1pZCAqIHlNaWQpO1xuICAgIHggPSB4U2l6ZSAtIHhNaWQ7XG4gICAgeSA9IHlTaXplIC0geU1pZDtcbiAgICByYWQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgck1heCA9IHJhZCA+IHJNYXggPyByYWQgOiByTWF4O1xuXG4gICAgLy8gV2UnbGwgYmUgdWlzbmcgeSBhcyB0aGUgcmFkaXVzLCBhbmQgeCBhcyB0aGUgYW5nbGUgKHRoZXRhPXQpXG4gICAgdmFyIHJTaXplID0geVNpemUsXG4gICAgICB0U2l6ZSA9IHhTaXplLFxuICAgICAgcmFkaXVzLFxuICAgICAgdGhldGE7XG5cbiAgICAvLyBXZSB3YW50IHRvIGNvdmVyIGFsbCBhbmdsZXMgKDAtMzYwKSBhbmQgd2UgbmVlZCB0byBjb252ZXJ0IHRvXG4gICAgLy8gcmFkaWFucyAoKlBJLzE4MClcbiAgICB2YXIgY29udmVyc2lvbiA9IDM2MCAvIHRTaXplICogTWF0aC5QSSAvIDE4MCxcbiAgICAgIHNpbixcbiAgICAgIGNvcztcblxuICAgIC8vIHZhciB4MSwgeDIsIHgxaSwgeDJpLCB5MSwgeTIsIHkxaSwgeTJpLCBzY2FsZTtcblxuICAgIGZvciAodGhldGEgPSAwOyB0aGV0YSA8IHRTaXplOyB0aGV0YSArPSAxKSB7XG4gICAgICBzaW4gPSBNYXRoLnNpbih0aGV0YSAqIGNvbnZlcnNpb24pO1xuICAgICAgY29zID0gTWF0aC5jb3ModGhldGEgKiBjb252ZXJzaW9uKTtcbiAgICAgIGZvciAocmFkaXVzID0gMDsgcmFkaXVzIDwgclNpemU7IHJhZGl1cyArPSAxKSB7XG4gICAgICAgIHggPSBNYXRoLmZsb29yKHhNaWQgKyByTWF4ICogcmFkaXVzIC8gclNpemUgKiBjb3MpO1xuICAgICAgICB5ID0gTWF0aC5mbG9vcih5TWlkICsgck1heCAqIHJhZGl1cyAvIHJTaXplICogc2luKTtcbiAgICAgICAgaSA9ICh5ICogeFNpemUgKyB4KSAqIDQ7XG4gICAgICAgIHIgPSBzcmNQaXhlbHNbaSArIDBdO1xuICAgICAgICBnID0gc3JjUGl4ZWxzW2kgKyAxXTtcbiAgICAgICAgYiA9IHNyY1BpeGVsc1tpICsgMl07XG4gICAgICAgIGEgPSBzcmNQaXhlbHNbaSArIDNdO1xuXG4gICAgICAgIC8vIFN0b3JlIGl0XG4gICAgICAgIC8vaSA9ICh0aGV0YSAqIHhTaXplICArICByYWRpdXMpICogNDtcbiAgICAgICAgaSA9ICh0aGV0YSArIHJhZGl1cyAqIHhTaXplKSAqIDQ7XG4gICAgICAgIGRzdFBpeGVsc1tpICsgMF0gPSByO1xuICAgICAgICBkc3RQaXhlbHNbaSArIDFdID0gZztcbiAgICAgICAgZHN0UGl4ZWxzW2kgKyAyXSA9IGI7XG4gICAgICAgIGRzdFBpeGVsc1tpICsgM10gPSBhO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKlxuICAgICAqIEZyb21Qb2xhciBGaWx0ZXIuIENvbnZlcnRzIGltYWdlIGRhdGEgZnJvbSBwb2xhciBjb29yZGluYXRlcyBiYWNrIHRvIHJlY3Rhbmd1bGFyLlxuICAgICAqICBQZXJmb3JtcyB3KmgqNCBwaXhlbCByZWFkcyBhbmQgdypoIHBpeGVsIHdyaXRlcy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBzcmMsIHRoZSBzb3VyY2UgaW1hZ2UgZGF0YSAod2hhdCB3aWxsIGJlIHRyYW5zZm9ybWVkKVxuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBkc3QsIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBkYXRhICh3aGVyZSBpdCB3aWxsIGJlIHNhdmVkKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5wb2xhckNlbnRlclhdIGhvcml6b250YWwgbG9jYXRpb24gZm9yIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSxcbiAgICAgKiAgZGVmYXVsdCBpcyBpbiB0aGUgbWlkZGxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHQucG9sYXJDZW50ZXJZXSB2ZXJ0aWNhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxuICAgICAqICBkZWZhdWx0IGlzIGluIHRoZSBtaWRkbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5wb2xhclJvdGF0aW9uXSBhbW91bnQgdG8gcm90YXRlIHRoZSBpbWFnZSBjb3VudGVyY2xvY2t3aXMsXG4gICAgICogIDAgaXMgbm8gcm90YXRpb24sIDM2MCBkZWdyZWVzIGlzIGEgZnVsbCByb3RhdGlvblxuICAgICAqL1xuXG4gIHZhciBGcm9tUG9sYXIgPSBmdW5jdGlvbihzcmMsIGRzdCwgb3B0KSB7XG4gICAgdmFyIHNyY1BpeGVscyA9IHNyYy5kYXRhLFxuICAgICAgZHN0UGl4ZWxzID0gZHN0LmRhdGEsXG4gICAgICB4U2l6ZSA9IHNyYy53aWR0aCxcbiAgICAgIHlTaXplID0gc3JjLmhlaWdodCxcbiAgICAgIHhNaWQgPSBvcHQucG9sYXJDZW50ZXJYIHx8IHhTaXplIC8gMixcbiAgICAgIHlNaWQgPSBvcHQucG9sYXJDZW50ZXJZIHx8IHlTaXplIC8gMixcbiAgICAgIGksXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGR4LFxuICAgICAgZHksXG4gICAgICByID0gMCxcbiAgICAgIGcgPSAwLFxuICAgICAgYiA9IDAsXG4gICAgICBhID0gMDtcblxuICAgIC8vIEZpbmQgdGhlIGxhcmdlc3QgcmFkaXVzXG4gICAgdmFyIHJhZCxcbiAgICAgIHJNYXggPSBNYXRoLnNxcnQoeE1pZCAqIHhNaWQgKyB5TWlkICogeU1pZCk7XG4gICAgeCA9IHhTaXplIC0geE1pZDtcbiAgICB5ID0geVNpemUgLSB5TWlkO1xuICAgIHJhZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICByTWF4ID0gcmFkID4gck1heCA/IHJhZCA6IHJNYXg7XG5cbiAgICAvLyBXZSdsbCBiZSB1aXNuZyB4IGFzIHRoZSByYWRpdXMsIGFuZCB5IGFzIHRoZSBhbmdsZSAodGhldGE9dClcbiAgICB2YXIgclNpemUgPSB5U2l6ZSxcbiAgICAgIHRTaXplID0geFNpemUsXG4gICAgICByYWRpdXMsXG4gICAgICB0aGV0YSxcbiAgICAgIHBoYXNlU2hpZnQgPSBvcHQucG9sYXJSb3RhdGlvbiB8fCAwO1xuXG4gICAgLy8gV2UgbmVlZCB0byBjb252ZXJ0IHRvIGRlZ3JlZXMgYW5kIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG4gICAgLy8gaXQncyBiZXR3ZWVuICgwLTM2MClcbiAgICAvLyB2YXIgY29udmVyc2lvbiA9IHRTaXplLzM2MCoxODAvTWF0aC5QSTtcbiAgICAvL3ZhciBjb252ZXJzaW9uID0gdFNpemUvMzYwKjE4MC9NYXRoLlBJO1xuXG4gICAgdmFyIHgxLCB5MTtcblxuICAgIGZvciAoeCA9IDA7IHggPCB4U2l6ZTsgeCArPSAxKSB7XG4gICAgICBmb3IgKHkgPSAwOyB5IDwgeVNpemU7IHkgKz0gMSkge1xuICAgICAgICBkeCA9IHggLSB4TWlkO1xuICAgICAgICBkeSA9IHkgLSB5TWlkO1xuICAgICAgICByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpICogclNpemUgLyByTWF4O1xuICAgICAgICB0aGV0YSA9IChNYXRoLmF0YW4yKGR5LCBkeCkgKiAxODAgLyBNYXRoLlBJICsgMzYwICsgcGhhc2VTaGlmdCkgJSAzNjA7XG4gICAgICAgIHRoZXRhID0gdGhldGEgKiB0U2l6ZSAvIDM2MDtcbiAgICAgICAgeDEgPSBNYXRoLmZsb29yKHRoZXRhKTtcbiAgICAgICAgeTEgPSBNYXRoLmZsb29yKHJhZGl1cyk7XG4gICAgICAgIGkgPSAoeTEgKiB4U2l6ZSArIHgxKSAqIDQ7XG4gICAgICAgIHIgPSBzcmNQaXhlbHNbaSArIDBdO1xuICAgICAgICBnID0gc3JjUGl4ZWxzW2kgKyAxXTtcbiAgICAgICAgYiA9IHNyY1BpeGVsc1tpICsgMl07XG4gICAgICAgIGEgPSBzcmNQaXhlbHNbaSArIDNdO1xuXG4gICAgICAgIC8vIFN0b3JlIGl0XG4gICAgICAgIGkgPSAoeSAqIHhTaXplICsgeCkgKiA0O1xuICAgICAgICBkc3RQaXhlbHNbaSArIDBdID0gcjtcbiAgICAgICAgZHN0UGl4ZWxzW2kgKyAxXSA9IGc7XG4gICAgICAgIGRzdFBpeGVsc1tpICsgMl0gPSBiO1xuICAgICAgICBkc3RQaXhlbHNbaSArIDNdID0gYTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy9Lb252YS5GaWx0ZXJzLlRvUG9sYXIgPSBLb252YS5VdGlsLl9GaWx0ZXJXcmFwRG91YmxlQnVmZmVyKFRvUG9sYXIpO1xuICAvL0tvbnZhLkZpbHRlcnMuRnJvbVBvbGFyID0gS29udmEuVXRpbC5fRmlsdGVyV3JhcERvdWJsZUJ1ZmZlcihGcm9tUG9sYXIpO1xuXG4gIC8vIGNyZWF0ZSBhIHRlbXBvcmFyeSBjYW52YXMgZm9yIHdvcmtpbmcgLSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBjYWxsc1xuXG4gIC8qXG4gICAgICogS2FsZWlkb3Njb3BlIEZpbHRlci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBLYWxlaWRvc2NvcGVcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5LYWxlaWRvc2NvcGVdKTtcbiAgICAgKiBub2RlLmthbGVpZG9zY29wZVBvd2VyKDMpO1xuICAgICAqIG5vZGUua2FsZWlkb3Njb3BlQW5nbGUoNDUpO1xuICAgICAqL1xuICBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciB4U2l6ZSA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgIHlTaXplID0gaW1hZ2VEYXRhLmhlaWdodDtcblxuICAgIHZhciB4LCB5LCB4b2ZmLCBpLCByLCBnLCBiLCBhLCBzcmNQb3MsIGRzdFBvcztcbiAgICB2YXIgcG93ZXIgPSBNYXRoLnJvdW5kKHRoaXMua2FsZWlkb3Njb3BlUG93ZXIoKSk7XG4gICAgdmFyIGFuZ2xlID0gTWF0aC5yb3VuZCh0aGlzLmthbGVpZG9zY29wZUFuZ2xlKCkpO1xuICAgIHZhciBvZmZzZXQgPSBNYXRoLmZsb29yKHhTaXplICogKGFuZ2xlICUgMzYwKSAvIDM2MCk7XG5cbiAgICBpZiAocG93ZXIgPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV29yayB3aXRoIG91ciBzaGFyZWQgYnVmZmVyIGNhbnZhc1xuICAgIHZhciB0ZW1wQ2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgdGVtcENhbnZhcy53aWR0aCA9IHhTaXplO1xuICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0geVNpemU7XG4gICAgdmFyIHNjcmF0Y2hEYXRhID0gdGVtcENhbnZhc1xuICAgICAgLmdldENvbnRleHQoJzJkJylcbiAgICAgIC5nZXRJbWFnZURhdGEoMCwgMCwgeFNpemUsIHlTaXplKTtcblxuICAgIC8vIENvbnZlcnQgdGhoZSBvcmlnaW5hbCB0byBwb2xhciBjb29yZGluYXRlc1xuICAgIFRvUG9sYXIoaW1hZ2VEYXRhLCBzY3JhdGNoRGF0YSwge1xuICAgICAgcG9sYXJDZW50ZXJYOiB4U2l6ZSAvIDIsXG4gICAgICBwb2xhckNlbnRlclk6IHlTaXplIC8gMlxuICAgIH0pO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGhvdyBiaWcgZWFjaCBzZWN0aW9uIHdpbGwgYmUsIGlmIGl0J3MgdG9vIHNtYWxsXG4gICAgLy8gbWFrZSBpdCBiaWdnZXJcbiAgICB2YXIgbWluU2VjdGlvblNpemUgPSB4U2l6ZSAvIE1hdGgucG93KDIsIHBvd2VyKTtcbiAgICB3aGlsZSAobWluU2VjdGlvblNpemUgPD0gOCkge1xuICAgICAgbWluU2VjdGlvblNpemUgPSBtaW5TZWN0aW9uU2l6ZSAqIDI7XG4gICAgICBwb3dlciAtPSAxO1xuICAgIH1cbiAgICBtaW5TZWN0aW9uU2l6ZSA9IE1hdGguY2VpbChtaW5TZWN0aW9uU2l6ZSk7XG4gICAgdmFyIHNlY3Rpb25TaXplID0gbWluU2VjdGlvblNpemU7XG5cbiAgICAvLyBDb3B5IHRoZSBvZmZzZXQgcmVnaW9uIHRvIDBcbiAgICAvLyBEZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgZmlsdGVyIGFuZCBsb2NhdGlvbiBvZiB0aGUgb2Zmc2V0IHdlIG1heSBuZWVkXG4gICAgLy8gdG8gY29weSB0aGUgc2VjdGlvbiBiYWNrd2FyZHMgdG8gcHJldmVudCBpdCBmcm9tIHJld3JpdGluZyBpdHNlbGZcbiAgICB2YXIgeFN0YXJ0ID0gMCxcbiAgICAgIHhFbmQgPSBzZWN0aW9uU2l6ZSxcbiAgICAgIHhEZWx0YSA9IDE7XG4gICAgaWYgKG9mZnNldCArIG1pblNlY3Rpb25TaXplID4geFNpemUpIHtcbiAgICAgIHhTdGFydCA9IHNlY3Rpb25TaXplO1xuICAgICAgeEVuZCA9IDA7XG4gICAgICB4RGVsdGEgPSAtMTtcbiAgICB9XG4gICAgZm9yICh5ID0gMDsgeSA8IHlTaXplOyB5ICs9IDEpIHtcbiAgICAgIGZvciAoeCA9IHhTdGFydDsgeCAhPT0geEVuZDsgeCArPSB4RGVsdGEpIHtcbiAgICAgICAgeG9mZiA9IE1hdGgucm91bmQoeCArIG9mZnNldCkgJSB4U2l6ZTtcbiAgICAgICAgc3JjUG9zID0gKHhTaXplICogeSArIHhvZmYpICogNDtcbiAgICAgICAgciA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMF07XG4gICAgICAgIGcgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDFdO1xuICAgICAgICBiID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAyXTtcbiAgICAgICAgYSA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgM107XG4gICAgICAgIGRzdFBvcyA9ICh4U2l6ZSAqIHkgKyB4KSAqIDQ7XG4gICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMF0gPSByO1xuICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDFdID0gZztcbiAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAyXSA9IGI7XG4gICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgM10gPSBhO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gdGhlIGFjdHVhbCBlZmZlY3RcbiAgICBmb3IgKHkgPSAwOyB5IDwgeVNpemU7IHkgKz0gMSkge1xuICAgICAgc2VjdGlvblNpemUgPSBNYXRoLmZsb29yKG1pblNlY3Rpb25TaXplKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3dlcjsgaSArPSAxKSB7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBzZWN0aW9uU2l6ZSArIDE7IHggKz0gMSkge1xuICAgICAgICAgIHNyY1BvcyA9ICh4U2l6ZSAqIHkgKyB4KSAqIDQ7XG4gICAgICAgICAgciA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMF07XG4gICAgICAgICAgZyA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMV07XG4gICAgICAgICAgYiA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMl07XG4gICAgICAgICAgYSA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgM107XG4gICAgICAgICAgZHN0UG9zID0gKHhTaXplICogeSArIHNlY3Rpb25TaXplICogMiAtIHggLSAxKSAqIDQ7XG4gICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAwXSA9IHI7XG4gICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAxXSA9IGc7XG4gICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAyXSA9IGI7XG4gICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAzXSA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdGlvblNpemUgKj0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGJhY2sgZnJvbSBwb2xhciBjb29yZGluYXRlc1xuICAgIEZyb21Qb2xhcihzY3JhdGNoRGF0YSwgaW1hZ2VEYXRhLCB7IHBvbGFyUm90YXRpb246IDAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGdldC9zZXQga2FsZWlkb3Njb3BlIHBvd2VyLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5LYWxlaWRvc2NvcGV9IGZpbHRlci5cbiAgICogQG5hbWUga2FsZWlkb3Njb3BlUG93ZXJcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBwb3dlciBvZiBrYWxlaWRvc2NvcGVcbiAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdrYWxlaWRvc2NvcGVQb3dlcicsXG4gICAgMixcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBrYWxlaWRvc2NvcGUgYW5nbGUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZX0gZmlsdGVyLlxuICAgKiBAbmFtZSBrYWxlaWRvc2NvcGVBbmdsZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IGRlZ3JlZXNcbiAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdrYWxlaWRvc2NvcGVBbmdsZScsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBDb250cmFzdCBGaWx0ZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAqIEBleGFtcGxlXG4gICAqIG5vZGUuY2FjaGUoKTtcbiAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkNvbnRyYXN0XSk7XG4gICAqIG5vZGUuY29udHJhc3QoMTApO1xuICAgKi9cblxuICBLb252YS5GaWx0ZXJzLkNvbnRyYXN0ID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGFkanVzdCA9IE1hdGgucG93KChwYXJzZUludCh0aGlzLmNvbnRyYXN0KCkpICsgMTAwKSAvIDEwMCwgMik7XG5cbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgcmVkID0gMTUwLFxuICAgICAgZ3JlZW4gPSAxNTAsXG4gICAgICBibHVlID0gMTUwLFxuICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgIHJlZCA9IGRhdGFbaV07XG4gICAgICBncmVlbiA9IGRhdGFbaSArIDFdO1xuICAgICAgYmx1ZSA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAvL1JlZCBjaGFubmVsXG4gICAgICByZWQgLz0gMjU1O1xuICAgICAgcmVkIC09IDAuNTtcbiAgICAgIHJlZCAqPSBhZGp1c3Q7XG4gICAgICByZWQgKz0gMC41O1xuICAgICAgcmVkICo9IDI1NTtcblxuICAgICAgLy9HcmVlbiBjaGFubmVsXG4gICAgICBncmVlbiAvPSAyNTU7XG4gICAgICBncmVlbiAtPSAwLjU7XG4gICAgICBncmVlbiAqPSBhZGp1c3Q7XG4gICAgICBncmVlbiArPSAwLjU7XG4gICAgICBncmVlbiAqPSAyNTU7XG5cbiAgICAgIC8vQmx1ZSBjaGFubmVsXG4gICAgICBibHVlIC89IDI1NTtcbiAgICAgIGJsdWUgLT0gMC41O1xuICAgICAgYmx1ZSAqPSBhZGp1c3Q7XG4gICAgICBibHVlICs9IDAuNTtcbiAgICAgIGJsdWUgKj0gMjU1O1xuXG4gICAgICByZWQgPSByZWQgPCAwID8gMCA6IHJlZCA+IDI1NSA/IDI1NSA6IHJlZDtcbiAgICAgIGdyZWVuID0gZ3JlZW4gPCAwID8gMCA6IGdyZWVuID4gMjU1ID8gMjU1IDogZ3JlZW47XG4gICAgICBibHVlID0gYmx1ZSA8IDAgPyAwIDogYmx1ZSA+IDI1NSA/IDI1NSA6IGJsdWU7XG5cbiAgICAgIGRhdGFbaV0gPSByZWQ7XG4gICAgICBkYXRhW2kgKyAxXSA9IGdyZWVuO1xuICAgICAgZGF0YVtpICsgMl0gPSBibHVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWx0ZXIgY29udHJhc3QuICBUaGUgY29udHJhc3QgaXMgYSBudW1iZXIgYmV0d2VlbiAtMTAwIGFuZCAxMDAuXG4gICAqIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkNvbnRyYXN0fSBmaWx0ZXIuXG4gICAqIEBuYW1lIGNvbnRyYXN0XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdCB2YWx1ZSBiZXR3ZWVuIC0xMDAgYW5kIDEwMFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnY29udHJhc3QnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKSxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQ29udGFpbmVyIGNvbnN0cnVjdG9yLiZuYnNwOyBDb250YWluZXJzIGFyZSB1c2VkIHRvIGNvbnRhaW4gbm9kZXMgb3Igb3RoZXIgY29udGFpbmVyc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBhdWdtZW50cyBLb252YS5Ob2RlXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2xpcEZ1bmNdIHNldCBjbGlwIGZ1bmNcblxuICAgKi9cbiAgS29udmEuQ29udGFpbmVyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuQ29udGFpbmVyLCB7XG4gICAgX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgS29udmEuQ29sbGVjdGlvbigpO1xuICAgICAgS29udmEuTm9kZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGEge0BsaW5rIEtvbnZhLkNvbGxlY3Rpb259IG9mIGRpcmVjdCBkZXNjZW5kYW50IG5vZGVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZpbHRlckZ1bmNdIGZpbHRlciBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtLb252YS5Db2xsZWN0aW9ufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGFsbCBjaGlsZHJlblxuICAgICAqIHZhciBjaGlsZHJlbiA9IGxheWVyLmdldENoaWxkcmVuKCk7XG4gICAgICpcbiAgICAgKiAvLyBnZXQgb25seSBjaXJjbGVzXG4gICAgICogdmFyIGNpcmNsZXMgPSBsYXllci5nZXRDaGlsZHJlbihmdW5jdGlvbihub2RlKXtcbiAgICAgKiAgICByZXR1cm4gbm9kZS5nZXRDbGFzc05hbWUoKSA9PT0gJ0NpcmNsZSc7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uKGZpbHRlckZ1bmMpIHtcbiAgICAgIGlmICghZmlsdGVyRnVuYykge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgS29udmEuQ29sbGVjdGlvbigpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGlmIChmaWx0ZXJGdW5jKGNoaWxkKSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBoYXMgY2hpbGRyZW5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpLmxlbmd0aCA+IDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZW1vdmUgYWxsIGNoaWxkcmVuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gS29udmEuQ29sbGVjdGlvbi50b0NvbGxlY3Rpb24odGhpcy5jaGlsZHJlbik7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIC8vIHJlc2V0IHBhcmVudCB0byBwcmV2ZW50IG1hbnkgX3NldENoaWxkcmVuSW5kaWNlcyBjYWxsc1xuICAgICAgICBkZWxldGUgY2hpbGQucGFyZW50O1xuICAgICAgICBjaGlsZC5pbmRleCA9IDA7XG4gICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3kgYWxsIGNoaWxkcmVuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZGVzdHJveUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IEtvbnZhLkNvbGxlY3Rpb24udG9Db2xsZWN0aW9uKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAvLyByZXNldCBwYXJlbnQgdG8gcHJldmVudCBtYW55IF9zZXRDaGlsZHJlbkluZGljZXMgY2FsbHNcbiAgICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcbiAgICAgICAgY2hpbGQuaW5kZXggPSAwO1xuICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIG5vZGUgb3Igbm9kZXMgdG8gY29udGFpbmVyLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Li4uS29udmEuTm9kZX0gY2hpbGRcbiAgICAgKiBAcmV0dXJucyB7Q29udGFpbmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGF5ZXIuYWRkKHNoYXBlMSwgc2hhcGUyLCBzaGFwZTMpO1xuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuZ2V0UGFyZW50KCkpIHtcbiAgICAgICAgY2hpbGQubW92ZVRvKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICB0aGlzLl92YWxpZGF0ZUFkZChjaGlsZCk7XG4gICAgICBjaGlsZC5pbmRleCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHRoaXMuX2ZpcmUoJ2FkZCcsIHtcbiAgICAgICAgY2hpbGQ6IGNoaWxkXG4gICAgICB9KTtcblxuICAgICAgLy8gaWYgbm9kZSB1bmRlciBkcmFnIHdlIG5lZWQgdG8gdXBkYXRlIGRyYWcgYW5pbWF0aW9uXG4gICAgICBpZiAoS29udmEuREQgJiYgY2hpbGQuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIEtvbnZhLkRELmFuaW0uc2V0TGF5ZXJzKGNoaWxkLmdldExheWVyKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGFpbmFibGVcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBkZXN0cm95IGNoaWxkcmVuXG4gICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUNoaWxkcmVuKCk7XG4gICAgICB9XG4gICAgICAvLyB0aGVuIGRlc3Ryb3kgc2VsZlxuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSB7QGxpbmsgS29udmEuQ29sbGVjdGlvbn0gb2Ygbm9kZXMgdGhhdCBtYXRjaCB0aGUgc2VsZWN0b3IuXG4gICAgICogWW91IGNhbiBwcm92aWRlIGEgc3RyaW5nIHdpdGggJyMnIGZvciBpZCBzZWxlY3Rpb25zIGFuZCAnLicgZm9yIG5hbWUgc2VsZWN0aW9ucy5cbiAgICAgKiBPciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gdHJ1ZS9mYWxzZSB3aGVuIGEgbm9kZSBpcyBwYXNzZWQgdGhyb3VnaC4gIFNlZSBleGFtcGxlIGJlbG93LlxuICAgICAqIFdpdGggc3RyaW5ncyB5b3UgY2FuIGFsc28gc2VsZWN0IGJ5IHR5cGUgb3IgY2xhc3MgbmFtZS4gUGFzcyBtdWx0aXBsZSBzZWxlY3RvcnNcbiAgICAgKiBzZXBhcmF0ZWQgYnkgYSBzcGFjZS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZyB8IEZ1bmN0aW9ufSBzZWxlY3RvclxuICAgICAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBQYXNzaW5nIGEgc3RyaW5nIGFzIGEgc2VsZWN0b3JcbiAgICAgKiAvLyBzZWxlY3Qgbm9kZSB3aXRoIGlkIGZvb1xuICAgICAqIHZhciBub2RlID0gc3RhZ2UuZmluZCgnI2ZvbycpO1xuICAgICAqXG4gICAgICogLy8gc2VsZWN0IG5vZGVzIHdpdGggbmFtZSBiYXIgaW5zaWRlIGxheWVyXG4gICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnLmJhcicpO1xuICAgICAqXG4gICAgICogLy8gc2VsZWN0IGFsbCBncm91cHMgaW5zaWRlIGxheWVyXG4gICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnR3JvdXAnKTtcbiAgICAgKlxuICAgICAqIC8vIHNlbGVjdCBhbGwgcmVjdGFuZ2xlcyBpbnNpZGUgbGF5ZXJcbiAgICAgKiB2YXIgbm9kZXMgPSBsYXllci5maW5kKCdSZWN0Jyk7XG4gICAgICpcbiAgICAgKiAvLyBzZWxlY3Qgbm9kZSB3aXRoIGFuIGlkIG9mIGZvbyBvciBhIG5hbWUgb2YgYmFyIGluc2lkZSBsYXllclxuICAgICAqIHZhciBub2RlcyA9IGxheWVyLmZpbmQoJyNmb28sIC5iYXInKTtcbiAgICAgKlxuICAgICAqIFBhc3NpbmcgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyBnZXQgYWxsIEdyb3Vwc1xuICAgICAqIHZhciBncm91cHMgPSBzdGFnZS5maW5kKG5vZGUgPT4ge1xuICAgICAqICByZXR1cm4gbm9kZS5nZXRUeXBlKCkgPT09ICdHcm91cCc7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBnZXQgb25seSBOb2RlcyB3aXRoIHBhcnRpYWwgb3BhY2l0eVxuICAgICAqIHZhciBhbHBoYU5vZGVzID0gbGF5ZXIuZmluZChub2RlID0+IHtcbiAgICAgKiAgcmV0dXJuIG5vZGUuZ2V0VHlwZSgpID09PSAnTm9kZScgJiYgbm9kZS5nZXRBYnNvbHV0ZU9wYWNpdHkoKSA8IDE7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZmluZDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIC8vIHByb3RlY3RpbmcgX2dlbmVyYWxGaW5kIHRvIHByZXZlbnQgdXNlciBmcm9tIGFjY2lkZW50YWxseSBhZGRpbmdcbiAgICAgIC8vIHNlY29uZCBhcmd1bWVudCBhbmQgZ2V0dGluZyB1bmV4cGVjdGVkIGBmaW5kT25lYCByZXN1bHRcbiAgICAgIHJldHVybiB0aGlzLl9nZW5lcmFsRmluZChzZWxlY3RvciwgZmFsc2UpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgZmlyc3Qgbm9kZSBmcm9tIGBmaW5kYCBtZXRob2RcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZyB8IEZ1bmN0aW9ufSBzZWxlY3RvclxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlIHwgVW5kZWZpbmVkfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gc2VsZWN0IG5vZGUgd2l0aCBpZCBmb29cbiAgICAgKiB2YXIgbm9kZSA9IHN0YWdlLmZpbmRPbmUoJyNmb28nKTtcbiAgICAgKlxuICAgICAqIC8vIHNlbGVjdCBub2RlIHdpdGggbmFtZSBiYXIgaW5zaWRlIGxheWVyXG4gICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZE9uZSgnLmJhcicpO1xuICAgICAqXG4gICAgICogLy8gc2VsZWN0IHRoZSBmaXJzdCBub2RlIHRvIHJldHVybiB0cnVlIGluIGEgZnVuY3Rpb25cbiAgICAgKiB2YXIgbm9kZSA9IHN0YWdlLmZpbmRPbmUobm9kZSA9PiB7XG4gICAgICogIHJldHVybiBub2RlLmdldFR5cGUoKSA9PT0gJ1NoYXBlJ1xuICAgICAqIH0pXG4gICAgICovXG4gICAgZmluZE9uZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9nZW5lcmFsRmluZChzZWxlY3RvciwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDAgPyByZXN1bHRbMF0gOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBfZ2VuZXJhbEZpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBmaW5kT25lKSB7XG4gICAgICB2YXIgcmV0QXJyID0gW107XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldEFyciA9IHRoaXMuX2ZpbmRCeVN0cmluZyhzZWxlY3RvciwgZmluZE9uZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXRBcnIgPSB0aGlzLl9maW5kQnlGdW5jdGlvbihzZWxlY3RvciwgZmluZE9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBLb252YS5Db2xsZWN0aW9uLnRvQ29sbGVjdGlvbihyZXRBcnIpO1xuICAgIH0sXG4gICAgX2ZpbmRCeVN0cmluZzogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciByZXRBcnIgPSBbXSxcbiAgICAgICAgc2VsZWN0b3JBcnIgPSBzZWxlY3Rvci5yZXBsYWNlKC8gL2csICcnKS5zcGxpdCgnLCcpLFxuICAgICAgICBsZW4gPSBzZWxlY3RvckFyci5sZW5ndGgsXG4gICAgICAgIG4sXG4gICAgICAgIGksXG4gICAgICAgIHNlbCxcbiAgICAgICAgYXJyLFxuICAgICAgICBub2RlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgY2xlbjtcblxuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIHNlbCA9IHNlbGVjdG9yQXJyW25dO1xuICAgICAgICBpZiAoIUtvbnZhLlV0aWwuaXNWYWxpZFNlbGVjdG9yKHNlbCkpIHtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9XG4gICAgICAgICAgICAnU2VsZWN0b3IgXCInICtcbiAgICAgICAgICAgIHNlbCArXG4gICAgICAgICAgICAnXCIgaXMgaW52YWxpZC4gQWxsb3dlZCBzZWxlY3RvcnMgZXhhbXBsZXMgYXJlIFwiI2Zvb1wiLCBcIi5iYXJcIiBvciBcIkdyb3VwXCIuXFxuJyArXG4gICAgICAgICAgICAnSWYgeW91IGhhdmUgYSBjdXN0b20gc2hhcGUgd2l0aCBzdWNoIGNsYXNzTmFtZSwgcGxlYXNlIGNoYW5nZSBpdCB0byBzdGFydCB3aXRoIHVwcGVyIGxldHRlciBsaWtlIFwiVHJpYW5nbGVcIi5cXG4nICtcbiAgICAgICAgICAgICdLb252YSBpcyBhd2Vzb21lLCByaWdodD8nO1xuICAgICAgICAgIEtvbnZhLlV0aWwud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZCBzZWxlY3RvclxuICAgICAgICBpZiAoc2VsLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuX2dldE5vZGVCeUlkKHNlbC5zbGljZSgxKSk7XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZWwuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgICAvLyBuYW1lIHNlbGVjdG9yXG4gICAgICAgICAgYXJyID0gdGhpcy5fZ2V0Tm9kZXNCeU5hbWUoc2VsLnNsaWNlKDEpKTtcbiAgICAgICAgICByZXRBcnIgPSByZXRBcnIuY29uY2F0KGFycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdW5yZWNvZ25pemVkIHNlbGVjdG9yLCBwYXNzIHRvIGNoaWxkcmVuXG4gICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgY2xlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2xlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXRBcnIgPSByZXRBcnIuY29uY2F0KGNoaWxkcmVuW2ldLl9nZXQoc2VsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfSxcbiAgICAvLyAoZm46ICgoTm9kZSkgPT4gYm9vbGVhbiwgZmluZE9uZT86IGJvb2xlYW4pXG4gICAgX2ZpbmRCeUZ1bmN0aW9uOiBmdW5jdGlvbihmbiwgZmluZE9uZSkge1xuICAgICAgdmFyIHJldEFyciA9IFtdO1xuXG4gICAgICB2YXIgYWRkSXRlbXMgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAvLyBlc2NhcGUgZnVuY3Rpb24gaWYgd2UndmUgYWxyZWFkeSBmb3VuZCBvbmUuXG4gICAgICAgIGlmIChmaW5kT25lICYmIHJldEFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgdmFyIGNsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGZuKGVsKSkge1xuICAgICAgICAgIHJldEFyciA9IHJldEFyci5jb25jYXQoZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGVuOyBpKyspIHtcbiAgICAgICAgICBhZGRJdGVtcyhjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGFkZEl0ZW1zKHRoaXMpO1xuXG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH0sXG4gICAgX2dldE5vZGVCeUlkOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBub2RlID0gS29udmEuaWRzW2tleV07XG5cbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pc0FuY2VzdG9yT2Yobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIF9nZXROb2Rlc0J5TmFtZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgYXJyID0gS29udmEubmFtZXNba2V5XSB8fCBbXTtcbiAgICAgIHJldHVybiB0aGlzLl9nZXREZXNjZW5kYW50cyhhcnIpO1xuICAgIH0sXG4gICAgX2dldDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciByZXRBcnIgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5fZ2V0LmNhbGwodGhpcywgc2VsZWN0b3IpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgcmV0QXJyID0gcmV0QXJyLmNvbmNhdChjaGlsZHJlbltuXS5fZ2V0KHNlbGVjdG9yKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kZXJzXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IEtvbnZhLk5vZGUucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAgIG9iai5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuXTtcbiAgICAgICAgb2JqLmNoaWxkcmVuLnB1c2goY2hpbGQudG9PYmplY3QoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBfZ2V0RGVzY2VuZGFudHM6IGZ1bmN0aW9uKGFycikge1xuICAgICAgdmFyIHJldEFyciA9IFtdO1xuICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIHZhciBub2RlID0gYXJyW25dO1xuICAgICAgICBpZiAodGhpcy5pc0FuY2VzdG9yT2Yobm9kZSkpIHtcbiAgICAgICAgICByZXRBcnIucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZGV0ZXJtaW5lIGlmIG5vZGUgaXMgYW4gYW5jZXN0b3JcbiAgICAgKiBvZiBkZXNjZW5kYW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtLb252YS5Ob2RlfSBub2RlXG4gICAgICovXG4gICAgaXNBbmNlc3Rvck9mOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5faWQgPT09IHRoaXMuX2lkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIG1ldGhvZFxuICAgICAgdmFyIG5vZGUgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsIG9iaik7XG5cbiAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKG5vKSB7XG4gICAgICAgIG5vZGUuYWRkKG5vLmNsb25lKCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBhbGwgc2hhcGVzIHRoYXQgaW50ZXJzZWN0IGEgcG9pbnQuICBOb3RlOiBiZWNhdXNlIHRoaXMgbWV0aG9kIG11c3QgY2xlYXIgYSB0ZW1wb3JhcnlcbiAgICAgKiBjYW52YXMgYW5kIHJlZHJhdyBldmVyeSBzaGFwZSBpbnNpZGUgdGhlIGNvbnRhaW5lciwgaXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3Igc3BlY2lhbCBzaXRhdGlvbnNcbiAgICAgKiBiZWNhdXNlIGl0IHBlcmZvcm1zIHZlcnkgcG9vcmx5LiAgUGxlYXNlIHVzZSB0aGUge0BsaW5rIEtvbnZhLlN0YWdlI2dldEludGVyc2VjdGlvbn0gbWV0aG9kIGlmIGF0IGFsbCBwb3NzaWJsZVxuICAgICAqIGJlY2F1c2UgaXQgcGVyZm9ybXMgbXVjaCBiZXR0ZXJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XG4gICAgICogQHJldHVybnMge0FycmF5fSBhcnJheSBvZiBzaGFwZXNcbiAgICAgKi9cbiAgICBnZXRBbGxJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcblxuICAgICAgdGhpcy5maW5kKCdTaGFwZScpLmVhY2goZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgaWYgKHNoYXBlLmlzVmlzaWJsZSgpICYmIHNoYXBlLmludGVyc2VjdHMocG9zKSkge1xuICAgICAgICAgIGFyci5wdXNoKHNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICBfc2V0Q2hpbGRyZW5JbmRpY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZCwgbikge1xuICAgICAgICBjaGlsZC5pbmRleCA9IG47XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRyYXdTY2VuZTogZnVuY3Rpb24oY2FuLCB0b3AsIGNhY2hpbmcpIHtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5nZXRDYW52YXMoKSksXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICBjYWNoZWRTY2VuZUNhbnZhcyA9IGNhY2hlZENhbnZhcyAmJiBjYWNoZWRDYW52YXMuc2NlbmU7XG5cbiAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSgpIHx8IGNhY2hpbmcpIHtcbiAgICAgICAgaWYgKCFjYWNoaW5nICYmIGNhY2hlZFNjZW5lQ2FudmFzKSB7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZFNjZW5lQ2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RyYXdDaGlsZHJlbihjYW52YXMsICdkcmF3U2NlbmUnLCB0b3AsIGZhbHNlLCBjYWNoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkcmF3SGl0OiBmdW5jdGlvbihjYW4sIHRvcCwgY2FjaGluZykge1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmhpdENhbnZhcyksXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICBjYWNoZWRIaXRDYW52YXMgPSBjYWNoZWRDYW52YXMgJiYgY2FjaGVkQ2FudmFzLmhpdDtcblxuICAgICAgaWYgKHRoaXMuc2hvdWxkRHJhd0hpdChjYW52YXMpIHx8IGNhY2hpbmcpIHtcbiAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgbGF5ZXIuY2xlYXJIaXRDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FjaGluZyAmJiBjYWNoZWRIaXRDYW52YXMpIHtcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgICB0aGlzLl9kcmF3Q2FjaGVkSGl0Q2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RyYXdDaGlsZHJlbihjYW52YXMsICdkcmF3SGl0JywgdG9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfZHJhd0NoaWxkcmVuOiBmdW5jdGlvbihjYW52YXMsIGRyYXdNZXRob2QsIHRvcCwgY2FjaGluZywgc2tpcEJ1ZmZlcikge1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgIGNsaXBXaWR0aCA9IHRoaXMuZ2V0Q2xpcFdpZHRoKCksXG4gICAgICAgIGNsaXBIZWlnaHQgPSB0aGlzLmdldENsaXBIZWlnaHQoKSxcbiAgICAgICAgY2xpcEZ1bmMgPSB0aGlzLmdldENsaXBGdW5jKCksXG4gICAgICAgIGhhc0NsaXAgPSAoY2xpcFdpZHRoICYmIGNsaXBIZWlnaHQpIHx8IGNsaXBGdW5jLFxuICAgICAgICBjbGlwWCxcbiAgICAgICAgY2xpcFk7XG5cbiAgICAgIGlmIChoYXNDbGlwICYmIGxheWVyKSB7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApO1xuICAgICAgICB2YXIgbSA9IHRyYW5zZm9ybS5nZXRNYXRyaXgoKTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmIChjbGlwRnVuYykge1xuICAgICAgICAgIGNsaXBGdW5jLmNhbGwodGhpcywgY29udGV4dCwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpcFggPSB0aGlzLmdldENsaXBYKCk7XG4gICAgICAgICAgY2xpcFkgPSB0aGlzLmdldENsaXBZKCk7XG4gICAgICAgICAgY29udGV4dC5yZWN0KGNsaXBYLCBjbGlwWSwgY2xpcFdpZHRoLCBjbGlwSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgICAgbSA9IHRyYW5zZm9ybVxuICAgICAgICAgIC5jb3B5KClcbiAgICAgICAgICAuaW52ZXJ0KClcbiAgICAgICAgICAuZ2V0TWF0cml4KCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgY2hpbGRbZHJhd01ldGhvZF0oY2FudmFzLCB0b3AsIGNhY2hpbmcsIHNraXBCdWZmZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNDbGlwKSB7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdWxkRHJhd0hpdDogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgICB2YXIgZGQgPSBLb252YS5ERDtcbiAgICAgIHZhciBsYXllclVuZGVyRHJhZyA9XG4gICAgICAgIGRkICYmXG4gICAgICAgIEtvbnZhLmlzRHJhZ2dpbmcoKSAmJlxuICAgICAgICBLb252YS5ERC5hbmltLmdldExheWVycygpLmluZGV4T2YobGF5ZXIpICE9PSAtMTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjYW52YXMgJiYgY2FudmFzLmlzQ2FjaGUpIHx8XG4gICAgICAgIChsYXllciAmJlxuICAgICAgICAgIGxheWVyLmhpdEdyYXBoRW5hYmxlZCgpICYmXG4gICAgICAgICAgdGhpcy5pc1Zpc2libGUoKSAmJlxuICAgICAgICAgICFsYXllclVuZGVyRHJhZylcbiAgICAgICk7XG4gICAgfSxcbiAgICBnZXRDbGllbnRSZWN0OiBmdW5jdGlvbihhdHRycykge1xuICAgICAgYXR0cnMgPSBhdHRycyB8fCB7fTtcbiAgICAgIHZhciBza2lwVHJhbnNmb3JtID0gYXR0cnMuc2tpcFRyYW5zZm9ybTtcbiAgICAgIHZhciByZWxhdGl2ZVRvID0gYXR0cnMucmVsYXRpdmVUbztcblxuICAgICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFk7XG4gICAgICB2YXIgc2VsZlJlY3QgPSB7XG4gICAgICAgIHg6IEluZmluaXR5LFxuICAgICAgICB5OiBJbmZpbml0eSxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAvLyBza2lwIGludmlzaWJsZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWNoaWxkLmdldFZpc2libGUoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN0ID0gY2hpbGQuZ2V0Q2xpZW50UmVjdCh7XG4gICAgICAgICAgcmVsYXRpdmVUbzogdGhhdCxcbiAgICAgICAgICBza2lwU2hhZG93OiBhdHRycy5za2lwU2hhZG93XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNraXAgaW52aXNpYmxlIGNoaWxkcmVuIChsaWtlIGVtcHR5IGdyb3VwcylcbiAgICAgICAgaWYgKHJlY3Qud2lkdGggPT09IDAgJiYgcmVjdC5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluWCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gaW5pdGlhbCB2YWx1ZSBmb3IgZmlyc3QgY2hpbGRcbiAgICAgICAgICBtaW5YID0gcmVjdC54O1xuICAgICAgICAgIG1pblkgPSByZWN0Lnk7XG4gICAgICAgICAgbWF4WCA9IHJlY3QueCArIHJlY3Qud2lkdGg7XG4gICAgICAgICAgbWF4WSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCByZWN0LngpO1xuICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCByZWN0LnkpO1xuICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCByZWN0LnggKyByZWN0LndpZHRoKTtcbiAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gaWYgY2hpbGQgaXMgZ3JvdXAgd2UgbmVlZCB0byBtYWtlIHN1cmUgaXQgaGFzIHZpc2libGUgc2hhcGVzIGluc2lkZVxuICAgICAgdmFyIHNoYXBlcyA9IHRoaXMuZmluZCgnU2hhcGUnKTtcbiAgICAgIHZhciBoYXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV07XG4gICAgICAgIGlmIChzaGFwZS5faXNWaXNpYmxlKHRoaXMpKSB7XG4gICAgICAgICAgaGFzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1Zpc2libGUpIHtcbiAgICAgICAgc2VsZlJlY3QgPSB7XG4gICAgICAgICAgeDogbWluWCxcbiAgICAgICAgICB5OiBtaW5ZLFxuICAgICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmUmVjdCA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICghc2tpcFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRSZWN0KHNlbGZSZWN0LCByZWxhdGl2ZVRvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmUmVjdDtcbiAgICB9XG4gIH0pO1xuXG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkNvbnRhaW5lciwgS29udmEuTm9kZSk7XG4gIC8vIGRlcHJlY2F0ZWQgbWV0aG9kc1xuICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmdldCA9IEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZmluZDtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwJywgW1xuICAgICd4JyxcbiAgICAneScsXG4gICAgJ3dpZHRoJyxcbiAgICAnaGVpZ2h0J1xuICBdKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgY2xpcFxuICAgKiBAbWV0aG9kXG4gICAqIEBuYW1lIGNsaXBcbiAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNsaXBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAueFxuICAgKiBAcGFyYW0ge051bWJlcn0gY2xpcC55XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjbGlwLndpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjbGlwLmhlaWdodFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgY2xpcFxuICAgKiB2YXIgY2xpcCA9IGNvbnRhaW5lci5jbGlwKCk7XG4gICAqXG4gICAqIC8vIHNldCBjbGlwXG4gICAqIGNvbnRhaW5lci5zZXRDbGlwKHtcbiAgICogICB4OiAyMCxcbiAgICogICB5OiAyMCxcbiAgICogICB3aWR0aDogMjAsXG4gICAqICAgaGVpZ2h0OiAyMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuQ29udGFpbmVyLFxuICAgICdjbGlwWCcsXG4gICAgdW5kZWZpbmVkLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgY2xpcCB4XG4gICAqIEBuYW1lIGNsaXBYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNsaXAgeFxuICAgKiB2YXIgY2xpcFggPSBjb250YWluZXIuY2xpcFgoKTtcbiAgICpcbiAgICogLy8gc2V0IGNsaXAgeFxuICAgKiBjb250YWluZXIuY2xpcFgoMTApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Db250YWluZXIsXG4gICAgJ2NsaXBZJyxcbiAgICB1bmRlZmluZWQsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBjbGlwIHlcbiAgICogQG5hbWUgY2xpcFlcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgY2xpcCB5XG4gICAqIHZhciBjbGlwWSA9IGNvbnRhaW5lci5jbGlwWSgpO1xuICAgKlxuICAgKiAvLyBzZXQgY2xpcCB5XG4gICAqIGNvbnRhaW5lci5jbGlwWSgxMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLkNvbnRhaW5lcixcbiAgICAnY2xpcFdpZHRoJyxcbiAgICB1bmRlZmluZWQsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBjbGlwIHdpZHRoXG4gICAqIEBuYW1lIGNsaXBXaWR0aFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgY2xpcCB3aWR0aFxuICAgKiB2YXIgY2xpcFdpZHRoID0gY29udGFpbmVyLmNsaXBXaWR0aCgpO1xuICAgKlxuICAgKiAvLyBzZXQgY2xpcCB3aWR0aFxuICAgKiBjb250YWluZXIuY2xpcFdpZHRoKDEwMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLkNvbnRhaW5lcixcbiAgICAnY2xpcEhlaWdodCcsXG4gICAgdW5kZWZpbmVkLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgY2xpcCBoZWlnaHRcbiAgICogQG5hbWUgY2xpcEhlaWdodFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNsaXAgaGVpZ2h0XG4gICAqIHZhciBjbGlwSGVpZ2h0ID0gY29udGFpbmVyLmNsaXBIZWlnaHQoKTtcbiAgICpcbiAgICogLy8gc2V0IGNsaXAgaGVpZ2h0XG4gICAqIGNvbnRhaW5lci5jbGlwSGVpZ2h0KDEwMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBGdW5jJyk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGNsaXAgZnVuY3Rpb25cbiAgICogQG5hbWUgY2xpcEZ1bmNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBjbGlwIGZ1bmN0aW9uXG4gICAqIHZhciBjbGlwRnVuY3Rpb24gPSBjb250YWluZXIuY2xpcEZ1bmMoKTtcbiAgICpcbiAgICogLy8gc2V0IGNsaXAgaGVpZ2h0XG4gICAqIGNvbnRhaW5lci5jbGlwRnVuYyhmdW5jdGlvbihjdHgpIHtcbiAgICogICBjdHgucmVjdCgwLCAwLCAxMDAsIDEwMCk7XG4gICAqIH0pO1xuICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQ29udGFpbmVyKTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBIQVNfU0hBRE9XID0gJ2hhc1NoYWRvdyc7XG4gIHZhciBTSEFET1dfUkdCQSA9ICdzaGFkb3dSR0JBJztcblxuICBmdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG4gIGZ1bmN0aW9uIF9zdHJva2VGdW5jKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9XG4gIGZ1bmN0aW9uIF9maWxsRnVuY0hpdChjb250ZXh0KSB7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cbiAgZnVuY3Rpb24gX3N0cm9rZUZ1bmNIaXQoY29udGV4dCkge1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xlYXJIYXNTaGFkb3dDYWNoZSgpIHtcbiAgICB0aGlzLl9jbGVhckNhY2hlKEhBU19TSEFET1cpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsZWFyR2V0U2hhZG93UkdCQUNhY2hlKCkge1xuICAgIHRoaXMuX2NsZWFyQ2FjaGUoU0hBRE9XX1JHQkEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoYXBlIGNvbnN0cnVjdG9yLiAgU2hhcGVzIGFyZSBwcmltaXRpdmUgb2JqZWN0cyBzdWNoIGFzIHJlY3RhbmdsZXMsXG4gICAqICBjaXJjbGVzLCB0ZXh0LCBsaW5lcywgZXRjLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBhdWdtZW50cyBLb252YS5Ob2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBjdXN0b21TaGFwZSA9IG5ldyBLb252YS5TaGFwZSh7XG4gICAqICAgeDogNSxcbiAgICogICB5OiAxMCxcbiAgICogICBmaWxsOiAncmVkJyxcbiAgICogICAvLyBhIEtvbnZhLkNhbnZhcyByZW5kZXJlciBpcyBwYXNzZWQgaW50byB0aGUgc2NlbmVGdW5jIGZ1bmN0aW9uXG4gICAqICAgc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0LCBzaGFwZSkge1xuICAgKiAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICogICAgIGNvbnRleHQubW92ZVRvKDIwMCwgNTApO1xuICAgKiAgICAgY29udGV4dC5saW5lVG8oNDIwLCA4MCk7XG4gICAqICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oMzAwLCAxMDAsIDI2MCwgMTcwKTtcbiAgICogICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAqICAgICAvLyBLb252YSBzcGVjaWZpYyBtZXRob2RcbiAgICogICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHNoYXBlKTtcbiAgICogICB9XG4gICAqfSk7XG4gICAqL1xuICBLb252YS5TaGFwZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLlNoYXBlLCB7XG4gICAgX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMubm9kZVR5cGUgPSAnU2hhcGUnO1xuICAgICAgdGhpcy5fZmlsbEZ1bmMgPSBfZmlsbEZ1bmM7XG4gICAgICB0aGlzLl9zdHJva2VGdW5jID0gX3N0cm9rZUZ1bmM7XG4gICAgICB0aGlzLl9maWxsRnVuY0hpdCA9IF9maWxsRnVuY0hpdDtcbiAgICAgIHRoaXMuX3N0cm9rZUZ1bmNIaXQgPSBfc3Ryb2tlRnVuY0hpdDtcblxuICAgICAgLy8gc2V0IGNvbG9yS2V5XG4gICAgICB2YXIgc2hhcGVzID0gS29udmEuc2hhcGVzO1xuICAgICAgdmFyIGtleTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAga2V5ID0gS29udmEuVXRpbC5nZXRSYW5kb21Db2xvcigpO1xuICAgICAgICBpZiAoa2V5ICYmICEoa2V5IGluIHNoYXBlcykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbG9yS2V5ID0ga2V5O1xuICAgICAgc2hhcGVzW2tleV0gPSB0aGlzO1xuXG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5Ob2RlLmNhbGwodGhpcywgY29uZmlnKTtcblxuICAgICAgdGhpcy5vbihcbiAgICAgICAgJ3NoYWRvd0NvbG9yQ2hhbmdlLmtvbnZhIHNoYWRvd0JsdXJDaGFuZ2Uua29udmEgc2hhZG93T2Zmc2V0Q2hhbmdlLmtvbnZhIHNoYWRvd09wYWNpdHlDaGFuZ2Uua29udmEgc2hhZG93RW5hYmxlZENoYW5nZS5rb252YScsXG4gICAgICAgIF9jbGVhckhhc1NoYWRvd0NhY2hlXG4gICAgICApO1xuXG4gICAgICB0aGlzLm9uKFxuICAgICAgICAnc2hhZG93Q29sb3JDaGFuZ2Uua29udmEgc2hhZG93T3BhY2l0eUNoYW5nZS5rb252YSBzaGFkb3dFbmFibGVkQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgX2NsZWFyR2V0U2hhZG93UkdCQUNhY2hlXG4gICAgICApO1xuICAgIH0sXG4gICAgaGFzQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGNhbnZhcyBjb250ZXh0IHRpZWQgdG8gdGhlIGxheWVyXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuQ29udGV4dH1cbiAgICAgKi9cbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExheWVyKCkuZ2V0Q29udGV4dCgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGNhbnZhcyByZW5kZXJlciB0aWVkIHRvIHRoZSBsYXllci4gIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgYSBjYW52YXMgcmVuZGVyZXIsIG5vdCBhIGNhbnZhcyBlbGVtZW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuQ2FudmFzfVxuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMYXllcigpLmdldENhbnZhcygpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIHNoYWRvdyB3aWxsIGJlIHJlbmRlcmVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEhBU19TSEFET1csIHRoaXMuX2hhc1NoYWRvdyk7XG4gICAgfSxcbiAgICBfaGFzU2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuZ2V0U2hhZG93RW5hYmxlZCgpICYmXG4gICAgICAgICh0aGlzLmdldFNoYWRvd09wYWNpdHkoKSAhPT0gMCAmJlxuICAgICAgICAgICEhKFxuICAgICAgICAgICAgdGhpcy5nZXRTaGFkb3dDb2xvcigpIHx8XG4gICAgICAgICAgICB0aGlzLmdldFNoYWRvd0JsdXIoKSB8fFxuICAgICAgICAgICAgdGhpcy5nZXRTaGFkb3dPZmZzZXRYKCkgfHxcbiAgICAgICAgICAgIHRoaXMuZ2V0U2hhZG93T2Zmc2V0WSgpXG4gICAgICAgICAgKSlcbiAgICAgICk7XG4gICAgfSxcbiAgICBnZXRTaGFkb3dSR0JBOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShTSEFET1dfUkdCQSwgdGhpcy5fZ2V0U2hhZG93UkdCQSk7XG4gICAgfSxcbiAgICBfZ2V0U2hhZG93UkdCQTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5oYXNTaGFkb3coKSkge1xuICAgICAgICB2YXIgcmdiYSA9IEtvbnZhLlV0aWwuY29sb3JUb1JHQkEodGhpcy5zaGFkb3dDb2xvcigpKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAncmdiYSgnICtcbiAgICAgICAgICByZ2JhLnIgK1xuICAgICAgICAgICcsJyArXG4gICAgICAgICAgcmdiYS5nICtcbiAgICAgICAgICAnLCcgK1xuICAgICAgICAgIHJnYmEuYiArXG4gICAgICAgICAgJywnICtcbiAgICAgICAgICByZ2JhLmEgKiAodGhpcy5nZXRTaGFkb3dPcGFjaXR5KCkgfHwgMSkgK1xuICAgICAgICAgICcpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc2hhcGUgd2lsbCBiZSBmaWxsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEhKFxuICAgICAgICB0aGlzLmdldEZpbGwoKSB8fFxuICAgICAgICB0aGlzLmdldEZpbGxQYXR0ZXJuSW1hZ2UoKSB8fFxuICAgICAgICB0aGlzLmdldEZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKSB8fFxuICAgICAgICB0aGlzLmdldEZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHNoYXBlIHdpbGwgYmUgc3Ryb2tlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuc3Ryb2tlRW5hYmxlZCgpICYmXG4gICAgICAgICEhKHRoaXMuc3Ryb2tlKCkgfHwgdGhpcy5nZXRTdHJva2VMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKSlcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCByYWRpYWwgZ3JhZGllbnRcbiAgICAgICAgLy8gdGhpcy5nZXRTdHJva2VSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRldGVybWluZXMgaWYgcG9pbnQgaXMgaW4gdGhlIHNoYXBlLCByZWdhcmRsZXNzIGlmIG90aGVyIHNoYXBlcyBhcmUgb24gdG9wIG9mIGl0LiAgTm90ZTogYmVjYXVzZVxuICAgICAqICB0aGlzIG1ldGhvZCBjbGVhcnMgYSB0ZW1wb3JhcnkgY2FudmFzIGFuZCB0aGVuIHJlZHJhd3MgdGhlIHNoYXBlLCBpdCBwZXJmb3JtcyB2ZXJ5IHBvb3JseSBpZiBleGVjdXRlZCBtYW55IHRpbWVzXG4gICAgICogIGNvbnNlY3V0aXZlbHkuICBQbGVhc2UgdXNlIHRoZSB7QGxpbmsgS29udmEuU3RhZ2UjZ2V0SW50ZXJzZWN0aW9ufSBtZXRob2QgaWYgYXQgYWxsIHBvc3NpYmxlXG4gICAgICogIGJlY2F1c2UgaXQgcGVyZm9ybXMgbXVjaCBiZXR0ZXJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50LnlcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpLFxuICAgICAgICBidWZmZXJIaXRDYW52YXMgPSBzdGFnZS5idWZmZXJIaXRDYW52YXMsXG4gICAgICAgIHA7XG5cbiAgICAgIGJ1ZmZlckhpdENhbnZhcy5nZXRDb250ZXh0KCkuY2xlYXIoKTtcbiAgICAgIHRoaXMuZHJhd0hpdChidWZmZXJIaXRDYW52YXMpO1xuICAgICAgcCA9IGJ1ZmZlckhpdENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YShcbiAgICAgICAgTWF0aC5yb3VuZChwb2ludC54KSxcbiAgICAgICAgTWF0aC5yb3VuZChwb2ludC55KSxcbiAgICAgICAgMSxcbiAgICAgICAgMVxuICAgICAgKS5kYXRhO1xuICAgICAgcmV0dXJuIHBbM10gPiAwO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kcyBOb2RlLnByb3RvdHlwZS5kZXN0cm95XG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICBkZWxldGUgS29udmEuc2hhcGVzW3RoaXMuY29sb3JLZXldO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfdXNlQnVmZmVyQ2FudmFzOiBmdW5jdGlvbihjYWNoaW5nKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoIWNhY2hpbmcgJiZcbiAgICAgICAgICAodGhpcy5wZXJmZWN0RHJhd0VuYWJsZWQoKSAmJlxuICAgICAgICAgICAgdGhpcy5nZXRBYnNvbHV0ZU9wYWNpdHkoKSAhPT0gMSAmJlxuICAgICAgICAgICAgdGhpcy5oYXNGaWxsKCkgJiZcbiAgICAgICAgICAgIHRoaXMuaGFzU3Ryb2tlKCkgJiZcbiAgICAgICAgICAgIHRoaXMuZ2V0U3RhZ2UoKSkpIHx8XG4gICAgICAgICh0aGlzLnBlcmZlY3REcmF3RW5hYmxlZCgpICYmXG4gICAgICAgICAgdGhpcy5oYXNTaGFkb3coKSAmJlxuICAgICAgICAgIHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDEgJiZcbiAgICAgICAgICB0aGlzLmhhc0ZpbGwoKSAmJlxuICAgICAgICAgIHRoaXMuaGFzU3Ryb2tlKCkgJiZcbiAgICAgICAgICB0aGlzLmdldFN0YWdlKCkpXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHNlbGYgcmVjdGFuZ2xlICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSBvZiBzaGFwZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBhcmUgbm90IHRha2VuIGludG8gYWNjb3VudCB0cmFuc2Zvcm1hdGlvbiBhbmQgc3R5bGVzLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH0gcmVjdCB3aXRoIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBwcm9wZXJ0aWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHJlY3QuZ2V0U2VsZlJlY3QoKTsgIC8vIHJldHVybiB7eDowLCB5OjAsIHdpZHRoOnJlY3Qud2lkdGgoKSwgaGVpZ2h0OnJlY3QuaGVpZ2h0KCl9XG4gICAgICogY2lyY2xlLmdldFNlbGZSZWN0KCk7ICAvLyByZXR1cm4ge3g6IC0gY2lyY2xlLndpZHRoKCkgLyAyLCB5OiAtIGNpcmNsZS5oZWlnaHQoKSAvIDIsIHdpZHRoOmNpcmNsZS53aWR0aCgpLCBoZWlnaHQ6Y2lyY2xlLmhlaWdodCgpfVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMuX2NlbnRyb2lkID8gTWF0aC5yb3VuZCgtc2l6ZS53aWR0aCAvIDIpIDogMCxcbiAgICAgICAgeTogdGhpcy5fY2VudHJvaWQgPyBNYXRoLnJvdW5kKC1zaXplLmhlaWdodCAvIDIpIDogMCxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRDbGllbnRSZWN0OiBmdW5jdGlvbihhdHRycykge1xuICAgICAgYXR0cnMgPSBhdHRycyB8fCB7fTtcbiAgICAgIHZhciBza2lwVHJhbnNmb3JtID0gYXR0cnMuc2tpcFRyYW5zZm9ybTtcblxuICAgICAgdmFyIHJlbGF0aXZlVG8gPSBhdHRycy5yZWxhdGl2ZVRvO1xuXG4gICAgICB2YXIgZmlsbFJlY3QgPSB0aGlzLmdldFNlbGZSZWN0KCk7XG5cbiAgICAgIHZhciBzdHJva2VXaWR0aCA9ICh0aGlzLmhhc1N0cm9rZSgpICYmIHRoaXMuc3Ryb2tlV2lkdGgoKSkgfHwgMDtcbiAgICAgIHZhciBmaWxsQW5kU3Ryb2tlV2lkdGggPSBmaWxsUmVjdC53aWR0aCArIHN0cm9rZVdpZHRoO1xuICAgICAgdmFyIGZpbGxBbmRTdHJva2VIZWlnaHQgPSBmaWxsUmVjdC5oZWlnaHQgKyBzdHJva2VXaWR0aDtcblxuICAgICAgdmFyIGFwcGx5U2hhZG93ID0gIWF0dHJzLnNraXBTaGFkb3cgJiYgdGhpcy5oYXNTaGFkb3coKTtcbiAgICAgIHZhciBzaGFkb3dPZmZzZXRYID0gYXBwbHlTaGFkb3cgPyB0aGlzLnNoYWRvd09mZnNldFgoKSA6IDA7XG4gICAgICB2YXIgc2hhZG93T2Zmc2V0WSA9IGFwcGx5U2hhZG93ID8gdGhpcy5zaGFkb3dPZmZzZXRZKCkgOiAwO1xuXG4gICAgICB2YXIgcHJlV2lkdGggPSBmaWxsQW5kU3Ryb2tlV2lkdGggKyBNYXRoLmFicyhzaGFkb3dPZmZzZXRYKTtcbiAgICAgIHZhciBwcmVIZWlnaHQgPSBmaWxsQW5kU3Ryb2tlSGVpZ2h0ICsgTWF0aC5hYnMoc2hhZG93T2Zmc2V0WSk7XG5cbiAgICAgIHZhciBibHVyUmFkaXVzID0gKGFwcGx5U2hhZG93ICYmIHRoaXMuc2hhZG93Qmx1cigpKSB8fCAwO1xuXG4gICAgICB2YXIgd2lkdGggPSBwcmVXaWR0aCArIGJsdXJSYWRpdXMgKiAyO1xuICAgICAgdmFyIGhlaWdodCA9IHByZUhlaWdodCArIGJsdXJSYWRpdXMgKiAyO1xuXG4gICAgICAvLyBpZiBzdHJva2UsIGZvciBleGFtcGxlID0gM1xuICAgICAgLy8gd2UgbmVlZCB0byBzZXQgeCB0byAxLjUsIGJ1dCBhZnRlciBNYXRoLnJvdW5kIGl0IHdpbGwgYmUgMlxuICAgICAgLy8gYXMgd2UgaGF2ZSBhZGRpdGlvbmFsIG9mZnNldCB3ZSBuZWVkIHRvIGluY3JlYXNlIHdpZHRoIGFuZCBoZWlnaHQgYnkgMSBwaXhlbFxuICAgICAgdmFyIHJvdW5kaW5nT2Zmc2V0ID0gMDtcbiAgICAgIGlmIChNYXRoLnJvdW5kKHN0cm9rZVdpZHRoIC8gMikgIT09IHN0cm9rZVdpZHRoIC8gMikge1xuICAgICAgICByb3VuZGluZ09mZnNldCA9IDE7XG4gICAgICB9XG4gICAgICB2YXIgcmVjdCA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgcm91bmRpbmdPZmZzZXQsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgcm91bmRpbmdPZmZzZXQsXG4gICAgICAgIHg6XG4gICAgICAgICAgLU1hdGgucm91bmQoc3Ryb2tlV2lkdGggLyAyICsgYmx1clJhZGl1cykgK1xuICAgICAgICAgIE1hdGgubWluKHNoYWRvd09mZnNldFgsIDApICtcbiAgICAgICAgICBmaWxsUmVjdC54LFxuICAgICAgICB5OlxuICAgICAgICAgIC1NYXRoLnJvdW5kKHN0cm9rZVdpZHRoIC8gMiArIGJsdXJSYWRpdXMpICtcbiAgICAgICAgICBNYXRoLm1pbihzaGFkb3dPZmZzZXRZLCAwKSArXG4gICAgICAgICAgZmlsbFJlY3QueVxuICAgICAgfTtcbiAgICAgIGlmICghc2tpcFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRSZWN0KHJlY3QsIHJlbGF0aXZlVG8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfSxcbiAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbiwgdG9wLCBjYWNoaW5nLCBza2lwQnVmZmVyKSB7XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgIGNhbnZhcyA9IGNhbiB8fCBsYXllci5nZXRDYW52YXMoKSxcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgZHJhd0Z1bmMgPSB0aGlzLnNjZW5lRnVuYygpLFxuICAgICAgICBoYXNTaGFkb3cgPSB0aGlzLmhhc1NoYWRvdygpLFxuICAgICAgICBoYXNTdHJva2UgPSB0aGlzLmhhc1N0cm9rZSgpLFxuICAgICAgICBzdGFnZSxcbiAgICAgICAgYnVmZmVyQ2FudmFzLFxuICAgICAgICBidWZmZXJDb250ZXh0O1xuXG4gICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKCkgJiYgIWNhY2hpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoY2FjaGVkQ2FudmFzKSB7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgdGhpcy5fZHJhd0NhY2hlZFNjZW5lQ2FudmFzKGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIWRyYXdGdW5jKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAvLyBpZiBidWZmZXIgY2FudmFzIGlzIG5lZWRlZFxuICAgICAgaWYgKHRoaXMuX3VzZUJ1ZmZlckNhbnZhcyhjYWNoaW5nKSAmJiAhc2tpcEJ1ZmZlcikge1xuICAgICAgICBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgYnVmZmVyQ2FudmFzID0gc3RhZ2UuYnVmZmVyQ2FudmFzO1xuICAgICAgICBidWZmZXJDb250ZXh0ID0gYnVmZmVyQ2FudmFzLmdldENvbnRleHQoKTtcbiAgICAgICAgYnVmZmVyQ29udGV4dC5jbGVhcigpO1xuICAgICAgICBidWZmZXJDb250ZXh0LnNhdmUoKTtcbiAgICAgICAgYnVmZmVyQ29udGV4dC5fYXBwbHlMaW5lSm9pbih0aGlzKTtcbiAgICAgICAgLy8gbGF5ZXIgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIHdlIGFyZSB1c2luZyBjYWNoZSBiZWZvcmUgYWRkaW5nIHRvIGxheWVyXG4gICAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGJ1ZmZlckNvbnRleHQsIHRvcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBidWZmZXJDb250ZXh0LCB0aGlzKTtcbiAgICAgICAgYnVmZmVyQ29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgdmFyIHJhdGlvID0gYnVmZmVyQ2FudmFzLnBpeGVsUmF0aW87XG4gICAgICAgIGlmIChoYXNTaGFkb3cgJiYgIWNhbnZhcy5oaXRDYW52YXMpIHtcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgICAgIGNvbnRleHQuX2FwcGx5U2hhZG93KHRoaXMpO1xuICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICBjb250ZXh0Ll9hcHBseUdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgIGJ1ZmZlckNhbnZhcy5fY2FudmFzLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBidWZmZXJDYW52YXMud2lkdGggLyByYXRpbyxcbiAgICAgICAgICAgIGJ1ZmZlckNhbnZhcy5oZWlnaHQgLyByYXRpb1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgIGNvbnRleHQuX2FwcGx5R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKHRoaXMpO1xuICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgYnVmZmVyQ2FudmFzLl9jYW52YXMsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGJ1ZmZlckNhbnZhcy53aWR0aCAvIHJhdGlvLFxuICAgICAgICAgICAgYnVmZmVyQ2FudmFzLmhlaWdodCAvIHJhdGlvXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgYnVmZmVyIGNhbnZhcyBpcyBub3QgbmVlZGVkXG4gICAgICAgIGNvbnRleHQuX2FwcGx5TGluZUpvaW4odGhpcyk7XG4gICAgICAgIC8vIGxheWVyIG1pZ2h0IGJlIHVuZGVmaW5lZCBpZiB3ZSBhcmUgdXNpbmcgY2FjaGUgYmVmb3JlIGFkZGluZyB0byBsYXllclxuICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG9bMF0sIG9bMV0sIG9bMl0sIG9bM10sIG9bNF0sIG9bNV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTaGFkb3cgJiYgaGFzU3Ryb2tlICYmICFjYW52YXMuaGl0Q2FudmFzKSB7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgLy8gYXBwbHkgc2hhZG93XG4gICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseUdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dC5fYXBwbHlTaGFkb3codGhpcyk7XG5cbiAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQsIHRoaXMpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgIC8vIGlmIHNoYXBlIGhhcyBzdHJva2Ugd2UgbmVlZCB0byByZWRyYXcgc2hhcGVcbiAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBzZWUgYSBzaGFkb3cgdW5kZXIgc3Ryb2tlIChhbmQgb3ZlciBmaWxsKVxuICAgICAgICAgIC8vIGJ1dCBJIHRoaW5rIHRoaXMgaXMgdW5leHBlY3RlZCBiZWhhdmlvclxuICAgICAgICAgIGlmICh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmdldFNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBjb250ZXh0LCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzU2hhZG93ICYmICFjYW52YXMuaGl0Q2FudmFzKSB7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseUdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dC5fYXBwbHlTaGFkb3codGhpcyk7XG4gICAgICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBjb250ZXh0LCB0aGlzKTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZHJhd0hpdDogZnVuY3Rpb24oY2FuLCB0b3AsIGNhY2hpbmcpIHtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgY2FudmFzID0gY2FuIHx8IGxheWVyLmhpdENhbnZhcyxcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgIGRyYXdGdW5jID0gdGhpcy5oaXRGdW5jKCkgfHwgdGhpcy5zY2VuZUZ1bmMoKSxcbiAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICBjYWNoZWRIaXRDYW52YXMgPSBjYWNoZWRDYW52YXMgJiYgY2FjaGVkQ2FudmFzLmhpdDtcblxuICAgICAgaWYgKCF0aGlzLnNob3VsZERyYXdIaXQoY2FudmFzKSAmJiAhY2FjaGluZykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmIChsYXllcikge1xuICAgICAgICBsYXllci5jbGVhckhpdENhY2hlKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FjaGVkSGl0Q2FudmFzKSB7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgdGhpcy5fZHJhd0NhY2hlZEhpdENhbnZhcyhjb250ZXh0KTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFkcmF3RnVuYykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgY29udGV4dC5fYXBwbHlMaW5lSm9pbih0aGlzKTtcbiAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShvWzBdLCBvWzFdLCBvWzJdLCBvWzNdLCBvWzRdLCBvWzVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBjb250ZXh0LCB0aGlzKTtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBkcmF3IGhpdCBncmFwaCB1c2luZyB0aGUgY2FjaGVkIHNjZW5lIGNhbnZhc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBhbHBoYVRocmVzaG9sZCBhbHBoYSBjaGFubmVsIHRocmVzaG9sZCB0aGF0IGRldGVybWluZXMgd2hldGhlciBvciBub3RcbiAgICAgKiAgYSBwaXhlbCBzaG91bGQgYmUgZHJhd24gb250byB0aGUgaGl0IGdyYXBoLiAgTXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1LlxuICAgICAqICBUaGUgZGVmYXVsdCBpcyAwXG4gICAgICogQHJldHVybnMge0tvbnZhLlNoYXBlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogc2hhcGUuY2FjaGUoKTtcbiAgICAgKiBzaGFwZS5kcmF3SGl0RnJvbUNhY2hlKCk7XG4gICAgICovXG4gICAgZHJhd0hpdEZyb21DYWNoZTogZnVuY3Rpb24oYWxwaGFUaHJlc2hvbGQpIHtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSBhbHBoYVRocmVzaG9sZCB8fCAwLFxuICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgIHNjZW5lQ2FudmFzID0gdGhpcy5fZ2V0Q2FjaGVkU2NlbmVDYW52YXMoKSxcbiAgICAgICAgaGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzLmhpdCxcbiAgICAgICAgaGl0Q29udGV4dCA9IGhpdENhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgIGhpdFdpZHRoID0gaGl0Q2FudmFzLmdldFdpZHRoKCksXG4gICAgICAgIGhpdEhlaWdodCA9IGhpdENhbnZhcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgaGl0SW1hZ2VEYXRhLFxuICAgICAgICBoaXREYXRhLFxuICAgICAgICBsZW4sXG4gICAgICAgIHJnYkNvbG9yS2V5LFxuICAgICAgICBpLFxuICAgICAgICBhbHBoYTtcblxuICAgICAgaGl0Q29udGV4dC5jbGVhcigpO1xuICAgICAgaGl0Q29udGV4dC5kcmF3SW1hZ2Uoc2NlbmVDYW52YXMuX2NhbnZhcywgMCwgMCwgaGl0V2lkdGgsIGhpdEhlaWdodCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGhpdEltYWdlRGF0YSA9IGhpdENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGhpdFdpZHRoLCBoaXRIZWlnaHQpO1xuICAgICAgICBoaXREYXRhID0gaGl0SW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgIGxlbiA9IGhpdERhdGEubGVuZ3RoO1xuICAgICAgICByZ2JDb2xvcktleSA9IEtvbnZhLlV0aWwuX2hleFRvUmdiKHRoaXMuY29sb3JLZXkpO1xuXG4gICAgICAgIC8vIHJlcGxhY2Ugbm9uIHRyYW5zcGFyZW50IHBpeGVscyB3aXRoIGNvbG9yIGtleVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgICBhbHBoYSA9IGhpdERhdGFbaSArIDNdO1xuICAgICAgICAgIGlmIChhbHBoYSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgaGl0RGF0YVtpXSA9IHJnYkNvbG9yS2V5LnI7XG4gICAgICAgICAgICBoaXREYXRhW2kgKyAxXSA9IHJnYkNvbG9yS2V5Lmc7XG4gICAgICAgICAgICBoaXREYXRhW2kgKyAyXSA9IHJnYkNvbG9yS2V5LmI7XG4gICAgICAgICAgICBoaXREYXRhW2kgKyAzXSA9IDI1NTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGl0RGF0YVtpICsgM10gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoaXRDb250ZXh0LnB1dEltYWdlRGF0YShoaXRJbWFnZURhdGEsIDAsIDApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBLb252YS5VdGlsLmVycm9yKFxuICAgICAgICAgICdVbmFibGUgdG8gZHJhdyBoaXQgZ3JhcGggZnJvbSBjYWNoZWQgc2NlbmUgY2FudmFzLiAnICsgZS5tZXNzYWdlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlNoYXBlLCBLb252YS5Ob2RlKTtcblxuICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc3Ryb2tlJyxcbiAgICB1bmRlZmluZWQsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXRTdHJpbmdWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHN0cm9rZSBjb2xvclxuICAgKiBAbmFtZSBzdHJva2VcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc3Ryb2tlIGNvbG9yXG4gICAqIHZhciBzdHJva2UgPSBzaGFwZS5zdHJva2UoKTtcbiAgICpcbiAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIGNvbG9yIHN0cmluZ1xuICAgKiBzaGFwZS5zdHJva2UoJ2dyZWVuJyk7XG4gICAqXG4gICAqIC8vIHNldCBzdHJva2UgY29sb3Igd2l0aCBoZXhcbiAgICogc2hhcGUuc3Ryb2tlKCcjMDBmZjAwJyk7XG4gICAqXG4gICAqIC8vIHNldCBzdHJva2UgY29sb3Igd2l0aCByZ2JcbiAgICogc2hhcGUuc3Ryb2tlKCdyZ2IoMCwyNTUsMCknKTtcbiAgICpcbiAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIHJnYmEgYW5kIG1ha2UgaXQgNTAlIG9wYXF1ZVxuICAgKiBzaGFwZS5zdHJva2UoJ3JnYmEoMCwyNTUsMCwwLjUnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ3N0cm9rZVdpZHRoJyxcbiAgICAyLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzdHJva2Ugd2lkdGhcbiAgICogQG5hbWUgc3Ryb2tlV2lkdGhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdHJva2VXaWR0aFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc3Ryb2tlIHdpZHRoXG4gICAqIHZhciBzdHJva2VXaWR0aCA9IHNoYXBlLnN0cm9rZVdpZHRoKCk7XG4gICAqXG4gICAqIC8vIHNldCBzdHJva2Ugd2lkdGhcbiAgICogc2hhcGUuc3Ryb2tlV2lkdGgoKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ3N0cm9rZUhpdEVuYWJsZWQnLFxuICAgIHRydWUsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXRCb29sZWFuVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzdHJva2VIaXRFbmFibGVkIHByb3BlcnR5LiBVc2VmdWwgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICogWW91IG1heSBzZXQgYHNoYXBlLnN0cm9rZUhpdEVuYWJsZWQoZmFsc2UpYC4gSW4gdGhpcyBjYXNlIHN0cm9rZSB3aWxsIGJlIG5vIGRyYXcgb24gaGl0IGNhbnZhcywgc28gaGl0IGFyZWFcbiAgICogb2Ygc2hhcGUgd2lsbCBiZSBkZWNyZWFzZWQgKGJ5IGxpbmVXaWR0aCAvIDIpLiBSZW1lbWJlciB0aGF0IG5vbiBjbG9zZWQgbGluZSB3aXRoIGBzdHJva2VIaXRFbmFibGVkID0gZmFsc2VgXG4gICAqIHdpbGwgYmUgbm90IGRyYXduIG9uIGhpdCBjYW52YXMsIHRoYXQgaXMgbWVhbiBsaW5lIHdpbGwgbm8gdHJpZ2dlciBwb2ludGVyIGV2ZW50cyAobGlrZSBtb3VzZW92ZXIpXG4gICAqIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAbmFtZSBzdHJva2VIaXRFbmFibGVkXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0cm9rZUhpdEVuYWJsZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzdHJva2VIaXRFbmFibGVkXG4gICAqIHZhciBzdHJva2VIaXRFbmFibGVkID0gc2hhcGUuc3Ryb2tlSGl0RW5hYmxlZCgpO1xuICAgKlxuICAgKiAvLyBzZXQgc3Ryb2tlSGl0RW5hYmxlZFxuICAgKiBzaGFwZS5zdHJva2VIaXRFbmFibGVkKCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdwZXJmZWN0RHJhd0VuYWJsZWQnLFxuICAgIHRydWUsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXRCb29sZWFuVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBwZXJmZWN0RHJhd0VuYWJsZWQuIElmIGEgc2hhcGUgaGFzIGZpbGwsIHN0cm9rZSBhbmQgb3BhY2l0eSB5b3UgbWF5IHNldCBgcGVyZmVjdERyYXdFbmFibGVkYCB0byBmYWxzZSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgKiBTZWUgaHR0cDovL2tvbnZhanMuZ2l0aHViLmlvL2RvY3MvcGVyZm9ybWFuY2UvRGlzYWJsZV9QZXJmZWN0X0RyYXcuaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogRGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAqIEBuYW1lIHBlcmZlY3REcmF3RW5hYmxlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBwZXJmZWN0RHJhd0VuYWJsZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBwZXJmZWN0RHJhd0VuYWJsZWRcbiAgICogdmFyIHBlcmZlY3REcmF3RW5hYmxlZCA9IHNoYXBlLnBlcmZlY3REcmF3RW5hYmxlZCgpO1xuICAgKlxuICAgKiAvLyBzZXQgcGVyZmVjdERyYXdFbmFibGVkXG4gICAqIHNoYXBlLnBlcmZlY3REcmF3RW5hYmxlZCgpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCcsXG4gICAgdHJ1ZSxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldEJvb2xlYW5WYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNoYWRvd0ZvclN0cm9rZUVuYWJsZWQuIFVzZWZ1bCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgKiBZb3UgbWF5IHNldCBgc2hhcGUuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZChmYWxzZSlgLiBJbiB0aGlzIGNhc2Ugc3Ryb2tlIHdpbGwgYmUgbm8gZHJhdyBzaGFkb3cgZm9yIHN0cm9rZS5cbiAgICogUmVtZW1iZXIgaWYgeW91IHNldCBgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCA9IGZhbHNlYCBmb3Igbm9uIGNsb3NlZCBsaW5lIC0gdGhhdCBsaW5lIHdpdGggaGF2ZSBubyBzaGFkb3chLlxuICAgKiBEZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICogQG5hbWUgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBzaGFkb3dGb3JTdHJva2VFbmFibGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZFxuICAgKiB2YXIgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCA9IHNoYXBlLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKTtcbiAgICpcbiAgICogLy8gc2V0IHNoYWRvd0ZvclN0cm9rZUVuYWJsZWRcbiAgICogc2hhcGUuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCgpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2xpbmVKb2luJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgbGluZSBqb2luLiAgQ2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGVcbiAgICogIGRlZmF1bHQgaXMgbWl0ZXJcbiAgICogQG5hbWUgbGluZUpvaW5cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lSm9pblxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgbGluZSBqb2luXG4gICAqIHZhciBsaW5lSm9pbiA9IHNoYXBlLmxpbmVKb2luKCk7XG4gICAqXG4gICAqIC8vIHNldCBsaW5lIGpvaW5cbiAgICogc2hhcGUubGluZUpvaW4oJ3JvdW5kJyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnbGluZUNhcCcpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGxpbmUgY2FwLiAgQ2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcXVhcmVcbiAgICogQG5hbWUgbGluZUNhcFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmVDYXBcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGxpbmUgY2FwXG4gICAqIHZhciBsaW5lQ2FwID0gc2hhcGUubGluZUNhcCgpO1xuICAgKlxuICAgKiAvLyBzZXQgbGluZSBjYXBcbiAgICogc2hhcGUubGluZUNhcCgncm91bmQnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzY2VuZUZ1bmMnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzY2VuZSBkcmF3IGZ1bmN0aW9uXG4gICAqIEBuYW1lIHNjZW5lRnVuY1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhd0Z1bmMgZHJhd2luZyBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzY2VuZSBkcmF3IGZ1bmN0aW9uXG4gICAqIHZhciBzY2VuZUZ1bmMgPSBzaGFwZS5zY2VuZUZ1bmMoKTtcbiAgICpcbiAgICogLy8gc2V0IHNjZW5lIGRyYXcgZnVuY3Rpb25cbiAgICogc2hhcGUuc2NlbmVGdW5jKGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICogICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgKiAgIGNvbnRleHQucmVjdCgwLCAwLCB0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpO1xuICAgKiAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAqICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAqIH0pO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2hpdEZ1bmMnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBoaXQgZHJhdyBmdW5jdGlvblxuICAgKiBAbmFtZSBoaXRGdW5jXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmF3RnVuYyBkcmF3aW5nIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGhpdCBkcmF3IGZ1bmN0aW9uXG4gICAqIHZhciBoaXRGdW5jID0gc2hhcGUuaGl0RnVuYygpO1xuICAgKlxuICAgKiAvLyBzZXQgaGl0IGRyYXcgZnVuY3Rpb25cbiAgICogc2hhcGUuaGl0RnVuYyhmdW5jdGlvbihjb250ZXh0KSB7XG4gICAqICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICogICBjb250ZXh0LnJlY3QoMCwgMCwgdGhpcy53aWR0aCgpLCB0aGlzLmhlaWdodCgpKTtcbiAgICogICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgKiAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdkYXNoJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZGFzaCBhcnJheSBmb3Igc3Ryb2tlLlxuICAgKiBAbmFtZSBkYXNoXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXNoXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQGV4YW1wbGVcbiAgICogIC8vIGFwcGx5IGRhc2hlZCBzdHJva2UgdGhhdCBpcyAxMHB4IGxvbmcgYW5kIDUgcGl4ZWxzIGFwYXJ0XG4gICAqICBsaW5lLmRhc2goWzEwLCA1XSk7XG4gICAqICAvLyBhcHBseSBkYXNoZWQgc3Ryb2tlIHRoYXQgaXMgbWFkZSB1cCBvZiBhbHRlcm5hdGluZyBkYXNoZWRcbiAgICogIC8vIGxpbmVzIHRoYXQgYXJlIDEwcHggbG9uZyBhbmQgMjBweCBhcGFydCwgYW5kIGRvdHMgdGhhdCBoYXZlXG4gICAqICAvLyBhIHJhZGl1cyBvZiA1cHggYW5kIGFyZSAyMHB4IGFwYXJ0XG4gICAqICBsaW5lLmRhc2goWzEwLCAyMCwgMC4wMDEsIDIwXSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdkYXNoT2Zmc2V0JyxcbiAgICAwLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBkYXNoIG9mZnNldCBmb3Igc3Ryb2tlLlxuICAgKiBAbmFtZSBkYXNoXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGFzaCBvZmZzZXRcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogIC8vIGFwcGx5IGRhc2hlZCBzdHJva2UgdGhhdCBpcyAxMHB4IGxvbmcgYW5kIDUgcGl4ZWxzIGFwYXJ0IHdpdGggYW4gb2Zmc2V0IG9mIDVweFxuICAgKiAgbGluZS5kYXNoKFsxMCwgNV0pO1xuICAgKiAgbGluZS5kYXNoT2Zmc2V0KDUpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc2hhZG93Q29sb3InLFxuICAgIHVuZGVmaW5lZCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldFN0cmluZ1ZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc2hhZG93IGNvbG9yXG4gICAqIEBuYW1lIHNoYWRvd0NvbG9yXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHNoYWRvdyBjb2xvclxuICAgKiB2YXIgc2hhZG93ID0gc2hhcGUuc2hhZG93Q29sb3IoKTtcbiAgICpcbiAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIGNvbG9yIHN0cmluZ1xuICAgKiBzaGFwZS5zaGFkb3dDb2xvcignZ3JlZW4nKTtcbiAgICpcbiAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIGhleFxuICAgKiBzaGFwZS5zaGFkb3dDb2xvcignIzAwZmYwMCcpO1xuICAgKlxuICAgKiAvLyBzZXQgc2hhZG93IGNvbG9yIHdpdGggcmdiXG4gICAqIHNoYXBlLnNoYWRvd0NvbG9yKCdyZ2IoMCwyNTUsMCknKTtcbiAgICpcbiAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIHJnYmEgYW5kIG1ha2UgaXQgNTAlIG9wYXF1ZVxuICAgKiBzaGFwZS5zaGFkb3dDb2xvcigncmdiYSgwLDI1NSwwLDAuNScpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc2hhZG93Qmx1cicsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc2hhZG93IGJsdXJcbiAgICogQG5hbWUgc2hhZG93Qmx1clxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGJsdXJcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHNoYWRvdyBibHVyXG4gICAqIHZhciBzaGFkb3dCbHVyID0gc2hhcGUuc2hhZG93Qmx1cigpO1xuICAgKlxuICAgKiAvLyBzZXQgc2hhZG93IGJsdXJcbiAgICogc2hhcGUuc2hhZG93Qmx1cigxMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdzaGFkb3dPcGFjaXR5JyxcbiAgICAxLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzaGFkb3cgb3BhY2l0eS4gIG11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcbiAgICogQG5hbWUgc2hhZG93T3BhY2l0eVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wYWNpdHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHNoYWRvdyBvcGFjaXR5XG4gICAqIHZhciBzaGFkb3dPcGFjaXR5ID0gc2hhcGUuc2hhZG93T3BhY2l0eSgpO1xuICAgKlxuICAgKiAvLyBzZXQgc2hhZG93IG9wYWNpdHlcbiAgICogc2hhcGUuc2hhZG93T3BhY2l0eSgwLjUpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dPZmZzZXQnLCBbXG4gICAgJ3gnLFxuICAgICd5J1xuICBdKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzaGFkb3cgb2Zmc2V0XG4gICAqIEBuYW1lIHNoYWRvd09mZnNldFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC55XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzaGFkb3cgb2Zmc2V0XG4gICAqIHZhciBzaGFkb3dPZmZzZXQgPSBzaGFwZS5zaGFkb3dPZmZzZXQoKTtcbiAgICpcbiAgICogLy8gc2V0IHNoYWRvdyBvZmZzZXRcbiAgICogc2hhcGUuc2hhZG93T2Zmc2V0KHtcbiAgICogICB4OiAyMFxuICAgKiAgIHk6IDEwXG4gICAqIH0pO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc2hhZG93T2Zmc2V0WCcsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc2hhZG93IG9mZnNldCB4XG4gICAqIEBuYW1lIHNoYWRvd09mZnNldFhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzaGFkb3cgb2Zmc2V0IHhcbiAgICogdmFyIHNoYWRvd09mZnNldFggPSBzaGFwZS5zaGFkb3dPZmZzZXRYKCk7XG4gICAqXG4gICAqIC8vIHNldCBzaGFkb3cgb2Zmc2V0IHhcbiAgICogc2hhcGUuc2hhZG93T2Zmc2V0WCg1KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ3NoYWRvd09mZnNldFknLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNoYWRvdyBvZmZzZXQgeVxuICAgKiBAbmFtZSBzaGFkb3dPZmZzZXRZXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc2hhZG93IG9mZnNldCB5XG4gICAqIHZhciBzaGFkb3dPZmZzZXRZID0gc2hhcGUuc2hhZG93T2Zmc2V0WSgpO1xuICAgKlxuICAgKiAvLyBzZXQgc2hhZG93IG9mZnNldCB5XG4gICAqIHNoYXBlLnNoYWRvd09mZnNldFkoNSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5JbWFnZScpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBpbWFnZVxuICAgKiBAbmFtZSBmaWxsUGF0dGVybkltYWdlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZSBvYmplY3RcbiAgICogQHJldHVybnMge0ltYWdlfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAqIHZhciBmaWxsUGF0dGVybkltYWdlID0gc2hhcGUuZmlsbFBhdHRlcm5JbWFnZSgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAqIHZhciBpbWFnZU9iaiA9IG5ldyBJbWFnZSgpO1xuICAgKiBpbWFnZU9iai5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICogICBzaGFwZS5maWxsUGF0dGVybkltYWdlKGltYWdlT2JqKTtcbiAgICogfTtcbiAgICogaW1hZ2VPYmouc3JjID0gJ3BhdGgvdG8vaW1hZ2UvanBnJztcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGwnLFxuICAgIHVuZGVmaW5lZCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldFN0cmluZ1ZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBjb2xvclxuICAgKiBAbmFtZSBmaWxsXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgY29sb3JcbiAgICogdmFyIGZpbGwgPSBzaGFwZS5maWxsKCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIGNvbG9yIHdpdGggY29sb3Igc3RyaW5nXG4gICAqIHNoYXBlLmZpbGwoJ2dyZWVuJyk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIGNvbG9yIHdpdGggaGV4XG4gICAqIHNoYXBlLmZpbGwoJyMwMGZmMDAnKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgY29sb3Igd2l0aCByZ2JcbiAgICogc2hhcGUuZmlsbCgncmdiKDAsMjU1LDApJyk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIGNvbG9yIHdpdGggcmdiYSBhbmQgbWFrZSBpdCA1MCUgb3BhcXVlXG4gICAqIHNoYXBlLmZpbGwoJ3JnYmEoMCwyNTUsMCwwLjUnKTtcbiAgICpcbiAgICogLy8gc2hhcGUgd2l0aG91dCBmaWxsXG4gICAqIHNoYXBlLmZpbGwobnVsbCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUGF0dGVyblgnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiB4XG4gICAqIEBuYW1lIGZpbGxQYXR0ZXJuWFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiB4XG4gICAqIHZhciBmaWxsUGF0dGVyblggPSBzaGFwZS5maWxsUGF0dGVyblgoKTtcbiAgICogLy8gc2V0IGZpbGwgcGF0dGVybiB4XG4gICAqIHNoYXBlLmZpbGxQYXR0ZXJuWCgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUGF0dGVyblknLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiB5XG4gICAqIEBuYW1lIGZpbGxQYXR0ZXJuWVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiB5XG4gICAqIHZhciBmaWxsUGF0dGVyblkgPSBzaGFwZS5maWxsUGF0dGVyblkoKTtcbiAgICogLy8gc2V0IGZpbGwgcGF0dGVybiB5XG4gICAqIHNoYXBlLmZpbGxQYXR0ZXJuWSgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcycpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGNvbG9yIHN0b3BzXG4gICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yU3RvcHNcbiAgICogQHJldHVybnMge0FycmF5fSBjb2xvclN0b3BzXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIGxpbmVhciBncmFkaWVudCBjb2xvciBzdG9wc1xuICAgKiB2YXIgY29sb3JTdG9wcyA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKTtcbiAgICpcbiAgICogLy8gY3JlYXRlIGEgbGluZWFyIGdyYWRpZW50IHRoYXQgc3RhcnRzIHdpdGggcmVkLCBjaGFuZ2VzIHRvIGJsdWVcbiAgICogLy8gaGFsZndheSB0aHJvdWdoLCBhbmQgdGhlbiBjaGFuZ2VzIHRvIGdyZWVuXG4gICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoMCwgJ3JlZCcsIDAuNSwgJ2JsdWUnLCAxLCAnZ3JlZW4nKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2VMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IGNvbG9yIHN0b3BzXG4gICAqIEBuYW1lIHN0cm9rZUxpbmVhckdyYWRpZW50Q29sb3JTdG9wc1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtBcnJheX0gY29sb3JTdG9wc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9IGNvbG9yU3RvcHNcbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgY29sb3Igc3RvcHNcbiAgICogdmFyIGNvbG9yU3RvcHMgPSBzaGFwZS5zdHJva2VMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKTtcbiAgICpcbiAgICogLy8gY3JlYXRlIGEgbGluZWFyIGdyYWRpZW50IHRoYXQgc3RhcnRzIHdpdGggcmVkLCBjaGFuZ2VzIHRvIGJsdWVcbiAgICogLy8gaGFsZndheSB0aHJvdWdoLCBhbmQgdGhlbiBjaGFuZ2VzIHRvIGdyZWVuXG4gICAqIHNoYXBlLnN0cm9rZUxpbmVhckdyYWRpZW50Q29sb3JTdG9wcyhbMCwgJ3JlZCcsIDAuNSwgJ2JsdWUnLCAxLCAnZ3JlZW4nXSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1cycsXG4gICAgMFxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHJhZGl1c1xuICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHJhZGl1c1xuICAgKiB2YXIgc3RhcnRSYWRpdXMgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1cygpO1xuICAgKlxuICAgKiAvLyBzZXQgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHJhZGl1c1xuICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1cygwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMnLCAwKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcmFkaXVzXG4gICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgcmFkaWFsIGdyYWRpZW50IGVuZCByYWRpdXNcbiAgICogdmFyIGVuZFJhZGl1cyA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1cygpO1xuICAgKlxuICAgKiAvLyBzZXQgcmFkaWFsIGdyYWRpZW50IGVuZCByYWRpdXNcbiAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzKDEwMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcycpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGNvbG9yIHN0b3BzXG4gICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xvclN0b3BzXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGNvbG9yIHN0b3BzXG4gICAqIHZhciBjb2xvclN0b3BzID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcygpO1xuICAgKlxuICAgKiAvLyBjcmVhdGUgYSByYWRpYWwgZ3JhZGllbnQgdGhhdCBzdGFydHMgd2l0aCByZWQsIGNoYW5nZXMgdG8gYmx1ZVxuICAgKiAvLyBoYWxmd2F5IHRocm91Z2gsIGFuZCB0aGVuIGNoYW5nZXMgdG8gZ3JlZW5cbiAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcygwLCAncmVkJywgMC41LCAnYmx1ZScsIDEsICdncmVlbicpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuUmVwZWF0JywgJ3JlcGVhdCcpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiByZXBlYXQuICBDYW4gYmUgJ3JlcGVhdCcsICdyZXBlYXQteCcsICdyZXBlYXQteScsIG9yICduby1yZXBlYXQnLiAgVGhlIGRlZmF1bHQgaXMgJ3JlcGVhdCdcbiAgICogQG5hbWUgZmlsbFBhdHRlcm5SZXBlYXRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZXBlYXRcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiByZXBlYXRcbiAgICogdmFyIHJlcGVhdCA9IHNoYXBlLmZpbGxQYXR0ZXJuUmVwZWF0KCk7XG4gICAqXG4gICAqIC8vIHJlcGVhdCBwYXR0ZXJuIGluIHggZGlyZWN0aW9uIG9ubHlcbiAgICogc2hhcGUuZmlsbFBhdHRlcm5SZXBlYXQoJ3JlcGVhdC14Jyk7XG4gICAqXG4gICAqIC8vIGRvIG5vdCByZXBlYXQgdGhlIHBhdHRlcm5cbiAgICogc2hhcGUuZmlsbFBhdHRlcm5SZXBlYXQoJ25vIHJlcGVhdCcpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBlbmFibGVkIGZsYWdcbiAgICogQG5hbWUgZmlsbEVuYWJsZWRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgZW5hYmxlZCBmbGFnXG4gICAqIHZhciBmaWxsRW5hYmxlZCA9IHNoYXBlLmZpbGxFbmFibGVkKCk7XG4gICAqXG4gICAqIC8vIGRpc2FibGUgZmlsbFxuICAgKiBzaGFwZS5maWxsRW5hYmxlZChmYWxzZSk7XG4gICAqXG4gICAqIC8vIGVuYWJsZSBmaWxsXG4gICAqIHNoYXBlLmZpbGxFbmFibGVkKHRydWUpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZUVuYWJsZWQnLCB0cnVlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzdHJva2UgZW5hYmxlZCBmbGFnXG4gICAqIEBuYW1lIHN0cm9rZUVuYWJsZWRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHN0cm9rZSBlbmFibGVkIGZsYWdcbiAgICogdmFyIHN0cm9rZUVuYWJsZWQgPSBzaGFwZS5zdHJva2VFbmFibGVkKCk7XG4gICAqXG4gICAqIC8vIGRpc2FibGUgc3Ryb2tlXG4gICAqIHNoYXBlLnN0cm9rZUVuYWJsZWQoZmFsc2UpO1xuICAgKlxuICAgKiAvLyBlbmFibGUgc3Ryb2tlXG4gICAqIHNoYXBlLnN0cm9rZUVuYWJsZWQodHJ1ZSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93RW5hYmxlZCcsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNoYWRvdyBlbmFibGVkIGZsYWdcbiAgICogQG5hbWUgc2hhZG93RW5hYmxlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc2hhZG93IGVuYWJsZWQgZmxhZ1xuICAgKiB2YXIgc2hhZG93RW5hYmxlZCA9IHNoYXBlLnNoYWRvd0VuYWJsZWQoKTtcbiAgICpcbiAgICogLy8gZGlzYWJsZSBzaGFkb3dcbiAgICogc2hhcGUuc2hhZG93RW5hYmxlZChmYWxzZSk7XG4gICAqXG4gICAqIC8vIGVuYWJsZSBzaGFkb3dcbiAgICogc2hhcGUuc2hhZG93RW5hYmxlZCh0cnVlKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdkYXNoRW5hYmxlZCcsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGRhc2ggZW5hYmxlZCBmbGFnXG4gICAqIEBuYW1lIGRhc2hFbmFibGVkXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBkYXNoIGVuYWJsZWQgZmxhZ1xuICAgKiB2YXIgZGFzaEVuYWJsZWQgPSBzaGFwZS5kYXNoRW5hYmxlZCgpO1xuICAgKlxuICAgKiAvLyBkaXNhYmxlIGRhc2hcbiAgICogc2hhcGUuZGFzaEVuYWJsZWQoZmFsc2UpO1xuICAgKlxuICAgKiAvLyBlbmFibGUgZGFzaFxuICAgKiBzaGFwZS5kYXNoRW5hYmxlZCh0cnVlKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2VTY2FsZUVuYWJsZWQnLCB0cnVlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzdHJva2VTY2FsZSBlbmFibGVkIGZsYWdcbiAgICogQG5hbWUgc3Ryb2tlU2NhbGVFbmFibGVkXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzdHJva2Ugc2NhbGUgZW5hYmxlZCBmbGFnXG4gICAqIHZhciBzdHJva2VTY2FsZUVuYWJsZWQgPSBzaGFwZS5zdHJva2VTY2FsZUVuYWJsZWQoKTtcbiAgICpcbiAgICogLy8gZGlzYWJsZSBzdHJva2Ugc2NhbGVcbiAgICogc2hhcGUuc3Ryb2tlU2NhbGVFbmFibGVkKGZhbHNlKTtcbiAgICpcbiAgICogLy8gZW5hYmxlIHN0cm9rZSBzY2FsZVxuICAgKiBzaGFwZS5zdHJva2VTY2FsZUVuYWJsZWQodHJ1ZSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFByaW9yaXR5JywgJ2NvbG9yJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBwcmlvcml0eS4gIGNhbiBiZSBjb2xvciwgcGF0dGVybiwgbGluZWFyLWdyYWRpZW50LCBvciByYWRpYWwtZ3JhZGllbnQuICBUaGUgZGVmYXVsdCBpcyBjb2xvci5cbiAgICogICBUaGlzIGlzIGhhbmR5IGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLlxuICAgKiBAbmFtZSBmaWxsUHJpb3JpdHlcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcmlvcml0eVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBwcmlvcml0eVxuICAgKiB2YXIgZmlsbFByaW9yaXR5ID0gc2hhcGUuZmlsbFByaW9yaXR5KCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIHByaW9yaXR5XG4gICAqIHNoYXBlLmZpbGxQcmlvcml0eSgnbGluZWFyLWdyYWRpZW50Jyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuT2Zmc2V0JywgW1xuICAgICd4JyxcbiAgICAneSdcbiAgXSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIG9mZnNldFxuICAgKiBAbmFtZSBmaWxsUGF0dGVybk9mZnNldFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC55XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gb2Zmc2V0XG4gICAqIHZhciBwYXR0ZXJuT2Zmc2V0ID0gc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXQoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBvZmZzZXRcbiAgICogc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXQoe1xuICAgKiAgIHg6IDIwXG4gICAqICAgeTogMTBcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUGF0dGVybk9mZnNldFgnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBvZmZzZXQgeFxuICAgKiBAbmFtZSBmaWxsUGF0dGVybk9mZnNldFhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHhcbiAgICogdmFyIHBhdHRlcm5PZmZzZXRYID0gc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXRYKCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHhcbiAgICogc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXRYKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxQYXR0ZXJuT2Zmc2V0WScsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB5XG4gICAqIEBuYW1lIGZpbGxQYXR0ZXJuT2Zmc2V0WVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBvZmZzZXQgeVxuICAgKiB2YXIgcGF0dGVybk9mZnNldFkgPSBzaGFwZS5maWxsUGF0dGVybk9mZnNldFkoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBvZmZzZXQgeVxuICAgKiBzaGFwZS5maWxsUGF0dGVybk9mZnNldFkoMTApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVyblNjYWxlJywgW1xuICAgICd4JyxcbiAgICAneSdcbiAgXSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIHNjYWxlXG4gICAqIEBuYW1lIGZpbGxQYXR0ZXJuU2NhbGVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2FsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUueFxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUueVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHNjYWxlXG4gICAqIHZhciBwYXR0ZXJuU2NhbGUgPSBzaGFwZS5maWxsUGF0dGVyblNjYWxlKCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gc2NhbGVcbiAgICogc2hhcGUuZmlsbFBhdHRlcm5TY2FsZSh7XG4gICAqICAgeDogMlxuICAgKiAgIHk6IDJcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUGF0dGVyblNjYWxlWCcsXG4gICAgMSxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIHNjYWxlIHhcbiAgICogQG5hbWUgZmlsbFBhdHRlcm5TY2FsZVhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gc2NhbGUgeFxuICAgKiB2YXIgcGF0dGVyblNjYWxlWCA9IHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGVYKCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gc2NhbGUgeFxuICAgKiBzaGFwZS5maWxsUGF0dGVyblNjYWxlWCgyKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxQYXR0ZXJuU2NhbGVZJyxcbiAgICAxLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gc2NhbGUgeVxuICAgKiBAbmFtZSBmaWxsUGF0dGVyblNjYWxlWVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBzY2FsZSB5XG4gICAqIHZhciBwYXR0ZXJuU2NhbGVZID0gc2hhcGUuZmlsbFBhdHRlcm5TY2FsZVkoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBzY2FsZSB5XG4gICAqIHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGVZKDIpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludFxuICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhcnRQb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb2ludC54XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvaW50LnlcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAqIHZhciBzdGFydFBvaW50ID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCh7XG4gICAqICAgeDogMjBcbiAgICogICB5OiAxMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdzdHJva2VMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAqIEBuYW1lIHN0cm9rZUxpbmVhckdyYWRpZW50U3RhcnRQb2ludFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXJ0UG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb2ludC55XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAqIHZhciBzdGFydFBvaW50ID0gc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50KCk7XG4gICAqXG4gICAqIC8vIHNldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAqIHNoYXBlLnN0cm9rZUxpbmVhckdyYWRpZW50U3RhcnRQb2ludCh7XG4gICAqICAgeDogMjBcbiAgICogICB5OiAxMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYJyxcbiAgICAwXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcbiAgICogdmFyIHN0YXJ0UG9pbnRYID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFgoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcbiAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFgoMjApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50WCcsXG4gICAgMFxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgKiBAbmFtZSBsaW5lYXJMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc3Ryb2tlIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludCB4XG4gICAqIHZhciBzdGFydFBvaW50WCA9IHNoYXBlLnN0cm9rZUxpbmVhckdyYWRpZW50U3RhcnRQb2ludFgoKTtcbiAgICpcbiAgICogLy8gc2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgKiBzaGFwZS5zdHJva2VMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZJyxcbiAgICAwXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxuICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICogdmFyIHN0YXJ0UG9pbnRZID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFkoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFkoMjApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50WScsXG4gICAgMFxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICogQG5hbWUgc3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50WVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxuICAgKiB2YXIgc3RhcnRQb2ludFkgPSBzaGFwZS5zdHJva2VMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZKCk7XG4gICAqXG4gICAqIC8vIHNldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICogc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50WSgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmRQb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAqIHZhciBlbmRQb2ludCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50KCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQoe1xuICAgKiAgIHg6IDIwXG4gICAqICAgeTogMTBcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludCcsXG4gICAgWyd4JywgJ3knXVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAqIEBuYW1lIHN0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmRQb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc3Ryb2tlIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogdmFyIGVuZFBvaW50ID0gc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludCgpO1xuICAgKlxuICAgKiAvLyBzZXQgc3Ryb2tlIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludCh7XG4gICAqICAgeDogMjBcbiAgICogICB5OiAxMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFgnLCAwKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICogdmFyIGVuZFBvaW50WCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WCgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ3N0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnRYJyxcbiAgICAwXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAqIEBuYW1lIHN0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnRYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc3Ryb2tlIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgKiB2YXIgZW5kUG9pbnRYID0gc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludFgoKTtcbiAgICpcbiAgICogLy8gc2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICogc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludFgoMjApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WScsIDApO1xuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFlcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgKiB2YXIgZW5kUG9pbnRZID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZKCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFkoMjApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludFknLFxuICAgIDBcbiAgKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgc3Ryb2tlIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgKiBAbmFtZSBzdHJva2VMaW5lYXJHcmFkaWVudEVuZFBvaW50WVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHlcbiAgICogdmFyIGVuZFBvaW50WSA9IHNoYXBlLnN0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnRZKCk7XG4gICAqXG4gICAqIC8vIHNldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAqIHNoYXBlLnN0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnRZKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50JyxcbiAgICBbJ3gnLCAneSddXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXJ0UG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb2ludC55XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludFxuICAgKiB2YXIgc3RhcnRQb2ludCA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoe1xuICAgKiAgIHg6IDIwXG4gICAqICAgeTogMTBcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCcsXG4gICAgMFxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB4XG4gICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgKiB2YXIgc3RhcnRQb2ludFggPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WScsXG4gICAgMFxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxuICAgKiB2YXIgc3RhcnRQb2ludFkgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WSgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxuICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WSgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmRQb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAqIHZhciBlbmRQb2ludCA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50KCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQoe1xuICAgKiAgIHg6IDIwXG4gICAqICAgeTogMTBcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYJywgMCk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAqIHZhciBlbmRQb2ludFggPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFgoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WCgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZJywgMCk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAqIHZhciBlbmRQb2ludFkgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFkoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WSgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5Sb3RhdGlvbicsIDApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAqIEBuYW1lIGZpbGxQYXR0ZXJuUm90YXRpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuICAgKiBAcmV0dXJucyB7S29udmEuU2hhcGV9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gcm90YXRpb25cbiAgICogdmFyIHBhdHRlcm5Sb3RhdGlvbiA9IHNoYXBlLmZpbGxQYXR0ZXJuUm90YXRpb24oKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcGF0dGVybiByb3RhdGlvblxuICAgKiBzaGFwZS5maWxsUGF0dGVyblJvdGF0aW9uKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLlNoYXBlLCB7XG4gICAgZGFzaEFycmF5OiAnZGFzaCcsXG4gICAgZ2V0RGFzaEFycmF5OiAnZ2V0RGFzaCcsXG4gICAgc2V0RGFzaEFycmF5OiAnZ2V0RGFzaCcsXG5cbiAgICBkcmF3RnVuYzogJ3NjZW5lRnVuYycsXG4gICAgZ2V0RHJhd0Z1bmM6ICdnZXRTY2VuZUZ1bmMnLFxuICAgIHNldERyYXdGdW5jOiAnc2V0U2NlbmVGdW5jJyxcblxuICAgIGRyYXdIaXRGdW5jOiAnaGl0RnVuYycsXG4gICAgZ2V0RHJhd0hpdEZ1bmM6ICdnZXRIaXRGdW5jJyxcbiAgICBzZXREcmF3SGl0RnVuYzogJ3NldEhpdEZ1bmMnXG4gIH0pO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5TaGFwZSk7XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBDT05TVEFOVFNcbiAgdmFyIFNUQUdFID0gJ1N0YWdlJyxcbiAgICBTVFJJTkcgPSAnc3RyaW5nJyxcbiAgICBQWCA9ICdweCcsXG4gICAgTU9VU0VPVVQgPSAnbW91c2VvdXQnLFxuICAgIE1PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZScsXG4gICAgTU9VU0VPVkVSID0gJ21vdXNlb3ZlcicsXG4gICAgTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJyxcbiAgICBNT1VTRU1PVkUgPSAnbW91c2Vtb3ZlJyxcbiAgICBNT1VTRURPV04gPSAnbW91c2Vkb3duJyxcbiAgICBNT1VTRVVQID0gJ21vdXNldXAnLFxuICAgIENPTlRFWFRNRU5VID0gJ2NvbnRleHRtZW51JyxcbiAgICBDTElDSyA9ICdjbGljaycsXG4gICAgREJMX0NMSUNLID0gJ2RibGNsaWNrJyxcbiAgICBUT1VDSFNUQVJUID0gJ3RvdWNoc3RhcnQnLFxuICAgIFRPVUNIRU5EID0gJ3RvdWNoZW5kJyxcbiAgICBUQVAgPSAndGFwJyxcbiAgICBEQkxfVEFQID0gJ2RibHRhcCcsXG4gICAgVE9VQ0hNT1ZFID0gJ3RvdWNobW92ZScsXG4gICAgV0hFRUwgPSAnd2hlZWwnLFxuICAgIENPTlRFTlRfTU9VU0VPVVQgPSAnY29udGVudE1vdXNlb3V0JyxcbiAgICBDT05URU5UX01PVVNFT1ZFUiA9ICdjb250ZW50TW91c2VvdmVyJyxcbiAgICBDT05URU5UX01PVVNFTU9WRSA9ICdjb250ZW50TW91c2Vtb3ZlJyxcbiAgICBDT05URU5UX01PVVNFRE9XTiA9ICdjb250ZW50TW91c2Vkb3duJyxcbiAgICBDT05URU5UX01PVVNFVVAgPSAnY29udGVudE1vdXNldXAnLFxuICAgIENPTlRFTlRfQ09OVEVYVE1FTlUgPSAnY29udGVudENvbnRleHRtZW51JyxcbiAgICBDT05URU5UX0NMSUNLID0gJ2NvbnRlbnRDbGljaycsXG4gICAgQ09OVEVOVF9EQkxfQ0xJQ0sgPSAnY29udGVudERibGNsaWNrJyxcbiAgICBDT05URU5UX1RPVUNIU1RBUlQgPSAnY29udGVudFRvdWNoc3RhcnQnLFxuICAgIENPTlRFTlRfVE9VQ0hFTkQgPSAnY29udGVudFRvdWNoZW5kJyxcbiAgICBDT05URU5UX0RCTF9UQVAgPSAnY29udGVudERibHRhcCcsXG4gICAgQ09OVEVOVF9UQVAgPSAnY29udGVudFRhcCcsXG4gICAgQ09OVEVOVF9UT1VDSE1PVkUgPSAnY29udGVudFRvdWNobW92ZScsXG4gICAgQ09OVEVOVF9XSEVFTCA9ICdjb250ZW50V2hlZWwnLFxuICAgIERJViA9ICdkaXYnLFxuICAgIFJFTEFUSVZFID0gJ3JlbGF0aXZlJyxcbiAgICBLT05WQV9DT05URU5UID0gJ2tvbnZhanMtY29udGVudCcsXG4gICAgU1BBQ0UgPSAnICcsXG4gICAgVU5ERVJTQ09SRSA9ICdfJyxcbiAgICBDT05UQUlORVIgPSAnY29udGFpbmVyJyxcbiAgICBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICBFVkVOVFMgPSBbXG4gICAgICBNT1VTRURPV04sXG4gICAgICBNT1VTRU1PVkUsXG4gICAgICBNT1VTRVVQLFxuICAgICAgTU9VU0VPVVQsXG4gICAgICBUT1VDSFNUQVJULFxuICAgICAgVE9VQ0hNT1ZFLFxuICAgICAgVE9VQ0hFTkQsXG4gICAgICBNT1VTRU9WRVIsXG4gICAgICBXSEVFTCxcbiAgICAgIENPTlRFWFRNRU5VXG4gICAgXSxcbiAgICAvLyBjYWNoZWQgdmFyaWFibGVzXG4gICAgZXZlbnRzTGVuZ3RoID0gRVZFTlRTLmxlbmd0aDtcblxuICBmdW5jdGlvbiBhZGRFdmVudChjdHgsIGV2ZW50TmFtZSkge1xuICAgIGN0eC5jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBldmVudE5hbWUsXG4gICAgICBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY3R4W1VOREVSU0NPUkUgKyBldmVudE5hbWVdKGV2dCk7XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YWdlIGNvbnN0cnVjdG9yLiAgQSBzdGFnZSBpcyB1c2VkIHRvIGNvbnRhaW4gbXVsdGlwbGUgbGF5ZXJzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQGF1Z21lbnRzIEtvbnZhLkNvbnRhaW5lclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGNvbmZpZy5jb250YWluZXIgQ29udGFpbmVyIHNlbGVjdG9yIG9yIERPTSBlbGVtZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBzdGFnZSA9IG5ldyBLb252YS5TdGFnZSh7XG4gICAqICAgd2lkdGg6IDUwMCxcbiAgICogICBoZWlnaHQ6IDgwMCxcbiAgICogICBjb250YWluZXI6ICdjb250YWluZXJJZCcgLy8gb3IgXCIjY29udGFpbmVySWRcIiBvciBcIi5jb250YWluZXJDbGFzc1wiXG4gICAqIH0pO1xuICAgKi9cbiAgS29udmEuU3RhZ2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuU3RhZ2UsIHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMubm9kZVR5cGUgPSBTVEFHRTtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLkNvbnRhaW5lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLl9pZCA9IEtvbnZhLmlkQ291bnRlcisrO1xuICAgICAgdGhpcy5fYnVpbGRET00oKTtcbiAgICAgIHRoaXMuX2JpbmRDb250ZW50RXZlbnRzKCk7XG4gICAgICB0aGlzLl9lbmFibGVOZXN0ZWRUcmFuc2Zvcm1zID0gZmFsc2U7XG4gICAgICBLb252YS5zdGFnZXMucHVzaCh0aGlzKTtcbiAgICB9LFxuICAgIF92YWxpZGF0ZUFkZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5nZXRUeXBlKCkgIT09ICdMYXllcicpIHtcbiAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBsYXllcnMgdG8gdGhlIHN0YWdlLicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2V0IGNvbnRhaW5lciBkb20gZWxlbWVudCB3aGljaCBjb250YWlucyB0aGUgc3RhZ2Ugd3JhcHBlciBkaXYgZWxlbWVudFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtEb21FbGVtZW50fSBjb250YWluZXIgY2FuIHBhc3MgaW4gYSBkb20gZWxlbWVudCBvciBpZCBzdHJpbmdcbiAgICAgKi9cbiAgICBzZXRDb250YWluZXI6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBjb250YWluZXIgPT09IFNUUklORykge1xuICAgICAgICBpZiAoY29udGFpbmVyLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNvbnRhaW5lci5zbGljZSgxKTtcbiAgICAgICAgICBjb250YWluZXIgPSBLb252YS5kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSlbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlkO1xuICAgICAgICAgIGlmIChjb250YWluZXIuY2hhckF0KDApICE9PSAnIycpIHtcbiAgICAgICAgICAgIGlkID0gY29udGFpbmVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZCA9IGNvbnRhaW5lci5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGFpbmVyID0gS29udmEuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgdGhyb3cgJ0NhbiBub3QgZmluZCBjb250YWluZXIgaW4gZG9jdW1lbnQgd2l0aCBpZCAnICsgaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEF0dHIoQ09OVEFJTkVSLCBjb250YWluZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzaG91bGREcmF3SGl0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5kcmF3LmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRyYXcgbGF5ZXIgc2NlbmUgZ3JhcGhzXG4gICAgICogQG5hbWUgZHJhd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBkcmF3IGxheWVyIGhpdCBncmFwaHNcbiAgICAgKiBAbmFtZSBkcmF3SGl0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIHNldCBoZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX3Jlc2l6ZURPTSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXQgd2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqL1xuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICB0aGlzLl9yZXNpemVET00oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY2xlYXIgYWxsIGxheWVyc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxheWVycyA9IHRoaXMuY2hpbGRyZW4sXG4gICAgICAgIGxlbiA9IGxheWVycy5sZW5ndGgsXG4gICAgICAgIG47XG5cbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICBsYXllcnNbbl0uY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgICB9XG4gICAgICBvYmouY29udGFpbmVyID0gS29udmEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChESVYpO1xuICAgICAgcmV0dXJuIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLCBvYmopO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZGVzdHJveSBzdGFnZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudDtcbiAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgICBpZiAoY29udGVudCAmJiBLb252YS5VdGlsLl9pc0luRG9jdW1lbnQoY29udGVudCkpIHtcbiAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5yZW1vdmVDaGlsZChjb250ZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IEtvbnZhLnN0YWdlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgS29udmEuc3RhZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBwb2ludGVyIHBvc2l0aW9uIHdoaWNoIGNhbiBiZSBhIHRvdWNoIHBvc2l0aW9uIG9yIG1vdXNlIHBvc2l0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFBvaW50ZXJQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb2ludGVyUG9zO1xuICAgIH0sXG4gICAgZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgc3RhZ2UgY29udGVudCBkaXYgZWxlbWVudCB3aGljaCBoYXMgdGhlXG4gICAgICogIHRoZSBjbGFzcyBuYW1lIFwia29udmFqcy1jb250ZW50XCJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICB9LFxuICAgIF90b0tvbnZhQ2FudmFzOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgdmFyIHggPSBjb25maWcueCB8fCAwLFxuICAgICAgICB5ID0gY29uZmlnLnkgfHwgMCxcbiAgICAgICAgY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICB3aWR0aDogY29uZmlnLndpZHRoIHx8IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICBoZWlnaHQ6IGNvbmZpZy5oZWlnaHQgfHwgdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgICBwaXhlbFJhdGlvOiBjb25maWcucGl4ZWxSYXRpbyB8fCAxXG4gICAgICAgIH0pLFxuICAgICAgICBfY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCkuX2NvbnRleHQsXG4gICAgICAgIGxheWVycyA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICAgIGlmICh4IHx8IHkpIHtcbiAgICAgICAgX2NvbnRleHQudHJhbnNsYXRlKC0xICogeCwgLTEgKiB5KTtcbiAgICAgIH1cblxuICAgICAgbGF5ZXJzLmVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgaWYgKCFsYXllci5pc1Zpc2libGUoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF5ZXJDYW52YXMgPSBsYXllci5fdG9Lb252YUNhbnZhcyhjb25maWcpO1xuICAgICAgICBfY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgbGF5ZXJDYW52YXMuX2NhbnZhcyxcbiAgICAgICAgICB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgbGF5ZXJDYW52YXMuZ2V0V2lkdGgoKSAvIGxheWVyQ2FudmFzLmdldFBpeGVsUmF0aW8oKSxcbiAgICAgICAgICBsYXllckNhbnZhcy5nZXRIZWlnaHQoKSAvIGxheWVyQ2FudmFzLmdldFBpeGVsUmF0aW8oKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2FudmFzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY29udmVydHMgc3RhZ2UgaW50byBhbiBpbWFnZS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcuY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgY29tcG9zaXRlIGhhcyBjb21wbGV0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5taW1lVHlwZV0gY2FuIGJlIFwiaW1hZ2UvcG5nXCIgb3IgXCJpbWFnZS9qcGVnXCIuXG4gICAgICogIFwiaW1hZ2UvcG5nXCIgaXMgdGhlIGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV0geSBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSB3aWR0aCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucXVhbGl0eV0ganBlZyBxdWFsaXR5LiAgSWYgdXNpbmcgYW4gXCJpbWFnZS9qcGVnXCIgbWltZVR5cGUsXG4gICAgICogIHlvdSBjYW4gc3BlY2lmeSB0aGUgcXVhbGl0eSBmcm9tIDAgdG8gMSwgd2hlcmUgMCBpcyB2ZXJ5IHBvb3IgcXVhbGl0eSBhbmQgMVxuICAgICAqICBpcyB2ZXJ5IGhpZ2ggcXVhbGl0eVxuICAgICAqL1xuICAgIHRvSW1hZ2U6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdmFyIGNiID0gY29uZmlnLmNhbGxiYWNrO1xuXG4gICAgICBjb25maWcuY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhVXJsKSB7XG4gICAgICAgIEtvbnZhLlV0aWwuX2dldEltYWdlKGRhdGFVcmwsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgIGNiKGltZyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMudG9EYXRhVVJMKGNvbmZpZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgdmlzaWJsZSBpbnRlcnNlY3Rpb24gc2hhcGUuIFRoaXMgaXMgdGhlIHByZWZlcnJlZFxuICAgICAqICBtZXRob2QgZm9yIGRldGVybWluaW5nIGlmIGEgcG9pbnQgaW50ZXJzZWN0cyBhIHNoYXBlIG9yIG5vdFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgc2hhcGUgPSBzdGFnZS5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0pO1xuICAgICAqIC8vIG9yIGlmIHlvdSBpbnRlcmVzdGVkIGluIHNoYXBlIHBhcmVudDpcbiAgICAgKiB2YXIgZ3JvdXAgPSBzdGFnZS5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0sICdHcm91cCcpO1xuICAgICAqL1xuICAgIGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24ocG9zLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIGxheWVycyA9IHRoaXMuZ2V0Q2hpbGRyZW4oKSxcbiAgICAgICAgbGVuID0gbGF5ZXJzLmxlbmd0aCxcbiAgICAgICAgZW5kID0gbGVuIC0gMSxcbiAgICAgICAgbixcbiAgICAgICAgc2hhcGU7XG5cbiAgICAgIGZvciAobiA9IGVuZDsgbiA+PSAwOyBuLS0pIHtcbiAgICAgICAgc2hhcGUgPSBsYXllcnNbbl0uZ2V0SW50ZXJzZWN0aW9uKHBvcywgc2VsZWN0b3IpO1xuICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBfcmVzaXplRE9NOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgbGF5ZXJzID0gdGhpcy5nZXRDaGlsZHJlbigpLFxuICAgICAgICAgIGxlbiA9IGxheWVycy5sZW5ndGgsXG4gICAgICAgICAgbixcbiAgICAgICAgICBsYXllcjtcblxuICAgICAgICAvLyBzZXQgY29udGVudCBkaW1lbnNpb25zXG4gICAgICAgIHRoaXMuY29udGVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgUFg7XG4gICAgICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBQWDtcblxuICAgICAgICB0aGlzLmJ1ZmZlckNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmJ1ZmZlckhpdENhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vIHNldCBsYXllciBkaW1lbnNpb25zXG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgIGxheWVyID0gbGF5ZXJzW25dO1xuICAgICAgICAgIGxheWVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgbGF5ZXIuZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBhZGQgbGF5ZXIgb3IgbGF5ZXJzIHRvIHN0YWdlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gey4uLktvbnZhLkxheWVyfSBsYXllclxuICAgICAqIEBleGFtcGxlXG4gICAgICogc3RhZ2UuYWRkKGxheWVyMSwgbGF5ZXIyLCBsYXllcjMpO1xuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIGxheWVyKTtcbiAgICAgIGxheWVyLl9zZXRDYW52YXNTaXplKHRoaXMud2lkdGgoKSwgdGhpcy5oZWlnaHQoKSk7XG5cbiAgICAgIC8vIGRyYXcgbGF5ZXIgYW5kIGFwcGVuZCBjYW52YXMgdG8gY29udGFpbmVyXG4gICAgICBsYXllci5kcmF3KCk7XG5cbiAgICAgIGlmIChLb252YS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKGxheWVyLmNhbnZhcy5fY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hhaW5hYmxlXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldFBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldExheWVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhIHtAbGluayBLb252YS5Db2xsZWN0aW9ufSBvZiBsYXllcnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldExheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIH0sXG4gICAgX2JpbmRDb250ZW50RXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghS29udmEuaXNCcm93c2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZXZlbnRzTGVuZ3RoOyBuKyspIHtcbiAgICAgICAgYWRkRXZlbnQodGhpcywgRVZFTlRTW25dKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9tb3VzZW92ZXI6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRU9WRVIsIHsgZXZ0OiBldnQgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfbW91c2VvdXQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IHRoaXMudGFyZ2V0U2hhcGU7XG5cbiAgICAgICAgaWYgKHRhcmdldFNoYXBlICYmICFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICB0YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRU9VVCwgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgICB0YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRUxFQVZFLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9pbnRlclBvcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VPVVQsIHsgZXZ0OiBldnQgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfbW91c2Vtb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxuICAgICAgaWYgKEtvbnZhLlVBLmllTW9iaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaG1vdmUoZXZ0KTtcbiAgICAgIH1cbiAgICAgIC8vIHdvcmthcm91bmQgZmFrZSBtb3VzZW1vdmUgZXZlbnQgaW4gY2hyb21lIGJyb3dzZXIgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE2MTQ2NFxuICAgICAgaWYgKFxuICAgICAgICAodHlwZW9mIGV2dC5tb3ZlbWVudFggIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgdHlwZW9mIGV2dC5tb3ZlbWVudFkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICBldnQubW92ZW1lbnRZID09PSAwICYmXG4gICAgICAgIGV2dC5tb3ZlbWVudFggPT09IDBcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgIHZhciBzaGFwZTtcblxuICAgICAgaWYgKCFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcbiAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhS29udmEuaXNEcmFnZ2luZygpICYmXG4gICAgICAgICAgICAoIXRoaXMudGFyZ2V0U2hhcGUgfHwgdGhpcy50YXJnZXRTaGFwZS5faWQgIT09IHNoYXBlLl9pZClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldFNoYXBlKSB7XG4gICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVVQsIHsgZXZ0OiBldnQgfSwgc2hhcGUpO1xuICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFTEVBVkUsIHsgZXZ0OiBldnQgfSwgc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVkVSLCB7IGV2dDogZXZ0IH0sIHRoaXMudGFyZ2V0U2hhcGUpO1xuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VFTlRFUiwgeyBldnQ6IGV2dCB9LCB0aGlzLnRhcmdldFNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VNT1ZFLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGlmIG5vIHNoYXBlIHdhcyBkZXRlY3RlZCwgY2xlYXIgdGFyZ2V0IHNoYXBlIGFuZCB0cnlcbiAgICAgICAgICAgICAgICAgKiB0byBydW4gbW91c2VvdXQgZnJvbSBwcmV2aW91cyB0YXJnZXQgc2hhcGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAodGhpcy50YXJnZXRTaGFwZSAmJiAhS29udmEuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFT1VULCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRUxFQVZFLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2ZpcmUoTU9VU0VNT1ZFLCB7XG4gICAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRoaXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnRlbnQgZXZlbnRcbiAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX01PVVNFTU9WRSwgeyBldnQ6IGV2dCB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gYWx3YXlzIGNhbGwgcHJldmVudERlZmF1bHQgZm9yIGRlc2t0b3AgZXZlbnRzIGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgLy8gdHJ5IHRvIGRyYWcgYW5kIGRyb3AgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICBpZiAoZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfbW91c2Vkb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxuICAgICAgaWYgKEtvbnZhLlVBLmllTW9iaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaHN0YXJ0KGV2dCk7XG4gICAgICB9XG4gICAgICBpZiAoIUtvbnZhLlVBLm1vYmlsZSkge1xuICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XG5cbiAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgdGhpcy5jbGlja1N0YXJ0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRURPV04sIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZmlyZShNT1VTRURPV04sIHtcbiAgICAgICAgICAgIGV2dDogZXZ0LFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGhpc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29udGVudCBldmVudFxuICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VET1dOLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBhbHdheXMgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3IgZGVza3RvcCBldmVudHMgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgICAvLyB0cnkgdG8gZHJhZyBhbmQgZHJvcCB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICAgIC8vIFRPRE86IGlmIHdlIHByZXZlbnREZWZhdWx0KCkgaXQgd2lsbCBjYW5jZWwgZXZlbnQgZGV0ZWN0aW9uIG91dHNpZGUgb2Ygd2luZG93IGluc2lkZSBpZnJhbWVcbiAgICAgIC8vIGJ1dCB3ZSBuZWVkIGl0IGZvciBiZXR0ZXIgZHJhZyZkcm9wXG4gICAgICAvLyBjYW4gd2UgZGlzYWJsZSBuYXRpdmUgZHJhZyZkcm9wIHNvbWVob3cgZGlmZmVyZW50bHk/XG4gICAgICAvLyBpZiAoZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgIC8vIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgLy8gfVxuICAgIH0sXG4gICAgX21vdXNldXA6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgbW9iaWxlIElFIHRvIGZvcmNlIHRvdWNoIGV2ZW50IHdoZW4gdW5oYW5kbGVkIHBvaW50ZXIgZXZlbnQgZWxldmF0ZXMgaW50byBhIG1vdXNlIGV2ZW50XG4gICAgICBpZiAoS29udmEuVUEuaWVNb2JpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoZW5kKGV2dCk7XG4gICAgICB9XG4gICAgICBpZiAoIUtvbnZhLlVBLm1vYmlsZSkge1xuICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSksXG4gICAgICAgICAgY2xpY2tTdGFydFNoYXBlID0gdGhpcy5jbGlja1N0YXJ0U2hhcGUsXG4gICAgICAgICAgY2xpY2tFbmRTaGFwZSA9IHRoaXMuY2xpY2tFbmRTaGFwZSxcbiAgICAgICAgICBmaXJlRGJsQ2xpY2sgPSBmYWxzZSxcbiAgICAgICAgICBkZCA9IEtvbnZhLkREO1xuXG4gICAgICAgIGlmIChLb252YS5pbkRibENsaWNrV2luZG93KSB7XG4gICAgICAgICAgZmlyZURibENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kYmxUaW1lb3V0KTtcbiAgICAgICAgICAvLyBLb252YS5pbkRibENsaWNrV2luZG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRkIHx8ICFkZC5qdXN0RHJhZ2dlZCkge1xuICAgICAgICAgIC8vIGRvbid0IHNldCBpbkRibENsaWNrV2luZG93IGFmdGVyIGRyYWdnaW5nXG4gICAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IHRydWU7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGJsVGltZW91dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGQpIHtcbiAgICAgICAgICBkZC5qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYmxUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBLb252YS5pbkRibENsaWNrV2luZG93ID0gZmFsc2U7XG4gICAgICAgIH0sIEtvbnZhLmRibENsaWNrV2luZG93KTtcblxuICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgIHRoaXMuY2xpY2tFbmRTaGFwZSA9IHNoYXBlO1xuICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFVVAsIHsgZXZ0OiBldnQgfSk7XG5cbiAgICAgICAgICAvLyBkZXRlY3QgaWYgY2xpY2sgb3IgZG91YmxlIGNsaWNrIG9jY3VycmVkXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgJiZcbiAgICAgICAgICAgIGNsaWNrU3RhcnRTaGFwZSAmJlxuICAgICAgICAgICAgY2xpY2tTdGFydFNoYXBlLl9pZCA9PT0gc2hhcGUuX2lkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShDTElDSywgeyBldnQ6IGV2dCB9KTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBmaXJlRGJsQ2xpY2sgJiZcbiAgICAgICAgICAgICAgY2xpY2tFbmRTaGFwZSAmJlxuICAgICAgICAgICAgICBjbGlja0VuZFNoYXBlLl9pZCA9PT0gc2hhcGUuX2lkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoREJMX0NMSUNLLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9maXJlKE1PVVNFVVAsIHsgZXZ0OiBldnQsIHRhcmdldDogdGhpcywgY3VycmVudFRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgICBpZiAoS29udmEubGlzdGVuQ2xpY2tUYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ0xJQ0ssIHsgZXZ0OiBldnQsIHRhcmdldDogdGhpcywgY3VycmVudFRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmlyZURibENsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlKERCTF9DTElDSywge1xuICAgICAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udGVudCBldmVudHNcbiAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX01PVVNFVVAsIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgIGlmIChLb252YS5saXN0ZW5DbGlja1RhcCkge1xuICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9DTElDSywgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgICBpZiAoZmlyZURibENsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfREJMX0NMSUNLLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEtvbnZhLmxpc3RlbkNsaWNrVGFwID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGFsd2F5cyBjYWxsIHByZXZlbnREZWZhdWx0IGZvciBkZXNrdG9wIGV2ZW50cyBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgIC8vIHRyeSB0byBkcmFnIGFuZCBkcm9wIHRoZSBjYW52YXMgZWxlbWVudFxuICAgICAgaWYgKGV2dC5jYW5jZWxhYmxlKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NvbnRleHRtZW51OiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XG5cbiAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKENPTlRFWFRNRU5VLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmlyZShDT05URVhUTUVOVSwge1xuICAgICAgICAgIGV2dDogZXZ0LFxuICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fZmlyZShDT05URU5UX0NPTlRFWFRNRU5VLCB7IGV2dDogZXZ0IH0pO1xuICAgIH0sXG4gICAgX3RvdWNoc3RhcnQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICB2YXIgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcblxuICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSB0cnVlO1xuXG4gICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICB0aGlzLnRhcFN0YXJ0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoVE9VQ0hTVEFSVCwgeyBldnQ6IGV2dCB9KTtcblxuICAgICAgICAvLyBvbmx5IGNhbGwgcHJldmVudERlZmF1bHQgaWYgdGhlIHNoYXBlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICAgIGlmIChzaGFwZS5pc0xpc3RlbmluZygpICYmIHNoYXBlLnByZXZlbnREZWZhdWx0KCkgJiYgZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmlyZShUT1VDSFNUQVJULCB7XG4gICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBjb250ZW50IGV2ZW50XG4gICAgICB0aGlzLl9maXJlKENPTlRFTlRfVE9VQ0hTVEFSVCwgeyBldnQ6IGV2dCB9KTtcbiAgICB9LFxuICAgIF90b3VjaGVuZDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpLFxuICAgICAgICBmaXJlRGJsQ2xpY2sgPSBmYWxzZTtcblxuICAgICAgaWYgKEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cpIHtcbiAgICAgICAgZmlyZURibENsaWNrID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGJsVGltZW91dCk7XG4gICAgICAgIC8vIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kYmxUaW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYmxUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xuICAgICAgfSwgS29udmEuZGJsQ2xpY2tXaW5kb3cpO1xuXG4gICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShUT1VDSEVORCwgeyBldnQ6IGV2dCB9KTtcblxuICAgICAgICAvLyBkZXRlY3QgaWYgdGFwIG9yIGRvdWJsZSB0YXAgb2NjdXJyZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIEtvbnZhLmxpc3RlbkNsaWNrVGFwICYmXG4gICAgICAgICAgdGhpcy50YXBTdGFydFNoYXBlICYmXG4gICAgICAgICAgc2hhcGUuX2lkID09PSB0aGlzLnRhcFN0YXJ0U2hhcGUuX2lkXG4gICAgICAgICkge1xuICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKFRBUCwgeyBldnQ6IGV2dCB9KTtcblxuICAgICAgICAgIGlmIChmaXJlRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKERCTF9UQVAsIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgY2FsbCBwcmV2ZW50RGVmYXVsdCBpZiB0aGUgc2hhcGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgICAgaWYgKHNoYXBlLmlzTGlzdGVuaW5nKCkgJiYgc2hhcGUucHJldmVudERlZmF1bHQoKSAmJiBldnQuY2FuY2VsYWJsZSkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9maXJlKFRPVUNIRU5ELCB7IGV2dDogZXZ0LCB0YXJnZXQ6IHRoaXMsIGN1cnJlbnRUYXJnZXQ6IHRoaXMgfSk7XG4gICAgICAgIGlmIChLb252YS5saXN0ZW5DbGlja1RhcCkge1xuICAgICAgICAgIHRoaXMuX2ZpcmUoVEFQLCB7IGV2dDogZXZ0LCB0YXJnZXQ6IHRoaXMsIGN1cnJlbnRUYXJnZXQ6IHRoaXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcmVEYmxDbGljaykge1xuICAgICAgICAgIHRoaXMuX2ZpcmUoREJMX1RBUCwge1xuICAgICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0aGlzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvbnRlbnQgZXZlbnRzXG4gICAgICB0aGlzLl9maXJlKENPTlRFTlRfVE9VQ0hFTkQsIHsgZXZ0OiBldnQgfSk7XG4gICAgICBpZiAoS29udmEubGlzdGVuQ2xpY2tUYXApIHtcbiAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX1RBUCwgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgaWYgKGZpcmVEYmxDbGljaykge1xuICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9EQkxfVEFQLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEtvbnZhLmxpc3RlbkNsaWNrVGFwID0gZmFsc2U7XG4gICAgfSxcbiAgICBfdG91Y2htb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgIHNoYXBlO1xuICAgICAgaWYgKCFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcbiAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShUT1VDSE1PVkUsIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgICAgLy8gb25seSBjYWxsIHByZXZlbnREZWZhdWx0IGlmIHRoZSBzaGFwZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAgICAgIGlmIChzaGFwZS5pc0xpc3RlbmluZygpICYmIHNoYXBlLnByZXZlbnREZWZhdWx0KCkgJiYgZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9maXJlKFRPVUNITU9WRSwge1xuICAgICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0aGlzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX1RPVUNITU9WRSwgeyBldnQ6IGV2dCB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChkZCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgS29udmEuaXNEcmFnZ2luZygpICYmXG4gICAgICAgICAgS29udmEuREQubm9kZS5wcmV2ZW50RGVmYXVsdCgpICYmXG4gICAgICAgICAgZXZ0LmNhbmNlbGFibGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF93aGVlbDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xuXG4gICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShXSEVFTCwgeyBldnQ6IGV2dCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZpcmUoV0hFRUwsIHtcbiAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgY3VycmVudFRhcmdldDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9XSEVFTCwgeyBldnQ6IGV2dCB9KTtcbiAgICB9LFxuICAgIF9zZXRQb2ludGVyUG9zaXRpb246IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIGNvbnRlbnRQb3NpdGlvbiA9IHRoaXMuX2dldENvbnRlbnRQb3NpdGlvbigpLFxuICAgICAgICB4ID0gbnVsbCxcbiAgICAgICAgeSA9IG51bGw7XG4gICAgICBldnQgPSBldnQgPyBldnQgOiB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgIC8vIHRvdWNoIGV2ZW50c1xuICAgICAgaWYgKGV2dC50b3VjaGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gY3VycmVudGx5LCBvbmx5IGhhbmRsZSBvbmUgZmluZ2VyXG4gICAgICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHRvdWNoID0gZXZ0LnRvdWNoZXNbMF07XG4gICAgICAgICAgLy8gZ2V0IHRoZSBpbmZvcm1hdGlvbiBmb3IgZmluZ2VyICMxXG4gICAgICAgICAgeCA9IHRvdWNoLmNsaWVudFggLSBjb250ZW50UG9zaXRpb24ubGVmdDtcbiAgICAgICAgICB5ID0gdG91Y2guY2xpZW50WSAtIGNvbnRlbnRQb3NpdGlvbi50b3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdXNlIGV2ZW50c1xuICAgICAgICB4ID0gZXZ0LmNsaWVudFggLSBjb250ZW50UG9zaXRpb24ubGVmdDtcbiAgICAgICAgeSA9IGV2dC5jbGllbnRZIC0gY29udGVudFBvc2l0aW9uLnRvcDtcbiAgICAgIH1cbiAgICAgIGlmICh4ICE9PSBudWxsICYmIHkgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5wb2ludGVyUG9zID0ge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldENvbnRlbnRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgPyB0aGlzLmNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgOiB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0XG4gICAgICB9O1xuICAgIH0sXG4gICAgX2J1aWxkRE9NOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHRoZSBidWZmZXIgY2FudmFzIHBpeGVsIHJhdGlvIG11c3QgYmUgMSBiZWNhdXNlIGl0IGlzIHVzZWQgYXMgYW5cbiAgICAgIC8vIGludGVybWVkaWF0ZSBjYW52YXMgYmVmb3JlIGNvcHlpbmcgdGhlIHJlc3VsdCBvbnRvIGEgc2NlbmUgY2FudmFzLlxuICAgICAgLy8gbm90IHNldHRpbmcgaXQgdG8gMSB3aWxsIHJlc3VsdCBpbiBhbiBvdmVyIGNvbXBlbnNhdGlvblxuICAgICAgdGhpcy5idWZmZXJDYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoKTtcbiAgICAgIHRoaXMuYnVmZmVySGl0Q2FudmFzID0gbmV3IEtvbnZhLkhpdENhbnZhcyh7IHBpeGVsUmF0aW86IDEgfSk7XG5cbiAgICAgIGlmICghS29udmEuaXNCcm93c2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcigpO1xuICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgdGhyb3cgJ1N0YWdlIGhhcyBubyBjb250YWluZXIuIEEgY29udGFpbmVyIGlzIHJlcXVpcmVkLic7XG4gICAgICB9XG4gICAgICAvLyBjbGVhciBjb250ZW50IGluc2lkZSBjb250YWluZXJcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBFTVBUWV9TVFJJTkc7XG5cbiAgICAgIC8vIGNvbnRlbnRcbiAgICAgIHRoaXMuY29udGVudCA9IEtvbnZhLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoRElWKTtcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZS5wb3NpdGlvbiA9IFJFTEFUSVZFO1xuICAgICAgdGhpcy5jb250ZW50LnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICB0aGlzLmNvbnRlbnQuY2xhc3NOYW1lID0gS09OVkFfQ09OVEVOVDtcblxuICAgICAgdGhpcy5jb250ZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcblxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XG5cbiAgICAgIHRoaXMuX3Jlc2l6ZURPTSgpO1xuICAgIH0sXG4gICAgX29uQ29udGVudDogZnVuY3Rpb24odHlwZXNTdHIsIGhhbmRsZXIpIHtcbiAgICAgIHZhciB0eXBlcyA9IHR5cGVzU3RyLnNwbGl0KFNQQUNFKSxcbiAgICAgICAgbGVuID0gdHlwZXMubGVuZ3RoLFxuICAgICAgICBuLFxuICAgICAgICBiYXNlRXZlbnQ7XG5cbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICBiYXNlRXZlbnQgPSB0eXBlc1tuXTtcbiAgICAgICAgdGhpcy5jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZUV2ZW50LCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBjdXJyZW50bHkgY2FjaGUgZnVuY3Rpb24gaXMgbm93IHdvcmtpbmcgZm9yIHN0YWdlLCBiZWNhdXNlIHN0YWdlIGhhcyBubyBpdHMgb3duIGNhbnZhcyBlbGVtZW50XG4gICAgLy8gVE9ETzogbWF5IGJlIGl0IGlzIGJldHRlciB0byBjYWNoZSBhbGwgY2hpbGRyZW4gbGF5ZXJzP1xuICAgIGNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgJ0NhY2hlIGZ1bmN0aW9uIGlzIG5vdCBhbGxvd2VkIGZvciBzdGFnZS4gWW91IG1heSB1c2UgY2FjaGUgb25seSBmb3IgbGF5ZXJzLCBncm91cHMgYW5kIHNoYXBlcy4nXG4gICAgICApO1xuICAgIH0sXG4gICAgY2xlYXJDYWNoZTogZnVuY3Rpb24oKSB7fVxuICB9KTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU3RhZ2UsIEtvbnZhLkNvbnRhaW5lcik7XG5cbiAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuU3RhZ2UsICdjb250YWluZXInKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLlN0YWdlLCAnY29udGFpbmVyJyk7XG5cbiAgLyoqXG4gICAqIGdldCBjb250YWluZXIgRE9NIGVsZW1lbnRcbiAgICogQG5hbWUgY29udGFpbmVyXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgKiBAcmV0dXJucyB7RG9tRWxlbWVudH0gY29udGFpbmVyXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBjb250YWluZXJcbiAgICogdmFyIGNvbnRhaW5lciA9IHN0YWdlLmNvbnRhaW5lcigpO1xuICAgKiAvLyBzZXQgY29udGFpbmVyXG4gICAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICogYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgKiBzdGFnZS5jb250YWluZXIoY29udGFpbmVyKTtcbiAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24oS29udmEpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQmFzZUxheWVyIGNvbnN0cnVjdG9yLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBhdWdtZW50cyBLb252YS5Db250YWluZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xlYXJCZWZvcmVEcmF3XSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudFxuICAgKiB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBlYWNoIGxheWVyIGRyYXcuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNsaXBGdW5jXSBzZXQgY2xpcCBmdW5jXG5cbiAgICovXG4gIEtvbnZhLkJhc2VMYXllciA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5CYXNlTGF5ZXIsIHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMubm9kZVR5cGUgPSAnTGF5ZXInO1xuICAgICAgS29udmEuQ29udGFpbmVyLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICB9LFxuICAgIGNyZWF0ZVBOR1N0cmVhbTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXMuX2NhbnZhcy5jcmVhdGVQTkdTdHJlYW0oKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBsYXllciBjYW52YXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGxheWVyIGhpdCBjYW52YXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRIaXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGl0Q2FudmFzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGxheWVyIGNhbnZhcyBjb250ZXh0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDYW52YXMoKS5nZXRDb250ZXh0KCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjbGVhciBzY2VuZSBhbmQgaGl0IGNhbnZhcyBjb250ZXh0cyB0aWVkIHRvIHRoZSBsYXllclxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYm91bmRzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy5oZWlnaHRdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBsYXllci5jbGVhcigpO1xuICAgICAqIGxheWVyLmNsZWFyKHtcbiAgICAgKiAgIHggOiAwLFxuICAgICAqICAgeSA6IDAsXG4gICAgICogICB3aWR0aCA6IDEwMCxcbiAgICAgKiAgIGhlaWdodCA6IDEwMFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICAgIHRoaXMuZ2V0Q29udGV4dCgpLmNsZWFyKGJvdW5kcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNsZWFySGl0Q2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhID0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLnNldFpJbmRleFxuICAgIHNldFpJbmRleDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFpJbmRleC5jYWxsKHRoaXMsIGluZGV4KTtcbiAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgIGlmIChzdGFnZSkge1xuICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgc3RhZ2UuZ2V0Q2hpbGRyZW4oKS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgc3RhZ2UuY29udGVudC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMsXG4gICAgICAgICAgICBzdGFnZS5nZXRDaGlsZHJlbigpW2luZGV4ICsgMV0uZ2V0Q2FudmFzKCkuX2NhbnZhc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhZ2UuY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5tb3ZlVG9Ub3BcbiAgICBtb3ZlVG9Ub3A6IGZ1bmN0aW9uKCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUubW92ZVRvVG9wLmNhbGwodGhpcyk7XG4gICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICBpZiAoc3RhZ2UpIHtcbiAgICAgICAgc3RhZ2UuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICBzdGFnZS5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5tb3ZlVXBcbiAgICBtb3ZlVXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1vdmVkID0gS29udmEuTm9kZS5wcm90b3R5cGUubW92ZVVwLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIW1vdmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgaWYgKCFzdGFnZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcblxuICAgICAgaWYgKHRoaXMuaW5kZXggPCBzdGFnZS5nZXRDaGlsZHJlbigpLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgc3RhZ2UuY29udGVudC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLFxuICAgICAgICAgIHN0YWdlLmdldENoaWxkcmVuKClbdGhpcy5pbmRleCArIDFdLmdldENhbnZhcygpLl9jYW52YXNcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWdlLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLm1vdmVEb3duXG4gICAgbW92ZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKEtvbnZhLk5vZGUucHJvdG90eXBlLm1vdmVEb3duLmNhbGwodGhpcykpIHtcbiAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICBpZiAoc3RhZ2UpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBzdGFnZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZShcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyxcbiAgICAgICAgICAgIGNoaWxkcmVuW3RoaXMuaW5kZXggKyAxXS5nZXRDYW52YXMoKS5fY2FudmFzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUubW92ZVRvQm90dG9tXG4gICAgbW92ZVRvQm90dG9tOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChLb252YS5Ob2RlLnByb3RvdHlwZS5tb3ZlVG9Cb3R0b20uY2FsbCh0aGlzKSkge1xuICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgIGlmIChzdGFnZSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHN0YWdlLmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgc3RhZ2UuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgIHN0YWdlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLFxuICAgICAgICAgICAgY2hpbGRyZW5bMV0uZ2V0Q2FudmFzKCkuX2NhbnZhc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9jYW52YXMgPSB0aGlzLmdldENhbnZhcygpLl9jYW52YXM7XG5cbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMpO1xuXG4gICAgICBpZiAoX2NhbnZhcyAmJiBfY2FudmFzLnBhcmVudE5vZGUgJiYgS29udmEuVXRpbC5faXNJbkRvY3VtZW50KF9jYW52YXMpKSB7XG4gICAgICAgIF9jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH0sXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX3RvS29udmFDYW52YXM6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgY29uZmlnLndpZHRoID0gY29uZmlnLndpZHRoIHx8IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIGNvbmZpZy5oZWlnaHQgPSBjb25maWcuaGVpZ2h0IHx8IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICBjb25maWcueCA9IGNvbmZpZy54ICE9PSB1bmRlZmluZWQgPyBjb25maWcueCA6IHRoaXMuZ2V0WCgpO1xuICAgICAgY29uZmlnLnkgPSBjb25maWcueSAhPT0gdW5kZWZpbmVkID8gY29uZmlnLnkgOiB0aGlzLmdldFkoKTtcblxuICAgICAgcmV0dXJuIEtvbnZhLk5vZGUucHJvdG90eXBlLl90b0tvbnZhQ2FudmFzLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgd2lkdGggb2YgbGF5ZXIuZ2V0dGVyIHJldHVybiB3aWR0aCBvZiBzdGFnZS4gc2V0dGVyIGRvaW5nIG5vdGhpbmcuXG4gICAgICogaWYgeW91IHdhbnQgY2hhbmdlIHdpZHRoIHVzZSBgc3RhZ2Uud2lkdGgodmFsdWUpO2BcbiAgICAgKiBAbmFtZSB3aWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgd2lkdGggPSBsYXllci53aWR0aCgpO1xuICAgICAqL1xuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0V2lkdGgoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgJ0NhbiBub3QgY2hhbmdlIHdpZHRoIG9mIGxheWVyLiBVc2UgXCJzdGFnZS53aWR0aCh2YWx1ZSlcIiBmdW5jdGlvbiBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGhlaWdodCBvZiBsYXllci5nZXR0ZXIgcmV0dXJuIGhlaWdodCBvZiBzdGFnZS4gc2V0dGVyIGRvaW5nIG5vdGhpbmcuXG4gICAgICogaWYgeW91IHdhbnQgY2hhbmdlIGhlaWdodCB1c2UgYHN0YWdlLmhlaWdodCh2YWx1ZSk7YFxuICAgICAqIEBuYW1lIGhlaWdodFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgaGVpZ2h0ID0gbGF5ZXIuaGVpZ2h0KCk7XG4gICAgICovXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0SGVpZ2h0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgS29udmEuVXRpbC53YXJuKFxuICAgICAgICAnQ2FuIG5vdCBjaGFuZ2UgaGVpZ2h0IG9mIGxheWVyLiBVc2UgXCJzdGFnZS5oZWlnaHQodmFsdWUpXCIgZnVuY3Rpb24gaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH0sXG4gICAgLy8gdGhlIGFwcGx5IHRyYW5zZm9ybSBtZXRob2QgaXMgaGFuZGxlZCBieSB0aGUgTGF5ZXIgYW5kIEZhc3RMYXllciBjbGFzc1xuICAgIC8vIGJlY2F1c2UgaXQgaXMgdXAgdG8gdGhlIGxheWVyIHRvIGRlY2lkZSBpZiBhbiBhYnNvbHV0ZSBvciByZWxhdGl2ZSB0cmFuc2Zvcm1cbiAgICAvLyBzaG91bGQgYmUgdXNlZFxuICAgIF9hcHBseVRyYW5zZm9ybTogZnVuY3Rpb24oc2hhcGUsIGNvbnRleHQsIHRvcCkge1xuICAgICAgdmFyIG0gPSBzaGFwZS5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgY29udGV4dC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgfVxuICB9KTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQmFzZUxheWVyLCBLb252YS5Db250YWluZXIpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkJhc2VMYXllciwgJ2NsZWFyQmVmb3JlRHJhdycsIHRydWUpO1xuICAvKipcbiAgICogZ2V0L3NldCBjbGVhckJlZm9yZURyYXcgZmxhZyB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSBsYXllciBpcyBjbGVhcmVkIG9yIG5vdFxuICAgKiAgYmVmb3JlIGRyYXdpbmdcbiAgICogQG5hbWUgY2xlYXJCZWZvcmVEcmF3XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBjbGVhckJlZm9yZURyYXdcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBjbGVhckJlZm9yZURyYXcgZmxhZ1xuICAgKiB2YXIgY2xlYXJCZWZvcmVEcmF3ID0gbGF5ZXIuY2xlYXJCZWZvcmVEcmF3KCk7XG4gICAqXG4gICAqIC8vIGRpc2FibGUgY2xlYXIgYmVmb3JlIGRyYXdcbiAgICogbGF5ZXIuY2xlYXJCZWZvcmVEcmF3KGZhbHNlKTtcbiAgICpcbiAgICogLy8gZW5hYmxlIGNsZWFyIGJlZm9yZSBkcmF3XG4gICAqIGxheWVyLmNsZWFyQmVmb3JlRHJhdyh0cnVlKTtcbiAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkJhc2VMYXllcik7XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBjb25zdGFudHNcbiAgdmFyIEhBU0ggPSAnIycsXG4gICAgQkVGT1JFX0RSQVcgPSAnYmVmb3JlRHJhdycsXG4gICAgRFJBVyA9ICdkcmF3JyxcbiAgICAvKlxuICAgICAgICAgKiAyIC0gMyAtIDRcbiAgICAgICAgICogfCAgICAgICB8XG4gICAgICAgICAqIDEgLSAwICAgNVxuICAgICAgICAgKiAgICAgICAgIHxcbiAgICAgICAgICogOCAtIDcgLSA2XG4gICAgICAgICAqL1xuICAgIElOVEVSU0VDVElPTl9PRkZTRVRTID0gW1xuICAgICAgeyB4OiAwLCB5OiAwIH0sIC8vIDBcbiAgICAgIHsgeDogLTEsIHk6IC0xIH0sIC8vIDJcbiAgICAgIHsgeDogMSwgeTogLTEgfSwgLy8gNFxuICAgICAgeyB4OiAxLCB5OiAxIH0sIC8vIDZcbiAgICAgIHsgeDogLTEsIHk6IDEgfSAvLyA4XG4gICAgXSxcbiAgICBJTlRFUlNFQ1RJT05fT0ZGU0VUU19MRU4gPSBJTlRFUlNFQ1RJT05fT0ZGU0VUUy5sZW5ndGg7XG5cbiAgLyoqXG4gICAqIExheWVyIGNvbnN0cnVjdG9yLiAgTGF5ZXJzIGFyZSB0aWVkIHRvIHRoZWlyIG93biBjYW52YXMgZWxlbWVudCBhbmQgYXJlIHVzZWRcbiAgICogdG8gY29udGFpbiBncm91cHMgb3Igc2hhcGVzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBhdWdtZW50cyBLb252YS5CYXNlTGF5ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xlYXJCZWZvcmVEcmF3XSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudFxuICAgKiB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBlYWNoIGxheWVyIGRyYXcuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNsaXBGdW5jXSBzZXQgY2xpcCBmdW5jXG5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGxheWVyID0gbmV3IEtvbnZhLkxheWVyKCk7XG4gICAqL1xuICBLb252YS5MYXllciA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuTGF5ZXIsIHtcbiAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB0aGlzLm5vZGVUeXBlID0gJ0xheWVyJztcbiAgICAgIHRoaXMuY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKCk7XG4gICAgICB0aGlzLmhpdENhbnZhcyA9IG5ldyBLb252YS5IaXRDYW52YXMoe1xuICAgICAgICBwaXhlbFJhdGlvOiAxXG4gICAgICB9KTtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLkJhc2VMYXllci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgfSxcbiAgICBfc2V0Q2FudmFzU2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuaGl0Q2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICB2YXIgdHlwZSA9IGNoaWxkLmdldFR5cGUoKTtcbiAgICAgIGlmICh0eXBlICE9PSAnR3JvdXAnICYmIHR5cGUgIT09ICdTaGFwZScpIHtcbiAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBncm91cHMgYW5kIHNoYXBlcyB0byBhIGxheWVyLicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IHZpc2libGUgaW50ZXJzZWN0aW9uIHNoYXBlLiBUaGlzIGlzIHRoZSBwcmVmZXJyZWRcbiAgICAgKiBtZXRob2QgZm9yIGRldGVybWluaW5nIGlmIGEgcG9pbnQgaW50ZXJzZWN0cyBhIHNoYXBlIG9yIG5vdFxuICAgICAqIGFsc28geW91IG1heSBwYXNzIG9wdGlvbmFsIHNlbGVjdG9yIHBhcmFtZXRyIHRvIHJldHVybiBhbmNlc3RvciBvZiBpbnRlcnNlY3RlZCBzaGFwZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTGF5ZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgc2hhcGUgPSBsYXllci5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0pO1xuICAgICAqIC8vIG9yIGlmIHlvdSBpbnRlcmVzdGVkIGluIHNoYXBlIHBhcmVudDpcbiAgICAgKiB2YXIgZ3JvdXAgPSBsYXllci5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0sICdHcm91cCcpO1xuICAgICAqL1xuICAgIGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24ocG9zLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIG9iaiwgaSwgaW50ZXJzZWN0aW9uT2Zmc2V0LCBzaGFwZTtcblxuICAgICAgaWYgKCF0aGlzLmhpdEdyYXBoRW5hYmxlZCgpIHx8ICF0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gaW4gc29tZSBjYXNlcyBhbnRpYWxpYXNlZCBhcmVhIG1heSBiZSBiaWdnZXIgdGhhbiAxcHhcbiAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIGlmIHdlIHdpbGwgY2FjaGUgbm9kZSwgdGhlbiBzY2FsZSBpdCBhIGxvdFxuICAgICAgLy8gVE9ETzogY2hlY2sgeyAwOyAwIH0gcG9pbnQgYmVmb3JlIGxvb3AsIGFuZCByZW1vdmUgaXQgZnJvbSBJTlRFUlNFQ1RJT05fT0ZGU0VUUy5cbiAgICAgIHZhciBzcGlyYWxTZWFyY2hEaXN0YW5jZSA9IDE7XG4gICAgICB2YXIgY29udGludWVTZWFyY2ggPSBmYWxzZTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBJTlRFUlNFQ1RJT05fT0ZGU0VUU19MRU47IGkrKykge1xuICAgICAgICAgIGludGVyc2VjdGlvbk9mZnNldCA9IElOVEVSU0VDVElPTl9PRkZTRVRTW2ldO1xuICAgICAgICAgIG9iaiA9IHRoaXMuX2dldEludGVyc2VjdGlvbih7XG4gICAgICAgICAgICB4OiBwb3MueCArIGludGVyc2VjdGlvbk9mZnNldC54ICogc3BpcmFsU2VhcmNoRGlzdGFuY2UsXG4gICAgICAgICAgICB5OiBwb3MueSArIGludGVyc2VjdGlvbk9mZnNldC55ICogc3BpcmFsU2VhcmNoRGlzdGFuY2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzaGFwZSA9IG9iai5zaGFwZTtcbiAgICAgICAgICBpZiAoc2hhcGUgJiYgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBzaGFwZS5maW5kQW5jZXN0b3Ioc2VsZWN0b3IsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2Ugc2hvdWxkIGNvbnRpbnVlIHNlYXJjaCBpZiB3ZSBmb3VuZCBhbnRpYWxpYXNlZCBwaXhlbFxuICAgICAgICAgIC8vIHRoYXQgbWVhbnMgb3VyIG5vZGUgc29tZXdoZXJlIHZlcnkgY2xvc2VcbiAgICAgICAgICBjb250aW51ZVNlYXJjaCA9ICEhb2JqLmFudGlhbGlhc2VkO1xuICAgICAgICAgIC8vIHN0b3Agc2VhcmNoIGlmIGZvdW5kIGVtcHR5IHBpeGVsXG4gICAgICAgICAgaWYgKCFvYmouYW50aWFsaWFzZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBubyBzaGFwZSwgYW5kIG5vIGFudGlhbGlhc2VkIHBpeGVsLCB3ZSBzaG91bGQgZW5kIHNlYXJjaGluZ1xuICAgICAgICBpZiAoY29udGludWVTZWFyY2gpIHtcbiAgICAgICAgICBzcGlyYWxTZWFyY2hEaXN0YW5jZSArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0SW1hZ2VEYXRhOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmhpdENhbnZhcy53aWR0aCB8fCAxLFxuICAgICAgICBoZWlnaHQgPSB0aGlzLmhpdENhbnZhcy5oZWlnaHQgfHwgMSxcbiAgICAgICAgaW5kZXggPSBNYXRoLnJvdW5kKHkpICogd2lkdGggKyBNYXRoLnJvdW5kKHgpO1xuXG4gICAgICBpZiAoIXRoaXMuX2hpdEltYWdlRGF0YSkge1xuICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEgPSB0aGlzLmhpdENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YShcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YS5kYXRhWzQgKiBpbmRleCArIDBdLCAvLyBSZWRcbiAgICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhLmRhdGFbNCAqIGluZGV4ICsgMV0sIC8vIEdyZWVuXG4gICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YS5kYXRhWzQgKiBpbmRleCArIDJdLCAvLyBCbHVlXG4gICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YS5kYXRhWzQgKiBpbmRleCArIDNdIC8vIEFscGhhXG4gICAgICBdO1xuICAgIH0sXG4gICAgX2dldEludGVyc2VjdGlvbjogZnVuY3Rpb24ocG9zKSB7XG4gICAgICB2YXIgcmF0aW8gPSB0aGlzLmhpdENhbnZhcy5waXhlbFJhdGlvO1xuICAgICAgdmFyIHAgPSB0aGlzLmhpdENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YShcbiAgICAgICAgICBNYXRoLnJvdW5kKHBvcy54ICogcmF0aW8pLFxuICAgICAgICAgIE1hdGgucm91bmQocG9zLnkgKiByYXRpbyksXG4gICAgICAgICAgMSxcbiAgICAgICAgICAxXG4gICAgICAgICkuZGF0YSxcbiAgICAgICAgcDMgPSBwWzNdLFxuICAgICAgICBjb2xvcktleSxcbiAgICAgICAgc2hhcGU7XG4gICAgICAvLyBmdWxseSBvcGFxdWUgcGl4ZWxcbiAgICAgIGlmIChwMyA9PT0gMjU1KSB7XG4gICAgICAgIGNvbG9yS2V5ID0gS29udmEuVXRpbC5fcmdiVG9IZXgocFswXSwgcFsxXSwgcFsyXSk7XG4gICAgICAgIHNoYXBlID0gS29udmEuc2hhcGVzW0hBU0ggKyBjb2xvcktleV07XG4gICAgICAgIGlmIChzaGFwZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaGFwZTogc2hhcGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYW50aWFsaWFzZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAocDMgPiAwKSB7XG4gICAgICAgIC8vIGFudGlhbGlhc2VkIHBpeGVsXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYW50aWFsaWFzZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIGVtcHR5IHBpeGVsXG4gICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbiwgdG9wKSB7XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgIGNhbnZhcyA9IGNhbiB8fCAobGF5ZXIgJiYgbGF5ZXIuZ2V0Q2FudmFzKCkpO1xuXG4gICAgICB0aGlzLl9maXJlKEJFRk9SRV9EUkFXLCB7XG4gICAgICAgIG5vZGU6IHRoaXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5nZXRDbGVhckJlZm9yZURyYXcoKSkge1xuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgpLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZHJhd1NjZW5lLmNhbGwodGhpcywgY2FudmFzLCB0b3ApO1xuXG4gICAgICB0aGlzLl9maXJlKERSQVcsIHtcbiAgICAgICAgbm9kZTogdGhpc1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZHJhd0hpdDogZnVuY3Rpb24oY2FuLCB0b3ApIHtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5oaXRDYW52YXMpO1xuXG4gICAgICBpZiAobGF5ZXIgJiYgbGF5ZXIuZ2V0Q2xlYXJCZWZvcmVEcmF3KCkpIHtcbiAgICAgICAgbGF5ZXJcbiAgICAgICAgICAuZ2V0SGl0Q2FudmFzKClcbiAgICAgICAgICAuZ2V0Q29udGV4dCgpXG4gICAgICAgICAgLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZHJhd0hpdC5jYWxsKHRoaXMsIGNhbnZhcywgdG9wKTtcbiAgICAgIHRoaXMuaW1hZ2VEYXRhID0gbnVsbDsgLy8gQ2xlYXIgaW1hZ2VEYXRhIGNhY2hlXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICAgIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGUuY2xlYXIuY2FsbCh0aGlzLCBib3VuZHMpO1xuICAgICAgdGhpcy5nZXRIaXRDYW52YXMoKVxuICAgICAgICAuZ2V0Q29udGV4dCgpXG4gICAgICAgIC5jbGVhcihib3VuZHMpO1xuICAgICAgdGhpcy5pbWFnZURhdGEgPSBudWxsOyAvLyBDbGVhciBnZXRJbWFnZURhdGEgY2FjaGVcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLnNldFZpc2libGVcbiAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRWaXNpYmxlLmNhbGwodGhpcywgdmlzaWJsZSk7XG4gICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuaGl0Q2FudmFzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5oaXRDYW52YXMuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBlbmFibGUgaGl0IGdyYXBoXG4gICAgICogQG5hbWUgZW5hYmxlSGl0R3JhcGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkxheWVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtMYXllcn1cbiAgICAgKi9cbiAgICBlbmFibGVIaXRHcmFwaDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEhpdEdyYXBoRW5hYmxlZCh0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZGlzYWJsZSBoaXQgZ3JhcGhcbiAgICAgKiBAbmFtZSBkaXNhYmxlSGl0R3JhcGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkxheWVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtMYXllcn1cbiAgICAgKi9cbiAgICBkaXNhYmxlSGl0R3JhcGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRIaXRHcmFwaEVuYWJsZWQoZmFsc2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlLnNldFNpemUuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuaGl0Q2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5MYXllciwgS29udmEuQmFzZUxheWVyKTtcblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5MYXllciwgJ2hpdEdyYXBoRW5hYmxlZCcsIHRydWUpO1xuICAvKipcbiAgICogZ2V0L3NldCBoaXRHcmFwaEVuYWJsZWQgZmxhZy4gIERpc2FibGluZyB0aGUgaGl0IGdyYXBoIHdpbGwgZ3JlYXRseSBpbmNyZWFzZVxuICAgKiAgZHJhdyBwZXJmb3JtYW5jZSBiZWNhdXNlIHRoZSBoaXQgZ3JhcGggd2lsbCBub3QgYmUgcmVkcmF3biBlYWNoIHRpbWUgdGhlIGxheWVyIGlzXG4gICAqICBkcmF3bi4gIFRoaXMsIGhvd2V2ZXIsIGFsc28gZGlzYWJsZXMgbW91c2UvdG91Y2ggZXZlbnQgZGV0ZWN0aW9uXG4gICAqIEBuYW1lIGhpdEdyYXBoRW5hYmxlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5MYXllci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgaGl0R3JhcGhFbmFibGVkIGZsYWdcbiAgICogdmFyIGhpdEdyYXBoRW5hYmxlZCA9IGxheWVyLmhpdEdyYXBoRW5hYmxlZCgpO1xuICAgKlxuICAgKiAvLyBkaXNhYmxlIGhpdCBncmFwaFxuICAgKiBsYXllci5oaXRHcmFwaEVuYWJsZWQoZmFsc2UpO1xuICAgKlxuICAgKiAvLyBlbmFibGUgaGl0IGdyYXBoXG4gICAqIGxheWVyLmhpdEdyYXBoRW5hYmxlZCh0cnVlKTtcbiAgICovXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5MYXllcik7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEZhc3RMYXllciBjb25zdHJ1Y3Rvci4gTGF5ZXJzIGFyZSB0aWVkIHRvIHRoZWlyIG93biBjYW52YXMgZWxlbWVudCBhbmQgYXJlIHVzZWRcbiAgICogdG8gY29udGFpbiBzaGFwZXMgb25seS4gIElmIHlvdSBkb24ndCBuZWVkIG5vZGUgbmVzdGluZywgbW91c2UgYW5kIHRvdWNoIGludGVyYWN0aW9ucyxcbiAgICogb3IgZXZlbnQgcHViL3N1YiwgeW91IHNob3VsZCB1c2UgRmFzdExheWVyIGluc3RlYWQgb2YgTGF5ZXIgdG8gY3JlYXRlIHlvdXIgbGF5ZXJzLlxuICAgKiBJdCByZW5kZXJzIGFib3V0IDJ4IGZhc3RlciB0aGFuIG5vcm1hbCBsYXllcnMuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQGF1Z21lbnRzIEtvbnZhLkJhc2VMYXllclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbGVhckJlZm9yZURyYXddIHNldCB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50XG4gICAqIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggbGF5ZXIgZHJhdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNsaXBGdW5jXSBzZXQgY2xpcCBmdW5jXG5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGxheWVyID0gbmV3IEtvbnZhLkZhc3RMYXllcigpO1xuICAgKi9cbiAgS29udmEuRmFzdExheWVyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5GYXN0TGF5ZXIsIHtcbiAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB0aGlzLm5vZGVUeXBlID0gJ0xheWVyJztcbiAgICAgIHRoaXMuY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKCk7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5CYXNlTGF5ZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgIH0sXG4gICAgX3ZhbGlkYXRlQWRkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgdmFyIHR5cGUgPSBjaGlsZC5nZXRUeXBlKCk7XG4gICAgICBpZiAodHlwZSAhPT0gJ1NoYXBlJykge1xuICAgICAgICBLb252YS5VdGlsLnRocm93KCdZb3UgbWF5IG9ubHkgYWRkIHNoYXBlcyB0byBhIGZhc3QgbGF5ZXIuJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfc2V0Q2FudmFzU2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGhpdEdyYXBoRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbikge1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmdldENhbnZhcygpKTtcblxuICAgICAgaWYgKHRoaXMuZ2V0Q2xlYXJCZWZvcmVEcmF3KCkpIHtcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoKS5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmRyYXdTY2VuZS5jYWxsKHRoaXMsIGNhbnZhcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRyYXdTY2VuZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZVxuICAgIHNldFZpc2libGU6IGZ1bmN0aW9uKHZpc2libGUpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFZpc2libGUuY2FsbCh0aGlzLCB2aXNpYmxlKTtcbiAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuRmFzdExheWVyLCBLb252YS5CYXNlTGF5ZXIpO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5GYXN0TGF5ZXIpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBHcm91cCBjb25zdHJ1Y3Rvci4gIEdyb3VwcyBhcmUgdXNlZCB0byBjb250YWluIHNoYXBlcyBvciBvdGhlciBncm91cHMuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQGF1Z21lbnRzIEtvbnZhLkNvbnRhaW5lclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2xpcEZ1bmNdIHNldCBjbGlwIGZ1bmNcblxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZ3JvdXAgPSBuZXcgS29udmEuR3JvdXAoKTtcbiAgICovXG4gIEtvbnZhLkdyb3VwID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLkdyb3VwLCB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB0aGlzLm5vZGVUeXBlID0gJ0dyb3VwJztcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLkNvbnRhaW5lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgfSxcbiAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICB2YXIgdHlwZSA9IGNoaWxkLmdldFR5cGUoKTtcbiAgICAgIGlmICh0eXBlICE9PSAnR3JvdXAnICYmIHR5cGUgIT09ICdTaGFwZScpIHtcbiAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBncm91cHMgYW5kIHNoYXBlcyB0byBncm91cHMuJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuR3JvdXAsIEtvbnZhLkNvbnRhaW5lcik7XG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkdyb3VwKTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBub3cgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKEtvbnZhLmdsb2JhbC5wZXJmb3JtYW5jZSAmJiBLb252YS5nbG9iYWwucGVyZm9ybWFuY2Uubm93KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBLb252YS5nbG9iYWwucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIEZSQUYoY2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICB9XG5cbiAgdmFyIFJBRiA9IChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgS29udmEuZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgS29udmEuZ2xvYmFsLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgS29udmEuZ2xvYmFsLm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgS29udmEuZ2xvYmFsLm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIEtvbnZhLmdsb2JhbC5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgRlJBRlxuICAgICk7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZSgpIHtcbiAgICByZXR1cm4gUkFGLmFwcGx5KEtvbnZhLmdsb2JhbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmltYXRpb24gY29uc3RydWN0b3IuICBBIHN0YWdlIGlzIHVzZWQgdG8gY29udGFpbiBtdWx0aXBsZSBsYXllcnMgYW5kIGhhbmRsZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gZXhlY3V0ZWQgb24gZWFjaCBhbmltYXRpb24gZnJhbWUuICBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIGEgZnJhbWUgb2JqZWN0LCB3aGljaCBjb250YWluc1xuICAgKiAgdGltZURpZmYsIGxhc3RUaW1lLCB0aW1lLCBhbmQgZnJhbWVSYXRlIHByb3BlcnRpZXMuICBUaGUgdGltZURpZmYgcHJvcGVydHkgaXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIHBhc3NlZFxuICAgKiAgc2luY2UgdGhlIGxhc3QgYW5pbWF0aW9uIGZyYW1lLiAgVGhlIGxhc3RUaW1lIHByb3BlcnR5IGlzIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRoYXQgZWxhcHNlZCBmcm9tIHRoZSBtb21lbnQgdGhlIGFuaW1hdGlvbiBzdGFydGVkXG4gICAqICB0byB0aGUgbGFzdCBhbmltYXRpb24gZnJhbWUuICBUaGUgdGltZSBwcm9wZXJ0eSBpcyB0aGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCBlbGxhcHNlZCBmcm9tIHRoZSBtb21lbnQgdGhlIGFuaW1hdGlvbiBzdGFydGVkXG4gICAqICB0byB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWUuICBUaGUgZnJhbWVSYXRlIHByb3BlcnR5IGlzIHRoZSBjdXJyZW50IGZyYW1lIHJhdGUgaW4gZnJhbWVzIC8gc2Vjb25kLiBSZXR1cm4gZmFsc2UgZnJvbSBmdW5jdGlvbixcbiAgICogIGlmIHlvdSBkb24ndCBuZWVkIHRvIHJlZHJhdyBsYXllci9sYXllcnMgb24gc29tZSBmcmFtZXMuXG4gICAqIEBwYXJhbSB7S29udmEuTGF5ZXJ8QXJyYXl9IFtsYXllcnNdIGxheWVyKHMpIHRvIGJlIHJlZHJhd24gb24gZWFjaCBhbmltYXRpb24gZnJhbWUuIENhbiBiZSBhIGxheWVyLCBhbiBhcnJheSBvZiBsYXllcnMsIG9yIG51bGwuXG4gICAqICBOb3Qgc3BlY2lmeWluZyBhIG5vZGUgd2lsbCByZXN1bHQgaW4gbm8gcmVkcmF3LlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBtb3ZlIGEgbm9kZSB0byB0aGUgcmlnaHQgYXQgNTAgcGl4ZWxzIC8gc2Vjb25kXG4gICAqIHZhciB2ZWxvY2l0eSA9IDUwO1xuICAgKlxuICAgKiB2YXIgYW5pbSA9IG5ldyBLb252YS5BbmltYXRpb24oZnVuY3Rpb24oZnJhbWUpIHtcbiAgICogICB2YXIgZGlzdCA9IHZlbG9jaXR5ICogKGZyYW1lLnRpbWVEaWZmIC8gMTAwMCk7XG4gICAqICAgbm9kZS5tb3ZlKGRpc3QsIDApO1xuICAgKiB9LCBsYXllcik7XG4gICAqXG4gICAqIGFuaW0uc3RhcnQoKTtcbiAgICovXG4gIEtvbnZhLkFuaW1hdGlvbiA9IGZ1bmN0aW9uKGZ1bmMsIGxheWVycykge1xuICAgIHZhciBBbmltID0gS29udmEuQW5pbWF0aW9uO1xuICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgdGhpcy5zZXRMYXllcnMobGF5ZXJzKTtcbiAgICB0aGlzLmlkID0gQW5pbS5hbmltSWRDb3VudGVyKys7XG4gICAgdGhpcy5mcmFtZSA9IHtcbiAgICAgIHRpbWU6IDAsXG4gICAgICB0aW1lRGlmZjogMCxcbiAgICAgIGxhc3RUaW1lOiBub3coKVxuICAgIH07XG4gIH07XG4gIC8qXG4gICAgICogQW5pbWF0aW9uIG1ldGhvZHNcbiAgICAgKi9cbiAgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgbGF5ZXJzIHRvIGJlIHJlZHJhd24gb24gZWFjaCBhbmltYXRpb24gZnJhbWVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0tvbnZhLkxheWVyfEFycmF5fSBbbGF5ZXJzXSBsYXllcihzKSB0byBiZSByZWRyYXduLiZuYnNwOyBDYW4gYmUgYSBsYXllciwgYW4gYXJyYXkgb2YgbGF5ZXJzLCBvciBudWxsLiAgTm90IHNwZWNpZnlpbmcgYSBub2RlIHdpbGwgcmVzdWx0IGluIG5vIHJlZHJhdy5cbiAgICAgKiBAcmV0dXJuIHtLb252YS5BbmltYXRpb259IHRoaXNcbiAgICAgKi9cbiAgICBzZXRMYXllcnM6IGZ1bmN0aW9uKGxheWVycykge1xuICAgICAgdmFyIGxheXMgPSBbXTtcbiAgICAgIC8vIGlmIHBhc3NpbmcgaW4gbm8gbGF5ZXJzXG4gICAgICBpZiAoIWxheWVycykge1xuICAgICAgICBsYXlzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGlmIHBhc3NpbmcgaW4gYW4gYXJyYXkgb2YgTGF5ZXJzXG4gICAgICAgIC8vIE5PVEU6IGxheWVycyBjb3VsZCBiZSBhbiBhcnJheSBvciBLb252YS5Db2xsZWN0aW9uLiAgZm9yIHNpbXBsaWNpdHksIEknbSBqdXN0IGluc3BlY3RpbmdcbiAgICAgICAgLy8gdGhlIGxlbmd0aCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgYm90aCBjYXNlc1xuICAgICAgICBsYXlzID0gbGF5ZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgcGFzc2luZyBpbiBhIExheWVyXG4gICAgICAgIGxheXMgPSBbbGF5ZXJzXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXllcnMgPSBsYXlzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgbGF5ZXJzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIEtvbnZhLkxheWVyXG4gICAgICovXG4gICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheWVycztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGFkZCBsYXllci4gIFJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5ZXIgd2FzIGFkZGVkLCBhbmQgZmFsc2UgaWYgaXQgd2FzIG5vdFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7S29udmEuTGF5ZXJ9IGxheWVyIHRvIGFkZFxuICAgICAqIEByZXR1cm4ge0Jvb2x9IHRydWUgaWYgbGF5ZXIgaXMgYWRkZWQgdG8gYW5pbWF0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBhZGRMYXllcjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIHZhciBsYXllcnMgPSB0aGlzLmxheWVycyxcbiAgICAgICAgbGVuID0gbGF5ZXJzLmxlbmd0aCxcbiAgICAgICAgbjtcblxuICAgICAgLy8gZG9uJ3QgYWRkIHRoZSBsYXllciBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIGlmIChsYXllcnNbbl0uX2lkID09PSBsYXllci5faWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXllcnMucHVzaChsYXllcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRldGVybWluZSBpZiBhbmltYXRpb24gaXMgcnVubmluZyBvciBub3QuICByZXR1cm5zIHRydWUgb3IgZmFsc2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtCb29sfSBpcyBhbmltYXRpb24gcnVubmluZz9cbiAgICAgKi9cbiAgICBpc1J1bm5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBLb252YS5BbmltYXRpb24sXG4gICAgICAgIGFuaW1hdGlvbnMgPSBhLmFuaW1hdGlvbnMsXG4gICAgICAgIGxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoLFxuICAgICAgICBuO1xuXG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbnNbbl0uaWQgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc3RhcnQgYW5pbWF0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7S29udmEuQW5pbWF0aW9ufSB0aGlzXG4gICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEFuaW0gPSBLb252YS5BbmltYXRpb247XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIHRoaXMuZnJhbWUudGltZURpZmYgPSAwO1xuICAgICAgdGhpcy5mcmFtZS5sYXN0VGltZSA9IG5vdygpO1xuICAgICAgQW5pbS5fYWRkQW5pbWF0aW9uKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzdG9wIGFuaW1hdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge0tvbnZhLkFuaW1hdGlvbn0gdGhpc1xuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgS29udmEuQW5pbWF0aW9uLl9yZW1vdmVBbmltYXRpb24odGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIF91cGRhdGVGcmFtZU9iamVjdDogZnVuY3Rpb24odGltZSkge1xuICAgICAgdGhpcy5mcmFtZS50aW1lRGlmZiA9IHRpbWUgLSB0aGlzLmZyYW1lLmxhc3RUaW1lO1xuICAgICAgdGhpcy5mcmFtZS5sYXN0VGltZSA9IHRpbWU7XG4gICAgICB0aGlzLmZyYW1lLnRpbWUgKz0gdGhpcy5mcmFtZS50aW1lRGlmZjtcbiAgICAgIHRoaXMuZnJhbWUuZnJhbWVSYXRlID0gMTAwMCAvIHRoaXMuZnJhbWUudGltZURpZmY7XG4gICAgfVxuICB9O1xuICBLb252YS5BbmltYXRpb24uYW5pbWF0aW9ucyA9IFtdO1xuICBLb252YS5BbmltYXRpb24uYW5pbUlkQ291bnRlciA9IDA7XG4gIEtvbnZhLkFuaW1hdGlvbi5hbmltUnVubmluZyA9IGZhbHNlO1xuXG4gIEtvbnZhLkFuaW1hdGlvbi5fYWRkQW5pbWF0aW9uID0gZnVuY3Rpb24oYW5pbSkge1xuICAgIHRoaXMuYW5pbWF0aW9ucy5wdXNoKGFuaW0pO1xuICAgIHRoaXMuX2hhbmRsZUFuaW1hdGlvbigpO1xuICB9O1xuICBLb252YS5BbmltYXRpb24uX3JlbW92ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKGFuaW0pIHtcbiAgICB2YXIgaWQgPSBhbmltLmlkLFxuICAgICAgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucyxcbiAgICAgIGxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoLFxuICAgICAgbjtcblxuICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgaWYgKGFuaW1hdGlvbnNbbl0uaWQgPT09IGlkKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UobiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBLb252YS5BbmltYXRpb24uX3J1bkZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXllckhhc2ggPSB7fSxcbiAgICAgIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnMsXG4gICAgICBhbmltLFxuICAgICAgbGF5ZXJzLFxuICAgICAgZnVuYyxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgbGF5ZXJzTGVuLFxuICAgICAgbGF5ZXIsXG4gICAgICBrZXksXG4gICAgICBuZWVkUmVkcmF3O1xuICAgIC8qXG4gICAgICAgICAqIGxvb3AgdGhyb3VnaCBhbGwgYW5pbWF0aW9ucyBhbmQgZXhlY3V0ZSBhbmltYXRpb25cbiAgICAgICAgICogIGZ1bmN0aW9uLiAgaWYgdGhlIGFuaW1hdGlvbiBvYmplY3QgaGFzIHNwZWNpZmllZCBub2RlLFxuICAgICAgICAgKiAgd2UgY2FuIGFkZCB0aGUgbm9kZSB0byB0aGUgbm9kZXMgaGFzaCB0byBlbGltaW5hdGVcbiAgICAgICAgICogIGRyYXdpbmcgdGhlIHNhbWUgbm9kZSBtdWx0aXBsZSB0aW1lcy4gIFRoZSBub2RlIHByb3BlcnR5XG4gICAgICAgICAqICBjYW4gYmUgdGhlIHN0YWdlIGl0c2VsZiBvciBhIGxheWVyXG4gICAgICAgICAqL1xuICAgIC8qXG4gICAgICAgICAqIFdBUk5JTkc6IGRvbid0IGNhY2hlIGFuaW1hdGlvbnMubGVuZ3RoIGJlY2F1c2UgaXQgY291bGQgY2hhbmdlIHdoaWxlXG4gICAgICAgICAqIHRoZSBmb3IgbG9vcCBpcyBydW5uaW5nLCBjYXVzaW5nIGEgSlMgZXJyb3JcbiAgICAgICAgICovXG5cbiAgICBmb3IgKG4gPSAwOyBuIDwgYW5pbWF0aW9ucy5sZW5ndGg7IG4rKykge1xuICAgICAgYW5pbSA9IGFuaW1hdGlvbnNbbl07XG4gICAgICBsYXllcnMgPSBhbmltLmxheWVycztcbiAgICAgIGZ1bmMgPSBhbmltLmZ1bmM7XG5cbiAgICAgIGFuaW0uX3VwZGF0ZUZyYW1lT2JqZWN0KG5vdygpKTtcbiAgICAgIGxheWVyc0xlbiA9IGxheWVycy5sZW5ndGg7XG5cbiAgICAgIC8vIGlmIGFuaW1hdGlvbiBvYmplY3QgaGFzIGEgZnVuY3Rpb24sIGV4ZWN1dGUgaXRcbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIC8vIGFsbG93IGFuaW0gYnlwYXNzaW5nIGRyYXdpbmdcbiAgICAgICAgbmVlZFJlZHJhdyA9IGZ1bmMuY2FsbChhbmltLCBhbmltLmZyYW1lKSAhPT0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWVkUmVkcmF3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghbmVlZFJlZHJhdykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnNMZW47IGkrKykge1xuICAgICAgICBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgICBpZiAobGF5ZXIuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYXllckhhc2hbbGF5ZXIuX2lkXSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gbGF5ZXJIYXNoKSB7XG4gICAgICBpZiAoIWxheWVySGFzaC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGF5ZXJIYXNoW2tleV0uZHJhdygpO1xuICAgIH1cbiAgfTtcbiAgS29udmEuQW5pbWF0aW9uLl9hbmltYXRpb25Mb29wID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEFuaW0gPSBLb252YS5BbmltYXRpb247XG4gICAgaWYgKEFuaW0uYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIEFuaW0uX3J1bkZyYW1lcygpO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZShBbmltLl9hbmltYXRpb25Mb29wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQW5pbS5hbmltUnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgS29udmEuQW5pbWF0aW9uLl9oYW5kbGVBbmltYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuYW5pbVJ1bm5pbmcpIHtcbiAgICAgIHRoaXMuYW5pbVJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRpb25Mb29wKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGJhdGNoIGRyYXcuIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgZG8gaW1tZWRpYXRlIGRyYXdcbiAgICogYnV0IGl0IHdpbGwgc2NoZWR1bGUgZHJhd2luZyB0byBuZXh0IHRpY2sgKHJlcXVlc3RBbmltRnJhbWUpXG4gICAqIEBtZXRob2RcbiAgICogQHJldHVybiB7S29udmEuTGF5ZXJ9IHRoaXNcbiAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2UucHJvdG90eXBlXG4gICAqL1xuICBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlLmJhdGNoRHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgIEFuaW0gPSBLb252YS5BbmltYXRpb247XG5cbiAgICBpZiAoIXRoaXMuYmF0Y2hBbmltKSB7XG4gICAgICB0aGlzLmJhdGNoQW5pbSA9IG5ldyBBbmltKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzdG9wIGFuaW1hdGlvbiBhZnRlciBmaXJzdCB0aWNrXG4gICAgICAgIHRoYXQuYmF0Y2hBbmltLnN0b3AoKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5iYXRjaEFuaW0uaXNSdW5uaW5nKCkpIHtcbiAgICAgIHRoaXMuYmF0Y2hBbmltLnN0YXJ0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBiYXRjaCBkcmF3XG4gICAqIEBtZXRob2RcbiAgICogQHJldHVybiB7S29udmEuU3RhZ2V9IHRoaXNcbiAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgKi9cbiAgS29udmEuU3RhZ2UucHJvdG90eXBlLmJhdGNoRHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICBsYXllci5iYXRjaERyYXcoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pKEtvbnZhKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBibGFja2xpc3QgPSB7XG4gICAgICBub2RlOiAxLFxuICAgICAgZHVyYXRpb246IDEsXG4gICAgICBlYXNpbmc6IDEsXG4gICAgICBvbkZpbmlzaDogMSxcbiAgICAgIHlveW86IDFcbiAgICB9LFxuICAgIFBBVVNFRCA9IDEsXG4gICAgUExBWUlORyA9IDIsXG4gICAgUkVWRVJTSU5HID0gMyxcbiAgICBpZENvdW50ZXIgPSAwLFxuICAgIGNvbG9yQXR0cnMgPSBbJ2ZpbGwnLCAnc3Ryb2tlJywgJ3NoYWRvd0NvbG9yJ107XG5cbiAgdmFyIFR3ZWVuID0gZnVuY3Rpb24ocHJvcCwgcHJvcEZ1bmMsIGZ1bmMsIGJlZ2luLCBmaW5pc2gsIGR1cmF0aW9uLCB5b3lvKSB7XG4gICAgdGhpcy5wcm9wID0gcHJvcDtcbiAgICB0aGlzLnByb3BGdW5jID0gcHJvcEZ1bmM7XG4gICAgdGhpcy5iZWdpbiA9IGJlZ2luO1xuICAgIHRoaXMuX3BvcyA9IGJlZ2luO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLl9jaGFuZ2UgPSAwO1xuICAgIHRoaXMucHJldlBvcyA9IDA7XG4gICAgdGhpcy55b3lvID0geW95bztcbiAgICB0aGlzLl90aW1lID0gMDtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLl9maW5pc2ggPSAwO1xuICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgdGhpcy5fY2hhbmdlID0gZmluaXNoIC0gdGhpcy5iZWdpbjtcbiAgICB0aGlzLnBhdXNlKCk7XG4gIH07XG4gIC8qXG4gICAgICogVHdlZW4gbWV0aG9kc1xuICAgICAqL1xuICBUd2Vlbi5wcm90b3R5cGUgPSB7XG4gICAgZmlyZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHRoaXNbc3RyXTtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFRpbWU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIGlmICh0ID4gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICBpZiAodGhpcy55b3lvKSB7XG4gICAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgdGhpcy5yZXZlcnNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0IDwgMCkge1xuICAgICAgICBpZiAodGhpcy55b3lvKSB7XG4gICAgICAgICAgdGhpcy5fdGltZSA9IDA7XG4gICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90aW1lID0gdDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWU7XG4gICAgfSxcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24ocCkge1xuICAgICAgdGhpcy5wcmV2UG9zID0gdGhpcy5fcG9zO1xuICAgICAgdGhpcy5wcm9wRnVuYyhwKTtcbiAgICAgIHRoaXMuX3BvcyA9IHA7XG4gICAgfSxcbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24odCkge1xuICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0ID0gdGhpcy5fdGltZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZ1bmModCwgdGhpcy5iZWdpbiwgdGhpcy5fY2hhbmdlLCB0aGlzLmR1cmF0aW9uKTtcbiAgICB9LFxuICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBMQVlJTkc7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aGlzLmdldFRpbWVyKCkgLSB0aGlzLl90aW1lO1xuICAgICAgdGhpcy5vbkVudGVyRnJhbWUoKTtcbiAgICAgIHRoaXMuZmlyZSgnb25QbGF5Jyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBSRVZFUlNJTkc7XG4gICAgICB0aGlzLl90aW1lID0gdGhpcy5kdXJhdGlvbiAtIHRoaXMuX3RpbWU7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aGlzLmdldFRpbWVyKCkgLSB0aGlzLl90aW1lO1xuICAgICAgdGhpcy5vbkVudGVyRnJhbWUoKTtcbiAgICAgIHRoaXMuZmlyZSgnb25SZXZlcnNlJyk7XG4gICAgfSxcbiAgICBzZWVrOiBmdW5jdGlvbih0KSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLl90aW1lID0gdDtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLmZpcmUoJ29uU2VlaycpO1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy5fdGltZSA9IDA7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5maXJlKCdvblJlc2V0Jyk7XG4gICAgfSxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5maXJlKCdvbkZpbmlzaCcpO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24odGhpcy5nZXRQb3NpdGlvbih0aGlzLl90aW1lKSk7XG4gICAgfSxcbiAgICBvbkVudGVyRnJhbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmdldFRpbWVyKCkgLSB0aGlzLl9zdGFydFRpbWU7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gUExBWUlORykge1xuICAgICAgICB0aGlzLnNldFRpbWUodCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFJFVkVSU0lORykge1xuICAgICAgICB0aGlzLnNldFRpbWUodGhpcy5kdXJhdGlvbiAtIHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBBVVNFRDtcbiAgICAgIHRoaXMuZmlyZSgnb25QYXVzZScpO1xuICAgIH0sXG4gICAgZ2V0VGltZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHdlZW4gY29uc3RydWN0b3IuICBUd2VlbnMgZW5hYmxlIHlvdSB0byBhbmltYXRlIGEgbm9kZSBiZXR3ZWVuIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBhIG5ldyBzdGF0ZS5cbiAgICogIFlvdSBjYW4gcGxheSwgcGF1c2UsIHJldmVyc2UsIHNlZWssIHJlc2V0LCBhbmQgZmluaXNoIHR3ZWVucy4gIEJ5IGRlZmF1bHQsIHR3ZWVucyBhcmUgYW5pbWF0ZWQgdXNpbmdcbiAgICogIGEgbGluZWFyIGVhc2luZy4gIEZvciBtb3JlIHR3ZWVuaW5nIG9wdGlvbnMsIGNoZWNrIG91dCB7QGxpbmsgS29udmEuRWFzaW5nc31cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBpbnN0YW50aWF0ZSBuZXcgdHdlZW4gd2hpY2ggZnVsbHkgcm90YXRlcyBhIG5vZGUgaW4gMSBzZWNvbmRcbiAgICogdmFyIHR3ZWVuID0gbmV3IEtvbnZhLlR3ZWVuKHtcbiAgICogICBub2RlOiBub2RlLFxuICAgKiAgIHJvdGF0aW9uRGVnOiAzNjAsXG4gICAqICAgZHVyYXRpb246IDEsXG4gICAqICAgZWFzaW5nOiBLb252YS5FYXNpbmdzLkVhc2VJbk91dFxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gcGxheSB0d2VlblxuICAgKiB0d2Vlbi5wbGF5KCk7XG4gICAqXG4gICAqIC8vIHBhdXNlIHR3ZWVuXG4gICAqIHR3ZWVuLnBhdXNlKCk7XG4gICAqL1xuICBLb252YS5Ud2VlbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgIG5vZGUgPSBjb25maWcubm9kZSxcbiAgICAgIG5vZGVJZCA9IG5vZGUuX2lkLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBlYXNpbmcgPSBjb25maWcuZWFzaW5nIHx8IEtvbnZhLkVhc2luZ3MuTGluZWFyLFxuICAgICAgeW95byA9ICEhY29uZmlnLnlveW8sXG4gICAgICBrZXk7XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5kdXJhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGR1cmF0aW9uID0gMC4zO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmR1cmF0aW9uID09PSAwKSB7XG4gICAgICAvLyB6ZXJvIGlzIGJhZCB2YWx1ZSBmb3IgZHVyYXRpb25cbiAgICAgIGR1cmF0aW9uID0gMC4wMDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cmF0aW9uID0gY29uZmlnLmR1cmF0aW9uO1xuICAgIH1cbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuX2lkID0gaWRDb3VudGVyKys7XG5cbiAgICB2YXIgbGF5ZXJzID1cbiAgICAgIG5vZGUuZ2V0TGF5ZXIoKSB8fFxuICAgICAgKG5vZGUgaW5zdGFuY2VvZiBLb252YS5TdGFnZSA/IG5vZGUuZ2V0TGF5ZXJzKCkgOiBudWxsKTtcbiAgICBpZiAoIWxheWVycykge1xuICAgICAgS29udmEuVXRpbC5lcnJvcihcbiAgICAgICAgJ1R3ZWVuIGNvbnN0cnVjdG9yIGhhdmUgYG5vZGVgIHRoYXQgaXMgbm90IGluIGEgbGF5ZXIuIFBsZWFzZSBhZGQgbm9kZSBpbnRvIGxheWVyIGZpcnN0LidcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuYW5pbSA9IG5ldyBLb252YS5BbmltYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICB0aGF0LnR3ZWVuLm9uRW50ZXJGcmFtZSgpO1xuICAgIH0sIGxheWVycyk7XG5cbiAgICB0aGlzLnR3ZWVuID0gbmV3IFR3ZWVuKFxuICAgICAga2V5LFxuICAgICAgZnVuY3Rpb24oaSkge1xuICAgICAgICB0aGF0Ll90d2VlbkZ1bmMoaSk7XG4gICAgICB9LFxuICAgICAgZWFzaW5nLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICBkdXJhdGlvbiAqIDEwMDAsXG4gICAgICB5b3lvXG4gICAgKTtcblxuICAgIHRoaXMuX2FkZExpc3RlbmVycygpO1xuXG4gICAgLy8gaW5pdCBhdHRycyBtYXBcbiAgICBpZiAoIUtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF0pIHtcbiAgICAgIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF0gPSB7fTtcbiAgICB9XG4gICAgaWYgKCFLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3RoaXMuX2lkXSkge1xuICAgICAgS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXVt0aGlzLl9pZF0gPSB7fTtcbiAgICB9XG4gICAgLy8gaW5pdCB0d2VlbnMgbWFwXG4gICAgaWYgKCFLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXSkge1xuICAgICAgS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF0gPSB7fTtcbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChibGFja2xpc3Rba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2FkZEF0dHIoa2V5LCBjb25maWdba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldCgpO1xuXG4gICAgLy8gY2FsbGJhY2tzXG4gICAgdGhpcy5vbkZpbmlzaCA9IGNvbmZpZy5vbkZpbmlzaDtcbiAgICB0aGlzLm9uUmVzZXQgPSBjb25maWcub25SZXNldDtcbiAgfTtcblxuICAvLyBzdGFydC9kaWZmIG9iamVjdCA9IGF0dHJzLm5vZGVJZC50d2VlbklkLmF0dHJcbiAgS29udmEuVHdlZW4uYXR0cnMgPSB7fTtcbiAgLy8gdHdlZW5JZCA9IHR3ZWVucy5ub2RlSWQuYXR0clxuICBLb252YS5Ud2Vlbi50d2VlbnMgPSB7fTtcblxuICBLb252YS5Ud2Vlbi5wcm90b3R5cGUgPSB7XG4gICAgX2FkZEF0dHI6IGZ1bmN0aW9uKGtleSwgZW5kKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSxcbiAgICAgICAgbm9kZUlkID0gbm9kZS5faWQsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBkaWZmLFxuICAgICAgICB0d2VlbklkLFxuICAgICAgICBuLFxuICAgICAgICBsZW4sXG4gICAgICAgIHRydWVFbmQsXG4gICAgICAgIHRydWVTdGFydCxcbiAgICAgICAgZW5kUkdCQTtcblxuICAgICAgLy8gcmVtb3ZlIGNvbmZsaWN0IGZyb20gdHdlZW4gbWFwIGlmIGl0IGV4aXN0c1xuICAgICAgdHdlZW5JZCA9IEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdW2tleV07XG5cbiAgICAgIGlmICh0d2VlbklkKSB7XG4gICAgICAgIGRlbGV0ZSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3R3ZWVuSWRdW2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCB0byB0d2VlbiBtYXBcbiAgICAgIHN0YXJ0ID0gbm9kZS5nZXRBdHRyKGtleSk7XG5cbiAgICAgIGlmIChLb252YS5VdGlsLl9pc0FycmF5KGVuZCkpIHtcbiAgICAgICAgZGlmZiA9IFtdO1xuICAgICAgICBsZW4gPSBNYXRoLm1heChlbmQubGVuZ3RoLCBzdGFydC5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdwb2ludHMnICYmIGVuZC5sZW5ndGggIT09IHN0YXJ0Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIGJlZm9yZSB0d2VlbmluZyBwb2ludHMgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBzdGFydC5sZW5ndGggPT09IGVuZC5sZW5ndGhcbiAgICAgICAgICAvLyBLb252YS5VdGlsLl9wcmVwYXJlQXJyYXlGb3JUd2VlbiB0aGlua2luZyB0aGF0IGVuZC5sZW5ndGggPiBzdGFydC5sZW5ndGhcblxuICAgICAgICAgIGlmIChlbmQubGVuZ3RoID4gc3RhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzbyBpbiB0aGlzIGNhc2Ugd2Ugd2lsbCBpbmNyZWFzZSBudW1iZXIgb2Ygc3RhcnRpbmcgcG9pbnRzXG4gICAgICAgICAgICB0cnVlU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHN0YXJ0ID0gS29udmEuVXRpbC5fcHJlcGFyZUFycmF5Rm9yVHdlZW4oc3RhcnQsIGVuZCwgbm9kZS5jbG9zZWQoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3aWxsIGluY3JlYXNlIG51bWJlciBvZiBlZGluZyBwb2ludHNcbiAgICAgICAgICAgIHRydWVFbmQgPSBlbmQ7XG4gICAgICAgICAgICBlbmQgPSBLb252YS5VdGlsLl9wcmVwYXJlQXJyYXlGb3JUd2VlbihlbmQsIHN0YXJ0LCBub2RlLmNsb3NlZCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ2ZpbGwnKSA9PT0gMCkge1xuICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgaWYgKG4gJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgIGRpZmYucHVzaChlbmRbbl0gLSBzdGFydFtuXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc3RhcnRSR0JBID0gS29udmEuVXRpbC5jb2xvclRvUkdCQShzdGFydFtuXSk7XG4gICAgICAgICAgICAgIGVuZFJHQkEgPSBLb252YS5VdGlsLmNvbG9yVG9SR0JBKGVuZFtuXSk7XG4gICAgICAgICAgICAgIHN0YXJ0W25dID0gc3RhcnRSR0JBO1xuICAgICAgICAgICAgICBkaWZmLnB1c2goe1xuICAgICAgICAgICAgICAgIHI6IGVuZFJHQkEuciAtIHN0YXJ0UkdCQS5yLFxuICAgICAgICAgICAgICAgIGc6IGVuZFJHQkEuZyAtIHN0YXJ0UkdCQS5nLFxuICAgICAgICAgICAgICAgIGI6IGVuZFJHQkEuYiAtIHN0YXJ0UkdCQS5iLFxuICAgICAgICAgICAgICAgIGE6IGVuZFJHQkEuYSAtIHN0YXJ0UkdCQS5hXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgIGRpZmYucHVzaChlbmRbbl0gLSBzdGFydFtuXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbG9yQXR0cnMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICBzdGFydCA9IEtvbnZhLlV0aWwuY29sb3JUb1JHQkEoc3RhcnQpO1xuICAgICAgICBlbmRSR0JBID0gS29udmEuVXRpbC5jb2xvclRvUkdCQShlbmQpO1xuICAgICAgICBkaWZmID0ge1xuICAgICAgICAgIHI6IGVuZFJHQkEuciAtIHN0YXJ0LnIsXG4gICAgICAgICAgZzogZW5kUkdCQS5nIC0gc3RhcnQuZyxcbiAgICAgICAgICBiOiBlbmRSR0JBLmIgLSBzdGFydC5iLFxuICAgICAgICAgIGE6IGVuZFJHQkEuYSAtIHN0YXJ0LmFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpZmYgPSBlbmQgLSBzdGFydDtcbiAgICAgIH1cblxuICAgICAgS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXVt0aGlzLl9pZF1ba2V5XSA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBkaWZmOiBkaWZmLFxuICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgdHJ1ZUVuZDogdHJ1ZUVuZCxcbiAgICAgICAgdHJ1ZVN0YXJ0OiB0cnVlU3RhcnRcbiAgICAgIH07XG4gICAgICBLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXVtrZXldID0gdGhpcy5faWQ7XG4gICAgfSxcbiAgICBfdHdlZW5GdW5jOiBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSxcbiAgICAgICAgYXR0cnMgPSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlLl9pZF1bdGhpcy5faWRdLFxuICAgICAgICBrZXksXG4gICAgICAgIGF0dHIsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBkaWZmLFxuICAgICAgICBuZXdWYWwsXG4gICAgICAgIG4sXG4gICAgICAgIGxlbixcbiAgICAgICAgZW5kO1xuXG4gICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICBhdHRyID0gYXR0cnNba2V5XTtcbiAgICAgICAgc3RhcnQgPSBhdHRyLnN0YXJ0O1xuICAgICAgICBkaWZmID0gYXR0ci5kaWZmO1xuICAgICAgICBlbmQgPSBhdHRyLmVuZDtcblxuICAgICAgICBpZiAoS29udmEuVXRpbC5faXNBcnJheShzdGFydCkpIHtcbiAgICAgICAgICBuZXdWYWwgPSBbXTtcbiAgICAgICAgICBsZW4gPSBNYXRoLm1heChzdGFydC5sZW5ndGgsIGVuZC5sZW5ndGgpO1xuICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignZmlsbCcpID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgaWYgKG4gJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsLnB1c2goKHN0YXJ0W25dIHx8IDApICsgZGlmZltuXSAqIGkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ZhbC5wdXNoKFxuICAgICAgICAgICAgICAgICAgJ3JnYmEoJyArXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoc3RhcnRbbl0uciArIGRpZmZbbl0uciAqIGkpICtcbiAgICAgICAgICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydFtuXS5nICsgZGlmZltuXS5nICogaSkgK1xuICAgICAgICAgICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHN0YXJ0W25dLmIgKyBkaWZmW25dLmIgKiBpKSArXG4gICAgICAgICAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAgICAgICAgIChzdGFydFtuXS5hICsgZGlmZltuXS5hICogaSkgK1xuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICBuZXdWYWwucHVzaCgoc3RhcnRbbl0gfHwgMCkgKyBkaWZmW25dICogaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbG9yQXR0cnMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgIG5ld1ZhbCA9XG4gICAgICAgICAgICAncmdiYSgnICtcbiAgICAgICAgICAgIE1hdGgucm91bmQoc3RhcnQuciArIGRpZmYuciAqIGkpICtcbiAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKHN0YXJ0LmcgKyBkaWZmLmcgKiBpKSArXG4gICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydC5iICsgZGlmZi5iICogaSkgK1xuICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgIChzdGFydC5hICsgZGlmZi5hICogaSkgK1xuICAgICAgICAgICAgJyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1ZhbCA9IHN0YXJ0ICsgZGlmZiAqIGk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnNldEF0dHIoa2V5LCBuZXdWYWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIC8vIHN0YXJ0IGxpc3RlbmVyc1xuICAgICAgdGhpcy50d2Vlbi5vblBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5hbmltLnN0YXJ0KCk7XG4gICAgICB9O1xuICAgICAgdGhpcy50d2Vlbi5vblJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5hbmltLnN0YXJ0KCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBzdG9wIGxpc3RlbmVyc1xuICAgICAgdGhpcy50d2Vlbi5vblBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuYW5pbS5zdG9wKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy50d2Vlbi5vbkZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoYXQubm9kZTtcblxuICAgICAgICAvLyBhZnRlciB0d2VlbmluZyAgcG9pbnRzIG9mIGxpbmUgd2UgbmVlZCB0byBzZXQgb3JpZ2luYWwgZW5kXG4gICAgICAgIHZhciBhdHRycyA9IEtvbnZhLlR3ZWVuLmF0dHJzW25vZGUuX2lkXVt0aGF0Ll9pZF07XG4gICAgICAgIGlmIChhdHRycy5wb2ludHMgJiYgYXR0cnMucG9pbnRzLnRydWVFbmQpIHtcbiAgICAgICAgICBub2RlLnBvaW50cyhhdHRycy5wb2ludHMudHJ1ZUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhhdC5vbkZpbmlzaCkge1xuICAgICAgICAgIHRoYXQub25GaW5pc2guY2FsbCh0aGF0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMudHdlZW4ub25SZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoYXQubm9kZTtcbiAgICAgICAgLy8gYWZ0ZXIgdHdlZW5pbmcgIHBvaW50cyBvZiBsaW5lIHdlIG5lZWQgdG8gc2V0IG9yaWdpbmFsIHN0YXJ0XG4gICAgICAgIHZhciBhdHRycyA9IEtvbnZhLlR3ZWVuLmF0dHJzW25vZGUuX2lkXVt0aGF0Ll9pZF07XG4gICAgICAgIGlmIChhdHRycy5wb2ludHMgJiYgYXR0cnMucG9pbnRzLnRydWVTdGFydCkge1xuICAgICAgICAgIG5vZGUucG9pbnRzKGF0dHJzLnBvaW50cy50cnVlU3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoYXQub25SZXNldCkge1xuICAgICAgICAgIHRoYXQub25SZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcGxheVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAqL1xuICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50d2Vlbi5wbGF5KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHJldmVyc2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgKi9cbiAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHdlZW4ucmV2ZXJzZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXNldFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHdlZW4ucmVzZXQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2Vla1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB0IHRpbWUgaW4gc2Vjb25kcyBiZXR3ZWVuIDAgYW5kIHRoZSBkdXJhdGlvblxuICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgKi9cbiAgICBzZWVrOiBmdW5jdGlvbih0KSB7XG4gICAgICB0aGlzLnR3ZWVuLnNlZWsodCAqIDEwMDApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBwYXVzZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAqL1xuICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHdlZW4ucGF1c2UoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZmluaXNoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ud2Vlbi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICovXG4gICAgZmluaXNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHdlZW4uZmluaXNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3lcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGVJZCA9IHRoaXMubm9kZS5faWQsXG4gICAgICAgIHRoaXNJZCA9IHRoaXMuX2lkLFxuICAgICAgICBhdHRycyA9IEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdLFxuICAgICAgICBrZXk7XG5cbiAgICAgIHRoaXMucGF1c2UoKTtcblxuICAgICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgZGVsZXRlIEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdW2tleV07XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3RoaXNJZF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUd2VlbiBub2RlIHByb3BlcnRpZXMuIFNob3J0ZXIgdXNhZ2Ugb2Yge0BsaW5rIEtvbnZhLlR3ZWVufSBvYmplY3QuXG4gICAqXG4gICAqIEBtZXRob2QgS29udmEuTm9kZSN0b1xuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gdHdlZW4gcGFyYW1zXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGNpcmNsZS50byh7XG4gICAqICB4IDogNTAsXG4gICAqICBkdXJhdGlvbiA6IDAuNVxuICAgKiB9KTtcbiAgICovXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLnRvID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIG9uRmluaXNoID0gcGFyYW1zLm9uRmluaXNoO1xuICAgIHBhcmFtcy5ub2RlID0gdGhpcztcbiAgICBwYXJhbXMub25GaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICAgIG9uRmluaXNoKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgdHdlZW4gPSBuZXcgS29udmEuVHdlZW4ocGFyYW1zKTtcbiAgICB0d2Vlbi5wbGF5KCk7XG4gIH07XG5cbiAgLypcbiAgICAqIFRoZXNlIGVhc2VzIHdlcmUgcG9ydGVkIGZyb20gYW4gQWRvYmUgRmxhc2ggdHdlZW5pbmcgbGlicmFyeSB0byBKYXZhU2NyaXB0XG4gICAgKiBieSBYYXJpY1xuICAgICovXG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgRWFzaW5nc1xuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICovXG4gIEtvbnZhLkVhc2luZ3MgPSB7XG4gICAgLyoqXG4gICAgICogYmFjayBlYXNlIGluXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgKi9cbiAgICBCYWNrRWFzZUluOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqICgocyArIDEpICogdCAtIHMpICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGJhY2sgZWFzZSBvdXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAqL1xuICAgIEJhY2tFYXNlT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBiYWNrIGVhc2UgaW4gb3V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgKi9cbiAgICBCYWNrRWFzZUluT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICBpZiAoKHQgLz0gZCAvIDIpIDwgMSkge1xuICAgICAgICByZXR1cm4gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9IDEuNTI1KSArIDEpICogdCAtIHMpKSArIGI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAxLjUyNSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGVsYXN0aWMgZWFzZSBpblxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICovXG4gICAgRWxhc3RpY0Vhc2VJbjogZnVuY3Rpb24odCwgYiwgYywgZCwgYSwgcCkge1xuICAgICAgLy8gYWRkZWQgcyA9IDBcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIGlmICh0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgICAgaWYgKCh0IC89IGQpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBiICsgYztcbiAgICAgIH1cbiAgICAgIGlmICghcCkge1xuICAgICAgICBwID0gZCAqIDAuMztcbiAgICAgIH1cbiAgICAgIGlmICghYSB8fCBhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgICAgYSA9IGM7XG4gICAgICAgIHMgPSBwIC8gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICAtKFxuICAgICAgICAgIGEgKlxuICAgICAgICAgIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICpcbiAgICAgICAgICBNYXRoLnNpbigodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKVxuICAgICAgICApICsgYlxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGVsYXN0aWMgZWFzZSBvdXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAqL1xuICAgIEVsYXN0aWNFYXNlT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkLCBhLCBwKSB7XG4gICAgICAvLyBhZGRlZCBzID0gMFxuICAgICAgdmFyIHMgPSAwO1xuICAgICAgaWYgKHQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgICBpZiAoKHQgLz0gZCkgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGIgKyBjO1xuICAgICAgfVxuICAgICAgaWYgKCFwKSB7XG4gICAgICAgIHAgPSBkICogMC4zO1xuICAgICAgfVxuICAgICAgaWYgKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgICBhID0gYztcbiAgICAgICAgcyA9IHAgLyA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICtcbiAgICAgICAgYyArXG4gICAgICAgIGJcbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBlbGFzdGljIGVhc2UgaW4gb3V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgKi9cbiAgICBFbGFzdGljRWFzZUluT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkLCBhLCBwKSB7XG4gICAgICAvLyBhZGRlZCBzID0gMFxuICAgICAgdmFyIHMgPSAwO1xuICAgICAgaWYgKHQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgICBpZiAoKHQgLz0gZCAvIDIpID09PSAyKSB7XG4gICAgICAgIHJldHVybiBiICsgYztcbiAgICAgIH1cbiAgICAgIGlmICghcCkge1xuICAgICAgICBwID0gZCAqICgwLjMgKiAxLjUpO1xuICAgICAgfVxuICAgICAgaWYgKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgICBhID0gYztcbiAgICAgICAgcyA9IHAgLyA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgIH1cbiAgICAgIGlmICh0IDwgMSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC0wLjUgKlxuICAgICAgICAgICAgKGEgKlxuICAgICAgICAgICAgICBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqXG4gICAgICAgICAgICAgIE1hdGguc2luKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKSArXG4gICAgICAgICAgYlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgYSAqXG4gICAgICAgICAgTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICpcbiAgICAgICAgICBNYXRoLnNpbigodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqXG4gICAgICAgICAgMC41ICtcbiAgICAgICAgYyArXG4gICAgICAgIGJcbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBib3VuY2UgZWFzZSBvdXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAqL1xuICAgIEJvdW5jZUVhc2VPdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIGlmICgodCAvPSBkKSA8IDEgLyAyLjc1KSB7XG4gICAgICAgIHJldHVybiBjICogKDcuNTYyNSAqIHQgKiB0KSArIGI7XG4gICAgICB9IGVsc2UgaWYgKHQgPCAyIC8gMi43NSkge1xuICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAxLjUgLyAyLjc1KSAqIHQgKyAwLjc1KSArIGI7XG4gICAgICB9IGVsc2UgaWYgKHQgPCAyLjUgLyAyLjc1KSB7XG4gICAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09IDIuMjUgLyAyLjc1KSAqIHQgKyAwLjkzNzUpICsgYjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09IDIuNjI1IC8gMi43NSkgKiB0ICsgMC45ODQzNzUpICsgYjtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGJvdW5jZSBlYXNlIGluXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgKi9cbiAgICBCb3VuY2VFYXNlSW46IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjIC0gS29udmEuRWFzaW5ncy5Cb3VuY2VFYXNlT3V0KGQgLSB0LCAwLCBjLCBkKSArIGI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBib3VuY2UgZWFzZSBpbiBvdXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAqL1xuICAgIEJvdW5jZUVhc2VJbk91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgaWYgKHQgPCBkIC8gMikge1xuICAgICAgICByZXR1cm4gS29udmEuRWFzaW5ncy5Cb3VuY2VFYXNlSW4odCAqIDIsIDAsIGMsIGQpICogMC41ICsgYjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgS29udmEuRWFzaW5ncy5Cb3VuY2VFYXNlT3V0KHQgKiAyIC0gZCwgMCwgYywgZCkgKiAwLjUgKyBjICogMC41ICsgYlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogZWFzZSBpblxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICovXG4gICAgRWFzZUluOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCArIGI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBlYXNlIG91dFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICovXG4gICAgRWFzZU91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGVhc2UgaW4gb3V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgKi9cbiAgICBFYXNlSW5PdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSB7XG4gICAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICsgYjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtYyAvIDIgKiAoLS10ICogKHQgLSAyKSAtIDEpICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHN0cm9uZyBlYXNlIGluXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgKi9cbiAgICBTdHJvbmdFYXNlSW46IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHN0cm9uZyBlYXNlIG91dFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICovXG4gICAgU3Ryb25nRWFzZU91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0ICogdCArIDEpICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHN0cm9uZyBlYXNlIGluIG91dFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICovXG4gICAgU3Ryb25nRWFzZUluT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICBpZiAoKHQgLz0gZCAvIDIpIDwgMSkge1xuICAgICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMikgKyBiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogbGluZWFyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgKi9cbiAgICBMaW5lYXI6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogdCAvIGQgKyBiO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBLb252YS5ERCA9IHtcbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgYW5pbTogbmV3IEtvbnZhLkFuaW1hdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiID0gdGhpcy5kaXJ0eTtcbiAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgIHJldHVybiBiO1xuICAgIH0pLFxuICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgIGp1c3REcmFnZ2VkOiBmYWxzZSxcbiAgICBvZmZzZXQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICBub2RlOiBudWxsLFxuXG4gICAgLy8gbWV0aG9kc1xuICAgIF9kcmFnOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBkZCA9IEtvbnZhLkRELFxuICAgICAgICBub2RlID0gZGQubm9kZTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmICghZGQuaXNEcmFnZ2luZykge1xuICAgICAgICAgIHZhciBwb3MgPSBub2RlLmdldFN0YWdlKCkuZ2V0UG9pbnRlclBvc2l0aW9uKCk7XG4gICAgICAgICAgLy8gaXQgaXMgcG9zc2libGUgdGhhdCBwb3MgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgLy8gcmVhdHRhY2ggaXRcbiAgICAgICAgICBpZiAoIXBvcykge1xuICAgICAgICAgICAgbm9kZS5nZXRTdGFnZSgpLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgICAgIHBvcyA9IG5vZGUuZ2V0U3RhZ2UoKS5nZXRQb2ludGVyUG9zaXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRyYWdEaXN0YW5jZSA9IG5vZGUuZHJhZ0Rpc3RhbmNlKCk7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5tYXgoXG4gICAgICAgICAgICBNYXRoLmFicyhwb3MueCAtIGRkLnN0YXJ0UG9pbnRlclBvcy54KSxcbiAgICAgICAgICAgIE1hdGguYWJzKHBvcy55IC0gZGQuc3RhcnRQb2ludGVyUG9zLnkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBkcmFnRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLmdldFN0YWdlKCkuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICBpZiAoIWRkLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICBkZC5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICBub2RlLmZpcmUoXG4gICAgICAgICAgICAnZHJhZ3N0YXJ0JyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2RyYWdzdGFydCcsXG4gICAgICAgICAgICAgIHRhcmdldDogbm9kZSxcbiAgICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBhIHVzZXIgY2FuIHN0b3AgZHJhZ2dpbmcgaW5zaWRlIGBkcmFnc3RhcnRgXG4gICAgICAgICAgaWYgKCFub2RlLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLl9zZXREcmFnUG9zaXRpb24oZXZ0KTtcblxuICAgICAgICAvLyBleGVjdXRlIG9uZHJhZ21vdmUgaWYgZGVmaW5lZFxuICAgICAgICBub2RlLmZpcmUoXG4gICAgICAgICAgJ2RyYWdtb3ZlJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnZHJhZ21vdmUnLFxuICAgICAgICAgICAgdGFyZ2V0OiBub2RlLFxuICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9lbmREcmFnQmVmb3JlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBkZCA9IEtvbnZhLkRELFxuICAgICAgICBub2RlID0gZGQubm9kZSxcbiAgICAgICAgbGF5ZXI7XG5cbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGxheWVyID0gbm9kZS5nZXRMYXllcigpO1xuICAgICAgICBkZC5hbmltLnN0b3AoKTtcblxuICAgICAgICAvLyBvbmx5IGZpcmUgZHJhZ2VuZCBldmVudCBpZiB0aGUgZHJhZyBhbmQgZHJvcFxuICAgICAgICAvLyBvcGVyYXRpb24gYWN0dWFsbHkgc3RhcnRlZC5cbiAgICAgICAgaWYgKGRkLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICBkZC5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgZGQuanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgIEtvbnZhLmxpc3RlbkNsaWNrVGFwID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgICBldnQuZHJhZ0VuZE5vZGUgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBkZC5ub2RlO1xuXG4gICAgICAgIGlmIChub2RlLmdldExheWVyKCkgfHwgbGF5ZXIgfHwgbm9kZSBpbnN0YW5jZW9mIEtvbnZhLlN0YWdlKSB7XG4gICAgICAgICAgKGxheWVyIHx8IG5vZGUpLmRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX2VuZERyYWdBZnRlcjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBldnQgPSBldnQgfHwge307XG4gICAgICB2YXIgZHJhZ0VuZE5vZGUgPSBldnQuZHJhZ0VuZE5vZGU7XG5cbiAgICAgIGlmIChldnQgJiYgZHJhZ0VuZE5vZGUpIHtcbiAgICAgICAgZHJhZ0VuZE5vZGUuZmlyZShcbiAgICAgICAgICAnZHJhZ2VuZCcsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ2RyYWdlbmQnLFxuICAgICAgICAgICAgdGFyZ2V0OiBkcmFnRW5kTm9kZSxcbiAgICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIE5vZGUgZXh0ZW5kZXJzXG5cbiAgLyoqXG4gICAqIGluaXRpYXRlIGRyYWcgYW5kIGRyb3BcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICovXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLnN0YXJ0RHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZCA9IEtvbnZhLkRELFxuICAgICAgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCksXG4gICAgICBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgIHBvcyA9IHN0YWdlLmdldFBvaW50ZXJQb3NpdGlvbigpLFxuICAgICAgYXAgPSB0aGlzLmdldEFic29sdXRlUG9zaXRpb24oKTtcblxuICAgIGlmIChwb3MpIHtcbiAgICAgIGlmIChkZC5ub2RlKSB7XG4gICAgICAgIGRkLm5vZGUuc3RvcERyYWcoKTtcbiAgICAgIH1cblxuICAgICAgZGQubm9kZSA9IHRoaXM7XG4gICAgICBkZC5zdGFydFBvaW50ZXJQb3MgPSBwb3M7XG4gICAgICBkZC5vZmZzZXQueCA9IHBvcy54IC0gYXAueDtcbiAgICAgIGRkLm9mZnNldC55ID0gcG9zLnkgLSBhcC55O1xuICAgICAgZGQuYW5pbS5zZXRMYXllcnMobGF5ZXIgfHwgdGhpcy5nZXRMYXllcnMoKSk7XG4gICAgICBkZC5hbmltLnN0YXJ0KCk7XG5cbiAgICAgIHRoaXMuX3NldERyYWdQb3NpdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBLb252YS5Ob2RlLnByb3RvdHlwZS5fc2V0RHJhZ1Bvc2l0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICBwb3MgPSB0aGlzLmdldFN0YWdlKCkuZ2V0UG9pbnRlclBvc2l0aW9uKCksXG4gICAgICBkYmYgPSB0aGlzLmdldERyYWdCb3VuZEZ1bmMoKTtcbiAgICBpZiAoIXBvcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV3Tm9kZVBvcyA9IHtcbiAgICAgIHg6IHBvcy54IC0gZGQub2Zmc2V0LngsXG4gICAgICB5OiBwb3MueSAtIGRkLm9mZnNldC55XG4gICAgfTtcblxuICAgIGlmIChkYmYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3Tm9kZVBvcyA9IGRiZi5jYWxsKHRoaXMsIG5ld05vZGVQb3MsIGV2dCk7XG4gICAgfVxuICAgIHRoaXMuc2V0QWJzb2x1dGVQb3NpdGlvbihuZXdOb2RlUG9zKTtcblxuICAgIGlmIChcbiAgICAgICF0aGlzLl9sYXN0UG9zIHx8XG4gICAgICB0aGlzLl9sYXN0UG9zLnggIT09IG5ld05vZGVQb3MueCB8fFxuICAgICAgdGhpcy5fbGFzdFBvcy55ICE9PSBuZXdOb2RlUG9zLnlcbiAgICApIHtcbiAgICAgIGRkLmFuaW0uZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RQb3MgPSBuZXdOb2RlUG9zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBzdG9wIGRyYWcgYW5kIGRyb3BcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICovXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLnN0b3BEcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICBldnQgPSB7fTtcbiAgICBkZC5fZW5kRHJhZ0JlZm9yZShldnQpO1xuICAgIGRkLl9lbmREcmFnQWZ0ZXIoZXZ0KTtcbiAgfTtcblxuICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXREcmFnZ2FibGUgPSBmdW5jdGlvbihkcmFnZ2FibGUpIHtcbiAgICB0aGlzLl9zZXRBdHRyKCdkcmFnZ2FibGUnLCBkcmFnZ2FibGUpO1xuICAgIHRoaXMuX2RyYWdDaGFuZ2UoKTtcbiAgfTtcblxuICB2YXIgb3JpZ1JlbW92ZSA9IEtvbnZhLk5vZGUucHJvdG90eXBlLnJlbW92ZTtcblxuICBLb252YS5Ob2RlLnByb3RvdHlwZS5fX29yaWdpbmFsUmVtb3ZlID0gb3JpZ1JlbW92ZTtcbiAgS29udmEuTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRkID0gS29udmEuREQ7XG5cbiAgICAvLyBzdG9wIEREXG4gICAgaWYgKGRkLm5vZGUgJiYgZGQubm9kZS5faWQgPT09IHRoaXMuX2lkKSB7XG4gICAgICB0aGlzLnN0b3BEcmFnKCk7XG4gICAgfVxuXG4gICAgb3JpZ1JlbW92ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBpcyBjdXJyZW50bHkgaW4gZHJhZyBhbmQgZHJvcCBtb2RlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqL1xuICBLb252YS5Ob2RlLnByb3RvdHlwZS5pc0RyYWdnaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRkID0gS29udmEuREQ7XG4gICAgcmV0dXJuICEhKGRkLm5vZGUgJiYgZGQubm9kZS5faWQgPT09IHRoaXMuX2lkICYmIGRkLmlzRHJhZ2dpbmcpO1xuICB9O1xuXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLl9saXN0ZW5EcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgdGhpcy5fZHJhZ0NsZWFudXAoKTtcblxuICAgIGlmICh0aGlzLmdldENsYXNzTmFtZSgpID09PSAnU3RhZ2UnKSB7XG4gICAgICB0aGlzLm9uKCdjb250ZW50TW91c2Vkb3duLmtvbnZhIGNvbnRlbnRUb3VjaHN0YXJ0LmtvbnZhJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghS29udmEuREQubm9kZSkge1xuICAgICAgICAgIHRoYXQuc3RhcnREcmFnKGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdtb3VzZWRvd24ua29udmEgdG91Y2hzdGFydC5rb252YScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAvLyBpZ25vcmUgcmlnaHQgYW5kIG1pZGRsZSBidXR0b25zXG4gICAgICAgIGlmIChldnQuZXZ0LmJ1dHRvbiA9PT0gMSB8fCBldnQuZXZ0LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUtvbnZhLkRELm5vZGUpIHtcbiAgICAgICAgICB0aGF0LnN0YXJ0RHJhZyhldnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBsaXN0ZW5pbmcgaXMgcmVxdWlyZWQgZm9yIGRyYWcgYW5kIGRyb3BcbiAgICAvKlxuICAgICAgICB0aGlzLl9saXN0ZW5pbmdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kQW5jZXN0b3JDYWNoZSgnbGlzdGVuaW5nRW5hYmxlZCcpO1xuICAgICAgICAqL1xuICB9O1xuXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLl9kcmFnQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYXR0cnMuZHJhZ2dhYmxlKSB7XG4gICAgICB0aGlzLl9saXN0ZW5EcmFnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHRoaXMuX2RyYWdDbGVhbnVwKCk7XG5cbiAgICAgIC8qXG4gICAgICAgICAgICAgKiBmb3JjZSBkcmFnIGFuZCBkcm9wIHRvIGVuZFxuICAgICAgICAgICAgICogaWYgdGhpcyBub2RlIGlzIGN1cnJlbnRseSBpblxuICAgICAgICAgICAgICogZHJhZyBhbmQgZHJvcCBtb2RlXG4gICAgICAgICAgICAgKi9cbiAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgIHZhciBkZCA9IEtvbnZhLkREO1xuICAgICAgaWYgKHN0YWdlICYmIGRkLm5vZGUgJiYgZGQubm9kZS5faWQgPT09IHRoaXMuX2lkKSB7XG4gICAgICAgIGRkLm5vZGUuc3RvcERyYWcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgS29udmEuTm9kZS5wcm90b3R5cGUuX2RyYWdDbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ2V0Q2xhc3NOYW1lKCkgPT09ICdTdGFnZScpIHtcbiAgICAgIHRoaXMub2ZmKCdjb250ZW50TW91c2Vkb3duLmtvbnZhJyk7XG4gICAgICB0aGlzLm9mZignY29udGVudFRvdWNoc3RhcnQua29udmEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmYoJ21vdXNlZG93bi5rb252YScpO1xuICAgICAgdGhpcy5vZmYoJ3RvdWNoc3RhcnQua29udmEnKTtcbiAgICB9XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdCb3VuZEZ1bmMnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBkcmFnIGJvdW5kIGZ1bmN0aW9uLiAgVGhpcyBpcyB1c2VkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0XG4gICAqICBkcmFnIGFuZCBkcm9wIHBvc2l0aW9uLlxuICAgKiBAbmFtZSBkcmFnQm91bmRGdW5jXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWdCb3VuZEZ1bmNcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZHJhZyBib3VuZCBmdW5jdGlvblxuICAgKiB2YXIgZHJhZ0JvdW5kRnVuYyA9IG5vZGUuZHJhZ0JvdW5kRnVuYygpO1xuICAgKlxuICAgKiAvLyBjcmVhdGUgdmVydGljYWwgZHJhZyBhbmQgZHJvcFxuICAgKiBub2RlLmRyYWdCb3VuZEZ1bmMoZnVuY3Rpb24ocG9zKXtcbiAgICogICAvLyBpbXBvcnRhbnQgcG9zIC0gaXMgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAvLyB5b3Ugc2hvdWxkIHJldHVybiBhYnNvbHV0ZSBwb3NpdGlvbiB0b29cbiAgICogICByZXR1cm4ge1xuICAgKiAgICAgeDogdGhpcy5nZXRBYnNvbHV0ZVBvc2l0aW9uKCkueCxcbiAgICogICAgIHk6IHBvcy55XG4gICAqICAgfTtcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLk5vZGUsICdkcmFnZ2FibGUnLCBmYWxzZSk7XG4gIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZHJhZ2dhYmxlJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZHJhZ2dhYmxlIGZsYWdcbiAgICogQG5hbWUgZHJhZ2dhYmxlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZHJhZ2dhYmxlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZHJhZ2dhYmxlIGZsYWdcbiAgICogdmFyIGRyYWdnYWJsZSA9IG5vZGUuZHJhZ2dhYmxlKCk7XG4gICAqXG4gICAqIC8vIGVuYWJsZSBkcmFnIGFuZCBkcm9wXG4gICAqIG5vZGUuZHJhZ2dhYmxlKHRydWUpO1xuICAgKlxuICAgKiAvLyBkaXNhYmxlIGRyYWcgYW5kIGRyb3BcbiAgICogbm9kZS5kcmFnZ2FibGUoZmFsc2UpO1xuICAgKi9cblxuICBpZiAoS29udmEuaXNCcm93c2VyKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBLb252YS5ERC5fZW5kRHJhZ0JlZm9yZSwgdHJ1ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgS29udmEuREQuX2VuZERyYWdCZWZvcmUsIHRydWUpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIEtvbnZhLkRELl9kcmFnKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgS29udmEuREQuX2RyYWcpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBLb252YS5ERC5fZW5kRHJhZ0FmdGVyLCBmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgS29udmEuREQuX2VuZERyYWdBZnRlciwgZmFsc2UpO1xuICB9XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIFJlY3QgY29uc3RydWN0b3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jb3JuZXJSYWRpdXNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVjdCA9IG5ldyBLb252YS5SZWN0KHtcbiAgICogICB3aWR0aDogMTAwLFxuICAgKiAgIGhlaWdodDogNTAsXG4gICAqICAgZmlsbDogJ3JlZCcsXG4gICAqICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgKiAgIHN0cm9rZVdpZHRoOiA1XG4gICAqIH0pO1xuICAgKi9cbiAgS29udmEuUmVjdCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlJlY3QucHJvdG90eXBlID0ge1xuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUmVjdCc7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IHRoaXMuZ2V0Q29ybmVyUmFkaXVzKCksXG4gICAgICAgIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICBpZiAoIWNvcm5lclJhZGl1cykge1xuICAgICAgICAvLyBzaW1wbGUgcmVjdCAtIGRvbid0IGJvdGhlciBkb2luZyBhbGwgdGhhdCBjb21wbGljYXRlZCBtYXRocyBzdHVmZi5cbiAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXJjVG8gd291bGQgYmUgbmljZXIsIGJ1dCBicm93c2VyIHN1cHBvcnQgaXMgcGF0Y2h5IChPcGVyYSlcbiAgICAgICAgY29ybmVyUmFkaXVzID0gTWF0aC5taW4oY29ybmVyUmFkaXVzLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhjb3JuZXJSYWRpdXMsIDApO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAtIGNvcm5lclJhZGl1cywgMCk7XG4gICAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAgIHdpZHRoIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgTWF0aC5QSSAqIDMgLyAyLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIGhlaWdodCAtIGNvcm5lclJhZGl1cyk7XG4gICAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAgIHdpZHRoIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGhlaWdodCAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBNYXRoLlBJIC8gMixcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhjb3JuZXJSYWRpdXMsIGhlaWdodCk7XG4gICAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBoZWlnaHQgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIE1hdGguUEkgLyAyLFxuICAgICAgICAgIE1hdGguUEksXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oMCwgY29ybmVyUmFkaXVzKTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICBNYXRoLlBJICogMyAvIDIsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuUmVjdCwgS29udmEuU2hhcGUpO1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlJlY3QsXG4gICAgJ2Nvcm5lclJhZGl1cycsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGNvcm5lciByYWRpdXNcbiAgICogQG5hbWUgY29ybmVyUmFkaXVzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlJlY3QucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3JuZXJSYWRpdXNcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNvcm5lciByYWRpdXNcbiAgICogdmFyIGNvcm5lclJhZGl1cyA9IHJlY3QuY29ybmVyUmFkaXVzKCk7XG4gICAqXG4gICAqIC8vIHNldCBjb3JuZXIgcmFkaXVzXG4gICAqIHJlY3QuY29ybmVyUmFkaXVzKDEwKTtcbiAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlJlY3QpO1xufSkoKTtcblxuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gdGhlIDAuMDAwMSBvZmZzZXQgZml4ZXMgYSBidWcgaW4gQ2hyb21lIDI3XG4gIHZhciBQSXgyID0gTWF0aC5QSSAqIDIgLSAwLjAwMDEsXG4gICAgQ0lSQ0xFID0gJ0NpcmNsZSc7XG5cbiAgLyoqXG4gICAqIENpcmNsZSBjb25zdHJ1Y3RvclxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucmFkaXVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBjcmVhdGUgY2lyY2xlXG4gICAqIHZhciBjaXJjbGUgPSBuZXcgS29udmEuQ2lyY2xlKHtcbiAgICogICByYWRpdXM6IDQwLFxuICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgKiAgIHN0cm9rZTogJ2JsYWNrJ1xuICAgKiAgIHN0cm9rZVdpZHRoOiA1XG4gICAqIH0pO1xuICAgKi9cbiAgS29udmEuQ2lyY2xlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuQ2lyY2xlLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IENJUkNMRTtcbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRSYWRpdXMoKSwgMCwgUEl4MiwgZmFsc2UpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICB0aGlzLnNldFJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQ2lyY2xlLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5DaXJjbGUsXG4gICAgJ3JhZGl1cycsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG4gIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5DaXJjbGUsICdyYWRpdXMnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCByYWRpdXNcbiAgICogQG5hbWUgcmFkaXVzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkNpcmNsZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgcmFkaXVzXG4gICAqIHZhciByYWRpdXMgPSBjaXJjbGUucmFkaXVzKCk7XG4gICAqXG4gICAqIC8vIHNldCByYWRpdXNcbiAgICogY2lyY2xlLnJhZGl1cygxMCk7XG4gICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5DaXJjbGUpO1xufSkoS29udmEpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gdGhlIDAuMDAwMSBvZmZzZXQgZml4ZXMgYSBidWcgaW4gQ2hyb21lIDI3XG4gIHZhciBQSXgyID0gTWF0aC5QSSAqIDIgLSAwLjAwMDEsXG4gICAgRUxMSVBTRSA9ICdFbGxpcHNlJztcblxuICAvKipcbiAgICogRWxsaXBzZSBjb25zdHJ1Y3RvclxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5yYWRpdXMgZGVmaW5lcyB4IGFuZCB5IHJhZGl1c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGVsbGlwc2UgPSBuZXcgS29udmEuRWxsaXBzZSh7XG4gICAqICAgcmFkaXVzIDoge1xuICAgKiAgICAgeCA6IDUwLFxuICAgKiAgICAgeSA6IDUwXG4gICAqICAgfSxcbiAgICogICBmaWxsOiAncmVkJ1xuICAgKiB9KTtcbiAgICovXG4gIEtvbnZhLkVsbGlwc2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5FbGxpcHNlLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IEVMTElQU0U7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIHJ4ID0gdGhpcy5nZXRSYWRpdXNYKCksXG4gICAgICAgIHJ5ID0gdGhpcy5nZXRSYWRpdXNZKCk7XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGlmIChyeCAhPT0gcnkpIHtcbiAgICAgICAgY29udGV4dC5zY2FsZSgxLCByeSAvIHJ4KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHJ4LCAwLCBQSXgyLCBmYWxzZSk7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldFdpZHRoKClcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXNYKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzWSgpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgdGhpcy5zZXRSYWRpdXMoe1xuICAgICAgICB4OiB3aWR0aCAvIDJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgIHRoaXMuc2V0UmFkaXVzKHtcbiAgICAgICAgeTogaGVpZ2h0IC8gMlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5FbGxpcHNlLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuRWxsaXBzZSwgJ3JhZGl1cycsIFsneCcsICd5J10pO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHJhZGl1c1xuICAgKiBAbmFtZSByYWRpdXNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuRWxsaXBzZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHJhZGl1c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzLnhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cy55XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCByYWRpdXNcbiAgICogdmFyIHJhZGl1cyA9IGVsbGlwc2UucmFkaXVzKCk7XG4gICAqXG4gICAqIC8vIHNldCByYWRpdXNcbiAgICogZWxsaXBzZS5yYWRpdXMoe1xuICAgKiAgIHg6IDIwMCxcbiAgICogICB5OiAxMDBcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLkVsbGlwc2UsXG4gICAgJ3JhZGl1c1gnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCByYWRpdXMgeFxuICAgKiBAbmFtZSByYWRpdXNYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkVsbGlwc2UucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCByYWRpdXMgeFxuICAgKiB2YXIgcmFkaXVzWCA9IGVsbGlwc2UucmFkaXVzWCgpO1xuICAgKlxuICAgKiAvLyBzZXQgcmFkaXVzIHhcbiAgICogZWxsaXBzZS5yYWRpdXNYKDIwMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLkVsbGlwc2UsXG4gICAgJ3JhZGl1c1knLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCByYWRpdXMgeVxuICAgKiBAbmFtZSByYWRpdXNZXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkVsbGlwc2UucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCByYWRpdXMgeVxuICAgKiB2YXIgcmFkaXVzWSA9IGVsbGlwc2UucmFkaXVzWSgpO1xuICAgKlxuICAgKiAvLyBzZXQgcmFkaXVzIHlcbiAgICogZWxsaXBzZS5yYWRpdXNZKDIwMCk7XG4gICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5FbGxpcHNlKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyB0aGUgMC4wMDAxIG9mZnNldCBmaXhlcyBhIGJ1ZyBpbiBDaHJvbWUgMjdcbiAgdmFyIFBJeDIgPSBNYXRoLlBJICogMiAtIDAuMDAwMTtcbiAgLyoqXG4gICAqIFJpbmcgY29uc3RydWN0b3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5vdXRlclJhZGl1c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xvY2t3aXNlXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHJpbmcgPSBuZXcgS29udmEuUmluZyh7XG4gICAqICAgaW5uZXJSYWRpdXM6IDQwLFxuICAgKiAgIG91dGVyUmFkaXVzOiA4MCxcbiAgICogICBmaWxsOiAncmVkJyxcbiAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAqICAgc3Ryb2tlV2lkdGg6IDVcbiAgICogfSk7XG4gICAqL1xuICBLb252YS5SaW5nID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuUmluZy5wcm90b3R5cGUgPSB7XG4gICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUmluZyc7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0SW5uZXJSYWRpdXMoKSwgMCwgUEl4MiwgZmFsc2UpO1xuICAgICAgY29udGV4dC5tb3ZlVG8odGhpcy5nZXRPdXRlclJhZGl1cygpLCAwKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSwgUEl4MiwgMCwgdHJ1ZSk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRIZWlnaHQoKVxuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgaWYgKHRoaXMub3V0ZXJSYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICBpZiAodGhpcy5vdXRlclJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRPdXRlclJhZGl1czogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyKCdvdXRlclJhZGl1cycsIHZhbCk7XG4gICAgICB0aGlzLnNldFdpZHRoKHZhbCAqIDIpO1xuICAgICAgdGhpcy5zZXRIZWlnaHQodmFsICogMik7XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5SaW5nLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5SaW5nLFxuICAgICdpbm5lclJhZGl1cycsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgaW5uZXJSYWRpdXNcbiAgICogQG5hbWUgaW5uZXJSYWRpdXNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuUmluZy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyUmFkaXVzXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBpbm5lciByYWRpdXNcbiAgICogdmFyIGlubmVyUmFkaXVzID0gcmluZy5pbm5lclJhZGl1cygpO1xuICAgKlxuICAgKiAvLyBzZXQgaW5uZXIgcmFkaXVzXG4gICAqIHJpbmcuaW5uZXJSYWRpdXMoMjApO1xuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoXG4gICAgS29udmEuUmluZyxcbiAgICAnb3V0ZXJSYWRpdXMnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuUmluZywgJ291dGVyUmFkaXVzJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgb3V0ZXJSYWRpdXNcbiAgICogQG5hbWUgb3V0ZXJSYWRpdXNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuUmluZy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyUmFkaXVzXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBvdXRlciByYWRpdXNcbiAgICogdmFyIG91dGVyUmFkaXVzID0gcmluZy5vdXRlclJhZGl1cygpO1xuICAgKlxuICAgKiAvLyBzZXQgb3V0ZXIgcmFkaXVzXG4gICAqIHJpbmcub3V0ZXJSYWRpdXMoMjApO1xuICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuUmluZyk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIFdlZGdlIGNvbnN0cnVjdG9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLmFuZ2xlIGluIGRlZ3JlZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5yYWRpdXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsb2Nrd2lzZV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGRyYXcgYSB3ZWRnZSB0aGF0J3MgcG9pbnRpbmcgZG93bndhcmRzXG4gICAqIHZhciB3ZWRnZSA9IG5ldyBLb252YS5XZWRnZSh7XG4gICAqICAgcmFkaXVzOiA0MCxcbiAgICogICBmaWxsOiAncmVkJyxcbiAgICogICBzdHJva2U6ICdibGFjaydcbiAgICogICBzdHJva2VXaWR0aDogNSxcbiAgICogICBhbmdsZURlZzogNjAsXG4gICAqICAgcm90YXRpb25EZWc6IC0xMjBcbiAgICogfSk7XG4gICAqL1xuICBLb252YS5XZWRnZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLldlZGdlLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdXZWRnZSc7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLmdldFJhZGl1cygpLFxuICAgICAgICAwLFxuICAgICAgICBLb252YS5nZXRBbmdsZSh0aGlzLmdldEFuZ2xlKCkpLFxuICAgICAgICB0aGlzLmdldENsb2Nrd2lzZSgpXG4gICAgICApO1xuICAgICAgY29udGV4dC5saW5lVG8oMCwgMCk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgdGhpcy5zZXRSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5XZWRnZSwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuV2VkZ2UsXG4gICAgJ3JhZGl1cycsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgcmFkaXVzXG4gICAqIEBuYW1lIHJhZGl1c1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5XZWRnZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgcmFkaXVzXG4gICAqIHZhciByYWRpdXMgPSB3ZWRnZS5yYWRpdXMoKTtcbiAgICpcbiAgICogLy8gc2V0IHJhZGl1c1xuICAgKiB3ZWRnZS5yYWRpdXMoMTApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5XZWRnZSxcbiAgICAnYW5nbGUnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGFuZ2xlIGluIGRlZ3JlZXNcbiAgICogQG5hbWUgYW5nbGVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuV2VkZ2UucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgYW5nbGVcbiAgICogdmFyIGFuZ2xlID0gd2VkZ2UuYW5nbGUoKTtcbiAgICpcbiAgICogLy8gc2V0IGFuZ2xlXG4gICAqIHdlZGdlLmFuZ2xlKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuV2VkZ2UsICdjbG9ja3dpc2UnLCBmYWxzZSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgY2xvY2t3aXNlIGZsYWdcbiAgICogQG5hbWUgY2xvY2t3aXNlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLldlZGdlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gY2xvY2t3aXNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBjbG9ja3dpc2UgZmxhZ1xuICAgKiB2YXIgY2xvY2t3aXNlID0gd2VkZ2UuY2xvY2t3aXNlKCk7XG4gICAqXG4gICAqIC8vIGRyYXcgd2VkZ2UgY291bnRlci1jbG9ja3dpc2VcbiAgICogd2VkZ2UuY2xvY2t3aXNlKGZhbHNlKTtcbiAgICpcbiAgICogLy8gZHJhdyB3ZWRnZSBjbG9ja3dpc2VcbiAgICogd2VkZ2UuY2xvY2t3aXNlKHRydWUpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmJhY2tDb21wYXQoS29udmEuV2VkZ2UsIHtcbiAgICBhbmdsZURlZzogJ2FuZ2xlJyxcbiAgICBnZXRBbmdsZURlZzogJ2dldEFuZ2xlJyxcbiAgICBzZXRBbmdsZURlZzogJ3NldEFuZ2xlJ1xuICB9KTtcblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuV2VkZ2UpO1xufSkoKTtcblxuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEFyYyBjb25zdHJ1Y3RvclxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5hbmdsZSBpbiBkZWdyZWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5vdXRlclJhZGl1c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xvY2t3aXNlXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZHJhdyBhIEFyYyB0aGF0J3MgcG9pbnRpbmcgZG93bndhcmRzXG4gICAqIHZhciBhcmMgPSBuZXcgS29udmEuQXJjKHtcbiAgICogICBpbm5lclJhZGl1czogNDAsXG4gICAqICAgb3V0ZXJSYWRpdXM6IDgwLFxuICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgKiAgIHN0cm9rZTogJ2JsYWNrJ1xuICAgKiAgIHN0cm9rZVdpZHRoOiA1LFxuICAgKiAgIGFuZ2xlOiA2MCxcbiAgICogICByb3RhdGlvbkRlZzogLTEyMFxuICAgKiB9KTtcbiAgICovXG4gIEtvbnZhLkFyYyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLkFyYy5wcm90b3R5cGUgPSB7XG4gICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQXJjJztcbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgYW5nbGUgPSBLb252YS5nZXRBbmdsZSh0aGlzLmFuZ2xlKCkpLFxuICAgICAgICBjbG9ja3dpc2UgPSB0aGlzLmNsb2Nrd2lzZSgpO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRPdXRlclJhZGl1cygpLCAwLCBhbmdsZSwgY2xvY2t3aXNlKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0SW5uZXJSYWRpdXMoKSwgYW5nbGUsIDAsICFjbG9ja3dpc2UpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgIGlmICh0aGlzLmdldE91dGVyUmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgaWYgKHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xuICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQXJjLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5BcmMsXG4gICAgJ2lubmVyUmFkaXVzJyxcbiAgICAwLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBpbm5lclJhZGl1c1xuICAgKiBAbmFtZSBpbm5lclJhZGl1c1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5BcmMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclJhZGl1c1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgaW5uZXIgcmFkaXVzXG4gICAqIHZhciBpbm5lclJhZGl1cyA9IGFyYy5pbm5lclJhZGl1cygpO1xuICAgKlxuICAgKiAvLyBzZXQgaW5uZXIgcmFkaXVzXG4gICAqIGFyYy5pbm5lclJhZGl1cygyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLkFyYyxcbiAgICAnb3V0ZXJSYWRpdXMnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IG91dGVyUmFkaXVzXG4gICAqIEBuYW1lIG91dGVyUmFkaXVzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkFyYy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyUmFkaXVzXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBvdXRlciByYWRpdXNcbiAgICogdmFyIG91dGVyUmFkaXVzID0gYXJjLm91dGVyUmFkaXVzKCk7XG4gICAqXG4gICAqIC8vIHNldCBvdXRlciByYWRpdXNcbiAgICogYXJjLm91dGVyUmFkaXVzKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuQXJjLFxuICAgICdhbmdsZScsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgYW5nbGUgaW4gZGVncmVlc1xuICAgKiBAbmFtZSBhbmdsZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5BcmMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgYW5nbGVcbiAgICogdmFyIGFuZ2xlID0gYXJjLmFuZ2xlKCk7XG4gICAqXG4gICAqIC8vIHNldCBhbmdsZVxuICAgKiBhcmMuYW5nbGUoMjApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcmMsICdjbG9ja3dpc2UnLCBmYWxzZSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgY2xvY2t3aXNlIGZsYWdcbiAgICogQG5hbWUgY2xvY2t3aXNlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkFyYy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBjbG9ja3dpc2VcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBjbG9ja3dpc2UgZmxhZ1xuICAgKiB2YXIgY2xvY2t3aXNlID0gYXJjLmNsb2Nrd2lzZSgpO1xuICAgKlxuICAgKiAvLyBkcmF3IGFyYyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgKiBhcmMuY2xvY2t3aXNlKGZhbHNlKTtcbiAgICpcbiAgICogLy8gZHJhdyBhcmMgY2xvY2t3aXNlXG4gICAqIGFyYy5jbG9ja3dpc2UodHJ1ZSk7XG4gICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5BcmMpO1xufSkoS29udmEpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gQ09OU1RBTlRTXG4gIHZhciBJTUFHRSA9ICdJbWFnZSc7XG5cbiAgLyoqXG4gICAqIEltYWdlIGNvbnN0cnVjdG9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtJbWFnZX0gY29uZmlnLmltYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNyb3BdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaW1hZ2VPYmogPSBuZXcgSW1hZ2UoKTtcbiAgICogaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAqICAgdmFyIGltYWdlID0gbmV3IEtvbnZhLkltYWdlKHtcbiAgICogICAgIHg6IDIwMCxcbiAgICogICAgIHk6IDUwLFxuICAgKiAgICAgaW1hZ2U6IGltYWdlT2JqLFxuICAgKiAgICAgd2lkdGg6IDEwMCxcbiAgICogICAgIGhlaWdodDogMTAwXG4gICAqICAgfSk7XG4gICAqIH07XG4gICAqIGltYWdlT2JqLnNyYyA9ICcvcGF0aC90by9pbWFnZS5qcGcnXG4gICAqL1xuICBLb252YS5JbWFnZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLkltYWdlLnByb3RvdHlwZSA9IHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gSU1BR0U7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgdGhpcy5oaXRGdW5jKHRoaXMuX2hpdEZ1bmMpO1xuICAgIH0sXG4gICAgX3VzZUJ1ZmZlckNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAodGhpcy5oYXNTaGFkb3coKSB8fCB0aGlzLmdldEFic29sdXRlT3BhY2l0eSgpICE9PSAxKSAmJlxuICAgICAgICB0aGlzLmhhc1N0cm9rZSgpICYmXG4gICAgICAgIHRoaXMuZ2V0U3RhZ2UoKVxuICAgICAgKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgaW1hZ2UgPSB0aGlzLmdldEltYWdlKCksXG4gICAgICAgIGNyb3BXaWR0aCxcbiAgICAgICAgY3JvcEhlaWdodCxcbiAgICAgICAgcGFyYW1zO1xuXG4gICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgY3JvcFdpZHRoID0gdGhpcy5nZXRDcm9wV2lkdGgoKTtcbiAgICAgICAgY3JvcEhlaWdodCA9IHRoaXMuZ2V0Q3JvcEhlaWdodCgpO1xuICAgICAgICBpZiAoY3JvcFdpZHRoICYmIGNyb3BIZWlnaHQpIHtcbiAgICAgICAgICBwYXJhbXMgPSBbXG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3JvcFgoKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3JvcFkoKSxcbiAgICAgICAgICAgIGNyb3BXaWR0aCxcbiAgICAgICAgICAgIGNyb3BIZWlnaHQsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbXMgPSBbaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc0ZpbGwoKSB8fCB0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZS5hcHBseShjb250ZXh0LCBwYXJhbXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2hpdEZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuZ2V0SW1hZ2UoKTtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJzLndpZHRoIHx8IChpbWFnZSA/IGltYWdlLndpZHRoIDogMCk7XG4gICAgfSxcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuaGVpZ2h0IHx8IChpbWFnZSA/IGltYWdlLmhlaWdodCA6IDApO1xuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuSW1hZ2UsIEtvbnZhLlNoYXBlKTtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnaW1hZ2UnKTtcblxuICAvKipcbiAgICogc2V0IGltYWdlXG4gICAqIEBuYW1lIHNldEltYWdlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgKi9cblxuICAvKipcbiAgICogZ2V0IGltYWdlXG4gICAqIEBuYW1lIGdldEltYWdlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgKiBAcmV0dXJucyB7SW1hZ2V9XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3AnLCBbXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnXG4gIF0pO1xuICAvKipcbiAgICogZ2V0L3NldCBjcm9wXG4gICAqIEBtZXRob2RcbiAgICogQG5hbWUgY3JvcFxuICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjcm9wXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjcm9wLnhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3AueVxuICAgKiBAcGFyYW0ge051bWJlcn0gY3JvcC53aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gY3JvcC5oZWlnaHRcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNyb3BcbiAgICogdmFyIGNyb3AgPSBpbWFnZS5jcm9wKCk7XG4gICAqXG4gICAqIC8vIHNldCBjcm9wXG4gICAqIGltYWdlLmNyb3Aoe1xuICAgKiAgIHg6IDIwLFxuICAgKiAgIHk6IDIwLFxuICAgKiAgIHdpZHRoOiAyMCxcbiAgICogICBoZWlnaHQ6IDIwXG4gICAqIH0pO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5JbWFnZSxcbiAgICAnY3JvcFgnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBjcm9wIHhcbiAgICogQG1ldGhvZFxuICAgKiBAbmFtZSBjcm9wWFxuICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBjcm9wIHhcbiAgICogdmFyIGNyb3BYID0gaW1hZ2UuY3JvcFgoKTtcbiAgICpcbiAgICogLy8gc2V0IGNyb3AgeFxuICAgKiBpbWFnZS5jcm9wWCgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLkltYWdlLFxuICAgICdjcm9wWScsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGNyb3AgeVxuICAgKiBAbmFtZSBjcm9wWVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNyb3AgeVxuICAgKiB2YXIgY3JvcFkgPSBpbWFnZS5jcm9wWSgpO1xuICAgKlxuICAgKiAvLyBzZXQgY3JvcCB5XG4gICAqIGltYWdlLmNyb3BZKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuSW1hZ2UsXG4gICAgJ2Nyb3BXaWR0aCcsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGNyb3Agd2lkdGhcbiAgICogQG5hbWUgY3JvcFdpZHRoXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNyb3Agd2lkdGhcbiAgICogdmFyIGNyb3BXaWR0aCA9IGltYWdlLmNyb3BXaWR0aCgpO1xuICAgKlxuICAgKiAvLyBzZXQgY3JvcCB3aWR0aFxuICAgKiBpbWFnZS5jcm9wV2lkdGgoMjApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5JbWFnZSxcbiAgICAnY3JvcEhlaWdodCcsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGNyb3AgaGVpZ2h0XG4gICAqIEBuYW1lIGNyb3BIZWlnaHRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNyb3AgaGVpZ2h0XG4gICAqIHZhciBjcm9wSGVpZ2h0ID0gaW1hZ2UuY3JvcEhlaWdodCgpO1xuICAgKlxuICAgKiAvLyBzZXQgY3JvcCBoZWlnaHRcbiAgICogaW1hZ2UuY3JvcEhlaWdodCgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5JbWFnZSk7XG5cbiAgLyoqXG4gICAqIGxvYWQgaW1hZ2UgZnJvbSBnaXZlbiB1cmwgYW5kIGNyZWF0ZSBgS29udmEuSW1hZ2VgIGluc3RhbmNlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgaW1hZ2Ugc291cmNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHdpdGggS29udmEuSW1hZ2UgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQGV4YW1wbGVcbiAgICogIEtvbnZhLkltYWdlLmZyb21VUkwoaW1hZ2VVUkwsIGZ1bmN0aW9uKGltYWdlKXtcbiAgICogICAgLy8gaW1hZ2UgaXMgS29udmEuSW1hZ2UgaW5zdGFuY2VcbiAgICogICAgbGF5ZXIuYWRkKGltYWdlKTtcbiAgICogICAgbGF5ZXIuZHJhdygpO1xuICAgKiAgfSk7XG4gICAqL1xuICBLb252YS5JbWFnZS5mcm9tVVJMID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1hZ2UgPSBuZXcgS29udmEuSW1hZ2Uoe1xuICAgICAgICBpbWFnZTogaW1nXG4gICAgICB9KTtcbiAgICAgIGNhbGxiYWNrKGltYWdlKTtcbiAgICB9O1xuICAgIGltZy5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgIGltZy5zcmMgPSB1cmw7XG4gIH07XG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIHZhciBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gLTE7XG4gIC8vIGNvbnN0YW50c1xuICB2YXIgQVVUTyA9ICdhdXRvJyxcbiAgICAvL0NBTlZBUyA9ICdjYW52YXMnLFxuICAgIENFTlRFUiA9ICdjZW50ZXInLFxuICAgIEpVU1RJRlkgPSAnanVzdGlmeScsXG4gICAgQ0hBTkdFX0tPTlZBID0gJ0NoYW5nZS5rb252YScsXG4gICAgQ09OVEVYVF8yRCA9ICcyZCcsXG4gICAgREFTSCA9ICctJyxcbiAgICBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICBMRUZUID0gJ2xlZnQnLFxuICAgIFRFWFQgPSAndGV4dCcsXG4gICAgVEVYVF9VUFBFUiA9ICdUZXh0JyxcbiAgICBUT1AgPSAndG9wJyxcbiAgICBCT1RUT00gPSAnYm90dG9tJyxcbiAgICBNSURETEUgPSAnbWlkZGxlJyxcbiAgICBOT1JNQUwgPSAnbm9ybWFsJyxcbiAgICBQWF9TUEFDRSA9ICdweCAnLFxuICAgIFNQQUNFID0gJyAnLFxuICAgIFJJR0hUID0gJ3JpZ2h0JyxcbiAgICBXT1JEID0gJ3dvcmQnLFxuICAgIENIQVIgPSAnY2hhcicsXG4gICAgTk9ORSA9ICdub25lJyxcbiAgICBFTExJUFNJUyA9ICfigKYnLFxuICAgIEFUVFJfQ0hBTkdFX0xJU1QgPSBbXG4gICAgICAnZm9udEZhbWlseScsXG4gICAgICAnZm9udFNpemUnLFxuICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAnZm9udFZhcmlhbnQnLFxuICAgICAgJ3BhZGRpbmcnLFxuICAgICAgJ2FsaWduJyxcbiAgICAgICd2ZXJ0aWNhbEFsaWduJyxcbiAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICd0ZXh0JyxcbiAgICAgICd3aWR0aCcsXG4gICAgICAnaGVpZ2h0JyxcbiAgICAgICd3cmFwJyxcbiAgICAgICdlbGxpcHNpcycsXG4gICAgICAnbGV0dGVyU3BhY2luZydcbiAgICBdLFxuICAgIC8vIGNhY2hlZCB2YXJpYWJsZXNcbiAgICBhdHRyQ2hhbmdlTGlzdExlbiA9IEFUVFJfQ0hBTkdFX0xJU1QubGVuZ3RoO1xuICB2YXIgZHVtbXlDb250ZXh0O1xuICBmdW5jdGlvbiBnZXREdW1teUNvbnRleHQoKSB7XG4gICAgaWYgKGR1bW15Q29udGV4dCkge1xuICAgICAgcmV0dXJuIGR1bW15Q29udGV4dDtcbiAgICB9XG4gICAgZHVtbXlDb250ZXh0ID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCkuZ2V0Q29udGV4dChDT05URVhUXzJEKTtcbiAgICByZXR1cm4gZHVtbXlDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRleHQgY29uc3RydWN0b3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250RmFtaWx5XSBkZWZhdWx0IGlzIEFyaWFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZvbnRTaXplXSBpbiBwaXhlbHMuICBEZWZhdWx0IGlzIDEyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRTdHlsZV0gY2FuIGJlIG5vcm1hbCwgYm9sZCwgb3IgaXRhbGljLiAgRGVmYXVsdCBpcyBub3JtYWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZm9udFZhcmlhbnRdIGNhbiBiZSBub3JtYWwgb3Igc21hbGwtY2Fwcy4gIERlZmF1bHQgaXMgbm9ybWFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGV4dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5hbGlnbl0gY2FuIGJlIGxlZnQsIGNlbnRlciwgb3IgcmlnaHRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcudmVydGljYWxBbGlnbl0gY2FuIGJlIHRvcCwgbWlkZGxlIG9yIGJvdHRvbVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wYWRkaW5nXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5saW5lSGVpZ2h0XSBkZWZhdWx0IGlzIDFcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcud3JhcF0gY2FuIGJlIHdvcmQsIGNoYXIsIG9yIG5vbmUuIERlZmF1bHQgaXMgd29yZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZWxsaXBzaXNdIGNhbiBiZSB0cnVlIG9yIGZhbHNlLiBEZWZhdWx0IGlzIGZhbHNlLiBpZiBLb252YS5UZXh0IGNvbmZpZyBpcyBzZXQgdG8gd3JhcD1cIm5vbmVcIiBhbmQgZWxsaXBzaXM9dHJ1ZSwgdGhlbiBpdCB3aWxsIGFkZCBcIi4uLlwiIHRvIHRoZSBlbmRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0ZXh0ID0gbmV3IEtvbnZhLlRleHQoe1xuICAgKiAgIHg6IDEwLFxuICAgKiAgIHk6IDE1LFxuICAgKiAgIHRleHQ6ICdTaW1wbGUgVGV4dCcsXG4gICAqICAgZm9udFNpemU6IDMwLFxuICAgKiAgIGZvbnRGYW1pbHk6ICdDYWxpYnJpJyxcbiAgICogICBmaWxsOiAnZ3JlZW4nXG4gICAqIH0pO1xuICAgKi9cbiAgS29udmEuVGV4dCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuICBmdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xuICAgIGNvbnRleHQuZmlsbFRleHQodGhpcy5wYXJ0aWFsVGV4dCwgMCwgMCk7XG4gIH1cbiAgZnVuY3Rpb24gX3N0cm9rZUZ1bmMoY29udGV4dCkge1xuICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0aGlzLnBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgfVxuXG4gIEtvbnZhLlRleHQucHJvdG90eXBlID0ge1xuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAvLyBzZXQgZGVmYXVsdCBjb2xvciB0byBibGFja1xuICAgICAgaWYgKFxuICAgICAgICAhY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMgJiZcbiAgICAgICAgIWNvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXG4gICAgICApIHtcbiAgICAgICAgY29uZmlnLmZpbGwgPSBjb25maWcuZmlsbCB8fCAnYmxhY2snO1xuICAgICAgfVxuICAgICAgLy9cbiAgICAgIC8vIGlmIChjb25maWcud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gICAgIGNvbmZpZy53aWR0aCA9IEFVVE87XG4gICAgICAvLyB9XG4gICAgICAvLyBpZiAoY29uZmlnLmhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAgICAgY29uZmlnLmhlaWdodCA9IEFVVE87XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcblxuICAgICAgdGhpcy5fZmlsbEZ1bmMgPSBfZmlsbEZ1bmM7XG4gICAgICB0aGlzLl9zdHJva2VGdW5jID0gX3N0cm9rZUZ1bmM7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IFRFWFRfVVBQRVI7XG5cbiAgICAgIC8vIHVwZGF0ZSB0ZXh0IGRhdGEgZm9yIGNlcnRhaW4gYXR0ciBjaGFuZ2VzXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGF0dHJDaGFuZ2VMaXN0TGVuOyBuKyspIHtcbiAgICAgICAgdGhpcy5vbihBVFRSX0NIQU5HRV9MSVNUW25dICsgQ0hBTkdFX0tPTlZBLCB0aGlzLl9zZXRUZXh0RGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFRleHREYXRhKCk7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgdGhpcy5oaXRGdW5jKHRoaXMuX2hpdEZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmdldFBhZGRpbmcoKSxcbiAgICAgICAgdGV4dEhlaWdodCA9IHRoaXMuZ2V0VGV4dEhlaWdodCgpLFxuICAgICAgICBsaW5lSGVpZ2h0UHggPSB0aGlzLmdldExpbmVIZWlnaHQoKSAqIHRleHRIZWlnaHQsXG4gICAgICAgIHRleHRBcnIgPSB0aGlzLnRleHRBcnIsXG4gICAgICAgIHRleHRBcnJMZW4gPSB0ZXh0QXJyLmxlbmd0aCxcbiAgICAgICAgdmVydGljYWxBbGlnbiA9IHRoaXMuZ2V0VmVydGljYWxBbGlnbigpLFxuICAgICAgICBhbGlnblkgPSAwLFxuICAgICAgICBhbGlnbiA9IHRoaXMuZ2V0QWxpZ24oKSxcbiAgICAgICAgdG90YWxXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgbGV0dGVyU3BhY2luZyA9IHRoaXMuZ2V0TGV0dGVyU3BhY2luZygpLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMudGV4dERlY29yYXRpb24oKSxcbiAgICAgICAgZmlsbCA9IHRoaXMuZmlsbCgpLFxuICAgICAgICBmb250U2l6ZSA9IHRoaXMuZm9udFNpemUoKSxcbiAgICAgICAgbjtcblxuICAgICAgY29udGV4dC5zZXRBdHRyKCdmb250JywgdGhpcy5fZ2V0Q29udGV4dEZvbnQoKSk7XG5cbiAgICAgIGNvbnRleHQuc2V0QXR0cigndGV4dEJhc2VsaW5lJywgTUlERExFKTtcbiAgICAgIGNvbnRleHQuc2V0QXR0cigndGV4dEFsaWduJywgTEVGVCk7XG5cbiAgICAgIC8vIGhhbmRsZSB2ZXJ0aWNhbCBhbGlnbm1lbnRcbiAgICAgIGlmICh2ZXJ0aWNhbEFsaWduID09PSBNSURETEUpIHtcbiAgICAgICAgYWxpZ25ZID1cbiAgICAgICAgICAodGhpcy5nZXRIZWlnaHQoKSAtIHRleHRBcnJMZW4gKiBsaW5lSGVpZ2h0UHggLSBwYWRkaW5nICogMikgLyAyO1xuICAgICAgfSBlbHNlIGlmICh2ZXJ0aWNhbEFsaWduID09PSBCT1RUT00pIHtcbiAgICAgICAgYWxpZ25ZID0gdGhpcy5nZXRIZWlnaHQoKSAtIHRleHRBcnJMZW4gKiBsaW5lSGVpZ2h0UHggLSBwYWRkaW5nICogMjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUocGFkZGluZywgMCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKDAsIGFsaWduWSArIHBhZGRpbmcgKyBsaW5lSGVpZ2h0UHggLyAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKDAsIGFsaWduWSArIGxpbmVIZWlnaHRQeCAvIDIpO1xuICAgICAgfVxuXG4gICAgICAvLyBkcmF3IHRleHQgbGluZXNcbiAgICAgIGZvciAobiA9IDA7IG4gPCB0ZXh0QXJyTGVuOyBuKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IHRleHRBcnJbbl0sXG4gICAgICAgICAgdGV4dCA9IG9iai50ZXh0LFxuICAgICAgICAgIHdpZHRoID0gb2JqLndpZHRoLFxuICAgICAgICAgIGxhc3RMaW5lID0gbiAhPT0gdGV4dEFyckxlbiAtIDEsXG4gICAgICAgICAgc3BhY2VzTnVtYmVyLFxuICAgICAgICAgIG9uZVdvcmQsXG4gICAgICAgICAgbGluZVdpZHRoO1xuXG4gICAgICAgIC8vIGhvcml6b250YWwgYWxpZ25tZW50XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBpZiAoYWxpZ24gPT09IFJJR0hUKSB7XG4gICAgICAgICAgY29udGV4dC50cmFuc2xhdGUodG90YWxXaWR0aCAtIHdpZHRoIC0gcGFkZGluZyAqIDIsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduID09PSBDRU5URVIpIHtcbiAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgodG90YWxXaWR0aCAtIHdpZHRoIC0gcGFkZGluZyAqIDIpIC8gMiwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dERlY29yYXRpb24uaW5kZXhPZigndW5kZXJsaW5lJykgIT09IC0xKSB7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIE1hdGgucm91bmQobGluZUhlaWdodFB4IC8gMikpO1xuICAgICAgICAgIHNwYWNlc051bWJlciA9IHRleHQuc3BsaXQoJyAnKS5sZW5ndGggLSAxO1xuICAgICAgICAgIG9uZVdvcmQgPSBzcGFjZXNOdW1iZXIgPT09IDA7XG4gICAgICAgICAgbGluZVdpZHRoID1cbiAgICAgICAgICAgIGFsaWduID09PSBKVVNUSUZZICYmIGxhc3RMaW5lICYmICFvbmVXb3JkXG4gICAgICAgICAgICAgID8gdG90YWxXaWR0aCAtIHBhZGRpbmcgKiAyXG4gICAgICAgICAgICAgIDogd2lkdGg7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8oTWF0aC5yb3VuZChsaW5lV2lkdGgpLCBNYXRoLnJvdW5kKGxpbmVIZWlnaHRQeCAvIDIpKTtcbiAgICAgICAgICAvLyBUT0RPOiBJIGhhdmUgbm8gaWRlYSB3aGF0IGlzIHJlYWwgcmF0aW9cbiAgICAgICAgICAvLyBqdXN0IC8xNSBsb29rcyBnb29kIGVub3VnaFxuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZm9udFNpemUgLyAxNTtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZmlsbDtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSAhPT0gLTEpIHtcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDApO1xuICAgICAgICAgIHNwYWNlc051bWJlciA9IHRleHQuc3BsaXQoJyAnKS5sZW5ndGggLSAxO1xuICAgICAgICAgIG9uZVdvcmQgPSBzcGFjZXNOdW1iZXIgPT09IDA7XG4gICAgICAgICAgbGluZVdpZHRoID1cbiAgICAgICAgICAgIGFsaWduID09PSBKVVNUSUZZICYmIGxhc3RMaW5lICYmICFvbmVXb3JkXG4gICAgICAgICAgICAgID8gdG90YWxXaWR0aCAtIHBhZGRpbmcgKiAyXG4gICAgICAgICAgICAgIDogd2lkdGg7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8oTWF0aC5yb3VuZChsaW5lV2lkdGgpLCAwKTtcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGZvbnRTaXplIC8gMTU7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGZpbGw7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV0dGVyU3BhY2luZyAhPT0gMCB8fCBhbGlnbiA9PT0gSlVTVElGWSkge1xuICAgICAgICAgIC8vICAgdmFyIHdvcmRzID0gdGV4dC5zcGxpdCgnICcpO1xuICAgICAgICAgIHNwYWNlc051bWJlciA9IHRleHQuc3BsaXQoJyAnKS5sZW5ndGggLSAxO1xuICAgICAgICAgIGZvciAodmFyIGxpID0gMDsgbGkgPCB0ZXh0Lmxlbmd0aDsgbGkrKykge1xuICAgICAgICAgICAgdmFyIGxldHRlciA9IHRleHRbbGldO1xuICAgICAgICAgICAgLy8gc2tpcCBqdXN0aWZ5IGZvciB0aGUgbGFzdCBsaW5lXG4gICAgICAgICAgICBpZiAobGV0dGVyID09PSAnICcgJiYgbiAhPT0gdGV4dEFyckxlbiAtIDEgJiYgYWxpZ24gPT09IEpVU1RJRlkpIHtcbiAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcigodG90YWxXaWR0aCAtIHBhZGRpbmcgKiAyIC0gd2lkdGgpIC8gc3BhY2VzTnVtYmVyKSxcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxUZXh0ID0gbGV0dGVyO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aGlzLl9nZXRUZXh0U2l6ZShsZXR0ZXIpLndpZHRoKSArIGxldHRlclNwYWNpbmcsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFydGlhbFRleHQgPSB0ZXh0O1xuXG4gICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIGlmICh0ZXh0QXJyTGVuID4gMSkge1xuICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKDAsIGxpbmVIZWlnaHRQeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF9oaXRGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICBzZXRUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgc3RyID0gS29udmEuVXRpbC5faXNTdHJpbmcodGV4dCkgPyB0ZXh0IDogKHRleHQgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLl9zZXRBdHRyKFRFWFQsIHN0cik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCB3aWR0aCBvZiB0ZXh0IGFyZWEsIHdoaWNoIGluY2x1ZGVzIHBhZGRpbmdcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXNBdXRvID0gdGhpcy5hdHRycy53aWR0aCA9PT0gQVVUTyB8fCB0aGlzLmF0dHJzLndpZHRoID09PSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gaXNBdXRvXG4gICAgICAgID8gdGhpcy5nZXRUZXh0V2lkdGgoKSArIHRoaXMuZ2V0UGFkZGluZygpICogMlxuICAgICAgICA6IHRoaXMuYXR0cnMud2lkdGg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGhlaWdodCBvZiB0aGUgdGV4dCBhcmVhLCB3aGljaCB0YWtlcyBpbnRvIGFjY291bnQgbXVsdGktbGluZSB0ZXh0LCBsaW5lIGhlaWdodHMsIGFuZCBwYWRkaW5nXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc0F1dG8gPVxuICAgICAgICB0aGlzLmF0dHJzLmhlaWdodCA9PT0gQVVUTyB8fCB0aGlzLmF0dHJzLmhlaWdodCA9PT0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGlzQXV0b1xuICAgICAgICA/IHRoaXMuZ2V0VGV4dEhlaWdodCgpICogdGhpcy50ZXh0QXJyLmxlbmd0aCAqIHRoaXMuZ2V0TGluZUhlaWdodCgpICtcbiAgICAgICAgICAgIHRoaXMuZ2V0UGFkZGluZygpICogMlxuICAgICAgICA6IHRoaXMuYXR0cnMuaGVpZ2h0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IHRleHQgd2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dFdpZHRoO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGhlaWdodCBvZiBvbmUgbGluZSB0ZXh0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0VGV4dEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0SGVpZ2h0O1xuICAgIH0sXG4gICAgX2dldFRleHRTaXplOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgX2NvbnRleHQgPSBnZXREdW1teUNvbnRleHQoKSxcbiAgICAgICAgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCksXG4gICAgICAgIG1ldHJpY3M7XG5cbiAgICAgIF9jb250ZXh0LnNhdmUoKTtcbiAgICAgIF9jb250ZXh0LmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xuXG4gICAgICBtZXRyaWNzID0gX2NvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICBfY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogbWV0cmljcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUludChmb250U2l6ZSwgMTApXG4gICAgICB9O1xuICAgIH0sXG4gICAgX2dldENvbnRleHRGb250OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIElFIGRvbid0IHdhbnQgdG8gd29yayB3aXRoIHVzdWFsIGZvbnQgc3R5bGVcbiAgICAgIC8vIGJvbGQgd2FzIG5vdCB3b3JraW5nXG4gICAgICAvLyByZW1vdmluZyBmb250IHZhcmlhbnQgd2lsbCBzb2x2ZVxuICAgICAgLy8gZml4IGZvcjogaHR0cHM6Ly9naXRodWIuY29tL2tvbnZhanMva29udmEvaXNzdWVzLzk0XG4gICAgICBpZiAoS29udmEuVUEuaXNJRSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHRoaXMuZ2V0Rm9udFN0eWxlKCkgK1xuICAgICAgICAgIFNQQUNFICtcbiAgICAgICAgICB0aGlzLmdldEZvbnRTaXplKCkgK1xuICAgICAgICAgIFBYX1NQQUNFICtcbiAgICAgICAgICB0aGlzLmdldEZvbnRGYW1pbHkoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5nZXRGb250U3R5bGUoKSArXG4gICAgICAgIFNQQUNFICtcbiAgICAgICAgdGhpcy5nZXRGb250VmFyaWFudCgpICtcbiAgICAgICAgU1BBQ0UgK1xuICAgICAgICB0aGlzLmdldEZvbnRTaXplKCkgK1xuICAgICAgICBQWF9TUEFDRSArXG4gICAgICAgIHRoaXMuZ2V0Rm9udEZhbWlseSgpXG4gICAgICApO1xuICAgIH0sXG4gICAgX2FkZFRleHRMaW5lOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBpZiAodGhpcy5hbGlnbigpID09PSBKVVNUSUZZKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChsaW5lKTtcbiAgICAgIHJldHVybiB0aGlzLnRleHRBcnIucHVzaCh7IHRleHQ6IGxpbmUsIHdpZHRoOiB3aWR0aCB9KTtcbiAgICB9LFxuICAgIF9nZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBsYXR0ZXJTcGFjaW5nID0gdGhpcy5nZXRMZXR0ZXJTcGFjaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBnZXREdW1teUNvbnRleHQoKS5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCArXG4gICAgICAgIChsZW5ndGggPyBsYXR0ZXJTcGFjaW5nICogKGxlbmd0aCAtIDEpIDogMClcbiAgICAgICk7XG4gICAgfSxcbiAgICBfc2V0VGV4dERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVzID0gdGhpcy5nZXRUZXh0KCkuc3BsaXQoJ1xcbicpLFxuICAgICAgICBmb250U2l6ZSA9ICt0aGlzLmdldEZvbnRTaXplKCksXG4gICAgICAgIHRleHRXaWR0aCA9IDAsXG4gICAgICAgIGxpbmVIZWlnaHRQeCA9IHRoaXMuZ2V0TGluZUhlaWdodCgpICogZm9udFNpemUsXG4gICAgICAgIHdpZHRoID0gdGhpcy5hdHRycy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5hdHRycy5oZWlnaHQsXG4gICAgICAgIGZpeGVkV2lkdGggPSB3aWR0aCAhPT0gQVVUTyxcbiAgICAgICAgZml4ZWRIZWlnaHQgPSBoZWlnaHQgIT09IEFVVE8sXG4gICAgICAgIHBhZGRpbmcgPSB0aGlzLmdldFBhZGRpbmcoKSxcbiAgICAgICAgbWF4V2lkdGggPSB3aWR0aCAtIHBhZGRpbmcgKiAyLFxuICAgICAgICBtYXhIZWlnaHRQeCA9IGhlaWdodCAtIHBhZGRpbmcgKiAyLFxuICAgICAgICBjdXJyZW50SGVpZ2h0UHggPSAwLFxuICAgICAgICB3cmFwID0gdGhpcy5nZXRXcmFwKCksXG4gICAgICAgIC8vIGFsaWduID0gdGhpcy5nZXRBbGlnbigpLFxuICAgICAgICBzaG91bGRXcmFwID0gd3JhcCAhPT0gTk9ORSxcbiAgICAgICAgd3JhcEF0V29yZCA9IHdyYXAgIT09IENIQVIgJiYgc2hvdWxkV3JhcCxcbiAgICAgICAgc2hvdWxkQWRkRWxsaXBzaXMgPSB0aGlzLmdldEVsbGlwc2lzKCkgJiYgIXNob3VsZFdyYXA7XG5cbiAgICAgIHRoaXMudGV4dEFyciA9IFtdO1xuICAgICAgZ2V0RHVtbXlDb250ZXh0KCkuZm9udCA9IHRoaXMuX2dldENvbnRleHRGb250KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoOyBpIDwgbWF4OyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxXaWR0aCA9IHNob3VsZEFkZEVsbGlwc2lzXG4gICAgICAgICAgPyB0aGlzLl9nZXRUZXh0V2lkdGgoRUxMSVBTSVMpXG4gICAgICAgICAgOiAwO1xuXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgobGluZSk7XG4gICAgICAgIGlmIChmaXhlZFdpZHRoICYmIGxpbmVXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAqIGlmIHdpZHRoIGlzIGZpeGVkIGFuZCBsaW5lIGRvZXMgbm90IGZpdCBlbnRpcmVseVxuICAgICAgICAgICogYnJlYWsgdGhlIGxpbmUgaW50byBtdWx0aXBsZSBmaXR0aW5nIGxpbmVzXG4gICAgICAgICAgKi9cbiAgICAgICAgICB3aGlsZSAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgKiB1c2UgYmluYXJ5IHNlYXJjaCB0byBmaW5kIHRoZSBsb25nZXN0IHN1YnN0cmluZyB0aGF0XG4gICAgICAgICAgICAqIHRoYXQgd291bGQgZml0IGluIHRoZSBzcGVjaWZpZWQgd2lkdGhcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICAgICAgaGlnaCA9IGxpbmUubGVuZ3RoLFxuICAgICAgICAgICAgICBtYXRjaCA9ICcnLFxuICAgICAgICAgICAgICBtYXRjaFdpZHRoID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgICAgc3Vic3RyID0gbGluZS5zbGljZSgwLCBtaWQgKyAxKSxcbiAgICAgICAgICAgICAgICBzdWJzdHJXaWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChzdWJzdHIpICsgYWRkaXRpb25hbFdpZHRoO1xuICAgICAgICAgICAgICBpZiAoc3Vic3RyV2lkdGggPD0gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gc3Vic3RyICsgKHNob3VsZEFkZEVsbGlwc2lzID8gRUxMSVBTSVMgOiAnJyk7XG4gICAgICAgICAgICAgICAgbWF0Y2hXaWR0aCA9IHN1YnN0cldpZHRoO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAqICdsb3cnIGlzIG5vdyB0aGUgaW5kZXggb2YgdGhlIHN1YnN0cmluZyBlbmRcbiAgICAgICAgICAgICogJ21hdGNoJyBpcyB0aGUgc3Vic3RyaW5nXG4gICAgICAgICAgICAqICdtYXRjaFdpZHRoJyBpcyB0aGUgc3Vic3RyaW5nIHdpZHRoIGluIHB4XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIC8vIGEgZml0dGluZyBzdWJzdHJpbmcgd2FzIGZvdW5kXG4gICAgICAgICAgICAgIGlmICh3cmFwQXRXb3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGZpbmQgYSBzcGFjZSBvciBkYXNoIHdoZXJlIHdyYXBwaW5nIGNvdWxkIGJlIGRvbmVcbiAgICAgICAgICAgICAgICB2YXIgd3JhcEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IGxpbmVbbWF0Y2gubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dElzU3BhY2VPckRhc2ggPSBuZXh0Q2hhciA9PT0gU1BBQ0UgfHwgbmV4dENoYXIgPT09IERBU0g7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRJc1NwYWNlT3JEYXNoICYmIG1hdGNoV2lkdGggPD0gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgIHdyYXBJbmRleCA9IG1hdGNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgd3JhcEluZGV4ID1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2gubGFzdEluZGV4T2YoU1BBQ0UpLFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLmxhc3RJbmRleE9mKERBU0gpXG4gICAgICAgICAgICAgICAgICAgICkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod3JhcEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gcmUtY3V0IHRoZSBzdWJzdHJpbmcgZm91bmQgYXQgdGhlIHNwYWNlL2Rhc2ggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgIGxvdyA9IHdyYXBJbmRleDtcbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2guc2xpY2UoMCwgbG93KTtcbiAgICAgICAgICAgICAgICAgIG1hdGNoV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgobWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBLb252YS5VdGlsLnRyaW1SaWdodChtYXRjaCk7XG4gICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobWF0Y2gpO1xuICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGgsIG1hdGNoV2lkdGgpO1xuICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0UHggKz0gbGluZUhlaWdodFB4O1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXNob3VsZFdyYXAgfHxcbiAgICAgICAgICAgICAgICAoZml4ZWRIZWlnaHQgJiYgY3VycmVudEhlaWdodFB4ICsgbGluZUhlaWdodFB4ID4gbWF4SGVpZ2h0UHgpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgKiBzdG9wIHdyYXBwaW5nIGlmIHdyYXBwaW5nIGlzIGRpc2FibGVkIG9yIGlmIGFkZGluZ1xuICAgICAgICAgICAgICAgICogb25lIG1vcmUgbGluZSB3b3VsZCBvdmVyZmxvdyB0aGUgZml4ZWQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShsb3cpO1xuICAgICAgICAgICAgICBsaW5lID0gS29udmEuVXRpbC50cmltTGVmdChsaW5lKTtcbiAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByZW1haW5pbmcgdGV4dCB3b3VsZCBmaXQgb24gb25lIGxpbmVcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgobGluZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA8PSBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgZG9lcywgYWRkIHRoZSBsaW5lIGFuZCBicmVhayBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRleHRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEhlaWdodFB4ICs9IGxpbmVIZWlnaHRQeDtcbiAgICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCwgbGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gbm90IGV2ZW4gb25lIGNoYXJhY3RlciBjb3VsZCBmaXQgaW4gdGhlIGVsZW1lbnQsIGFib3J0XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlbGVtZW50IHdpZHRoIGlzIGF1dG9tYXRpY2FsbHkgYWRqdXN0ZWQgdG8gbWF4IGxpbmUgd2lkdGhcbiAgICAgICAgICB0aGlzLl9hZGRUZXh0TGluZShsaW5lKTtcbiAgICAgICAgICBjdXJyZW50SGVpZ2h0UHggKz0gbGluZUhlaWdodFB4O1xuICAgICAgICAgIHRleHRXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCwgbGluZVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBlbGVtZW50IGhlaWdodCBpcyBmaXhlZCwgYWJvcnQgaWYgYWRkaW5nIG9uZSBtb3JlIGxpbmUgd291bGQgb3ZlcmZsb3dcbiAgICAgICAgaWYgKGZpeGVkSGVpZ2h0ICYmIGN1cnJlbnRIZWlnaHRQeCArIGxpbmVIZWlnaHRQeCA+IG1heEhlaWdodFB4KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dEhlaWdodCA9IGZvbnRTaXplO1xuICAgICAgLy8gdmFyIG1heFRleHRXaWR0aCA9IDA7XG4gICAgICAvLyBmb3IodmFyIGogPSAwOyBqIDwgdGhpcy50ZXh0QXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAvLyAgICAgbWF4VGV4dFdpZHRoID0gTWF0aC5tYXgobWF4VGV4dFdpZHRoLCB0aGlzLnRleHRBcnJbal0ud2lkdGgpO1xuICAgICAgLy8gfVxuICAgICAgdGhpcy50ZXh0V2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5UZXh0LCBLb252YS5TaGFwZSk7XG5cbiAgS29udmEuRmFjdG9yeS5hZGRTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnd2lkdGgnLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyT3JBdXRvVmFsaWRhdG9yKClcbiAgKTtcblxuICBLb252YS5GYWN0b3J5LmFkZFNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdoZWlnaHQnLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyT3JBdXRvVmFsaWRhdG9yKClcbiAgKTtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdmb250RmFtaWx5JywgJ0FyaWFsJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZm9udCBmYW1pbHlcbiAgICogQG5hbWUgZm9udEZhbWlseVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udEZhbWlseVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZm9udCBmYW1pbHlcbiAgICogdmFyIGZvbnRGYW1pbHkgPSB0ZXh0LmZvbnRGYW1pbHkoKTtcbiAgICpcbiAgICogLy8gc2V0IGZvbnQgZmFtaWx5XG4gICAqIHRleHQuZm9udEZhbWlseSgnQXJpYWwnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuVGV4dCxcbiAgICAnZm9udFNpemUnLFxuICAgIDEyLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmb250IHNpemUgaW4gcGl4ZWxzXG4gICAqIEBuYW1lIGZvbnRTaXplXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmb250U2l6ZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZm9udCBzaXplXG4gICAqIHZhciBmb250U2l6ZSA9IHRleHQuZm9udFNpemUoKTtcbiAgICpcbiAgICogLy8gc2V0IGZvbnQgc2l6ZSB0byAyMnB4XG4gICAqIHRleHQuZm9udFNpemUoMjIpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnZm9udFN0eWxlJywgTk9STUFMKTtcblxuICAvKipcbiAgICogc2V0IGZvbnQgc3R5bGUuICBDYW4gYmUgJ25vcm1hbCcsICdpdGFsaWMnLCBvciAnYm9sZCcuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cbiAgICogQG5hbWUgZm9udFN0eWxlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb250U3R5bGVcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZvbnQgc3R5bGVcbiAgICogdmFyIGZvbnRTdHlsZSA9IHRleHQuZm9udFN0eWxlKCk7XG4gICAqXG4gICAqIC8vIHNldCBmb250IHN0eWxlXG4gICAqIHRleHQuZm9udFN0eWxlKCdib2xkJyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdmb250VmFyaWFudCcsIE5PUk1BTCk7XG5cbiAgLyoqXG4gICAqIHNldCBmb250IHZhcmlhbnQuICBDYW4gYmUgJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnLiAgJ25vcm1hbCcgaXMgdGhlIGRlZmF1bHQuXG4gICAqIEBuYW1lIGZvbnRWYXJpYW50XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb250VmFyaWFudFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZm9udCB2YXJpYW50XG4gICAqIHZhciBmb250VmFyaWFudCA9IHRleHQuZm9udFZhcmlhbnQoKTtcbiAgICpcbiAgICogLy8gc2V0IGZvbnQgdmFyaWFudFxuICAgKiB0ZXh0LmZvbnRWYXJpYW50KCdzbWFsbC1jYXBzJyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlRleHQsXG4gICAgJ3BhZGRpbmcnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBzZXQgcGFkZGluZ1xuICAgKiBAbmFtZSBwYWRkaW5nXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYWRkaW5nXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBwYWRkaW5nXG4gICAqIHZhciBwYWRkaW5nID0gdGV4dC5wYWRkaW5nKCk7XG4gICAqXG4gICAqIC8vIHNldCBwYWRkaW5nIHRvIDEwIHBpeGVsc1xuICAgKiB0ZXh0LnBhZGRpbmcoMTApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnYWxpZ24nLCBMRUZUKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBob3Jpem9udGFsIGFsaWduIG9mIHRleHQuICBDYW4gYmUgJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0JyBvciAnanVzdGlmeSdcbiAgICogQG5hbWUgYWxpZ25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsaWduXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB0ZXh0IGFsaWduXG4gICAqIHZhciBhbGlnbiA9IHRleHQuYWxpZ24oKTtcbiAgICpcbiAgICogLy8gY2VudGVyIHRleHRcbiAgICogdGV4dC5hbGlnbignY2VudGVyJyk7XG4gICAqXG4gICAqIC8vIGFsaWduIHRleHQgdG8gcmlnaHRcbiAgICogdGV4dC5hbGlnbigncmlnaHQnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ3ZlcnRpY2FsQWxpZ24nLCBUT1ApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHZlcnRpY2FsIGFsaWduIG9mIHRleHQuICBDYW4gYmUgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJy5cbiAgICogQG5hbWUgdmVydGljYWxBbGlnblxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmVydGljYWxBbGlnblxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgdGV4dCB2ZXJ0aWNhbCBhbGlnblxuICAgKiB2YXIgdmVydGljYWxBbGlnbiA9IHRleHQudmVydGljYWxBbGlnbigpO1xuICAgKlxuICAgKiAvLyBjZW50ZXIgdGV4dFxuICAgKiB0ZXh0LnZlcnRpY2FsQWxpZ24oJ21pZGRsZScpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5UZXh0LFxuICAgICdsaW5lSGVpZ2h0JyxcbiAgICAxLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBsaW5lIGhlaWdodC4gIFRoZSBkZWZhdWx0IGlzIDEuXG4gICAqIEBuYW1lIGxpbmVIZWlnaHRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVIZWlnaHRcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGxpbmUgaGVpZ2h0XG4gICAqIHZhciBsaW5lSGVpZ2h0ID0gdGV4dC5saW5lSGVpZ2h0KCk7XG4gICAqXG4gICAqIC8vIHNldCB0aGUgbGluZSBoZWlnaHRcbiAgICogdGV4dC5saW5lSGVpZ2h0KDIpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnd3JhcCcsIFdPUkQpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHdyYXAuICBDYW4gYmUgd29yZCwgY2hhciwgb3Igbm9uZS4gRGVmYXVsdCBpcyB3b3JkLlxuICAgKiBAbmFtZSB3cmFwXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB3cmFwXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB3cmFwXG4gICAqIHZhciB3cmFwID0gdGV4dC53cmFwKCk7XG4gICAqXG4gICAqIC8vIHNldCB3cmFwXG4gICAqIHRleHQud3JhcCgnd29yZCcpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnZWxsaXBzaXMnLCBmYWxzZSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZWxsaXBzaXMuICBDYW4gYmUgdHJ1ZSBvciBmYWxzZS4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICogaWYgS29udmEuVGV4dCBjb25maWcgaXMgc2V0IHRvIHdyYXA9XCJub25lXCIgYW5kIGVsbGlwc2lzPXRydWUsIHRoZW4gaXQgd2lsbCBhZGQgXCIuLi5cIiB0byB0aGUgZW5kXG4gICAqIEBuYW1lIGVsbGlwc2lzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZWxsaXBzaXNcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBlbGxpcHNpc1xuICAgKiB2YXIgZWxsaXBzaXMgPSB0ZXh0LmVsbGlwc2lzKCk7XG4gICAqXG4gICAqIC8vIHNldCBlbGxpcHNpc1xuICAgKiB0ZXh0LmVsbGlwc2lzKHRydWUpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5UZXh0LFxuICAgICdsZXR0ZXJTcGFjaW5nJyxcbiAgICAwLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogc2V0IGxldHRlciBzcGFjaW5nIHByb3BlcnR5LiBEZWZhdWx0IHZhbHVlIGlzIDAuXG4gICAqIEBuYW1lIGxldHRlclNwYWNpbmdcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZXR0ZXJTcGFjaW5nXG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLlRleHQsICd0ZXh0JywgRU1QVFlfU1RSSU5HKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICd0ZXh0Jyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgdGV4dFxuICAgKiBAbmFtZSBnZXRUZXh0XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB0ZXh0XG4gICAqIHZhciB0ZXh0ID0gdGV4dC50ZXh0KCk7XG4gICAqXG4gICAqIC8vIHNldCB0ZXh0XG4gICAqIHRleHQudGV4dCgnSGVsbG8gd29ybGQhJyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICd0ZXh0RGVjb3JhdGlvbicsIEVNUFRZX1NUUklORyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgdGV4dCBkZWNvcmF0aW9uIG9mIGEgdGV4dC4gIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3VuZGVybGluZScsICdsaW5lLXRocm91Z2gnIG9yIGNvbWJpbmF0aW9uIG9mIHRoZXNlIHZhbHVlcyBzZXBhcmF0ZWQgYnkgc3BhY2VcbiAgICogQG5hbWUgdGV4dERlY29yYXRpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHREZWNvcmF0aW9uXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB0ZXh0IGRlY29yYXRpb25cbiAgICogdmFyIHRleHREZWNvcmF0aW9uID0gdGV4dC50ZXh0RGVjb3JhdGlvbigpO1xuICAgKlxuICAgKiAvLyB1bmRlcmxpbmUgdGV4dFxuICAgKiB0ZXh0LnRleHREZWNvcmF0aW9uKCd1bmRlcmxpbmUnKTtcbiAgICpcbiAgICogLy8gc3RyaWtlIHRleHRcbiAgICogdGV4dC50ZXh0RGVjb3JhdGlvbignbGluZS10aHJvdWdoJyk7XG4gICAqXG4gICAqIC8vIHVuZGVybGluZSBhbmQgc3RyaWtlIHRleHRcbiAgICogdGV4dC50ZXh0RGVjb3JhdGlvbigndW5kZXJsaW5lIGxpbmUtdGhyb3VnaCcpO1xuICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVGV4dCk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIExpbmUgY29uc3RydWN0b3IuJm5ic3A7IExpbmVzIGFyZSBkZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHBvaW50cyBhbmRcbiAgICogIGEgdGVuc2lvblxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZy5wb2ludHMgRmxhdCBhcnJheSBvZiBwb2ludHMgY29vcmRpbmF0ZXMuIFlvdSBzaG91bGQgZGVmaW5lIHRoZW0gYXMgW3gxLCB5MSwgeDIsIHkyLCB4MywgeTNdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy50ZW5zaW9uXSBIaWdoZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIGEgbW9yZSBjdXJ2eSBsaW5lLiAgQSB2YWx1ZSBvZiAwIHdpbGwgcmVzdWx0IGluIG5vIGludGVycG9sYXRpb24uXG4gICAqICAgVGhlIGRlZmF1bHQgaXMgMFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xvc2VkXSBkZWZpbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBsaW5lIHNoYXBlIGlzIGNsb3NlZCwgY3JlYXRpbmcgYSBwb2x5Z29uIG9yIGJsb2JcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmJlemllcl0gaWYgbm8gdGVuc2lvbiBpcyBwcm92aWRlZCBidXQgYmV6aWVyPXRydWUsIHdlIGRyYXcgdGhlIGxpbmUgYXMgYSBiZXppZXIgdXNpbmcgdGhlIHBhc3NlZCBwb2ludHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBsaW5lID0gbmV3IEtvbnZhLkxpbmUoe1xuICAgKiAgIHg6IDEwMCxcbiAgICogICB5OiA1MCxcbiAgICogICBwb2ludHM6IFs3MywgNzAsIDM0MCwgMjMsIDQ1MCwgNjAsIDUwMCwgMjBdLFxuICAgKiAgIHN0cm9rZTogJ3JlZCcsXG4gICAqICAgdGVuc2lvbjogMVxuICAgKiB9KTtcbiAgICovXG4gIEtvbnZhLkxpbmUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5MaW5lLnByb3RvdHlwZSA9IHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0xpbmUnO1xuXG4gICAgICB0aGlzLm9uKFxuICAgICAgICAncG9pbnRzQ2hhbmdlLmtvbnZhIHRlbnNpb25DaGFuZ2Uua29udmEgY2xvc2VkQ2hhbmdlLmtvbnZhIGJlemllckNoYW5nZS5rb252YScsXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoJ3RlbnNpb25Qb2ludHMnKTtcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpLFxuICAgICAgICBsZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICB0ZW5zaW9uID0gdGhpcy5nZXRUZW5zaW9uKCksXG4gICAgICAgIGNsb3NlZCA9IHRoaXMuZ2V0Q2xvc2VkKCksXG4gICAgICAgIGJlemllciA9IHRoaXMuZ2V0QmV6aWVyKCksXG4gICAgICAgIHRwLFxuICAgICAgICBsZW4sXG4gICAgICAgIG47XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgLy8gdGVuc2lvblxuICAgICAgaWYgKHRlbnNpb24gIT09IDAgJiYgbGVuZ3RoID4gNCkge1xuICAgICAgICB0cCA9IHRoaXMuZ2V0VGVuc2lvblBvaW50cygpO1xuICAgICAgICBsZW4gPSB0cC5sZW5ndGg7XG4gICAgICAgIG4gPSBjbG9zZWQgPyAwIDogNDtcblxuICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh0cFswXSwgdHBbMV0sIHRwWzJdLCB0cFszXSk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAobiA8IGxlbiAtIDIpIHtcbiAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICB0cFtuKytdLFxuICAgICAgICAgICAgdHBbbisrXSxcbiAgICAgICAgICAgIHRwW24rK10sXG4gICAgICAgICAgICB0cFtuKytdLFxuICAgICAgICAgICAgdHBbbisrXSxcbiAgICAgICAgICAgIHRwW24rK11cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICB0cFtsZW4gLSAyXSxcbiAgICAgICAgICAgIHRwW2xlbiAtIDFdLFxuICAgICAgICAgICAgcG9pbnRzW2xlbmd0aCAtIDJdLFxuICAgICAgICAgICAgcG9pbnRzW2xlbmd0aCAtIDFdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChiZXppZXIpIHtcbiAgICAgICAgLy8gbm8gdGVuc2lvbiBidXQgYmV6aWVyXG4gICAgICAgIG4gPSAyO1xuXG4gICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgcG9pbnRzW24rK10sXG4gICAgICAgICAgICBwb2ludHNbbisrXSxcbiAgICAgICAgICAgIHBvaW50c1tuKytdLFxuICAgICAgICAgICAgcG9pbnRzW24rK10sXG4gICAgICAgICAgICBwb2ludHNbbisrXSxcbiAgICAgICAgICAgIHBvaW50c1tuKytdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gdGVuc2lvblxuICAgICAgICBmb3IgKG4gPSAyOyBuIDwgbGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbbl0sIHBvaW50c1tuICsgMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNsb3NlZCBlLmcuIHBvbHlnb25zIGFuZCBibG9ic1xuICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9wZW4gZS5nLiBsaW5lcyBhbmQgc3BsaW5lc1xuICAgICAgICBjb250ZXh0LnN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0VGVuc2lvblBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoJ3RlbnNpb25Qb2ludHMnLCB0aGlzLl9nZXRUZW5zaW9uUG9pbnRzKTtcbiAgICB9LFxuICAgIF9nZXRUZW5zaW9uUG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmdldENsb3NlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUZW5zaW9uUG9pbnRzQ2xvc2VkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gS29udmEuVXRpbC5fZXhwYW5kUG9pbnRzKHRoaXMuZ2V0UG9pbnRzKCksIHRoaXMuZ2V0VGVuc2lvbigpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRUZW5zaW9uUG9pbnRzQ2xvc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwID0gdGhpcy5nZXRQb2ludHMoKSxcbiAgICAgICAgbGVuID0gcC5sZW5ndGgsXG4gICAgICAgIHRlbnNpb24gPSB0aGlzLmdldFRlbnNpb24oKSxcbiAgICAgICAgdXRpbCA9IEtvbnZhLlV0aWwsXG4gICAgICAgIGZpcnN0Q29udHJvbFBvaW50cyA9IHV0aWwuX2dldENvbnRyb2xQb2ludHMoXG4gICAgICAgICAgcFtsZW4gLSAyXSxcbiAgICAgICAgICBwW2xlbiAtIDFdLFxuICAgICAgICAgIHBbMF0sXG4gICAgICAgICAgcFsxXSxcbiAgICAgICAgICBwWzJdLFxuICAgICAgICAgIHBbM10sXG4gICAgICAgICAgdGVuc2lvblxuICAgICAgICApLFxuICAgICAgICBsYXN0Q29udHJvbFBvaW50cyA9IHV0aWwuX2dldENvbnRyb2xQb2ludHMoXG4gICAgICAgICAgcFtsZW4gLSA0XSxcbiAgICAgICAgICBwW2xlbiAtIDNdLFxuICAgICAgICAgIHBbbGVuIC0gMl0sXG4gICAgICAgICAgcFtsZW4gLSAxXSxcbiAgICAgICAgICBwWzBdLFxuICAgICAgICAgIHBbMV0sXG4gICAgICAgICAgdGVuc2lvblxuICAgICAgICApLFxuICAgICAgICBtaWRkbGUgPSBLb252YS5VdGlsLl9leHBhbmRQb2ludHMocCwgdGVuc2lvbiksXG4gICAgICAgIHRwID0gW2ZpcnN0Q29udHJvbFBvaW50c1syXSwgZmlyc3RDb250cm9sUG9pbnRzWzNdXVxuICAgICAgICAgIC5jb25jYXQobWlkZGxlKVxuICAgICAgICAgIC5jb25jYXQoW1xuICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbMF0sXG4gICAgICAgICAgICBsYXN0Q29udHJvbFBvaW50c1sxXSxcbiAgICAgICAgICAgIHBbbGVuIC0gMl0sXG4gICAgICAgICAgICBwW2xlbiAtIDFdLFxuICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbMl0sXG4gICAgICAgICAgICBsYXN0Q29udHJvbFBvaW50c1szXSxcbiAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1swXSxcbiAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1sxXSxcbiAgICAgICAgICAgIHBbMF0sXG4gICAgICAgICAgICBwWzFdXG4gICAgICAgICAgXSk7XG5cbiAgICAgIHJldHVybiB0cDtcbiAgICB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNlbGZSZWN0KCkud2lkdGg7XG4gICAgfSxcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZlJlY3QoKS5oZWlnaHQ7XG4gICAgfSxcbiAgICAvLyBvdmVybG9hZCBzaXplIGRldGVjdGlvblxuICAgIGdldFNlbGZSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHM7XG4gICAgICBpZiAodGhpcy5nZXRUZW5zaW9uKCkgIT09IDApIHtcbiAgICAgICAgcG9pbnRzID0gdGhpcy5fZ2V0VGVuc2lvblBvaW50cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTtcbiAgICAgIH1cbiAgICAgIHZhciBtaW5YID0gcG9pbnRzWzBdO1xuICAgICAgdmFyIG1heFggPSBwb2ludHNbMF07XG4gICAgICB2YXIgbWluWSA9IHBvaW50c1sxXTtcbiAgICAgIHZhciBtYXhZID0gcG9pbnRzWzFdO1xuICAgICAgdmFyIHgsIHk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgeCA9IHBvaW50c1tpICogMl07XG4gICAgICAgIHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogTWF0aC5yb3VuZChtaW5YKSxcbiAgICAgICAgeTogTWF0aC5yb3VuZChtaW5ZKSxcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQobWF4WCAtIG1pblgpLFxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQobWF4WSAtIG1pblkpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuTGluZSwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTGluZSwgJ2Nsb3NlZCcsIGZhbHNlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBjbG9zZWQgZmxhZy4gIFRoZSBkZWZhdWx0IGlzIGZhbHNlXG4gICAqIEBuYW1lIGNsb3NlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5MaW5lLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNsb3NlZCBmbGFnXG4gICAqIHZhciBjbG9zZWQgPSBsaW5lLmNsb3NlZCgpO1xuICAgKlxuICAgKiAvLyBjbG9zZSB0aGUgc2hhcGVcbiAgICogbGluZS5jbG9zZWQodHJ1ZSk7XG4gICAqXG4gICAqIC8vIG9wZW4gdGhlIHNoYXBlXG4gICAqIGxpbmUuY2xvc2VkKGZhbHNlKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTGluZSwgJ2JlemllcicsIGZhbHNlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBiZXppZXIgZmxhZy4gIFRoZSBkZWZhdWx0IGlzIGZhbHNlXG4gICAqIEBuYW1lIGJlemllclxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5MaW5lLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGJlemllclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHdoZXRoZXIgdGhlIGxpbmUgaXMgYSBiZXppZXJcbiAgICogdmFyIGlzQmV6aWVyID0gbGluZS5iZXppZXIoKTtcbiAgICpcbiAgICogLy8gc2V0IHdoZXRoZXIgdGhlIGxpbmUgaXMgYSBiZXppZXJcbiAgICogbGluZS5iZXppZXIodHJ1ZSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLkxpbmUsXG4gICAgJ3RlbnNpb24nLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHRlbnNpb25cbiAgICogQG5hbWUgdGVuc2lvblxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5MaW5lLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gSGlnaGVyIHZhbHVlcyB3aWxsIHJlc3VsdCBpbiBhIG1vcmUgY3VydnkgbGluZS4gIEEgdmFsdWUgb2YgMCB3aWxsIHJlc3VsdCBpbiBubyBpbnRlcnBvbGF0aW9uLlxuICAgKiAgIFRoZSBkZWZhdWx0IGlzIDBcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHRlbnNpb25cbiAgICogdmFyIHRlbnNpb24gPSBsaW5lLnRlbnNpb24oKTtcbiAgICpcbiAgICogLy8gc2V0IHRlbnNpb25cbiAgICogbGluZS50ZW5zaW9uKDMpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5MaW5lLFxuICAgICdwb2ludHMnLFxuICAgIFtdLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyQXJyYXlWYWxpZGF0b3IoKVxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBwb2ludHMgYXJyYXlcbiAgICogQG5hbWUgcG9pbnRzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkxpbmUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBwb2ludHNcbiAgICogdmFyIHBvaW50cyA9IGxpbmUucG9pbnRzKCk7XG4gICAqXG4gICAqIC8vIHNldCBwb2ludHNcbiAgICogbGluZS5wb2ludHMoWzEwLCAyMCwgMzAsIDQwLCA1MCwgNjBdKTtcbiAgICpcbiAgICogLy8gcHVzaCBhIG5ldyBwb2ludFxuICAgKiBsaW5lLnBvaW50cyhsaW5lLnBvaW50cygpLmNvbmNhdChbNzAsIDgwXSkpO1xuICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuTGluZSk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIFNwcml0ZSBjb25zdHJ1Y3RvclxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuYW5pbWF0aW9uIGFuaW1hdGlvbiBrZXlcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5hbmltYXRpb25zIGFuaW1hdGlvbiBtYXBcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBbY29uZmlnLmZyYW1lSW5kZXhdIGFuaW1hdGlvbiBmcmFtZSBpbmRleFxuICAgKiBAcGFyYW0ge0ltYWdlfSBjb25maWcuaW1hZ2UgaW1hZ2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gW2NvbmZpZy5mcmFtZVJhdGVdIGFuaW1hdGlvbiBmcmFtZSByYXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaW1hZ2VPYmogPSBuZXcgSW1hZ2UoKTtcbiAgICogaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAqICAgdmFyIHNwcml0ZSA9IG5ldyBLb252YS5TcHJpdGUoe1xuICAgKiAgICAgeDogMjAwLFxuICAgKiAgICAgeTogMTAwLFxuICAgKiAgICAgaW1hZ2U6IGltYWdlT2JqLFxuICAgKiAgICAgYW5pbWF0aW9uOiAnc3RhbmRpbmcnLFxuICAgKiAgICAgYW5pbWF0aW9uczoge1xuICAgKiAgICAgICBzdGFuZGluZzogW1xuICAgKiAgICAgICAgIC8vIHgsIHksIHdpZHRoLCBoZWlnaHQgKDYgZnJhbWVzKVxuICAgKiAgICAgICAgIDAsIDAsIDQ5LCAxMDksXG4gICAqICAgICAgICAgNTIsIDAsIDQ5LCAxMDksXG4gICAqICAgICAgICAgMTA1LCAwLCA0OSwgMTA5LFxuICAgKiAgICAgICAgIDE1OCwgMCwgNDksIDEwOSxcbiAgICogICAgICAgICAyMTAsIDAsIDQ5LCAxMDksXG4gICAqICAgICAgICAgMjYyLCAwLCA0OSwgMTA5XG4gICAqICAgICAgIF0sXG4gICAqICAgICAgIGtpY2tpbmc6IFtcbiAgICogICAgICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcbiAgICogICAgICAgICAwLCAxMDksIDQ1LCA5OCxcbiAgICogICAgICAgICA0NSwgMTA5LCA0NSwgOTgsXG4gICAqICAgICAgICAgOTUsIDEwOSwgNjMsIDk4LFxuICAgKiAgICAgICAgIDE1NiwgMTA5LCA3MCwgOTgsXG4gICAqICAgICAgICAgMjI5LCAxMDksIDYwLCA5OCxcbiAgICogICAgICAgICAyODcsIDEwOSwgNDEsIDk4XG4gICAqICAgICAgIF1cbiAgICogICAgIH0sXG4gICAqICAgICBmcmFtZVJhdGU6IDcsXG4gICAqICAgICBmcmFtZUluZGV4OiAwXG4gICAqICAgfSk7XG4gICAqIH07XG4gICAqIGltYWdlT2JqLnNyYyA9ICcvcGF0aC90by9pbWFnZS5qcGcnXG4gICAqL1xuICBLb252YS5TcHJpdGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5TcHJpdGUucHJvdG90eXBlID0ge1xuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnU3ByaXRlJztcblxuICAgICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLmFuaW0gPSBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBpZiB3ZSBkb24ndCBuZWVkIHRvIHJlZHJhdyBsYXllciB3ZSBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAgIHZhciB1cGRhdGVkID0gdGhhdC5fdXBkYXRlZDtcbiAgICAgICAgdGhhdC5fdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignYW5pbWF0aW9uQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHJlc2V0IGluZGV4IHdoZW4gYW5pbWF0aW9uIGNoYW5nZXNcbiAgICAgICAgdGhpcy5mcmFtZUluZGV4KDApO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdmcmFtZUluZGV4Q2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICAvLyBzbW9vdGggY2hhbmdlIGZvciBmcmFtZVJhdGVcbiAgICAgIHRoaXMub24oJ2ZyYW1lUmF0ZUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuYW5pbS5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9zZXRJbnRlcnZhbCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICB0aGlzLmhpdEZ1bmModGhpcy5faGl0RnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgYW5pbSA9IHRoaXMuZ2V0QW5pbWF0aW9uKCksXG4gICAgICAgIGluZGV4ID0gdGhpcy5mcmFtZUluZGV4KCksXG4gICAgICAgIGl4NCA9IGluZGV4ICogNCxcbiAgICAgICAgc2V0ID0gdGhpcy5nZXRBbmltYXRpb25zKClbYW5pbV0sXG4gICAgICAgIG9mZnNldHMgPSB0aGlzLmZyYW1lT2Zmc2V0cygpLFxuICAgICAgICB4ID0gc2V0W2l4NCArIDBdLFxuICAgICAgICB5ID0gc2V0W2l4NCArIDFdLFxuICAgICAgICB3aWR0aCA9IHNldFtpeDQgKyAyXSxcbiAgICAgICAgaGVpZ2h0ID0gc2V0W2l4NCArIDNdLFxuICAgICAgICBpbWFnZSA9IHRoaXMuZ2V0SW1hZ2UoKTtcblxuICAgICAgaWYgKHRoaXMuaGFzRmlsbCgpIHx8IHRoaXMuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgIGlmIChvZmZzZXRzKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbYW5pbV0sXG4gICAgICAgICAgICBpeDIgPSBpbmRleCAqIDI7XG4gICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBvZmZzZXRbaXgyICsgMF0sXG4gICAgICAgICAgICBvZmZzZXRbaXgyICsgMV0sXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfaGl0RnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIGFuaW0gPSB0aGlzLmdldEFuaW1hdGlvbigpLFxuICAgICAgICBpbmRleCA9IHRoaXMuZnJhbWVJbmRleCgpLFxuICAgICAgICBpeDQgPSBpbmRleCAqIDQsXG4gICAgICAgIHNldCA9IHRoaXMuZ2V0QW5pbWF0aW9ucygpW2FuaW1dLFxuICAgICAgICBvZmZzZXRzID0gdGhpcy5mcmFtZU9mZnNldHMoKSxcbiAgICAgICAgd2lkdGggPSBzZXRbaXg0ICsgMl0sXG4gICAgICAgIGhlaWdodCA9IHNldFtpeDQgKyAzXTtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGlmIChvZmZzZXRzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRzW2FuaW1dO1xuICAgICAgICB2YXIgaXgyID0gaW5kZXggKiAyO1xuICAgICAgICBjb250ZXh0LnJlY3Qob2Zmc2V0W2l4MiArIDBdLCBvZmZzZXRbaXgyICsgMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbFNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgX3VzZUJ1ZmZlckNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAodGhpcy5oYXNTaGFkb3coKSB8fCB0aGlzLmdldEFic29sdXRlT3BhY2l0eSgpICE9PSAxKSAmJlxuICAgICAgICB0aGlzLmhhc1N0cm9rZSgpXG4gICAgICApO1xuICAgIH0sXG4gICAgX3NldEludGVydmFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5fdXBkYXRlSW5kZXgoKTtcbiAgICAgIH0sIDEwMDAgLyB0aGlzLmdldEZyYW1lUmF0ZSgpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHN0YXJ0IHNwcml0ZSBhbmltYXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc1J1bm5pbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG5cbiAgICAgIC8qXG4gICAgICAgICAgICAgKiBhbmltYXRpb24gb2JqZWN0IGhhcyBubyBleGVjdXRhYmxlIGZ1bmN0aW9uIGJlY2F1c2VcbiAgICAgICAgICAgICAqICB0aGUgdXBkYXRlcyBhcmUgZG9uZSB3aXRoIGEgZml4ZWQgRlBTIHdpdGggdGhlIHNldEludGVydmFsXG4gICAgICAgICAgICAgKiAgYmVsb3cuICBUaGUgYW5pbSBvYmplY3Qgb25seSBuZWVkcyB0aGUgbGF5ZXIgcmVmZXJlbmNlIGZvclxuICAgICAgICAgICAgICogIHJlZHJhd1xuICAgICAgICAgICAgICovXG4gICAgICB0aGlzLmFuaW0uc2V0TGF5ZXJzKGxheWVyKTtcbiAgICAgIHRoaXMuX3NldEludGVydmFsKCk7XG4gICAgICB0aGlzLmFuaW0uc3RhcnQoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHN0b3Agc3ByaXRlIGFuaW1hdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hbmltLnN0b3AoKTtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmUgaWYgYW5pbWF0aW9uIG9mIHNwcml0ZSBpcyBydW5uaW5nIG9yIG5vdC4gIHJldHVybnMgdHJ1ZSBvciBmYWxzZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUnVubmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmltLmlzUnVubmluZygpO1xuICAgIH0sXG4gICAgX3VwZGF0ZUluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZnJhbWVJbmRleCgpLFxuICAgICAgICBhbmltYXRpb24gPSB0aGlzLmdldEFuaW1hdGlvbigpLFxuICAgICAgICBhbmltYXRpb25zID0gdGhpcy5nZXRBbmltYXRpb25zKCksXG4gICAgICAgIGFuaW0gPSBhbmltYXRpb25zW2FuaW1hdGlvbl0sXG4gICAgICAgIGxlbiA9IGFuaW0ubGVuZ3RoIC8gNDtcblxuICAgICAgaWYgKGluZGV4IDwgbGVuIC0gMSkge1xuICAgICAgICB0aGlzLmZyYW1lSW5kZXgoaW5kZXggKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZnJhbWVJbmRleCgwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlNwcml0ZSwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnYW5pbWF0aW9uJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgYW5pbWF0aW9uIGtleVxuICAgKiBAbmFtZSBhbmltYXRpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYW5pbSBhbmltYXRpb24ga2V5XG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBhbmltYXRpb24ga2V5XG4gICAqIHZhciBhbmltYXRpb24gPSBzcHJpdGUuYW5pbWF0aW9uKCk7XG4gICAqXG4gICAqIC8vIHNldCBhbmltYXRpb24ga2V5XG4gICAqIHNwcml0ZS5hbmltYXRpb24oJ2tpY2tpbmcnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnYW5pbWF0aW9ucycpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGFuaW1hdGlvbnMgbWFwXG4gICAqIEBuYW1lIGFuaW1hdGlvbnNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgYW5pbWF0aW9ucyBtYXBcbiAgICogdmFyIGFuaW1hdGlvbnMgPSBzcHJpdGUuYW5pbWF0aW9ucygpO1xuICAgKlxuICAgKiAvLyBzZXQgYW5pbWF0aW9ucyBtYXBcbiAgICogc3ByaXRlLmFuaW1hdGlvbnMoe1xuICAgKiAgIHN0YW5kaW5nOiBbXG4gICAqICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcbiAgICogICAgIDAsIDAsIDQ5LCAxMDksXG4gICAqICAgICA1MiwgMCwgNDksIDEwOSxcbiAgICogICAgIDEwNSwgMCwgNDksIDEwOSxcbiAgICogICAgIDE1OCwgMCwgNDksIDEwOSxcbiAgICogICAgIDIxMCwgMCwgNDksIDEwOSxcbiAgICogICAgIDI2MiwgMCwgNDksIDEwOVxuICAgKiAgIF0sXG4gICAqICAga2lja2luZzogW1xuICAgKiAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodCAoNiBmcmFtZXMpXG4gICAqICAgICAwLCAxMDksIDQ1LCA5OCxcbiAgICogICAgIDQ1LCAxMDksIDQ1LCA5OCxcbiAgICogICAgIDk1LCAxMDksIDYzLCA5OCxcbiAgICogICAgIDE1NiwgMTA5LCA3MCwgOTgsXG4gICAqICAgICAyMjksIDEwOSwgNjAsIDk4LFxuICAgKiAgICAgMjg3LCAxMDksIDQxLCA5OFxuICAgKiAgIF1cbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNwcml0ZSwgJ2ZyYW1lT2Zmc2V0cycpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IG9mZnNldHMgbWFwXG4gICAqIEBuYW1lIG9mZnNldHNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0c1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgb2Zmc2V0cyBtYXBcbiAgICogdmFyIG9mZnNldHMgPSBzcHJpdGUub2Zmc2V0cygpO1xuICAgKlxuICAgKiAvLyBzZXQgb2Zmc2V0cyBtYXBcbiAgICogc3ByaXRlLm9mZnNldHMoe1xuICAgKiAgIHN0YW5kaW5nOiBbXG4gICAqICAgICAvLyB4LCB5ICg2IGZyYW1lcylcbiAgICogICAgIDAsIDAsXG4gICAqICAgICAwLCAwLFxuICAgKiAgICAgNSwgMCxcbiAgICogICAgIDAsIDAsXG4gICAqICAgICAwLCAzLFxuICAgKiAgICAgMiwgMFxuICAgKiAgIF0sXG4gICAqICAga2lja2luZzogW1xuICAgKiAgICAgLy8geCwgeSAoNiBmcmFtZXMpXG4gICAqICAgICAwLCA1LFxuICAgKiAgICAgNSwgMCxcbiAgICogICAgIDEwLCAwLFxuICAgKiAgICAgMCwgMCxcbiAgICogICAgIDIsIDEsXG4gICAqICAgICAwLCAwXG4gICAqICAgXVxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnaW1hZ2UnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBpbWFnZVxuICAgKiBAbmFtZSBpbWFnZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gICAqIEByZXR1cm5zIHtJbWFnZX1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGltYWdlXG4gICAqIHZhciBpbWFnZSA9IHNwcml0ZS5pbWFnZSgpO1xuICAgKlxuICAgKiAvLyBzZXQgaW1hZ2VcbiAgICogc3ByaXRlLmltYWdlKGltYWdlT2JqKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU3ByaXRlLFxuICAgICdmcmFtZUluZGV4JyxcbiAgICAwLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogc2V0L3NldCBhbmltYXRpb24gZnJhbWUgaW5kZXhcbiAgICogQG5hbWUgZnJhbWVJbmRleFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gZnJhbWVJbmRleFxuICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGFuaW1hdGlvbiBmcmFtZSBpbmRleFxuICAgKiB2YXIgZnJhbWVJbmRleCA9IHNwcml0ZS5mcmFtZUluZGV4KCk7XG4gICAqXG4gICAqIC8vIHNldCBhbmltYXRpb24gZnJhbWUgaW5kZXhcbiAgICogc3ByaXRlLmZyYW1lSW5kZXgoMyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNwcml0ZSxcbiAgICAnZnJhbWVSYXRlJyxcbiAgICAxNyxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZnJhbWUgcmF0ZSBpbiBmcmFtZXMgcGVyIHNlY29uZC4gIEluY3JlYXNlIHRoaXMgbnVtYmVyIHRvIG1ha2UgdGhlIHNwcml0ZVxuICAgKiAgYW5pbWF0aW9uIHJ1biBmYXN0ZXIsIGFuZCBkZWNyZWFzZSB0aGUgbnVtYmVyIHRvIG1ha2UgdGhlIHNwcml0ZSBhbmltYXRpb24gcnVuIHNsb3dlclxuICAgKiAgVGhlIGRlZmF1bHQgaXMgMTcgZnJhbWVzIHBlciBzZWNvbmRcbiAgICogQG5hbWUgZnJhbWVSYXRlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBmcmFtZVJhdGVcbiAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmcmFtZSByYXRlXG4gICAqIHZhciBmcmFtZVJhdGUgPSBzcHJpdGUuZnJhbWVSYXRlKCk7XG4gICAqXG4gICAqIC8vIHNldCBmcmFtZSByYXRlIHRvIDIgZnJhbWVzIHBlciBzZWNvbmRcbiAgICogc3ByaXRlLmZyYW1lUmF0ZSgyKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLlNwcml0ZSwge1xuICAgIGluZGV4OiAnZnJhbWVJbmRleCcsXG4gICAgZ2V0SW5kZXg6ICdnZXRGcmFtZUluZGV4JyxcbiAgICBzZXRJbmRleDogJ3NldEZyYW1lSW5kZXgnXG4gIH0pO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5TcHJpdGUpO1xufSkoKTtcblxuLyplc2xpbnQtZGlzYWJsZSAgbm8tc2hhZG93LCBtYXgtbGVuLCBtYXgtZGVwdGggKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogUGF0aCBjb25zdHJ1Y3Rvci5cbiAgICogQGF1dGhvciBKYXNvbiBGb2xsYXNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRhdGEgU1ZHIGRhdGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcGF0aCA9IG5ldyBLb252YS5QYXRoKHtcbiAgICogICB4OiAyNDAsXG4gICAqICAgeTogNDAsXG4gICAqICAgZGF0YTogJ00xMi41ODIsOS41NTFDMy4yNTEsMTYuMjM3LDAuOTIxLDI5LjAyMSw3LjA4LDM4LjU2NGwtMi4zNiwxLjY4OWw0Ljg5MywyLjI2Mmw0Ljg5MywyLjI2MmwtMC41NjgtNS4zNmwtMC41NjctNS4zNTlsLTIuMzY1LDEuNjk0Yy00LjY1Ny03LjM3NS0yLjgzLTE3LjE4NSw0LjM1Mi0yMi4zM2M3LjQ1MS01LjMzOCwxNy44MTctMy42MjUsMjMuMTU2LDMuODI0YzUuMzM3LDcuNDQ5LDMuNjI1LDE3LjgxMy0zLjgyMSwyMy4xNTJsMi44NTcsMy45ODhjOS42MTctNi44OTMsMTEuODI3LTIwLjI3Nyw0LjkzNS0yOS44OTZDMzUuNTkxLDQuODcsMjIuMjA0LDIuNjU4LDEyLjU4Miw5LjU1MXonLFxuICAgKiAgIGZpbGw6ICdncmVlbicsXG4gICAqICAgc2NhbGU6IDJcbiAgICogfSk7XG4gICAqL1xuICBLb252YS5QYXRoID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuUGF0aC5wcm90b3R5cGUgPSB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB0aGlzLmRhdGFBcnJheSA9IFtdO1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdQYXRoJztcblxuICAgICAgdGhpcy5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5nZXREYXRhKCkpO1xuICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5wYXRoTGVuZ3RoICs9IHRoaXMuZGF0YUFycmF5W2ldLnBhdGhMZW5ndGg7XG4gICAgICB9XG4gICAgICB0aGlzLm9uKCdkYXRhQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZGF0YUFycmF5ID0gS29udmEuUGF0aC5wYXJzZVBhdGhEYXRhKHRoaXMuZ2V0RGF0YSgpKTtcbiAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGFBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRoaXMucGF0aExlbmd0aCArPSB0aGlzLmRhdGFBcnJheVtpXS5wYXRoTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBjYSA9IHRoaXMuZGF0YUFycmF5O1xuXG4gICAgICAvLyBjb250ZXh0IHBvc2l0aW9uXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjYS5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgYyA9IGNhW25dLmNvbW1hbmQ7XG4gICAgICAgIHZhciBwID0gY2Fbbl0ucG9pbnRzO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHBbMF0sIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocFswXSwgcFsxXSwgcFsyXSwgcFszXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIHZhciBjeCA9IHBbMF0sXG4gICAgICAgICAgICAgIGN5ID0gcFsxXSxcbiAgICAgICAgICAgICAgcnggPSBwWzJdLFxuICAgICAgICAgICAgICByeSA9IHBbM10sXG4gICAgICAgICAgICAgIHRoZXRhID0gcFs0XSxcbiAgICAgICAgICAgICAgZFRoZXRhID0gcFs1XSxcbiAgICAgICAgICAgICAgcHNpID0gcFs2XSxcbiAgICAgICAgICAgICAgZnMgPSBwWzddO1xuXG4gICAgICAgICAgICB2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICAgICAgICAgICAgdmFyIHNjYWxlWCA9IHJ4ID4gcnkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG5cbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICBjb250ZXh0LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgY29udGV4dC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIDEgLSBmcyk7XG4gICAgICAgICAgICBjb250ZXh0LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgdGhpcy5kYXRhQXJyYXkuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHBvaW50cyA9IHBvaW50cy5jb25jYXQoZGF0YS5wb2ludHMpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbWluWCA9IHBvaW50c1swXTtcbiAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xuICAgICAgdmFyIG1pblkgPSBwb2ludHNbMV07XG4gICAgICB2YXIgbWF4WSA9IHBvaW50c1sxXTtcbiAgICAgIHZhciB4LCB5O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICB5ID0gcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICAgICAgLy8gc2tpcCBiYWQgdmFsdWVzXG4gICAgICAgIC8vIFRPRE86IHByZXZlbnQgdGhlbSBmcm9tIHBhcnNpbmcgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc05hTih4KSkge1xuICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc05hTih5KSkge1xuICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IE1hdGgucm91bmQobWluWCksXG4gICAgICAgIHk6IE1hdGgucm91bmQobWluWSksXG4gICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKG1heFkgLSBtaW5ZKVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBsZW5ndGggb2YgdGhlIHBhdGguXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5QYXRoLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxlbmd0aCA9IHBhdGguZ2V0TGVuZ3RoKCk7XG4gICAgICovXG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhMZW5ndGg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgcG9pbnQgb24gcGF0aCBhdCBzcGVjaWZpYyBsZW5ndGggb2YgdGhlIHBhdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlBhdGgucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBsZW5ndGhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwb2ludCB7eCx5fSBwb2ludFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBvaW50ID0gcGF0aC5nZXRQb2ludEF0TGVuZ3RoKDEwKTtcbiAgICAgKi9cbiAgICBnZXRQb2ludEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgIHZhciBwb2ludCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGlpID0gdGhpcy5kYXRhQXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAoIWlpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaSA8IGlpICYmIGxlbmd0aCA+IHRoaXMuZGF0YUFycmF5W2ldLnBhdGhMZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoIC09IHRoaXMuZGF0YUFycmF5W2ldLnBhdGhMZW5ndGg7XG4gICAgICAgICsraTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IGlpKSB7XG4gICAgICAgIHBvaW50ID0gdGhpcy5kYXRhQXJyYXlbaSAtIDFdLnBvaW50cy5zbGljZSgtMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcG9pbnRbMF0sXG4gICAgICAgICAgeTogcG9pbnRbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbmd0aCA8IDAuMDEpIHtcbiAgICAgICAgcG9pbnQgPSB0aGlzLmRhdGFBcnJheVtpXS5wb2ludHMuc2xpY2UoMCwgMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcG9pbnRbMF0sXG4gICAgICAgICAgeTogcG9pbnRbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNwID0gdGhpcy5kYXRhQXJyYXlbaV07XG4gICAgICB2YXIgcCA9IGNwLnBvaW50cztcbiAgICAgIHN3aXRjaCAoY3AuY29tbWFuZCkge1xuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICByZXR1cm4gS29udmEuUGF0aC5nZXRQb2ludE9uTGluZShcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIGNwLnN0YXJ0LngsXG4gICAgICAgICAgICBjcC5zdGFydC55LFxuICAgICAgICAgICAgcFswXSxcbiAgICAgICAgICAgIHBbMV1cbiAgICAgICAgICApO1xuICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICByZXR1cm4gS29udmEuUGF0aC5nZXRQb2ludE9uQ3ViaWNCZXppZXIoXG4gICAgICAgICAgICBsZW5ndGggLyBjcC5wYXRoTGVuZ3RoLFxuICAgICAgICAgICAgY3Auc3RhcnQueCxcbiAgICAgICAgICAgIGNwLnN0YXJ0LnksXG4gICAgICAgICAgICBwWzBdLFxuICAgICAgICAgICAgcFsxXSxcbiAgICAgICAgICAgIHBbMl0sXG4gICAgICAgICAgICBwWzNdLFxuICAgICAgICAgICAgcFs0XSxcbiAgICAgICAgICAgIHBbNV1cbiAgICAgICAgICApO1xuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICByZXR1cm4gS29udmEuUGF0aC5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKFxuICAgICAgICAgICAgbGVuZ3RoIC8gY3AucGF0aExlbmd0aCxcbiAgICAgICAgICAgIGNwLnN0YXJ0LngsXG4gICAgICAgICAgICBjcC5zdGFydC55LFxuICAgICAgICAgICAgcFswXSxcbiAgICAgICAgICAgIHBbMV0sXG4gICAgICAgICAgICBwWzJdLFxuICAgICAgICAgICAgcFszXVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHZhciBjeCA9IHBbMF0sXG4gICAgICAgICAgICBjeSA9IHBbMV0sXG4gICAgICAgICAgICByeCA9IHBbMl0sXG4gICAgICAgICAgICByeSA9IHBbM10sXG4gICAgICAgICAgICB0aGV0YSA9IHBbNF0sXG4gICAgICAgICAgICBkVGhldGEgPSBwWzVdLFxuICAgICAgICAgICAgcHNpID0gcFs2XTtcbiAgICAgICAgICB0aGV0YSArPSBkVGhldGEgKiBsZW5ndGggLyBjcC5wYXRoTGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBLb252YS5QYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgcHNpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5QYXRoLCBLb252YS5TaGFwZSk7XG5cbiAgS29udmEuUGF0aC5nZXRMaW5lTGVuZ3RoID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gIH07XG4gIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkxpbmUgPSBmdW5jdGlvbihkaXN0LCBQMXgsIFAxeSwgUDJ4LCBQMnksIGZyb21YLCBmcm9tWSkge1xuICAgIGlmIChmcm9tWCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tWCA9IFAxeDtcbiAgICB9XG4gICAgaWYgKGZyb21ZID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb21ZID0gUDF5O1xuICAgIH1cblxuICAgIHZhciBtID0gKFAyeSAtIFAxeSkgLyAoUDJ4IC0gUDF4ICsgMC4wMDAwMDAwMSk7XG4gICAgdmFyIHJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAvICgxICsgbSAqIG0pKTtcbiAgICBpZiAoUDJ4IDwgUDF4KSB7XG4gICAgICBydW4gKj0gLTE7XG4gICAgfVxuICAgIHZhciByaXNlID0gbSAqIHJ1bjtcbiAgICB2YXIgcHQ7XG5cbiAgICBpZiAoUDJ4ID09PSBQMXgpIHtcbiAgICAgIC8vIHZlcnRpY2FsIGxpbmVcbiAgICAgIHB0ID0ge1xuICAgICAgICB4OiBmcm9tWCxcbiAgICAgICAgeTogZnJvbVkgKyByaXNlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoKGZyb21ZIC0gUDF5KSAvIChmcm9tWCAtIFAxeCArIDAuMDAwMDAwMDEpID09PSBtKSB7XG4gICAgICBwdCA9IHtcbiAgICAgICAgeDogZnJvbVggKyBydW4sXG4gICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl4LCBpeTtcblxuICAgICAgdmFyIGxlbiA9IHRoaXMuZ2V0TGluZUxlbmd0aChQMXgsIFAxeSwgUDJ4LCBQMnkpO1xuICAgICAgaWYgKGxlbiA8IDAuMDAwMDAwMDEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciB1ID0gKGZyb21YIC0gUDF4KSAqIChQMnggLSBQMXgpICsgKGZyb21ZIC0gUDF5KSAqIChQMnkgLSBQMXkpO1xuICAgICAgdSA9IHUgLyAobGVuICogbGVuKTtcbiAgICAgIGl4ID0gUDF4ICsgdSAqIChQMnggLSBQMXgpO1xuICAgICAgaXkgPSBQMXkgKyB1ICogKFAyeSAtIFAxeSk7XG5cbiAgICAgIHZhciBwUmlzZSA9IHRoaXMuZ2V0TGluZUxlbmd0aChmcm9tWCwgZnJvbVksIGl4LCBpeSk7XG4gICAgICB2YXIgcFJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAtIHBSaXNlICogcFJpc2UpO1xuICAgICAgcnVuID0gTWF0aC5zcXJ0KHBSdW4gKiBwUnVuIC8gKDEgKyBtICogbSkpO1xuICAgICAgaWYgKFAyeCA8IFAxeCkge1xuICAgICAgICBydW4gKj0gLTE7XG4gICAgICB9XG4gICAgICByaXNlID0gbSAqIHJ1bjtcbiAgICAgIHB0ID0ge1xuICAgICAgICB4OiBpeCArIHJ1bixcbiAgICAgICAgeTogaXkgKyByaXNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwdDtcbiAgfTtcblxuICBLb252YS5QYXRoLmdldFBvaW50T25DdWJpY0JlemllciA9IGZ1bmN0aW9uKFxuICAgIHBjdCxcbiAgICBQMXgsXG4gICAgUDF5LFxuICAgIFAyeCxcbiAgICBQMnksXG4gICAgUDN4LFxuICAgIFAzeSxcbiAgICBQNHgsXG4gICAgUDR5XG4gICkge1xuICAgIGZ1bmN0aW9uIENCMSh0KSB7XG4gICAgICByZXR1cm4gdCAqIHQgKiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBDQjIodCkge1xuICAgICAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENCMyh0KSB7XG4gICAgICByZXR1cm4gMyAqIHQgKiAoMSAtIHQpICogKDEgLSB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ0I0KHQpIHtcbiAgICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCk7XG4gICAgfVxuICAgIHZhciB4ID0gUDR4ICogQ0IxKHBjdCkgKyBQM3ggKiBDQjIocGN0KSArIFAyeCAqIENCMyhwY3QpICsgUDF4ICogQ0I0KHBjdCk7XG4gICAgdmFyIHkgPSBQNHkgKiBDQjEocGN0KSArIFAzeSAqIENCMihwY3QpICsgUDJ5ICogQ0IzKHBjdCkgKyBQMXkgKiBDQjQocGN0KTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH07XG4gIEtvbnZhLlBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllciA9IGZ1bmN0aW9uKFxuICAgIHBjdCxcbiAgICBQMXgsXG4gICAgUDF5LFxuICAgIFAyeCxcbiAgICBQMnksXG4gICAgUDN4LFxuICAgIFAzeVxuICApIHtcbiAgICBmdW5jdGlvbiBRQjEodCkge1xuICAgICAgcmV0dXJuIHQgKiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBRQjIodCkge1xuICAgICAgcmV0dXJuIDIgKiB0ICogKDEgLSB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUUIzKHQpIHtcbiAgICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KTtcbiAgICB9XG4gICAgdmFyIHggPSBQM3ggKiBRQjEocGN0KSArIFAyeCAqIFFCMihwY3QpICsgUDF4ICogUUIzKHBjdCk7XG4gICAgdmFyIHkgPSBQM3kgKiBRQjEocGN0KSArIFAyeSAqIFFCMihwY3QpICsgUDF5ICogUUIzKHBjdCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICB9O1xuICBLb252YS5QYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjID0gZnVuY3Rpb24oY3gsIGN5LCByeCwgcnksIHRoZXRhLCBwc2kpIHtcbiAgICB2YXIgY29zUHNpID0gTWF0aC5jb3MocHNpKSxcbiAgICAgIHNpblBzaSA9IE1hdGguc2luKHBzaSk7XG4gICAgdmFyIHB0ID0ge1xuICAgICAgeDogcnggKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICB5OiByeSAqIE1hdGguc2luKHRoZXRhKVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGN4ICsgKHB0LnggKiBjb3NQc2kgLSBwdC55ICogc2luUHNpKSxcbiAgICAgIHk6IGN5ICsgKHB0LnggKiBzaW5Qc2kgKyBwdC55ICogY29zUHNpKVxuICAgIH07XG4gIH07XG4gIC8qXG4gICAgICogZ2V0IHBhcnNlZCBkYXRhIGFycmF5IGZyb20gdGhlIGRhdGFcbiAgICAgKiAgc3RyaW5nLiAgViwgdiwgSCwgaCwgYW5kIGwgZGF0YSBhcmUgY29udmVydGVkIHRvXG4gICAgICogIEwgZGF0YSBmb3IgdGhlIHB1cnBvc2Ugb2YgaGlnaCBwZXJmb3JtYW5jZSBQYXRoXG4gICAgICogIHJlbmRlcmluZ1xuICAgICAqL1xuICBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgLy8gUGF0aCBEYXRhIFNlZ21lbnQgbXVzdCBiZWdpbiB3aXRoIGEgbW92ZVRvXG4gICAgLy9tICh4IHkpKyAgUmVsYXRpdmUgbW92ZVRvIChzdWJzZXF1ZW50IHBvaW50cyBhcmUgdHJlYXRlZCBhcyBsaW5lVG8pXG4gICAgLy9NICh4IHkpKyAgQWJzb2x1dGUgbW92ZVRvIChzdWJzZXF1ZW50IHBvaW50cyBhcmUgdHJlYXRlZCBhcyBsaW5lVG8pXG4gICAgLy9sICh4IHkpKyAgUmVsYXRpdmUgbGluZVRvXG4gICAgLy9MICh4IHkpKyAgQWJzb2x1dGUgTGluZVRvXG4gICAgLy9oICh4KSsgICAgUmVsYXRpdmUgaG9yaXpvbnRhbCBsaW5lVG9cbiAgICAvL0ggKHgpKyAgICBBYnNvbHV0ZSBob3Jpem9udGFsIGxpbmVUb1xuICAgIC8vdiAoeSkrICAgIFJlbGF0aXZlIHZlcnRpY2FsIGxpbmVUb1xuICAgIC8vViAoeSkrICAgIEFic29sdXRlIHZlcnRpY2FsIGxpbmVUb1xuICAgIC8veiAoY2xvc2VwYXRoKVxuICAgIC8vWiAoY2xvc2VwYXRoKVxuICAgIC8vYyAoeDEgeTEgeDIgeTIgeCB5KSsgUmVsYXRpdmUgQmV6aWVyIGN1cnZlXG4gICAgLy9DICh4MSB5MSB4MiB5MiB4IHkpKyBBYnNvbHV0ZSBCZXppZXIgY3VydmVcbiAgICAvL3EgKHgxIHkxIHggeSkrICAgICAgIFJlbGF0aXZlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAvL1EgKHgxIHkxIHggeSkrICAgICAgIEFic29sdXRlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAvL3QgKHggeSkrICAgIFNob3J0aGFuZC9TbW9vdGggUmVsYXRpdmUgUXVhZHJhdGljIEJlemllclxuICAgIC8vVCAoeCB5KSsgICAgU2hvcnRoYW5kL1Ntb290aCBBYnNvbHV0ZSBRdWFkcmF0aWMgQmV6aWVyXG4gICAgLy9zICh4MiB5MiB4IHkpKyAgICAgICBTaG9ydGhhbmQvU21vb3RoIFJlbGF0aXZlIEJlemllciBjdXJ2ZVxuICAgIC8vUyAoeDIgeTIgeCB5KSsgICAgICAgU2hvcnRoYW5kL1Ntb290aCBBYnNvbHV0ZSBCZXppZXIgY3VydmVcbiAgICAvL2EgKHJ4IHJ5IHgtYXhpcy1yb3RhdGlvbiBsYXJnZS1hcmMtZmxhZyBzd2VlcC1mbGFnIHggeSkrICAgICBSZWxhdGl2ZSBFbGxpcHRpY2FsIEFyY1xuICAgIC8vQSAocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSsgIEFic29sdXRlIEVsbGlwdGljYWwgQXJjXG5cbiAgICAvLyByZXR1cm4gZWFybHkgaWYgZGF0YSBpcyBub3QgZGVmaW5lZFxuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIGNvbW1hbmQgc3RyaW5nXG4gICAgdmFyIGNzID0gZGF0YTtcblxuICAgIC8vIGNvbW1hbmQgY2hhcnNcbiAgICB2YXIgY2MgPSBbXG4gICAgICAnbScsXG4gICAgICAnTScsXG4gICAgICAnbCcsXG4gICAgICAnTCcsXG4gICAgICAndicsXG4gICAgICAnVicsXG4gICAgICAnaCcsXG4gICAgICAnSCcsXG4gICAgICAneicsXG4gICAgICAnWicsXG4gICAgICAnYycsXG4gICAgICAnQycsXG4gICAgICAncScsXG4gICAgICAnUScsXG4gICAgICAndCcsXG4gICAgICAnVCcsXG4gICAgICAncycsXG4gICAgICAnUycsXG4gICAgICAnYScsXG4gICAgICAnQSdcbiAgICBdO1xuICAgIC8vIGNvbnZlcnQgd2hpdGUgc3BhY2VzIHRvIGNvbW1hc1xuICAgIGNzID0gY3MucmVwbGFjZShuZXcgUmVnRXhwKCcgJywgJ2cnKSwgJywnKTtcbiAgICAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNjLmxlbmd0aDsgbisrKSB7XG4gICAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgYXJyYXlcbiAgICB2YXIgYXJyID0gY3Muc3BsaXQoJ3wnKTtcbiAgICB2YXIgY2EgPSBbXTtcbiAgICB2YXIgY29vcmRzID0gW107XG4gICAgLy8gaW5pdCBjb250ZXh0IHBvaW50XG4gICAgdmFyIGNweCA9IDA7XG4gICAgdmFyIGNweSA9IDA7XG5cbiAgICB2YXIgcmUgPSAvKFstK10/KChcXGQrXFwuXFxkKyl8KChcXGQrKXwoXFwuXFxkKykpKSg/OmVbLStdP1xcZCspPykvZ2k7XG4gICAgdmFyIG1hdGNoO1xuICAgIGZvciAobiA9IDE7IG4gPCBhcnIubGVuZ3RoOyBuKyspIHtcbiAgICAgIHZhciBzdHIgPSBhcnJbbl07XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG5cbiAgICAgIGNvb3Jkcy5sZW5ndGggPSAwO1xuICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoc3RyKSkpIHtcbiAgICAgICAgY29vcmRzLnB1c2gobWF0Y2hbMF0pO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhzdHIpKSkge1xuICAgICAgLy8gICBjb29yZHMucHVzaChtYXRjaFswXSk7XG4gICAgICAvLyB9XG4gICAgICB2YXIgcCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlRmxvYXQoY29vcmRzW2pdKTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgICAgcC5wdXNoKHBhcnNlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcC5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgICAgLy8gY2FzZSBmb3IgYSB0cmFpbGluZyBjb21tYSBiZWZvcmUgbmV4dCBjb21tYW5kXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY21kID0gbnVsbDtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgc3RhcnRYID0gY3B4LFxuICAgICAgICAgIHN0YXJ0WSA9IGNweTtcbiAgICAgICAgLy8gTW92ZSB2YXIgZnJvbSB3aXRoaW4gdGhlIHN3aXRjaCB0byB1cCBoZXJlIChqc2hpbnQpXG4gICAgICAgIHZhciBwcmV2Q21kLCBjdGxQdHgsIGN0bFB0eTsgLy8gU3MsIFR0XG4gICAgICAgIHZhciByeCwgcnksIHBzaSwgZmEsIGZzLCB4MSwgeTE7IC8vIEFhXG5cbiAgICAgICAgLy8gY29udmVydCBsLCBILCBoLCBWLCBhbmQgdiB0byBMXG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgIC8vIE5vdGU6IEtlZXAgdGhlIGxpbmVUbydzIGFib3ZlIHRoZSBtb3ZlVG8ncyBpbiB0aGlzIHN3aXRjaFxuICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnTCc7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIE5vdGU6IGxpbmVUbyBoYW5kbGVycyBuZWVkIHRvIGJlIGFib3ZlIHRoaXMgcG9pbnRcbiAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIHZhciBkeCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBkeSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNweCArPSBkeDtcbiAgICAgICAgICAgIGNweSArPSBkeTtcbiAgICAgICAgICAgIGNtZCA9ICdNJztcbiAgICAgICAgICAgIC8vIEFmdGVyIGNsb3NpbmcgdGhlIHBhdGggbW92ZSB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgLy8gdG8gdGhlIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgcGF0aCAoaWYgYW55KS5cbiAgICAgICAgICAgIGlmIChjYS5sZW5ndGggPiAyICYmIGNhW2NhLmxlbmd0aCAtIDFdLmNvbW1hbmQgPT09ICd6Jykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpZHggPSBjYS5sZW5ndGggLSAyOyBpZHggPj0gMDsgaWR4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FbaWR4XS5jb21tYW5kID09PSAnTScpIHtcbiAgICAgICAgICAgICAgICAgIGNweCA9IGNhW2lkeF0ucG9pbnRzWzBdICsgZHg7XG4gICAgICAgICAgICAgICAgICBjcHkgPSBjYVtpZHhdLnBvaW50c1sxXSArIGR5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBjID0gJ2wnO1xuICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBwb2ludHMgYXJlIHRyZWF0ZWQgYXMgcmVsYXRpdmUgbGluZVRvXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNtZCA9ICdNJztcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgICAvLyBzdWJzZXF1ZW50IHBvaW50cyBhcmUgdHJlYXRlZCBhcyBhYnNvbHV0ZSBsaW5lVG9cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnTCc7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnTCc7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgcG9pbnRzLnB1c2gocC5zaGlmdCgpLCBwLnNoaWZ0KCksIHAuc2hpZnQoKSwgcC5zaGlmdCgpKTtcbiAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgcG9pbnRzLnB1c2goXG4gICAgICAgICAgICAgIGNweCArIHAuc2hpZnQoKSxcbiAgICAgICAgICAgICAgY3B5ICsgcC5zaGlmdCgpLFxuICAgICAgICAgICAgICBjcHggKyBwLnNoaWZ0KCksXG4gICAgICAgICAgICAgIGNweSArIHAuc2hpZnQoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0MnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocHJldkNtZC5jb21tYW5kID09PSAnQycpIHtcbiAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzJdKTtcbiAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnQyc7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgIHByZXZDbWQgPSBjYVtjYS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2Q21kLmNvbW1hbmQgPT09ICdDJykge1xuICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMl0pO1xuICAgICAgICAgICAgICBjdGxQdHkgPSBjcHkgKyAoY3B5IC0gcHJldkNtZC5wb2ludHNbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3RsUHR4LCBjdGxQdHksIGNweCArIHAuc2hpZnQoKSwgY3B5ICsgcC5zaGlmdCgpKTtcbiAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0MnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICBwb2ludHMucHVzaChwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCArIHAuc2hpZnQoKSwgY3B5ICsgcC5zaGlmdCgpKTtcbiAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ1EnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocHJldkNtZC5jb21tYW5kID09PSAnUScpIHtcbiAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzBdKTtcbiAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNtZCA9ICdRJztcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgIHByZXZDbWQgPSBjYVtjYS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2Q21kLmNvbW1hbmQgPT09ICdRJykge1xuICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMF0pO1xuICAgICAgICAgICAgICBjdGxQdHkgPSBjcHkgKyAoY3B5IC0gcHJldkNtZC5wb2ludHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnUSc7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICByeCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHJ5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgcHNpID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgZmEgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBmcyA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHgxID0gY3B4O1xuICAgICAgICAgICAgeTEgPSBjcHk7XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnQSc7XG4gICAgICAgICAgICBwb2ludHMgPSB0aGlzLmNvbnZlcnRFbmRwb2ludFRvQ2VudGVyUGFyYW1ldGVyaXphdGlvbihcbiAgICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgICBjcHgsXG4gICAgICAgICAgICAgIGNweSxcbiAgICAgICAgICAgICAgZmEsXG4gICAgICAgICAgICAgIGZzLFxuICAgICAgICAgICAgICByeCxcbiAgICAgICAgICAgICAgcnksXG4gICAgICAgICAgICAgIHBzaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcnggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICByeSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHBzaSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGZhID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgZnMgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB4MSA9IGNweDtcbiAgICAgICAgICAgIHkxID0gY3B5O1xuICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnQSc7XG4gICAgICAgICAgICBwb2ludHMgPSB0aGlzLmNvbnZlcnRFbmRwb2ludFRvQ2VudGVyUGFyYW1ldGVyaXphdGlvbihcbiAgICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgICBjcHgsXG4gICAgICAgICAgICAgIGNweSxcbiAgICAgICAgICAgICAgZmEsXG4gICAgICAgICAgICAgIGZzLFxuICAgICAgICAgICAgICByeCxcbiAgICAgICAgICAgICAgcnksXG4gICAgICAgICAgICAgIHBzaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2EucHVzaCh7XG4gICAgICAgICAgY29tbWFuZDogY21kIHx8IGMsXG4gICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIHg6IHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IHN0YXJ0WVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGF0aExlbmd0aDogdGhpcy5jYWxjTGVuZ3RoKHN0YXJ0WCwgc3RhcnRZLCBjbWQgfHwgYywgcG9pbnRzKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGMgPT09ICd6JyB8fCBjID09PSAnWicpIHtcbiAgICAgICAgY2EucHVzaCh7XG4gICAgICAgICAgY29tbWFuZDogJ3onLFxuICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgc3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBwYXRoTGVuZ3RoOiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjYTtcbiAgfTtcbiAgS29udmEuUGF0aC5jYWxjTGVuZ3RoID0gZnVuY3Rpb24oeCwgeSwgY21kLCBwb2ludHMpIHtcbiAgICB2YXIgbGVuLCBwMSwgcDIsIHQ7XG4gICAgdmFyIHBhdGggPSBLb252YS5QYXRoO1xuXG4gICAgc3dpdGNoIChjbWQpIHtcbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgICByZXR1cm4gcGF0aC5nZXRMaW5lTGVuZ3RoKHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xuICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgIHAxID0gcGF0aC5nZXRQb2ludE9uQ3ViaWNCZXppZXIoXG4gICAgICAgICAgMCxcbiAgICAgICAgICB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgcG9pbnRzWzBdLFxuICAgICAgICAgIHBvaW50c1sxXSxcbiAgICAgICAgICBwb2ludHNbMl0sXG4gICAgICAgICAgcG9pbnRzWzNdLFxuICAgICAgICAgIHBvaW50c1s0XSxcbiAgICAgICAgICBwb2ludHNbNV1cbiAgICAgICAgKTtcbiAgICAgICAgZm9yICh0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgICBwMiA9IHBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyKFxuICAgICAgICAgICAgdCxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgcG9pbnRzWzBdLFxuICAgICAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICAgICAgcG9pbnRzWzJdLFxuICAgICAgICAgICAgcG9pbnRzWzNdLFxuICAgICAgICAgICAgcG9pbnRzWzRdLFxuICAgICAgICAgICAgcG9pbnRzWzVdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xuICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgIHAxID0gcGF0aC5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICBwb2ludHNbMV0sXG4gICAgICAgICAgcG9pbnRzWzJdLFxuICAgICAgICAgIHBvaW50c1szXVxuICAgICAgICApO1xuICAgICAgICBmb3IgKHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xuICAgICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKFxuICAgICAgICAgICAgdCxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgcG9pbnRzWzBdLFxuICAgICAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICAgICAgcG9pbnRzWzJdLFxuICAgICAgICAgICAgcG9pbnRzWzNdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byBsaW5lIHNlZ21lbnRzXG4gICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9pbnRzWzRdO1xuICAgICAgICAvLyA0ID0gdGhldGFcbiAgICAgICAgdmFyIGRUaGV0YSA9IHBvaW50c1s1XTtcbiAgICAgICAgLy8gNSA9IGRUaGV0YVxuICAgICAgICB2YXIgZW5kID0gcG9pbnRzWzRdICsgZFRoZXRhO1xuICAgICAgICB2YXIgaW5jID0gTWF0aC5QSSAvIDE4MC4wO1xuICAgICAgICAvLyAxIGRlZ3JlZSByZXNvbHV0aW9uXG4gICAgICAgIGlmIChNYXRoLmFicyhzdGFydCAtIGVuZCkgPCBpbmMpIHtcbiAgICAgICAgICBpbmMgPSBNYXRoLmFicyhzdGFydCAtIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogZm9yIHB1cnBvc2Ugb2YgY2FsY3VsYXRpbmcgYXJjIGxlbmd0aCwgbm90IGdvaW5nIHRvIHdvcnJ5IGFib3V0IHJvdGF0aW5nIFgtYXhpcyBieSBhbmdsZSBwc2lcbiAgICAgICAgcDEgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKFxuICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICBwb2ludHNbMV0sXG4gICAgICAgICAgcG9pbnRzWzJdLFxuICAgICAgICAgIHBvaW50c1szXSxcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIGlmIChkVGhldGEgPCAwKSB7XG4gICAgICAgICAgLy8gY2xvY2t3aXNlXG4gICAgICAgICAgZm9yICh0ID0gc3RhcnQgLSBpbmM7IHQgPiBlbmQ7IHQgLT0gaW5jKSB7XG4gICAgICAgICAgICBwMiA9IHBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoXG4gICAgICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICAgICAgICBwb2ludHNbMl0sXG4gICAgICAgICAgICAgIHBvaW50c1szXSxcbiAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxlbiArPSBwYXRoLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgICAgICAgIGZvciAodCA9IHN0YXJ0ICsgaW5jOyB0IDwgZW5kOyB0ICs9IGluYykge1xuICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKFxuICAgICAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgICAgIHBvaW50c1sxXSxcbiAgICAgICAgICAgICAgcG9pbnRzWzJdLFxuICAgICAgICAgICAgICBwb2ludHNbM10sXG4gICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKFxuICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICBwb2ludHNbMV0sXG4gICAgICAgICAgcG9pbnRzWzJdLFxuICAgICAgICAgIHBvaW50c1szXSxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuXG4gICAgICAgIHJldHVybiBsZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIEtvbnZhLlBhdGguY29udmVydEVuZHBvaW50VG9DZW50ZXJQYXJhbWV0ZXJpemF0aW9uID0gZnVuY3Rpb24oXG4gICAgeDEsXG4gICAgeTEsXG4gICAgeDIsXG4gICAgeTIsXG4gICAgZmEsXG4gICAgZnMsXG4gICAgcngsXG4gICAgcnksXG4gICAgcHNpRGVnXG4gICkge1xuICAgIC8vIERlcml2ZWQgZnJvbTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgIHZhciBwc2kgPSBwc2lEZWcgKiAoTWF0aC5QSSAvIDE4MC4wKTtcbiAgICB2YXIgeHAgPSBNYXRoLmNvcyhwc2kpICogKHgxIC0geDIpIC8gMi4wICsgTWF0aC5zaW4ocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgICB2YXIgeXAgPVxuICAgICAgLTEgKiBNYXRoLnNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgTWF0aC5jb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcblxuICAgIHZhciBsYW1iZGEgPSB4cCAqIHhwIC8gKHJ4ICogcngpICsgeXAgKiB5cCAvIChyeSAqIHJ5KTtcblxuICAgIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgICByeCAqPSBNYXRoLnNxcnQobGFtYmRhKTtcbiAgICAgIHJ5ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICAgIH1cblxuICAgIHZhciBmID0gTWF0aC5zcXJ0KFxuICAgICAgKHJ4ICogcnggKiAocnkgKiByeSkgLSByeCAqIHJ4ICogKHlwICogeXApIC0gcnkgKiByeSAqICh4cCAqIHhwKSkgL1xuICAgICAgICAocnggKiByeCAqICh5cCAqIHlwKSArIHJ5ICogcnkgKiAoeHAgKiB4cCkpXG4gICAgKTtcblxuICAgIGlmIChmYSA9PT0gZnMpIHtcbiAgICAgIGYgKj0gLTE7XG4gICAgfVxuICAgIGlmIChpc05hTihmKSkge1xuICAgICAgZiA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGN4cCA9IGYgKiByeCAqIHlwIC8gcnk7XG4gICAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuXG4gICAgdmFyIGN4ID0gKHgxICsgeDIpIC8gMi4wICsgTWF0aC5jb3MocHNpKSAqIGN4cCAtIE1hdGguc2luKHBzaSkgKiBjeXA7XG4gICAgdmFyIGN5ID0gKHkxICsgeTIpIC8gMi4wICsgTWF0aC5zaW4ocHNpKSAqIGN4cCArIE1hdGguY29zKHBzaSkgKiBjeXA7XG5cbiAgICB2YXIgdk1hZyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSk7XG4gICAgfTtcbiAgICB2YXIgdlJhdGlvID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdKSAvICh2TWFnKHUpICogdk1hZyh2KSk7XG4gICAgfTtcbiAgICB2YXIgdkFuZ2xlID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgcmV0dXJuICh1WzBdICogdlsxXSA8IHVbMV0gKiB2WzBdID8gLTEgOiAxKSAqIE1hdGguYWNvcyh2UmF0aW8odSwgdikpO1xuICAgIH07XG4gICAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gICAgdmFyIHUgPSBbKHhwIC0gY3hwKSAvIHJ4LCAoeXAgLSBjeXApIC8gcnldO1xuICAgIHZhciB2ID0gWygtMSAqIHhwIC0gY3hwKSAvIHJ4LCAoLTEgKiB5cCAtIGN5cCkgLyByeV07XG4gICAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICAgIGlmICh2UmF0aW8odSwgdikgPD0gLTEpIHtcbiAgICAgIGRUaGV0YSA9IE1hdGguUEk7XG4gICAgfVxuICAgIGlmICh2UmF0aW8odSwgdikgPj0gMSkge1xuICAgICAgZFRoZXRhID0gMDtcbiAgICB9XG4gICAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICAgIGRUaGV0YSA9IGRUaGV0YSAtIDIgKiBNYXRoLlBJO1xuICAgIH1cbiAgICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgICAgZFRoZXRhID0gZFRoZXRhICsgMiAqIE1hdGguUEk7XG4gICAgfVxuICAgIHJldHVybiBbY3gsIGN5LCByeCwgcnksIHRoZXRhLCBkVGhldGEsIHBzaSwgZnNdO1xuICB9O1xuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlBhdGgsICdkYXRhJyk7XG5cbiAgLyoqXG4gICAqIHNldCBTVkcgcGF0aCBkYXRhIHN0cmluZy4gIFRoaXMgbWV0aG9kXG4gICAqICBhbHNvIGF1dG9tYXRpY2FsbHkgcGFyc2VzIHRoZSBkYXRhIHN0cmluZ1xuICAgKiAgaW50byBhIGRhdGEgYXJyYXkuICBDdXJyZW50bHkgc3VwcG9ydGVkIFNWRyBkYXRhOlxuICAgKiAgTSwgbSwgTCwgbCwgSCwgaCwgViwgdiwgUSwgcSwgVCwgdCwgQywgYywgUywgcywgQSwgYSwgWiwgelxuICAgKiBAbmFtZSBzZXREYXRhXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlBhdGgucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBTVkcgcGF0aCBjb21tYW5kIHN0cmluZ1xuICAgKi9cblxuICAvKipcbiAgICogZ2V0IFNWRyBwYXRoIGRhdGEgc3RyaW5nXG4gICAqIEBuYW1lIGdldERhdGFcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuUGF0aC5wcm90b3R5cGVcbiAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlBhdGgpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICAvL0NBTElCUkkgPSAnQ2FsaWJyaScsXG4gICAgTk9STUFMID0gJ25vcm1hbCc7XG5cbiAgLyoqXG4gICAqIFBhdGggY29uc3RydWN0b3IuXG4gICAqIEBhdXRob3IgSmFzb24gRm9sbGFzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZm9udEZhbWlseV0gZGVmYXVsdCBpcyBDYWxpYnJpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZvbnRTaXplXSBkZWZhdWx0IGlzIDEyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRTdHlsZV0gY2FuIGJlIG5vcm1hbCwgYm9sZCwgb3IgaXRhbGljLiAgRGVmYXVsdCBpcyBub3JtYWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZm9udFZhcmlhbnRdIGNhbiBiZSBub3JtYWwgb3Igc21hbGwtY2Fwcy4gIERlZmF1bHQgaXMgbm9ybWFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGV4dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRhdGEgU1ZHIGRhdGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5nZXRLZXJuaW5nIGEgZ2V0dGVyIGZvciBrZXJuaW5nIHZhbHVlcyBmb3IgdGhlIHNwZWNpZmllZCBjaGFyYWN0ZXJzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIga2VybmluZ1BhaXJzID0ge1xuICAgKiAgICdBJzoge1xuICAgKiAgICAgJyAnOiAtMC4wNTUxNzU3ODEyNSxcbiAgICogICAgICdUJzogLTAuMDc0MjE4NzUsXG4gICAqICAgICAnVic6IC0wLjA3NDIxODc1LFxuICAgKiAgIH0sXG4gICAqICAgJ1YnOiB7XG4gICAqICAgICAnLCc6IC0wLjA5MTc5Njg3NSxcbiAgICogICAgIFwiOlwiOiAtMC4wMzcxMDkzNzUsXG4gICAqICAgICBcIjtcIjogLTAuMDM3MTA5Mzc1LFxuICAgKiAgICAgXCJBXCI6IC0wLjA3NDIxODc1LFxuICAgKiAgIH1cbiAgICogfVxuICAgKiB2YXIgdGV4dHBhdGggPSBuZXcgS29udmEuVGV4dFBhdGgoe1xuICAgKiAgIHg6IDEwMCxcbiAgICogICB5OiA1MCxcbiAgICogICBmaWxsOiAnIzMzMycsXG4gICAqICAgZm9udFNpemU6ICcyNCcsXG4gICAqICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICogICB0ZXh0OiAnQWxsIHRoZSB3b3JsZFxcJ3MgYSBzdGFnZSwgYW5kIGFsbCB0aGUgbWVuIGFuZCB3b21lbiBtZXJlbHkgcGxheWVycy4nLFxuICAgKiAgIGRhdGE6ICdNMTAsMTAgQzAsMCAxMCwxNTAgMTAwLDEwMCBTMzAwLDE1MCA0MDAsNTAnLFxuICAgKiAgIGdldEtlcm5pbmc6IGZ1bmN0aW9uKGxlZnRDaGFyLCByaWdodENoYXIpIHtcbiAgICogICAgIHJldHVybiBrZXJuaW5nUGFpcnMuaGFzT3duUHJvcGVydHkobGVmdENoYXIpID8gcGFpcnNbbGVmdENoYXJdW3JpZ2h0Q2hhcl0gfHwgMCA6IDBcbiAgICogICB9XG4gICAqIH0pO1xuICAgKi9cbiAgS29udmEuVGV4dFBhdGggPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xuICAgIGNvbnRleHQuZmlsbFRleHQodGhpcy5wYXJ0aWFsVGV4dCwgMCwgMCk7XG4gIH1cbiAgZnVuY3Rpb24gX3N0cm9rZUZ1bmMoY29udGV4dCkge1xuICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0aGlzLnBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgfVxuXG4gIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZSA9IHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMuZHVtbXlDYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIHRoaXMuZGF0YUFycmF5ID0gW107XG4gICAgICB0aGlzLmdldEtlcm5pbmcgPSBjb25maWcgJiYgY29uZmlnLmdldEtlcm5pbmc7XG5cbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcblxuICAgICAgLy8gb3ZlcnJpZGVzXG4gICAgICAvLyBUT0RPOiBzaG91bGRuJ3QgdGhpcyBiZSBvbiB0aGUgcHJvdG90eXBlP1xuICAgICAgdGhpcy5fZmlsbEZ1bmMgPSBfZmlsbEZ1bmM7XG4gICAgICB0aGlzLl9zdHJva2VGdW5jID0gX3N0cm9rZUZ1bmM7XG4gICAgICB0aGlzLl9maWxsRnVuY0hpdCA9IF9maWxsRnVuYztcbiAgICAgIHRoaXMuX3N0cm9rZUZ1bmNIaXQgPSBfc3Ryb2tlRnVuYztcblxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnVGV4dFBhdGgnO1xuXG4gICAgICB0aGlzLmRhdGFBcnJheSA9IEtvbnZhLlBhdGgucGFyc2VQYXRoRGF0YSh0aGlzLmF0dHJzLmRhdGEpO1xuICAgICAgdGhpcy5vbignZGF0YUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LmRhdGFBcnJheSA9IEtvbnZhLlBhdGgucGFyc2VQYXRoRGF0YSh0aGlzLmF0dHJzLmRhdGEpO1xuICAgICAgICB0aGF0Ll9zZXRUZXh0RGF0YSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0ZXh0IGRhdGEgZm9yIGNlcnRhaW4gYXR0ciBjaGFuZ2VzXG4gICAgICB0aGlzLm9uKFxuICAgICAgICAndGV4dENoYW5nZS5rb252YSBhbGlnbkNoYW5nZS5rb252YSBsZXR0ZXJTcGFjaW5nQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgdGhhdC5fc2V0VGV4dERhdGFcbiAgICAgICk7XG4gICAgICB0aGF0Ll9zZXRUZXh0RGF0YSgpO1xuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgIHRoaXMuaGl0RnVuYyh0aGlzLl9oaXRGdW5jKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQuc2V0QXR0cignZm9udCcsIHRoaXMuX2dldENvbnRleHRGb250KCkpO1xuICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QmFzZWxpbmUnLCB0aGlzLmdldFRleHRCYXNlbGluZSgpKTtcbiAgICAgIGNvbnRleHQuc2V0QXR0cigndGV4dEFsaWduJywgJ2xlZnQnKTtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICB2YXIgdGV4dERlY29yYXRpb24gPSB0aGlzLnRleHREZWNvcmF0aW9uKCk7XG4gICAgICB2YXIgZmlsbCA9IHRoaXMuZmlsbCgpO1xuICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZSgpO1xuXG4gICAgICB2YXIgZ2x5cGhJbmZvID0gdGhpcy5nbHlwaEluZm87XG4gICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgICB2YXIgcDAgPSBnbHlwaEluZm9baV0ucDA7XG5cbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUocDAueCwgcDAueSk7XG4gICAgICAgIGNvbnRleHQucm90YXRlKGdseXBoSW5mb1tpXS5yb3RhdGlvbik7XG4gICAgICAgIHRoaXMucGFydGlhbFRleHQgPSBnbHlwaEluZm9baV0udGV4dDtcblxuICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCBmb250U2l6ZSAvIDIgKyAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhmb250U2l6ZSwgZm9udFNpemUgLyAyICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgLy8vLyBUbyBhc3Npc3Qgd2l0aCBkZWJ1Z2dpbmcgdmlzdWFsbHksIHVuY29tbWVudCBmb2xsb3dpbmdcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaWYgKGkgJSAyKVxuICAgICAgICAvLyBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ2N5YW4nO1xuICAgICAgICAvLyBlbHNlXG4gICAgICAgIC8vIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgICAvLyB2YXIgcDEgPSBnbHlwaEluZm9baV0ucDE7XG4gICAgICAgIC8vIGNvbnRleHQubW92ZVRvKHAwLngsIHAwLnkpO1xuICAgICAgICAvLyBjb250ZXh0LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgICAgLy8gY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGZpbGw7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZm9udFNpemUgLyAyMDtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBfaGl0RnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgdmFyIGdseXBoSW5mbyA9IHRoaXMuZ2x5cGhJbmZvO1xuICAgICAgaWYgKGdseXBoSW5mby5sZW5ndGggPj0gMSkge1xuICAgICAgICB2YXIgcDAgPSBnbHlwaEluZm9bMF0ucDA7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHAwLngsIHAwLnkpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaEluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAxID0gZ2x5cGhJbmZvW2ldLnAxO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc2V0QXR0cignbGluZVdpZHRoJywgdGhpcy5nZXRGb250U2l6ZSgpKTtcbiAgICAgIGNvbnRleHQuc2V0QXR0cignc3Ryb2tlU3R5bGUnLCB0aGlzLmNvbG9yS2V5KTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgdGV4dCB3aWR0aCBpbiBwaXhlbHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldFRleHRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0V2lkdGg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgdGV4dCBoZWlnaHQgaW4gcGl4ZWxzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHRIZWlnaHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXQgdGV4dFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICAgKi9cbiAgICBzZXRUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICBLb252YS5UZXh0LnByb3RvdHlwZS5zZXRUZXh0LmNhbGwodGhpcywgdGV4dCk7XG4gICAgfSxcbiAgICBfZ2V0VGV4dFNpemU6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBkdW1teUNhbnZhcyA9IHRoaXMuZHVtbXlDYW52YXM7XG4gICAgICB2YXIgX2NvbnRleHQgPSBkdW1teUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICBfY29udGV4dC5zYXZlKCk7XG5cbiAgICAgIF9jb250ZXh0LmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xuICAgICAgdmFyIG1ldHJpY3MgPSBfY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcblxuICAgICAgX2NvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogbWV0cmljcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUludCh0aGlzLmF0dHJzLmZvbnRTaXplLCAxMClcbiAgICAgIH07XG4gICAgfSxcbiAgICBfc2V0VGV4dERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIHNpemUgPSB0aGlzLl9nZXRUZXh0U2l6ZSh0aGlzLmF0dHJzLnRleHQpO1xuICAgICAgdmFyIGxldHRlclNwYWNpbmcgPSB0aGlzLmdldExldHRlclNwYWNpbmcoKTtcbiAgICAgIHZhciBhbGlnbiA9IHRoaXMuYWxpZ24oKTtcblxuICAgICAgdGhpcy50ZXh0V2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cbiAgICAgIHZhciB0ZXh0RnVsbFdpZHRoID0gTWF0aC5tYXgoXG4gICAgICAgIHRoaXMudGV4dFdpZHRoICsgKCh0aGlzLmF0dHJzLnRleHQgfHwgJycpLmxlbmd0aCAtIDEpICogbGV0dGVyU3BhY2luZyxcbiAgICAgICAgMFxuICAgICAgKTtcblxuICAgICAgdGhpcy5nbHlwaEluZm8gPSBbXTtcblxuICAgICAgdmFyIGZ1bGxQYXRoV2lkdGggPSAwO1xuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0aGF0LmRhdGFBcnJheS5sZW5ndGg7IGwrKykge1xuICAgICAgICBpZiAodGhhdC5kYXRhQXJyYXlbbF0ucGF0aExlbmd0aCA+IDApIHtcbiAgICAgICAgICBmdWxsUGF0aFdpZHRoICs9IHRoYXQuZGF0YUFycmF5W2xdLnBhdGhMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KDAsIGZ1bGxQYXRoV2lkdGggLyAyIC0gdGV4dEZ1bGxXaWR0aCAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KDAsIGZ1bGxQYXRoV2lkdGggLSB0ZXh0RnVsbFdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoYXJBcnIgPSB0aGlzLmdldFRleHQoKS5zcGxpdCgnJyk7XG4gICAgICB2YXIgc3BhY2VzTnVtYmVyID0gdGhpcy5nZXRUZXh0KCkuc3BsaXQoJyAnKS5sZW5ndGggLSAxO1xuXG4gICAgICB2YXIgcDAsIHAxLCBwYXRoQ21kO1xuXG4gICAgICB2YXIgcEluZGV4ID0gLTE7XG4gICAgICB2YXIgY3VycmVudFQgPSAwO1xuICAgICAgLy8gdmFyIHN1bUxlbmd0aCA9IDA7XG4gICAgICAvLyBmb3IodmFyIGogPSAwOyBqIDwgdGhhdC5kYXRhQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vICAgaWYodGhhdC5kYXRhQXJyYXlbal0ucGF0aExlbmd0aCA+IDApIHtcbiAgICAgIC8vXG4gICAgICAvLyAgICAgaWYgKHN1bUxlbmd0aCArIHRoYXQuZGF0YUFycmF5W2pdLnBhdGhMZW5ndGggPiBvZmZzZXQpIHt9XG4gICAgICAvLyAgICAgICBmdWxsUGF0aFdpZHRoICs9IHRoYXQuZGF0YUFycmF5W2pdLnBhdGhMZW5ndGg7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cblxuICAgICAgdmFyIGdldE5leHRQYXRoU2VnbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjdXJyZW50VCA9IDA7XG4gICAgICAgIHZhciBwYXRoRGF0YSA9IHRoYXQuZGF0YUFycmF5O1xuXG4gICAgICAgIGZvciAodmFyIGogPSBwSW5kZXggKyAxOyBqIDwgcGF0aERhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAocGF0aERhdGFbal0ucGF0aExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBJbmRleCA9IGo7XG5cbiAgICAgICAgICAgIHJldHVybiBwYXRoRGF0YVtqXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhdGhEYXRhW2pdLmNvbW1hbmQgPT09ICdNJykge1xuICAgICAgICAgICAgcDAgPSB7XG4gICAgICAgICAgICAgIHg6IHBhdGhEYXRhW2pdLnBvaW50c1swXSxcbiAgICAgICAgICAgICAgeTogcGF0aERhdGFbal0ucG9pbnRzWzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBmaW5kU2VnbWVudFRvRml0Q2hhcmFjdGVyID0gZnVuY3Rpb24oYykge1xuICAgICAgICB2YXIgZ2x5cGhXaWR0aCA9IHRoYXQuX2dldFRleHRTaXplKGMpLndpZHRoICsgbGV0dGVyU3BhY2luZztcblxuICAgICAgICBpZiAoYyA9PT0gJyAnICYmIGFsaWduID09PSAnanVzdGlmeScpIHtcbiAgICAgICAgICBnbHlwaFdpZHRoICs9IChmdWxsUGF0aFdpZHRoIC0gdGV4dEZ1bGxXaWR0aCkgLyBzcGFjZXNOdW1iZXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VyckxlbiA9IDA7XG4gICAgICAgIHZhciBhdHRlbXB0cyA9IDA7XG5cbiAgICAgICAgcDEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICBNYXRoLmFicyhnbHlwaFdpZHRoIC0gY3VyckxlbikgLyBnbHlwaFdpZHRoID4gMC4wMSAmJlxuICAgICAgICAgIGF0dGVtcHRzIDwgMjVcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXR0ZW1wdHMrKztcbiAgICAgICAgICB2YXIgY3VtdWxhdGl2ZVBhdGhMZW5ndGggPSBjdXJyTGVuO1xuICAgICAgICAgIHdoaWxlIChwYXRoQ21kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhdGhDbWQgPSBnZXROZXh0UGF0aFNlZ21lbnQoKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBwYXRoQ21kICYmXG4gICAgICAgICAgICAgIGN1bXVsYXRpdmVQYXRoTGVuZ3RoICsgcGF0aENtZC5wYXRoTGVuZ3RoIDwgZ2x5cGhXaWR0aFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGN1bXVsYXRpdmVQYXRoTGVuZ3RoICs9IHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgcGF0aENtZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aENtZCA9PT0ge30gfHwgcDAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmVlZE5ld1NlZ21lbnQgPSBmYWxzZTtcblxuICAgICAgICAgIHN3aXRjaCAocGF0aENtZC5jb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIEtvbnZhLlBhdGguZ2V0TGluZUxlbmd0aChcbiAgICAgICAgICAgICAgICAgIHAwLngsXG4gICAgICAgICAgICAgICAgICBwMC55LFxuICAgICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1sxXVxuICAgICAgICAgICAgICAgICkgPiBnbHlwaFdpZHRoXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHAxID0gS29udmEuUGF0aC5nZXRQb2ludE9uTGluZShcbiAgICAgICAgICAgICAgICAgIGdseXBoV2lkdGgsXG4gICAgICAgICAgICAgICAgICBwMC54LFxuICAgICAgICAgICAgICAgICAgcDAueSxcbiAgICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMV0sXG4gICAgICAgICAgICAgICAgICBwMC54LFxuICAgICAgICAgICAgICAgICAgcDAueVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aENtZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBwYXRoQ21kLnBvaW50c1s0XTtcbiAgICAgICAgICAgICAgLy8gNCA9IHRoZXRhXG4gICAgICAgICAgICAgIHZhciBkVGhldGEgPSBwYXRoQ21kLnBvaW50c1s1XTtcbiAgICAgICAgICAgICAgLy8gNSA9IGRUaGV0YVxuICAgICAgICAgICAgICB2YXIgZW5kID0gcGF0aENtZC5wb2ludHNbNF0gKyBkVGhldGE7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgPSBzdGFydCArIDAuMDAwMDAwMDE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2x5cGhXaWR0aCA+IGN1cnJMZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBKdXN0IGluIGNhc2Ugc3RhcnQgaXMgMFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUICs9IE1hdGguUEkgLyAxODAuMCAqIGRUaGV0YSAvIE1hdGguYWJzKGRUaGV0YSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgLT0gTWF0aC5QSSAvIDM2MC4wICogZFRoZXRhIC8gTWF0aC5hYnMoZFRoZXRhKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIENyZWRpdCBmb3IgYnVnIGZpeDogQHRoZXJ0aCBodHRwczovL2dpdGh1Yi5jb20vZXJpY2Ryb3dlbGwvS29udmFKUy9pc3N1ZXMvMjQ5XG4gICAgICAgICAgICAgIC8vIE9sZCBjb2RlIGZhaWxlZCB0byByZW5kZXIgdGV4dCBhbG9uZyBhcmMgb2YgdGhpcyBwYXRoOiBcIk0gNTAgNTAgYSAxNTAgNTAgMCAwIDEgMjUwIDUwIGwgNTAgMFwiXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZFRoZXRhIDwgMCAmJiBjdXJyZW50VCA8IGVuZCkgfHxcbiAgICAgICAgICAgICAgICAoZFRoZXRhID49IDAgJiYgY3VycmVudFQgPiBlbmQpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gZW5kO1xuICAgICAgICAgICAgICAgIG5lZWROZXdTZWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwMSA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMV0sXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMl0sXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbM10sXG4gICAgICAgICAgICAgICAgY3VycmVudFQsXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbNl1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoV2lkdGggPiBwYXRoQ21kLnBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMC4wMDAwMDAwMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSBnbHlwaFdpZHRoIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChnbHlwaFdpZHRoID4gY3Vyckxlbikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUICs9IChnbHlwaFdpZHRoIC0gY3VyckxlbikgLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgLT0gKGN1cnJMZW4gLSBnbHlwaFdpZHRoKSAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VCA+IDEuMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMS4wO1xuICAgICAgICAgICAgICAgIG5lZWROZXdTZWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwMSA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyKFxuICAgICAgICAgICAgICAgIGN1cnJlbnRULFxuICAgICAgICAgICAgICAgIHBhdGhDbWQuc3RhcnQueCxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnN0YXJ0LnksXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMV0sXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMl0sXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbM10sXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbNF0sXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbNV1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgPSBnbHlwaFdpZHRoIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdseXBoV2lkdGggPiBjdXJyTGVuKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgKz0gKGdseXBoV2lkdGggLSBjdXJyTGVuKSAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCAtPSAoY3VyckxlbiAtIGdseXBoV2lkdGgpIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUID4gMS4wKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgPSAxLjA7XG4gICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHAxID0gS29udmEuUGF0aC5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKFxuICAgICAgICAgICAgICAgIGN1cnJlbnRULFxuICAgICAgICAgICAgICAgIHBhdGhDbWQuc3RhcnQueCxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnN0YXJ0LnksXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMV0sXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMl0sXG4gICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbM11cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN1cnJMZW4gPSBLb252YS5QYXRoLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcDEueCwgcDEueSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lZWROZXdTZWdtZW50KSB7XG4gICAgICAgICAgICBuZWVkTmV3U2VnbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcGF0aENtZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGZha2Ugc2VhcmNoIGZvciBvZmZzZXQsIHRoaXMgaXMgdmVyeSBiYWQgYXBwcm9hY2hcbiAgICAgIC8vIFRPRE86IGZpbmQgb3RoZXIgd2F5IHRvIGFkZCBvZmZzZXQgZnJvbSBzdGFydCAoZm9yIGFsaWduKVxuICAgICAgdmFyIHRlc3RDaGFyID0gJ0MnO1xuICAgICAgdmFyIGdseXBoV2lkdGggPSB0aGF0Ll9nZXRUZXh0U2l6ZSh0ZXN0Q2hhcikud2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvZmZzZXQgLyBnbHlwaFdpZHRoOyBrKyspIHtcbiAgICAgICAgZmluZFNlZ21lbnRUb0ZpdENoYXJhY3Rlcih0ZXN0Q2hhcik7XG4gICAgICAgIGlmIChwMCA9PT0gdW5kZWZpbmVkIHx8IHAxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwMCA9IHAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmluZCBwMSBzdWNoIHRoYXQgbGluZSBzZWdtZW50IGJldHdlZW4gcDAgYW5kIHAxIGlzIGFwcHJveC4gd2lkdGggb2YgZ2x5cGhcbiAgICAgICAgZmluZFNlZ21lbnRUb0ZpdENoYXJhY3RlcihjaGFyQXJyW2ldKTtcblxuICAgICAgICBpZiAocDAgPT09IHVuZGVmaW5lZCB8fCBwMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2lkdGggPSBLb252YS5QYXRoLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcDEueCwgcDEueSk7XG5cbiAgICAgICAgdmFyIGtlcm4gPSAwO1xuICAgICAgICBpZiAodGhpcy5nZXRLZXJuaW5nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGdldEtlcm5pbmcgaXMgYSB1c2VyIHByb3ZpZGVkIGdldHRlci4gTWFrZSBzdXJlIGl0IG5ldmVyIGJyZWFrcyBvdXIgbG9naWNcbiAgICAgICAgICAgIGtlcm4gPVxuICAgICAgICAgICAgICB0aGlzLmdldEtlcm5pbmcoY2hhckFycltpIC0gMV0sIGNoYXJBcnJbaV0pICogdGhpcy5mb250U2l6ZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGtlcm4gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAwLnggKz0ga2VybjtcbiAgICAgICAgcDEueCArPSBrZXJuO1xuICAgICAgICB0aGlzLnRleHRXaWR0aCArPSBrZXJuO1xuXG4gICAgICAgIHZhciBtaWRwb2ludCA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPbkxpbmUoXG4gICAgICAgICAga2VybiArIHdpZHRoIC8gMi4wLFxuICAgICAgICAgIHAwLngsXG4gICAgICAgICAgcDAueSxcbiAgICAgICAgICBwMS54LFxuICAgICAgICAgIHAxLnlcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcm90YXRpb24gPSBNYXRoLmF0YW4yKHAxLnkgLSBwMC55LCBwMS54IC0gcDAueCk7XG4gICAgICAgIHRoaXMuZ2x5cGhJbmZvLnB1c2goe1xuICAgICAgICAgIHRyYW5zcG9zZVg6IG1pZHBvaW50LngsXG4gICAgICAgICAgdHJhbnNwb3NlWTogbWlkcG9pbnQueSxcbiAgICAgICAgICB0ZXh0OiBjaGFyQXJyW2ldLFxuICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgICAgICBwMDogcDAsXG4gICAgICAgICAgcDE6IHAxXG4gICAgICAgIH0pO1xuICAgICAgICBwMCA9IHAxO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgICB0aGlzLmdseXBoSW5mby5mb3JFYWNoKGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgcG9pbnRzLnB1c2goaW5mby5wMC54KTtcbiAgICAgICAgcG9pbnRzLnB1c2goaW5mby5wMC55KTtcbiAgICAgICAgcG9pbnRzLnB1c2goaW5mby5wMS54KTtcbiAgICAgICAgcG9pbnRzLnB1c2goaW5mby5wMS55KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG1pblggPSBwb2ludHNbMF07XG4gICAgICB2YXIgbWF4WCA9IHBvaW50c1swXTtcbiAgICAgIHZhciBtaW5ZID0gcG9pbnRzWzBdO1xuICAgICAgdmFyIG1heFkgPSBwb2ludHNbMF07XG4gICAgICB2YXIgeCwgeTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB4ID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgICAgeSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgICB9XG4gICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmZvbnRTaXplKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBNYXRoLnJvdW5kKG1pblgpIC0gZm9udFNpemUgLyAyLFxuICAgICAgICB5OiBNYXRoLnJvdW5kKG1pblkpIC0gZm9udFNpemUgLyAyLFxuICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChtYXhYIC0gbWluWCkgKyBmb250U2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKG1heFkgLSBtaW5ZKSArIGZvbnRTaXplXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBtYXAgVGV4dFBhdGggbWV0aG9kcyB0byBUZXh0XG4gIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZS5fZ2V0Q29udGV4dEZvbnQgPVxuICAgIEtvbnZhLlRleHQucHJvdG90eXBlLl9nZXRDb250ZXh0Rm9udDtcblxuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5UZXh0UGF0aCwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBzZXR0ZXJzIGFuZCBnZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHRQYXRoLCAnZGF0YScpO1xuXG4gIC8qKlxuICAgKiBzZXQgU1ZHIHBhdGggZGF0YSBzdHJpbmcuICBUaGlzIG1ldGhvZFxuICAgKiAgYWxzbyBhdXRvbWF0aWNhbGx5IHBhcnNlcyB0aGUgZGF0YSBzdHJpbmdcbiAgICogIGludG8gYSBkYXRhIGFycmF5LiAgQ3VycmVudGx5IHN1cHBvcnRlZCBTVkcgZGF0YTpcbiAgICogIE0sIG0sIEwsIGwsIEgsIGgsIFYsIHYsIFEsIHEsIFQsIHQsIEMsIGMsIFMsIHMsIEEsIGEsIFosIHpcbiAgICogQG5hbWUgc2V0RGF0YVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFNWRyBwYXRoIGNvbW1hbmQgc3RyaW5nXG4gICAqL1xuXG4gIC8qKlxuICAgKiBnZXQgU1ZHIHBhdGggZGF0YSBzdHJpbmdcbiAgICogQG5hbWUgZ2V0RGF0YVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdmb250RmFtaWx5JywgJ0FyaWFsJyk7XG5cbiAgLyoqXG4gICAqIHNldCBmb250IGZhbWlseVxuICAgKiBAbmFtZSBzZXRGb250RmFtaWx5XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udEZhbWlseVxuICAgKi9cblxuICAvKipcbiAgICogZ2V0IGZvbnQgZmFtaWx5XG4gICAqIEBuYW1lIGdldEZvbnRGYW1pbHlcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlRleHRQYXRoLFxuICAgICdmb250U2l6ZScsXG4gICAgMTIsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBzZXQgZm9udCBzaXplXG4gICAqIEBuYW1lIHNldEZvbnRTaXplXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge2ludH0gZm9udFNpemVcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldCBmb250IHNpemVcbiAgICogQG5hbWUgZ2V0Rm9udFNpemVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHRQYXRoLCAnZm9udFN0eWxlJywgTk9STUFMKTtcblxuICAvKipcbiAgICogc2V0IGZvbnQgc3R5bGUuICBDYW4gYmUgJ25vcm1hbCcsICdpdGFsaWMnLCBvciAnYm9sZCcuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cbiAgICogQG5hbWUgc2V0Rm9udFN0eWxlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udFN0eWxlXG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2FsaWduJywgJ2xlZnQnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBob3Jpem9udGFsIGFsaWduIG9mIHRleHQuICBDYW4gYmUgJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0JyBvciAnanVzdGlmeSdcbiAgICogQG5hbWUgYWxpZ25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsaWduXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB0ZXh0IGFsaWduXG4gICAqIHZhciBhbGlnbiA9IHRleHQuYWxpZ24oKTtcbiAgICpcbiAgICogLy8gY2VudGVyIHRleHRcbiAgICogdGV4dC5hbGlnbignY2VudGVyJyk7XG4gICAqXG4gICAqIC8vIGFsaWduIHRleHQgdG8gcmlnaHRcbiAgICogdGV4dC5hbGlnbigncmlnaHQnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuVGV4dFBhdGgsXG4gICAgJ2xldHRlclNwYWNpbmcnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBzZXQgbGV0dGVyIHNwYWNpbmcgcHJvcGVydHkuIERlZmF1bHQgdmFsdWUgaXMgMC5cbiAgICogQG5hbWUgbGV0dGVyU3BhY2luZ1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxldHRlclNwYWNpbmdcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XG5cbiAgLyoqXG4gICAqIHNldCB0ZXh0QmFzZWxpbmUgcHJvcGVydHkuIERlZmF1bHQgdmFsdWUgaXMgJ21pZGRsZScuXG4gICAqIENhbiBiZSAndG9wJywgJ2JvdHRvbScsICdtaWRkbGUnLCAnYWxwaGFiZXRpYycsICdoYW5naW5nJ1xuICAgKiBAbmFtZSB0ZXh0QmFzZWxpbmVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0QmFzZWxpbmVcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldCBmb250IHN0eWxlXG4gICAqIEBuYW1lIGdldEZvbnRTdHlsZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdmb250VmFyaWFudCcsIE5PUk1BTCk7XG5cbiAgLyoqXG4gICAqIHNldCBmb250IHZhcmlhbnQuICBDYW4gYmUgJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnLiAgJ25vcm1hbCcgaXMgdGhlIGRlZmF1bHQuXG4gICAqIEBuYW1lIHNldEZvbnRWYXJpYW50XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udFZhcmlhbnRcbiAgICovXG5cbiAgLyoqXG4gICAqIEBnZXQgZm9udCB2YXJpYW50XG4gICAqIEBuYW1lIGdldEZvbnRWYXJpYW50XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5UZXh0UGF0aCwgJ3RleHQnLCBFTVBUWV9TVFJJTkcpO1xuXG4gIC8qKlxuICAgKiBnZXQgdGV4dFxuICAgKiBAbmFtZSBnZXRUZXh0XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ3RleHREZWNvcmF0aW9uJywgbnVsbCk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgdGV4dCBkZWNvcmF0aW9uIG9mIGEgdGV4dC4gIENhbiBiZSAnJyBvciAndW5kZXJsaW5lJ1xuICAgKiBAbmFtZSB0ZXh0RGVjb3JhdGlvblxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dERlY29yYXRpb25cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHRleHQgZGVjb3JhdGlvblxuICAgKiB2YXIgdGV4dERlY29yYXRpb24gPSB0ZXh0LnRleHREZWNvcmF0aW9uKCk7XG4gICAqXG4gICAqIC8vIGNlbnRlciB0ZXh0XG4gICAqIHRleHQudGV4dERlY29yYXRpb24oJ3VuZGVybGluZScpO1xuICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVGV4dFBhdGgpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBSZWd1bGFyUG9seWdvbiBjb25zdHJ1Y3Rvci4mbmJzcDsgRXhhbXBsZXMgaW5jbHVkZSB0cmlhbmdsZXMsIHNxdWFyZXMsIHBlbnRhZ29ucywgaGV4YWdvbnMsIGV0Yy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNpZGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucmFkaXVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaGV4YWdvbiA9IG5ldyBLb252YS5SZWd1bGFyUG9seWdvbih7XG4gICAqICAgeDogMTAwLFxuICAgKiAgIHk6IDIwMCxcbiAgICogICBzaWRlczogNixcbiAgICogICByYWRpdXM6IDcwLFxuICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgKiAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICogICBzdHJva2VXaWR0aDogNFxuICAgKiB9KTtcbiAgICovXG4gIEtvbnZhLlJlZ3VsYXJQb2x5Z29uID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlID0ge1xuICAgIF9jZW50cm9pZDogdHJ1ZSxcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1JlZ3VsYXJQb2x5Z29uJztcbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgc2lkZXMgPSB0aGlzLmF0dHJzLnNpZGVzLFxuICAgICAgICByYWRpdXMgPSB0aGlzLmF0dHJzLnJhZGl1cyxcbiAgICAgICAgbixcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKDAsIDAgLSByYWRpdXMpO1xuXG4gICAgICBmb3IgKG4gPSAxOyBuIDwgc2lkZXM7IG4rKykge1xuICAgICAgICB4ID0gcmFkaXVzICogTWF0aC5zaW4obiAqIDIgKiBNYXRoLlBJIC8gc2lkZXMpO1xuICAgICAgICB5ID0gLTEgKiByYWRpdXMgKiBNYXRoLmNvcyhuICogMiAqIE1hdGguUEkgLyBzaWRlcyk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgdGhpcy5zZXRSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5SZWd1bGFyUG9seWdvbiwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuUmVndWxhclBvbHlnb24sXG4gICAgJ3JhZGl1cycsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIHNldCByYWRpdXNcbiAgICogQG5hbWUgc2V0UmFkaXVzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBnZXQgcmFkaXVzXG4gICAqIEBuYW1lIGdldFJhZGl1c1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5SZWd1bGFyUG9seWdvbi5wcm90b3R5cGVcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuUmVndWxhclBvbHlnb24sXG4gICAgJ3NpZGVzJyxcbiAgICAwLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogc2V0IG51bWJlciBvZiBzaWRlc1xuICAgKiBAbmFtZSBzZXRTaWRlc1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5SZWd1bGFyUG9seWdvbi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtpbnR9IHNpZGVzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBnZXQgbnVtYmVyIG9mIHNpZGVzXG4gICAqIEBuYW1lIGdldFNpZGVzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZVxuICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuUmVndWxhclBvbHlnb24pO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBTdGFyIGNvbnN0cnVjdG9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBjb25maWcubnVtUG9pbnRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5vdXRlclJhZGl1c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHN0YXIgPSBuZXcgS29udmEuU3Rhcih7XG4gICAqICAgeDogMTAwLFxuICAgKiAgIHk6IDIwMCxcbiAgICogICBudW1Qb2ludHM6IDUsXG4gICAqICAgaW5uZXJSYWRpdXM6IDcwLFxuICAgKiAgIG91dGVyUmFkaXVzOiA3MCxcbiAgICogICBmaWxsOiAncmVkJyxcbiAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAqICAgc3Ryb2tlV2lkdGg6IDRcbiAgICogfSk7XG4gICAqL1xuICBLb252YS5TdGFyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuU3Rhci5wcm90b3R5cGUgPSB7XG4gICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnU3Rhcic7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIGlubmVyUmFkaXVzID0gdGhpcy5pbm5lclJhZGl1cygpLFxuICAgICAgICBvdXRlclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMoKSxcbiAgICAgICAgbnVtUG9pbnRzID0gdGhpcy5udW1Qb2ludHMoKTtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKDAsIDAgLSBvdXRlclJhZGl1cyk7XG5cbiAgICAgIGZvciAodmFyIG4gPSAxOyBuIDwgbnVtUG9pbnRzICogMjsgbisrKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBuICUgMiA9PT0gMCA/IG91dGVyUmFkaXVzIDogaW5uZXJSYWRpdXM7XG4gICAgICAgIHZhciB4ID0gcmFkaXVzICogTWF0aC5zaW4obiAqIE1hdGguUEkgLyBudW1Qb2ludHMpO1xuICAgICAgICB2YXIgeSA9IC0xICogcmFkaXVzICogTWF0aC5jb3MobiAqIE1hdGguUEkgLyBudW1Qb2ludHMpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgIGlmICh0aGlzLm91dGVyUmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgaWYgKHRoaXMub3V0ZXJSYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xuICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU3RhciwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU3RhcixcbiAgICAnbnVtUG9pbnRzJyxcbiAgICA1LFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogc2V0IG51bWJlciBvZiBwb2ludHNcbiAgICogQG5hbWUgc2V0TnVtUG9pbnRzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gcG9pbnRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBnZXQgbnVtYmVyIG9mIHBvaW50c1xuICAgKiBAbmFtZSBnZXROdW1Qb2ludHNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU3Rhci5wcm90b3R5cGVcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU3RhcixcbiAgICAnaW5uZXJSYWRpdXMnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBzZXQgaW5uZXIgcmFkaXVzXG4gICAqIEBuYW1lIHNldElubmVyUmFkaXVzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldCBpbm5lciByYWRpdXNcbiAgICogQG5hbWUgZ2V0SW5uZXJSYWRpdXNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU3Rhci5wcm90b3R5cGVcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU3RhcixcbiAgICAnb3V0ZXJSYWRpdXMnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBzZXQgb3V0ZXIgcmFkaXVzXG4gICAqIEBuYW1lIHNldE91dGVyUmFkaXVzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldCBvdXRlciByYWRpdXNcbiAgICogQG5hbWUgZ2V0T3V0ZXJSYWRpdXNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU3Rhci5wcm90b3R5cGVcbiAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlN0YXIpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIGNvbnN0YW50c1xuICB2YXIgQVRUUl9DSEFOR0VfTElTVCA9IFtcbiAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICdwYWRkaW5nJyxcbiAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICd0ZXh0JyxcbiAgICAgICd3aWR0aCdcbiAgICBdLFxuICAgIENIQU5HRV9LT05WQSA9ICdDaGFuZ2Uua29udmEnLFxuICAgIE5PTkUgPSAnbm9uZScsXG4gICAgVVAgPSAndXAnLFxuICAgIFJJR0hUID0gJ3JpZ2h0JyxcbiAgICBET1dOID0gJ2Rvd24nLFxuICAgIExFRlQgPSAnbGVmdCcsXG4gICAgTEFCRUwgPSAnTGFiZWwnLFxuICAgIC8vIGNhY2hlZCB2YXJpYWJsZXNcbiAgICBhdHRyQ2hhbmdlTGlzdExlbiA9IEFUVFJfQ0hBTkdFX0xJU1QubGVuZ3RoO1xuXG4gIC8qKlxuICAgKiBMYWJlbCBjb25zdHJ1Y3Rvci4mbmJzcDsgTGFiZWxzIGFyZSBncm91cHMgdGhhdCBjb250YWluIGEgVGV4dCBhbmQgVGFnIHNoYXBlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBjcmVhdGUgbGFiZWxcbiAgICogdmFyIGxhYmVsID0gbmV3IEtvbnZhLkxhYmVsKHtcbiAgICogICB4OiAxMDAsXG4gICAqICAgeTogMTAwLFxuICAgKiAgIGRyYWdnYWJsZTogdHJ1ZVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gYWRkIGEgdGFnIHRvIHRoZSBsYWJlbFxuICAgKiBsYWJlbC5hZGQobmV3IEtvbnZhLlRhZyh7XG4gICAqICAgZmlsbDogJyNiYmInLFxuICAgKiAgIHN0cm9rZTogJyMzMzMnLFxuICAgKiAgIHNoYWRvd0NvbG9yOiAnYmxhY2snLFxuICAgKiAgIHNoYWRvd0JsdXI6IDEwLFxuICAgKiAgIHNoYWRvd09mZnNldDogWzEwLCAxMF0sXG4gICAqICAgc2hhZG93T3BhY2l0eTogMC4yLFxuICAgKiAgIGxpbmVKb2luOiAncm91bmQnLFxuICAgKiAgIHBvaW50ZXJEaXJlY3Rpb246ICd1cCcsXG4gICAqICAgcG9pbnRlcldpZHRoOiAyMCxcbiAgICogICBwb2ludGVySGVpZ2h0OiAyMCxcbiAgICogICBjb3JuZXJSYWRpdXM6IDVcbiAgICogfSkpO1xuICAgKlxuICAgKiAvLyBhZGQgdGV4dCB0byB0aGUgbGFiZWxcbiAgICogbGFiZWwuYWRkKG5ldyBLb252YS5UZXh0KHtcbiAgICogICB0ZXh0OiAnSGVsbG8gV29ybGQhJyxcbiAgICogICBmb250U2l6ZTogNTAsXG4gICAqICAgbGluZUhlaWdodDogMS4yLFxuICAgKiAgIHBhZGRpbmc6IDEwLFxuICAgKiAgIGZpbGw6ICdncmVlbidcbiAgICogIH0pKTtcbiAgICovXG4gIEtvbnZhLkxhYmVsID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLkxhYmVsLnByb3RvdHlwZSA9IHtcbiAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIEtvbnZhLkdyb3VwLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gTEFCRUw7XG5cbiAgICAgIHRoaXMub24oJ2FkZC5rb252YScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0aGF0Ll9hZGRMaXN0ZW5lcnMoZXZ0LmNoaWxkKTtcbiAgICAgICAgdGhhdC5fc3luYygpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgVGV4dCBzaGFwZSBmb3IgdGhlIGxhYmVsLiAgWW91IG5lZWQgdG8gYWNjZXNzIHRoZSBUZXh0IHNoYXBlIGluIG9yZGVyIHRvIHVwZGF0ZVxuICAgICAqIHRoZSB0ZXh0IHByb3BlcnRpZXNcbiAgICAgKiBAbmFtZSBnZXRUZXh0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5MYWJlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoJ1RleHQnKVswXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBUYWcgc2hhcGUgZm9yIHRoZSBsYWJlbC4gIFlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgVGFnIHNoYXBlIGluIG9yZGVyIHRvIHVwZGF0ZVxuICAgICAqIHRoZSBwb2ludGVyIHByb3BlcnRpZXMgYW5kIHRoZSBjb3JuZXIgcmFkaXVzXG4gICAgICogQG5hbWUgZ2V0VGFnXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5MYWJlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRUYWc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZCgnVGFnJylbMF07XG4gICAgfSxcbiAgICBfYWRkTGlzdGVuZXJzOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIG47XG4gICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0Ll9zeW5jKCk7XG4gICAgICB9O1xuXG4gICAgICAvLyB1cGRhdGUgdGV4dCBkYXRhIGZvciBjZXJ0YWluIGF0dHIgY2hhbmdlc1xuICAgICAgZm9yIChuID0gMDsgbiA8IGF0dHJDaGFuZ2VMaXN0TGVuOyBuKyspIHtcbiAgICAgICAgdGV4dC5vbihBVFRSX0NIQU5HRV9MSVNUW25dICsgQ0hBTkdFX0tPTlZBLCBmdW5jKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRleHQoKS5nZXRXaWR0aCgpO1xuICAgIH0sXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRleHQoKS5nZXRIZWlnaHQoKTtcbiAgICB9LFxuICAgIF9zeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRUZXh0KCksXG4gICAgICAgIHRhZyA9IHRoaXMuZ2V0VGFnKCksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHBvaW50ZXJEaXJlY3Rpb24sXG4gICAgICAgIHBvaW50ZXJXaWR0aCxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcG9pbnRlckhlaWdodDtcblxuICAgICAgaWYgKHRleHQgJiYgdGFnKSB7XG4gICAgICAgIHdpZHRoID0gdGV4dC5nZXRXaWR0aCgpO1xuICAgICAgICBoZWlnaHQgPSB0ZXh0LmdldEhlaWdodCgpO1xuICAgICAgICBwb2ludGVyRGlyZWN0aW9uID0gdGFnLmdldFBvaW50ZXJEaXJlY3Rpb24oKTtcbiAgICAgICAgcG9pbnRlcldpZHRoID0gdGFnLmdldFBvaW50ZXJXaWR0aCgpO1xuICAgICAgICBwb2ludGVySGVpZ2h0ID0gdGFnLmdldFBvaW50ZXJIZWlnaHQoKTtcbiAgICAgICAgeCA9IDA7XG4gICAgICAgIHkgPSAwO1xuXG4gICAgICAgIHN3aXRjaCAocG9pbnRlckRpcmVjdGlvbikge1xuICAgICAgICAgIGNhc2UgVVA6XG4gICAgICAgICAgICB4ID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgeSA9IC0xICogcG9pbnRlckhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUklHSFQ6XG4gICAgICAgICAgICB4ID0gd2lkdGggKyBwb2ludGVyV2lkdGg7XG4gICAgICAgICAgICB5ID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRE9XTjpcbiAgICAgICAgICAgIHggPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICB5ID0gaGVpZ2h0ICsgcG9pbnRlckhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTEVGVDpcbiAgICAgICAgICAgIHggPSAtMSAqIHBvaW50ZXJXaWR0aDtcbiAgICAgICAgICAgIHkgPSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0YWcuc2V0QXR0cnMoe1xuICAgICAgICAgIHg6IC0xICogeCxcbiAgICAgICAgICB5OiAtMSAqIHksXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRleHQuc2V0QXR0cnMoe1xuICAgICAgICAgIHg6IC0xICogeCxcbiAgICAgICAgICB5OiAtMSAqIHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkxhYmVsLCBLb252YS5Hcm91cCk7XG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkxhYmVsKTtcblxuICAvKipcbiAgICogVGFnIGNvbnN0cnVjdG9yLiZuYnNwOyBBIFRhZyBjYW4gYmUgY29uZmlndXJlZFxuICAgKiAgdG8gaGF2ZSBhIHBvaW50ZXIgZWxlbWVudCB0aGF0IHBvaW50cyB1cCwgcmlnaHQsIGRvd24sIG9yIGxlZnRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnBvaW50ZXJEaXJlY3Rpb25dIGNhbiBiZSB1cCwgcmlnaHQsIGRvd24sIGxlZnQsIG9yIG5vbmU7IHRoZSBkZWZhdWx0XG4gICAqICBpcyBub25lLiAgV2hlbiBhIHBvaW50ZXIgaXMgcHJlc2VudCwgdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBsYWJlbCBpcyByZWxhdGl2ZSB0byB0aGUgdGlwIG9mIHRoZSBwb2ludGVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wb2ludGVyV2lkdGhdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnBvaW50ZXJIZWlnaHRdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNvcm5lclJhZGl1c11cbiAgICovXG4gIEtvbnZhLlRhZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlRhZy5wcm90b3R5cGUgPSB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdUYWcnO1xuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgcG9pbnRlckRpcmVjdGlvbiA9IHRoaXMuZ2V0UG9pbnRlckRpcmVjdGlvbigpLFxuICAgICAgICBwb2ludGVyV2lkdGggPSB0aGlzLmdldFBvaW50ZXJXaWR0aCgpLFxuICAgICAgICBwb2ludGVySGVpZ2h0ID0gdGhpcy5nZXRQb2ludGVySGVpZ2h0KCksXG4gICAgICAgIGNvcm5lclJhZGl1cyA9IE1hdGgubWluKHRoaXMuZ2V0Q29ybmVyUmFkaXVzKCksIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBpZiAoIWNvcm5lclJhZGl1cykge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGNvcm5lclJhZGl1cywgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb2ludGVyRGlyZWN0aW9uID09PSBVUCkge1xuICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggLSBwb2ludGVyV2lkdGgpIC8gMiwgMCk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoIC8gMiwgLTEgKiBwb2ludGVySGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oKHdpZHRoICsgcG9pbnRlcldpZHRoKSAvIDIsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNvcm5lclJhZGl1cykge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAtIGNvcm5lclJhZGl1cywgMCk7XG4gICAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAgIHdpZHRoIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgTWF0aC5QSSAqIDMgLyAyLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvaW50ZXJEaXJlY3Rpb24gPT09IFJJR0hUKSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCAoaGVpZ2h0IC0gcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggKyBwb2ludGVyV2lkdGgsIGhlaWdodCAvIDIpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgKGhlaWdodCArIHBvaW50ZXJIZWlnaHQpIC8gMik7XG4gICAgICB9XG5cbiAgICAgIGlmICghY29ybmVyUmFkaXVzKSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIGhlaWdodCAtIGNvcm5lclJhZGl1cyk7XG4gICAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAgIHdpZHRoIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGhlaWdodCAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBNYXRoLlBJIC8gMixcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gRE9XTikge1xuICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggKyBwb2ludGVyV2lkdGgpIC8gMiwgaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggLyAyLCBoZWlnaHQgKyBwb2ludGVySGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oKHdpZHRoIC0gcG9pbnRlcldpZHRoKSAvIDIsIGhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY29ybmVyUmFkaXVzKSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKDAsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhjb3JuZXJSYWRpdXMsIGhlaWdodCk7XG4gICAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBoZWlnaHQgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIE1hdGguUEkgLyAyLFxuICAgICAgICAgIE1hdGguUEksXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvaW50ZXJEaXJlY3Rpb24gPT09IExFRlQpIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8oMCwgKGhlaWdodCArIHBvaW50ZXJIZWlnaHQpIC8gMik7XG4gICAgICAgIGNvbnRleHQubGluZVRvKC0xICogcG9pbnRlcldpZHRoLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oMCwgKGhlaWdodCAtIHBvaW50ZXJIZWlnaHQpIC8gMik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8oMCwgY29ybmVyUmFkaXVzKTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICBNYXRoLlBJICogMyAvIDIsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSAwLFxuICAgICAgICB5ID0gMCxcbiAgICAgICAgcG9pbnRlcldpZHRoID0gdGhpcy5nZXRQb2ludGVyV2lkdGgoKSxcbiAgICAgICAgcG9pbnRlckhlaWdodCA9IHRoaXMuZ2V0UG9pbnRlckhlaWdodCgpLFxuICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLnBvaW50ZXJEaXJlY3Rpb24oKSxcbiAgICAgICAgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IFVQKSB7XG4gICAgICAgIHkgLT0gcG9pbnRlckhlaWdodDtcbiAgICAgICAgaGVpZ2h0ICs9IHBvaW50ZXJIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRE9XTikge1xuICAgICAgICBoZWlnaHQgKz0gcG9pbnRlckhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBMRUZUKSB7XG4gICAgICAgIC8vIEFSR0ghISEgSSBoYXZlIG5vIGlkZWEgd2h5IHNob3VsZCBJIHVzZWQgbWFnaWMgMS41ISEhISEhISEhXG4gICAgICAgIHggLT0gcG9pbnRlcldpZHRoICogMS41O1xuICAgICAgICB3aWR0aCArPSBwb2ludGVyV2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gUklHSFQpIHtcbiAgICAgICAgd2lkdGggKz0gcG9pbnRlcldpZHRoICogMS41O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuVGFnLCBLb252YS5TaGFwZSk7XG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRhZywgJ3BvaW50ZXJEaXJlY3Rpb24nLCBOT05FKTtcblxuICAvKipcbiAgICogc2V0IHBvaW50ZXIgRGlyZWN0aW9uXG4gICAqIEBuYW1lIHNldFBvaW50ZXJEaXJlY3Rpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9pbnRlckRpcmVjdGlvbiBjYW4gYmUgdXAsIHJpZ2h0LCBkb3duLCBsZWZ0LCBvciBub25lLiAgVGhlXG4gICAqICBkZWZhdWx0IGlzIG5vbmVcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldCBwb2ludGVyIERpcmVjdGlvblxuICAgKiBAbmFtZSBnZXRQb2ludGVyRGlyZWN0aW9uXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuVGFnLFxuICAgICdwb2ludGVyV2lkdGgnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBzZXQgcG9pbnRlciB3aWR0aFxuICAgKiBAbmFtZSBzZXRQb2ludGVyV2lkdGhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRlcldpZHRoXG4gICAqL1xuXG4gIC8qKlxuICAgKiBnZXQgcG9pbnRlciB3aWR0aFxuICAgKiBAbmFtZSBnZXRQb2ludGVyV2lkdGhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5UYWcsXG4gICAgJ3BvaW50ZXJIZWlnaHQnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBzZXQgcG9pbnRlciBoZWlnaHRcbiAgICogQG5hbWUgc2V0UG9pbnRlckhlaWdodFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludGVySGVpZ2h0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBnZXQgcG9pbnRlciBoZWlnaHRcbiAgICogQG5hbWUgZ2V0UG9pbnRlckhlaWdodFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlRhZyxcbiAgICAnY29ybmVyUmFkaXVzJyxcbiAgICAwLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogc2V0IGNvcm5lciByYWRpdXNcbiAgICogQG5hbWUgc2V0Q29ybmVyUmFkaXVzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvcm5lciByYWRpdXNcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldCBjb3JuZXIgcmFkaXVzXG4gICAqIEBuYW1lIGdldENvcm5lclJhZGl1c1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5UYWcpO1xufSkoKTtcblxuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEFycm93IGNvbnN0cnVjdG9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlnLnBvaW50cyBGbGF0IGFycmF5IG9mIHBvaW50cyBjb29yZGluYXRlcy4gWW91IHNob3VsZCBkZWZpbmUgdGhlbSBhcyBbeDEsIHkxLCB4MiwgeTIsIHgzLCB5M10uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnRlbnNpb25dIEhpZ2hlciB2YWx1ZXMgd2lsbCByZXN1bHQgaW4gYSBtb3JlIGN1cnZ5IGxpbmUuICBBIHZhbHVlIG9mIDAgd2lsbCByZXN1bHQgaW4gbm8gaW50ZXJwb2xhdGlvbi5cbiAgICogICBUaGUgZGVmYXVsdCBpcyAwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucG9pbnRlckxlbmd0aCBBcnJvdyBwb2ludGVyIGxlbmd0aC4gRGVmYXVsdCB2YWx1ZSBpcyAxMC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5wb2ludGVyV2lkdGggQXJyb3cgcG9pbnRlciB3aWR0aC4gRGVmYXVsdCB2YWx1ZSBpcyAxMC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBjb25maWcucG9pbnRlckF0QmVnaW5uaW5nIERvIHdlIG5lZWQgdG8gZHJhdyBwb2ludGVyIG9uIGJvdGggc2lkZXM/LiBEZWZhdWx0IGZhbHNlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGxpbmUgPSBuZXcgS29udmEuTGluZSh7XG4gICAqICAgcG9pbnRzOiBbNzMsIDcwLCAzNDAsIDIzLCA0NTAsIDYwLCA1MDAsIDIwXSxcbiAgICogICBzdHJva2U6ICdyZWQnLFxuICAgKiAgIHRlbnNpb246IDEsXG4gICAqICAgcG9pbnRlckxlbmd0aCA6IDEwLFxuICAgKiAgIHBvaW50ZXJXaWR0aCA6IDEyXG4gICAqIH0pO1xuICAgKi9cbiAgS29udmEuQXJyb3cgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuQXJyb3cucHJvdG90eXBlID0ge1xuICAgIF9fX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLkxpbmUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQXJyb3cnO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBLb252YS5MaW5lLnByb3RvdHlwZS5fc2NlbmVGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMoKTtcblxuICAgICAgdmFyIHRwID0gcG9pbnRzO1xuICAgICAgdmFyIGZyb21UZW5zaW9uID0gdGhpcy5nZXRUZW5zaW9uKCkgIT09IDAgJiYgcG9pbnRzLmxlbmd0aCA+IDQ7XG4gICAgICBpZiAoZnJvbVRlbnNpb24pIHtcbiAgICAgICAgdHAgPSB0aGlzLmdldFRlbnNpb25Qb2ludHMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICB2YXIgZHgsIGR5O1xuICAgICAgaWYgKGZyb21UZW5zaW9uKSB7XG4gICAgICAgIGR4ID0gcG9pbnRzW24gLSAyXSAtIHRwW24gLSAyXTtcbiAgICAgICAgZHkgPSBwb2ludHNbbiAtIDFdIC0gdHBbbiAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBwb2ludHNbbiAtIDJdIC0gcG9pbnRzW24gLSA0XTtcbiAgICAgICAgZHkgPSBwb2ludHNbbiAtIDFdIC0gcG9pbnRzW24gLSAzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhZGlhbnMgPSAoTWF0aC5hdGFuMihkeSwgZHgpICsgUEkyKSAlIFBJMjtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLnBvaW50ZXJMZW5ndGgoKTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMucG9pbnRlcldpZHRoKCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHBvaW50c1tuIC0gMl0sIHBvaW50c1tuIC0gMV0pO1xuICAgICAgY3R4LnJvdGF0ZShyYWRpYW5zKTtcbiAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICBjdHgubGluZVRvKC1sZW5ndGgsIHdpZHRoIC8gMik7XG4gICAgICBjdHgubGluZVRvKC1sZW5ndGgsIC13aWR0aCAvIDIpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgaWYgKHRoaXMucG9pbnRlckF0QmVnaW5uaW5nKCkpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgIGlmIChmcm9tVGVuc2lvbikge1xuICAgICAgICAgIGR4ID0gdHBbMF0gLSBwb2ludHNbMF07XG4gICAgICAgICAgZHkgPSB0cFsxXSAtIHBvaW50c1sxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkeCA9IHBvaW50c1syXSAtIHBvaW50c1swXTtcbiAgICAgICAgICBkeSA9IHBvaW50c1szXSAtIHBvaW50c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5yb3RhdGUoKE1hdGguYXRhbjIoLWR5LCAtZHgpICsgUEkyKSAlIFBJMik7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgd2lkdGggLyAyKTtcbiAgICAgICAgY3R4LmxpbmVUbygtbGVuZ3RoLCAtd2lkdGggLyAyKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBoZXJlIGlzIGEgdHJpY2t5IHBhcnRcbiAgICAgIC8vIHdlIG5lZWQgdG8gZGlzYWJsZSBkYXNoIGZvciBhcnJvdyBwb2ludGVyc1xuICAgICAgdmFyIGlzRGFzaEVuYWJsZWQgPSB0aGlzLmRhc2hFbmFibGVkKCk7XG4gICAgICBpZiAoaXNEYXNoRW5hYmxlZCkge1xuICAgICAgICAvLyBtYW51YWxseSBkaXNhYmxlIGRhc2ggZm9yIGhlYWRcbiAgICAgICAgLy8gaXQgaXMgYmV0dGVyIG5vdCB0byB1c2Ugc2V0dGVyIGhlcmUsXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgd2lsbCB0cmlnZ2VyIGF0dHIgY2hhbmdlIGV2ZW50XG4gICAgICAgIHRoaXMuYXR0cnMuZGFzaEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgIH1cblxuICAgICAgY3R4LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcblxuICAgICAgLy8gcmVzdG9yZSBvbGQgdmFsdWVcbiAgICAgIGlmIChpc0Rhc2hFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuYXR0cnMuZGFzaEVuYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5BcnJvdywgS29udmEuTGluZSk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IHBvaW50ZXJMZW5ndGhcbiAgICogQG5hbWUgcG9pbnRlckxlbmd0aFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5BcnJvdy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IExlbmd0aCBvZiBwb2ludGVyIG9mIGFycm93LlxuICAgKiAgIFRoZSBkZWZhdWx0IGlzIDEwLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgdGVuc2lvblxuICAgKiB2YXIgcG9pbnRlckxlbmd0aCA9IGxpbmUucG9pbnRlckxlbmd0aCgpO1xuICAgKlxuICAgKiAvLyBzZXQgdGVuc2lvblxuICAgKiBsaW5lLnBvaW50ZXJMZW5ndGgoMTUpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5BcnJvdyxcbiAgICAncG9pbnRlckxlbmd0aCcsXG4gICAgMTAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBwb2ludGVyV2lkdGhcbiAgICogQG5hbWUgcG9pbnRlcldpZHRoXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkFycm93LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gV2lkdGggb2YgcG9pbnRlciBvZiBhcnJvdy5cbiAgICogICBUaGUgZGVmYXVsdCBpcyAxMC5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHRlbnNpb25cbiAgICogdmFyIHBvaW50ZXJXaWR0aCA9IGxpbmUucG9pbnRlcldpZHRoKCk7XG4gICAqXG4gICAqIC8vIHNldCB0ZW5zaW9uXG4gICAqIGxpbmUucG9pbnRlcldpZHRoKDE1KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuQXJyb3csXG4gICAgJ3BvaW50ZXJXaWR0aCcsXG4gICAgMTAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBwb2ludGVyQXRCZWdpbm5pbmdcbiAgICogQG5hbWUgcG9pbnRlckF0QmVnaW5uaW5nXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkFycm93LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gU2hvdWxkIHBvaW50ZXIgZGlzcGxheWVkIGF0IGJlZ2lubmluZyBvZiBhcnJvdy5cbiAgICogICBUaGUgZGVmYXVsdCBpcyBmYWxzZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB0ZW5zaW9uXG4gICAqIHZhciBwb2ludGVyQXRCZWdpbm5pbmcgPSBsaW5lLnBvaW50ZXJBdEJlZ2lubmluZygpO1xuICAgKlxuICAgKiAvLyBzZXQgdGVuc2lvblxuICAgKiBsaW5lLnBvaW50ZXJBdEJlZ2lubmluZyh0cnVlKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJyb3csICdwb2ludGVyQXRCZWdpbm5pbmcnLCBmYWxzZSk7XG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5BcnJvdyk7XG59KShLb252YSk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFUVFJfQ0hBTkdFX0xJU1QgPSBbXG4gICAgJ3Jlc2l6ZUVuYWJsZWRDaGFuZ2UnLFxuICAgICdyb3RhdGVBbmNob3JPZmZzZXRDaGFuZ2UnLFxuICAgICdyb3RhdGVFbmFibGVkQ2hhbmdlJyxcbiAgICAnZW5hYmxlZEFuY2hvcnNDaGFuZ2UnLFxuICAgICdhbmNob3JTaXplQ2hhbmdlJyxcbiAgICAnYm9yZGVyRW5hYmxlZENoYW5nZScsXG4gICAgJ2JvcmRlclN0cm9rZUNoYW5nZScsXG4gICAgJ2JvcmRlclN0cm9rZVdpZHRoQ2hhbmdlJyxcbiAgICAnYW5jaG9yU3Ryb2tlQ2hhbmdlJyxcbiAgICAnYW5jaG9yU3Ryb2tlV2lkdGhDaGFuZ2UnLFxuICAgICdhbmNob3JGaWxsQ2hhbmdlJyxcbiAgICAnYW5jaG9yQ29ybmVyUmFkaXVzQ2hhbmdlJ1xuICBdLmpvaW4oJyAnKTtcblxuICB2YXIgTk9ERV9SRUNUID0gJ25vZGVSZWN0JztcblxuICB2YXIgVFJBTlNGT1JNX0NIQU5HRV9TVFIgPSBbXG4gICAgJ3hDaGFuZ2UucmVzaXplcicsXG4gICAgJ3lDaGFuZ2UucmVzaXplcicsXG4gICAgJ3dpZHRoQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdoZWlnaHRDaGFuZ2UucmVzaXplcicsXG4gICAgJ3NjYWxlWENoYW5nZS5yZXNpemVyJyxcbiAgICAnc2NhbGVZQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdza2V3WENoYW5nZS5yZXNpemVyJyxcbiAgICAnc2tld1lDaGFuZ2UucmVzaXplcicsXG4gICAgJ3JvdGF0aW9uQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdvZmZzZXRYQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdvZmZzZXRZQ2hhbmdlLnJlc2l6ZXInLFxuICAgICd0cmFuc2Zvcm1zRW5hYmxlZENoYW5nZS5yZXNpemVyJ1xuICBdLmpvaW4oJyAnKTtcblxuICB2YXIgUkVEUkFXX0NIQU5HRV9TVFIgPSBbXG4gICAgJ3dpZHRoQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdoZWlnaHRDaGFuZ2UucmVzaXplcicsXG4gICAgJ3NjYWxlWENoYW5nZS5yZXNpemVyJyxcbiAgICAnc2NhbGVZQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdza2V3WENoYW5nZS5yZXNpemVyJyxcbiAgICAnc2tld1lDaGFuZ2UucmVzaXplcicsXG4gICAgJ3JvdGF0aW9uQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdvZmZzZXRYQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdvZmZzZXRZQ2hhbmdlLnJlc2l6ZXInXG4gIF0uam9pbignICcpO1xuXG4gIHZhciBBTkdMRVMgPSB7XG4gICAgJ3RvcC1sZWZ0JzogLTQ1LFxuICAgICd0b3AtY2VudGVyJzogMCxcbiAgICAndG9wLXJpZ2h0JzogNDUsXG4gICAgJ21pZGRsZS1yaWdodCc6IC05MCxcbiAgICAnbWlkZGxlLWxlZnQnOiA5MCxcbiAgICAnYm90dG9tLWxlZnQnOiAtMTM1LFxuICAgICdib3R0b20tY2VudGVyJzogMTgwLFxuICAgICdib3R0b20tcmlnaHQnOiAxMzVcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRDdXJzb3IoYW5jaG9yTmFtZSwgcmFkLCBpc01pcnJvcmVkKSB7XG4gICAgaWYgKGFuY2hvck5hbWUgPT09ICdyb3RhdGVyJykge1xuICAgICAgcmV0dXJuICdjcm9zc2hhaXInO1xuICAgIH1cblxuICAgIHJhZCArPSBLb252YS5VdGlsLl9kZWdUb1JhZChBTkdMRVNbYW5jaG9yTmFtZV0gfHwgMCk7XG4gICAgLy8gSWYgd2UgYXJlIG1pcnJvcmVkLCB3ZSBuZWVkIHRvIG1pcnJvciB0aGUgYW5nbGUgKHRoaXMgaXMgbm90IHRoZSBzYW1lIGFzXG4gICAgLy8gcm90YXRlKS5cbiAgICBpZiAoaXNNaXJyb3JlZCkge1xuICAgICAgcmFkICo9IC0xO1xuICAgIH1cbiAgICB2YXIgYW5nbGUgPSAoS29udmEuVXRpbC5fcmFkVG9EZWcocmFkKSAlIDM2MCArIDM2MCkgJSAzNjA7XG5cbiAgICBpZiAoXG4gICAgICBLb252YS5VdGlsLl9pblJhbmdlKGFuZ2xlLCAzMTUgKyAyMi41LCAzNjApIHx8XG4gICAgICBLb252YS5VdGlsLl9pblJhbmdlKGFuZ2xlLCAwLCAyMi41KVxuICAgICkge1xuICAgICAgLy8gVE9QXG4gICAgICByZXR1cm4gJ25zLXJlc2l6ZSc7XG4gICAgfSBlbHNlIGlmIChLb252YS5VdGlsLl9pblJhbmdlKGFuZ2xlLCA0NSAtIDIyLjUsIDQ1ICsgMjIuNSkpIHtcbiAgICAgIC8vIFRPUCAtIFJJR0hUXG4gICAgICByZXR1cm4gJ25lc3ctcmVzaXplJztcbiAgICB9IGVsc2UgaWYgKEtvbnZhLlV0aWwuX2luUmFuZ2UoYW5nbGUsIDkwIC0gMjIuNSwgOTAgKyAyMi41KSkge1xuICAgICAgLy8gUklHSFRcbiAgICAgIHJldHVybiAnZXctcmVzaXplJztcbiAgICB9IGVsc2UgaWYgKEtvbnZhLlV0aWwuX2luUmFuZ2UoYW5nbGUsIDEzNSAtIDIyLjUsIDEzNSArIDIyLjUpKSB7XG4gICAgICAvLyBCT1RUT00gLSBSSUdIVFxuICAgICAgcmV0dXJuICdud3NlLXJlc2l6ZSc7XG4gICAgfSBlbHNlIGlmIChLb252YS5VdGlsLl9pblJhbmdlKGFuZ2xlLCAxODAgLSAyMi41LCAxODAgKyAyMi41KSkge1xuICAgICAgLy8gQk9UVE9NXG4gICAgICByZXR1cm4gJ25zLXJlc2l6ZSc7XG4gICAgfSBlbHNlIGlmIChLb252YS5VdGlsLl9pblJhbmdlKGFuZ2xlLCAyMjUgLSAyMi41LCAyMjUgKyAyMi41KSkge1xuICAgICAgLy8gQk9UVE9NIC0gTEVGVFxuICAgICAgcmV0dXJuICduZXN3LXJlc2l6ZSc7XG4gICAgfSBlbHNlIGlmIChLb252YS5VdGlsLl9pblJhbmdlKGFuZ2xlLCAyNzAgLSAyMi41LCAyNzAgKyAyMi41KSkge1xuICAgICAgLy8gUklHSFRcbiAgICAgIHJldHVybiAnZXctcmVzaXplJztcbiAgICB9IGVsc2UgaWYgKEtvbnZhLlV0aWwuX2luUmFuZ2UoYW5nbGUsIDMxNSAtIDIyLjUsIDMxNSArIDIyLjUpKSB7XG4gICAgICAvLyBCT1RUT00gLSBSSUdIVFxuICAgICAgcmV0dXJuICdud3NlLXJlc2l6ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvdyBjYW4gd2UgY2FuIHRoZXJlP1xuICAgICAgLy8gVE9ETzogdGhyb3cgZXJyb3JcbiAgICAgIEtvbnZhLlV0aWwuZXJyb3IoXG4gICAgICAgICdUcmFuc2Zvcm1lciBoYXMgdW5rbm93biBhbmdsZSBmb3IgY3Vyc29yIGRldGVjdGlvbjogJyArIGFuZ2xlXG4gICAgICApO1xuICAgICAgcmV0dXJuICdwb2ludGVyJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtZXIgY29uc3RydWN0b3IuICBUcmFuc2Zvcm1lciBpcyBhIHNwZWNpYWwgdHlwZSBvZiBncm91cCB0aGF0IGFsbG93IHlvdSB0cmFuc2Zvcm0gS29udmFcbiAgICogcHJpbWl0aXZlcyBhbmQgc2hhcGVzLiBUcmFuc2Zvcm1pbmcgdG9vbCBpcyBub3QgY2hhbmdpbmcgYHdpZHRoYCBhbmQgYGhlaWdodGAgcHJvcGVydGllcyBvZiBub2Rlc1xuICAgKiB3aGVuIHlvdSByZXNpemUgdGhlbS4gSW5zdGVhZCBpdCBjaGFuZ2VzIGBzY2FsZVhgIGFuZCBgc2NhbGVZYCBwcm9wZXJ0aWVzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnJlc2l6ZUVuYWJsZWRdIERlZmF1bHQgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucm90YXRlRW5hYmxlZF0gRGVmYXVsdCBpcyB0cnVlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcucm90YXRpb25TbmFwc10gQXJyYXkgb2YgYW5nbGVzIGZvciByb3RhdGlvbiBzbmFwcy4gRGVmYXVsdCBpcyBbXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGVBbmNob3JPZmZzZXRdIERlZmF1bHQgaXMgNTBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucGFkZGluZ10gRGVmYXVsdCBpcyAwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5ib3JkZXJFbmFibGVkXSBTaG91bGQgd2UgZHJhdyBib3JkZXI/IERlZmF1bHQgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5ib3JkZXJTdHJva2VdIEJvcmRlciBzdHJva2UgY29sb3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuYm9yZGVyU3Ryb2tlV2lkdGhdIEJvcmRlciBzdHJva2Ugc2l6ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmJvcmRlckRhc2hdIEFycmF5IGZvciBib3JkZXIgZGFzaC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuYW5jaG9yRmlsbF0gQW5jaG9yIGZpbGwgY29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuYW5jaG9yU3Ryb2tlXSBBbmNob3Igc3Ryb2tlIGNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmFuY2hvckNvcm5lclJhZGl1c10gQW5jaG9yIGNvcm5lciByYWRpdXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuYW5jaG9yU3Ryb2tlV2lkdGhdIEFuY2hvciBzdHJva2Ugc2l6ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5hbmNob3JTaXplXSBEZWZhdWx0IGlzIDEwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5rZWVwUmF0aW9dIFNob3VsZCB3ZSBrZWVwIHJhdGlvIHdoZW4gd2UgYXJlIG1vdmluZyBlZGdlcz8gRGVmYXVsdCBpcyB0cnVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jZW50ZXJlZFNjYWxpbmddIFNob3VsZCB3ZSByZXNpemUgcmVsYXRpdmUgdG8gbm9kZSdzIGNlbnRlcj8gRGVmYXVsdCBpcyBmYWxzZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmVuYWJsZWRBbmNob3JzXSBBcnJheSBvZiBuYW1lcyBvZiBlbmFibGVkIGhhbmRsZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5ib3VuZEJveEZ1bmNdIEJvdW5kaW5nIGJveCBmdW5jdGlvblxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdHJhbnNmb3JtZXIgPSBuZXcgS29udmEuVHJhbnNmb3JtZXIoe1xuICAgKiAgIG5vZGU6IHJlY3RhbmdsZSxcbiAgICogICByb3RhdGVBbmNob3JPZmZzZXQ6IDYwLFxuICAgKiAgIGVuYWJsZWRBbmNob3JzOiBbJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnXVxuICAgKiB9KTtcbiAgICogbGF5ZXIuYWRkKHRyYW5zZm9ybWVyKTtcbiAgICovXG5cbiAgS29udmEuVHJhbnNmb3JtZXIgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgdmFyIEFOQ0hPUlNfTkFNRVMgPSBbXG4gICAgJ3RvcC1sZWZ0JyxcbiAgICAndG9wLWNlbnRlcicsXG4gICAgJ3RvcC1yaWdodCcsXG4gICAgJ21pZGRsZS1yaWdodCcsXG4gICAgJ21pZGRsZS1sZWZ0JyxcbiAgICAnYm90dG9tLWxlZnQnLFxuICAgICdib3R0b20tY2VudGVyJyxcbiAgICAnYm90dG9tLXJpZ2h0J1xuICBdO1xuXG4gIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IGZhbHNlLFxuICAgIF9fX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLkdyb3VwLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RyYW5zZm9ybWVyJztcbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIC8vIGJpbmRpbmdzXG4gICAgICB0aGlzLl9oYW5kbGVNb3VzZU1vdmUgPSB0aGlzLl9oYW5kbGVNb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2hhbmRsZU1vdXNlVXAgPSB0aGlzLl9oYW5kbGVNb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnVwZGF0ZSA9IHRoaXMudXBkYXRlLmJpbmQodGhpcyk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0cmFuc2Zvcm1lciBkYXRhIGZvciBjZXJ0YWluIGF0dHIgY2hhbmdlc1xuICAgICAgdGhpcy5vbihBVFRSX0NIQU5HRV9MSVNULCB0aGlzLnVwZGF0ZSk7XG5cbiAgICAgIGlmICh0aGlzLmdldE5vZGUoKSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhbGlhcyB0byBgc2V0Tm9kZWBcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm1lcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHRyYW5zZm9ybWVyLmF0dGFjaFRvKHNoYXBlKTtcbiAgICAgKi9cbiAgICBhdHRhY2hUbzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdGhpcy5zZXROb2RlKG5vZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhdHRhY2ggdHJhbnNmb3JtZXIgdG8gYSBLb252YS5Ob2RlLiBUcmFuc2Zvcm1lciB3aWxsIGFkYXB0IHRvIGl0cyBzaXplIGFuZCBsaXN0ZW4gaXRzIGV2ZW50c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybWVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdHJhbnNmb3JtZXIuc2V0Tm9kZShzaGFwZSk7XG4gICAgICovXG4gICAgc2V0Tm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKHRoaXMuX25vZGUpIHtcbiAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1DYWNoZSgpO1xuXG4gICAgICBub2RlLm9uKFRSQU5TRk9STV9DSEFOR0VfU1RSLCB0aGlzLl9yZXNldFRyYW5zZm9ybUNhY2hlLmJpbmQodGhpcykpO1xuICAgICAgbm9kZS5vbihcbiAgICAgICAgUkVEUkFXX0NIQU5HRV9TVFIsXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNmb3JtaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICApO1xuXG4gICAgICAvLyBUT0RPOiB3aHkgZG8gd2UgbmVlZCB0aGlzP1xuICAgICAgdmFyIGVsZW1lbnRzQ3JlYXRlZCA9ICEhdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKTtcbiAgICAgIGlmIChlbGVtZW50c0NyZWF0ZWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXROb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkZXRhY2ggdHJhbnNmb3JtZXIgZnJvbSBhIGF0dGFjaGVkIG5vZGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm1lcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHRyYW5zZm9ybWVyLmRldGFjaCgpO1xuICAgICAqL1xuICAgIGRldGFjaDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5nZXROb2RlKCkpIHtcbiAgICAgICAgdGhpcy5nZXROb2RlKCkub2ZmKCcucmVzaXplcicpO1xuICAgICAgICB0aGlzLl9ub2RlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1DYWNoZSgpO1xuICAgIH0sXG5cbiAgICBfcmVzZXRUcmFuc2Zvcm1DYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKE5PREVfUkVDVCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCd0cmFuc2Zvcm0nKTtcbiAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZSgnYWJzb2x1dGVUcmFuc2Zvcm0nKTtcbiAgICB9LFxuXG4gICAgX2dldE5vZGVSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShOT0RFX1JFQ1QsIHRoaXMuX19nZXROb2RlUmVjdCk7XG4gICAgfSxcblxuICAgIF9fZ2V0Tm9kZVJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldE5vZGUoKTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IC1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICB5OiAtTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgIHJvdGF0aW9uOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7IHNraXBUcmFuc2Zvcm06IHRydWUsIHNraXBTaGFkb3c6IHRydWUgfSk7XG4gICAgICB2YXIgcm90YXRpb24gPSBLb252YS5nZXRBbmdsZShub2RlLnJvdGF0aW9uKCkpO1xuXG4gICAgICB2YXIgZHggPSByZWN0LnggKiBub2RlLnNjYWxlWCgpIC0gbm9kZS5vZmZzZXRYKCkgKiBub2RlLnNjYWxlWCgpO1xuICAgICAgdmFyIGR5ID0gcmVjdC55ICogbm9kZS5zY2FsZVkoKSAtIG5vZGUub2Zmc2V0WSgpICogbm9kZS5zY2FsZVkoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbm9kZS54KCkgKyBkeCAqIE1hdGguY29zKHJvdGF0aW9uKSArIGR5ICogTWF0aC5zaW4oLXJvdGF0aW9uKSxcbiAgICAgICAgeTogbm9kZS55KCkgKyBkeSAqIE1hdGguY29zKHJvdGF0aW9uKSArIGR4ICogTWF0aC5zaW4ocm90YXRpb24pLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAqIG5vZGUuc2NhbGVYKCksXG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKiBub2RlLnNjYWxlWSgpLFxuICAgICAgICByb3RhdGlvbjogbm9kZS5yb3RhdGlvbigpXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRYOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXROb2RlUmVjdCgpLng7XG4gICAgfSxcblxuICAgIGdldFk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE5vZGVSZWN0KCkueTtcbiAgICB9LFxuXG4gICAgZ2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE5vZGVSZWN0KCkucm90YXRpb247XG4gICAgfSxcblxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXROb2RlUmVjdCgpLndpZHRoO1xuICAgIH0sXG5cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE5vZGVSZWN0KCkuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICBfY3JlYXRlRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY3JlYXRlQmFjaygpO1xuXG4gICAgICBBTkNIT1JTX05BTUVTLmZvckVhY2goXG4gICAgICAgIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVBbmNob3IobmFtZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgKTtcblxuICAgICAgdGhpcy5fY3JlYXRlQW5jaG9yKCdyb3RhdGVyJyk7XG4gICAgfSxcblxuICAgIF9jcmVhdGVBbmNob3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBhbmNob3IgPSBuZXcgS29udmEuUmVjdCh7XG4gICAgICAgIHN0cm9rZTogJ3JnYigwLCAxNjEsIDI1NSknLFxuICAgICAgICBmaWxsOiAnd2hpdGUnLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgbmFtZTogbmFtZSArICcgX2FuY2hvcicsXG4gICAgICAgIGRyYWdEaXN0YW5jZTogMCxcbiAgICAgICAgZHJhZ2dhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGFuY2hvci5vbignbW91c2Vkb3duIHRvdWNoc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuX2hhbmRsZU1vdXNlRG93bihlKTtcbiAgICAgIH0pO1xuICAgICAgYW5jaG9yLm9uKCdkcmFnc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgYW5jaG9yLm9uKCdkcmFnbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBhbmNob3Iub24oJ2RyYWdlbmQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBhZGQgaG92ZXIgc3R5bGluZ1xuICAgICAgYW5jaG9yLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ciA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgdmFyIHJhZCA9IEtvbnZhLmdldEFuZ2xlKHRyLnJvdGF0aW9uKCkpO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IHRyLmdldE5vZGUoKS5nZXRBYnNvbHV0ZVNjYWxlKCk7XG4gICAgICAgIC8vIElmIHNjYWxlLnkgPCAwIHhvciBzY2FsZS54IDwgMCB3ZSBuZWVkIHRvIGZsaXAgKG5vdCByb3RhdGUpLlxuICAgICAgICB2YXIgaXNNaXJyb3JlZCA9IHNjYWxlLnkgKiBzY2FsZS54IDwgMDtcbiAgICAgICAgdmFyIGN1cnNvciA9IGdldEN1cnNvcihuYW1lLCByYWQsIGlzTWlycm9yZWQpO1xuICAgICAgICBhbmNob3IuZ2V0U3RhZ2UoKS5jb250ZW50LnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgdHIuX2N1cnNvckNoYW5nZSA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGFuY2hvci5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFhbmNob3IuZ2V0U3RhZ2UoKSB8fCAhdGhpcy5nZXRQYXJlbnQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhbmNob3IuZ2V0U3RhZ2UoKS5jb250ZW50LnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICB0aGlzLmdldFBhcmVudCgpLl9jdXJzb3JDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGQoYW5jaG9yKTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJhY2sgPSBuZXcgS29udmEuU2hhcGUoe1xuICAgICAgICBuYW1lOiAnYmFjaycsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIGxpc3RlbmluZzogZmFsc2UsXG4gICAgICAgIHNjZW5lRnVuYzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgdmFyIHRyID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgICAgICB2YXIgcGFkZGluZyA9IHRyLmdldFBhZGRpbmcoKTtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4LnJlY3QoXG4gICAgICAgICAgICAtcGFkZGluZyxcbiAgICAgICAgICAgIC1wYWRkaW5nLFxuICAgICAgICAgICAgdGhpcy53aWR0aCgpICsgcGFkZGluZyAqIDIsXG4gICAgICAgICAgICB0aGlzLmhlaWdodCgpICsgcGFkZGluZyAqIDJcbiAgICAgICAgICApO1xuICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy53aWR0aCgpIC8gMiwgLXBhZGRpbmcpO1xuICAgICAgICAgIGlmICh0ci5yb3RhdGVFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oXG4gICAgICAgICAgICAgIHRoaXMud2lkdGgoKSAvIDIsXG4gICAgICAgICAgICAgIC10ci5yb3RhdGVBbmNob3JPZmZzZXQoKSAqIEtvbnZhLlV0aWwuX3NpZ24odGhpcy5oZWlnaHQoKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZChiYWNrKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5tb3ZpbmdSZXNpemVyID0gZS50YXJnZXQubmFtZSgpLnNwbGl0KCcgJylbMF07XG5cbiAgICAgIC8vIHZhciBub2RlID0gdGhpcy5nZXROb2RlKCk7XG4gICAgICB2YXIgYXR0cnMgPSB0aGlzLl9nZXROb2RlUmVjdCgpO1xuICAgICAgdmFyIHdpZHRoID0gYXR0cnMud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gYXR0cnMuaGVpZ2h0O1xuICAgICAgdmFyIGh5cG90ZW51c2UgPSBNYXRoLnNxcnQoTWF0aC5wb3cod2lkdGgsIDIpICsgTWF0aC5wb3coaGVpZ2h0LCAyKSk7XG4gICAgICB0aGlzLnNpbiA9IGhlaWdodCAvIGh5cG90ZW51c2U7XG4gICAgICB0aGlzLmNvcyA9IHdpZHRoIC8gaHlwb3RlbnVzZTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlTW91c2VVcCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVNb3VzZVVwLCB0cnVlKTtcblxuICAgICAgdGhpcy5fdHJhbnNmb3JtaW5nID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fZmlyZSgndHJhbnNmb3Jtc3RhcnQnLCB7IGV2dDogZSB9KTtcbiAgICAgIHRoaXMuZ2V0Tm9kZSgpLl9maXJlKCd0cmFuc2Zvcm1zdGFydCcsIHsgZXZ0OiBlIH0pO1xuICAgIH0sXG5cbiAgICBfaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgeCwgeSwgbmV3SHlwb3RlbnVzZTtcbiAgICAgIHZhciByZXNpemVyTm9kZSA9IHRoaXMuZmluZE9uZSgnLicgKyB0aGlzLm1vdmluZ1Jlc2l6ZXIpO1xuICAgICAgdmFyIHN0YWdlID0gcmVzaXplck5vZGUuZ2V0U3RhZ2UoKTtcblxuICAgICAgdmFyIGJveCA9IHN0YWdlLmdldENvbnRlbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB6ZXJvUG9pbnQgPSB7XG4gICAgICAgIHg6IGJveC5sZWZ0LFxuICAgICAgICB5OiBib3gudG9wXG4gICAgICB9O1xuICAgICAgdmFyIHBvaW50ZXJQb3MgPSB7XG4gICAgICAgIGxlZnQ6IGUuY2xpZW50WCAhPT0gdW5kZWZpbmVkID8gZS5jbGllbnRYIDogZS50b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgIHRvcDogZS5jbGllbnRYICE9PSB1bmRlZmluZWQgPyBlLmNsaWVudFkgOiBlLnRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHZhciBuZXdBYnNQb3MgPSB7XG4gICAgICAgIHg6IHBvaW50ZXJQb3MubGVmdCAtIHplcm9Qb2ludC54LFxuICAgICAgICB5OiBwb2ludGVyUG9zLnRvcCAtIHplcm9Qb2ludC55XG4gICAgICB9O1xuXG4gICAgICByZXNpemVyTm9kZS5zZXRBYnNvbHV0ZVBvc2l0aW9uKG5ld0Fic1Bvcyk7XG5cbiAgICAgIHZhciBrZWVwUHJvcG9ydGlvbiA9IHRoaXMua2VlcFJhdGlvKCkgfHwgZS5zaGlmdEtleTtcblxuICAgICAgLy8gY29uc29sZS5sb2coa2VlcFByb3BvcnRpb24pO1xuXG4gICAgICBpZiAodGhpcy5tb3ZpbmdSZXNpemVyID09PSAndG9wLWxlZnQnKSB7XG4gICAgICAgIGlmIChrZWVwUHJvcG9ydGlvbikge1xuICAgICAgICAgIG5ld0h5cG90ZW51c2UgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICBNYXRoLnBvdyh0aGlzLmZpbmRPbmUoJy5ib3R0b20tcmlnaHQnKS54KCkgLSByZXNpemVyTm9kZS54KCksIDIpICtcbiAgICAgICAgICAgICAgTWF0aC5wb3codGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueSgpIC0gcmVzaXplck5vZGUueSgpLCAyKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB4ID0gbmV3SHlwb3RlbnVzZSAqIHRoaXMuY29zO1xuICAgICAgICAgIHkgPSBuZXdIeXBvdGVudXNlICogdGhpcy5zaW47XG5cbiAgICAgICAgICB0aGlzLmZpbmRPbmUoJy50b3AtbGVmdCcpLngodGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueCgpIC0geCk7XG4gICAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS55KHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLnkoKSAtIHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW92aW5nUmVzaXplciA9PT0gJ3RvcC1jZW50ZXInKSB7XG4gICAgICAgIHRoaXMuZmluZE9uZSgnLnRvcC1sZWZ0JykueShyZXNpemVyTm9kZS55KCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1vdmluZ1Jlc2l6ZXIgPT09ICd0b3AtcmlnaHQnKSB7XG4gICAgICAgIGlmIChrZWVwUHJvcG9ydGlvbikge1xuICAgICAgICAgIG5ld0h5cG90ZW51c2UgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICBNYXRoLnBvdyh0aGlzLmZpbmRPbmUoJy5ib3R0b20tbGVmdCcpLngoKSAtIHJlc2l6ZXJOb2RlLngoKSwgMikgK1xuICAgICAgICAgICAgICBNYXRoLnBvdyh0aGlzLmZpbmRPbmUoJy5ib3R0b20tbGVmdCcpLnkoKSAtIHJlc2l6ZXJOb2RlLnkoKSwgMilcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgeCA9IG5ld0h5cG90ZW51c2UgKiB0aGlzLmNvcztcbiAgICAgICAgICB5ID0gbmV3SHlwb3RlbnVzZSAqIHRoaXMuc2luO1xuXG4gICAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLXJpZ2h0JykueCh4KTtcbiAgICAgICAgICB0aGlzLmZpbmRPbmUoJy50b3AtcmlnaHQnKS55KHRoaXMuZmluZE9uZSgnLmJvdHRvbS1sZWZ0JykueSgpIC0geSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvcyA9IHJlc2l6ZXJOb2RlLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS55KHBvcy55KTtcbiAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueChwb3MueCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW92aW5nUmVzaXplciA9PT0gJ21pZGRsZS1sZWZ0Jykge1xuICAgICAgICB0aGlzLmZpbmRPbmUoJy50b3AtbGVmdCcpLngocmVzaXplck5vZGUueCgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb3ZpbmdSZXNpemVyID09PSAnbWlkZGxlLXJpZ2h0Jykge1xuICAgICAgICB0aGlzLmZpbmRPbmUoJy5ib3R0b20tcmlnaHQnKS54KHJlc2l6ZXJOb2RlLngoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW92aW5nUmVzaXplciA9PT0gJ2JvdHRvbS1sZWZ0Jykge1xuICAgICAgICBpZiAoa2VlcFByb3BvcnRpb24pIHtcbiAgICAgICAgICBuZXdIeXBvdGVudXNlID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3codGhpcy5maW5kT25lKCcudG9wLXJpZ2h0JykueCgpIC0gcmVzaXplck5vZGUueCgpLCAyKSArXG4gICAgICAgICAgICAgIE1hdGgucG93KHRoaXMuZmluZE9uZSgnLnRvcC1yaWdodCcpLnkoKSAtIHJlc2l6ZXJOb2RlLnkoKSwgMilcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgeCA9IG5ld0h5cG90ZW51c2UgKiB0aGlzLmNvcztcbiAgICAgICAgICB5ID0gbmV3SHlwb3RlbnVzZSAqIHRoaXMuc2luO1xuXG4gICAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLWxlZnQnKS54KHRoaXMuZmluZE9uZSgnLnRvcC1yaWdodCcpLngoKSAtIHgpO1xuICAgICAgICAgIHRoaXMuZmluZE9uZSgnLmJvdHRvbS1sZWZ0JykueSh5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcyA9IHJlc2l6ZXJOb2RlLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS54KHBvcy54KTtcbiAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueShwb3MueSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW92aW5nUmVzaXplciA9PT0gJ2JvdHRvbS1jZW50ZXInKSB7XG4gICAgICAgIHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLnkocmVzaXplck5vZGUueSgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb3ZpbmdSZXNpemVyID09PSAnYm90dG9tLXJpZ2h0Jykge1xuICAgICAgICBpZiAoa2VlcFByb3BvcnRpb24pIHtcbiAgICAgICAgICBuZXdIeXBvdGVudXNlID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3codGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueCgpLCAyKSArXG4gICAgICAgICAgICAgIE1hdGgucG93KHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLnkoKSwgMilcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgeCA9IG5ld0h5cG90ZW51c2UgKiB0aGlzLmNvcztcbiAgICAgICAgICB5ID0gbmV3SHlwb3RlbnVzZSAqIHRoaXMuc2luO1xuXG4gICAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueCh4KTtcbiAgICAgICAgICB0aGlzLmZpbmRPbmUoJy5ib3R0b20tcmlnaHQnKS55KHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW92aW5nUmVzaXplciA9PT0gJ3JvdGF0ZXInKSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5nZXRQYWRkaW5nKCk7XG4gICAgICAgIHZhciBhdHRycyA9IHRoaXMuX2dldE5vZGVSZWN0KCk7XG4gICAgICAgIHggPSByZXNpemVyTm9kZS54KCkgLSBhdHRycy53aWR0aCAvIDI7XG4gICAgICAgIHkgPSAtcmVzaXplck5vZGUueSgpICsgYXR0cnMuaGVpZ2h0IC8gMjtcblxuICAgICAgICB2YXIgZEFscGhhID0gTWF0aC5hdGFuMigteSwgeCkgKyBNYXRoLlBJIC8gMjtcblxuICAgICAgICBpZiAoYXR0cnMuaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGRBbHBoYSAtPSBNYXRoLlBJO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvdCA9IEtvbnZhLmdldEFuZ2xlKHRoaXMucm90YXRpb24oKSk7XG5cbiAgICAgICAgdmFyIG5ld1JvdGF0aW9uID1cbiAgICAgICAgICBLb252YS5VdGlsLl9yYWRUb0RlZyhyb3QpICsgS29udmEuVXRpbC5fcmFkVG9EZWcoZEFscGhhKTtcblxuICAgICAgICB2YXIgYWxwaGEgPSBLb252YS5nZXRBbmdsZSh0aGlzLmdldE5vZGUoKS5yb3RhdGlvbigpKTtcbiAgICAgICAgdmFyIG5ld0FscGhhID0gS29udmEuVXRpbC5fZGVnVG9SYWQobmV3Um90YXRpb24pO1xuXG4gICAgICAgIHZhciBzbmFwcyA9IHRoaXMucm90YXRpb25TbmFwcygpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMC4xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNuYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGFuZ2xlID0gS29udmEuZ2V0QW5nbGUoc25hcHNbaV0pO1xuXG4gICAgICAgICAgdmFyIGRpZiA9XG4gICAgICAgICAgICBNYXRoLmFicyhhbmdsZSAtIEtvbnZhLlV0aWwuX2RlZ1RvUmFkKG5ld1JvdGF0aW9uKSkgJSAoTWF0aC5QSSAqIDIpO1xuXG4gICAgICAgICAgaWYgKGRpZiA8IG9mZnNldCkge1xuICAgICAgICAgICAgbmV3Um90YXRpb24gPSBLb252YS5VdGlsLl9yYWRUb0RlZyhhbmdsZSk7XG4gICAgICAgICAgICBuZXdBbHBoYSA9IEtvbnZhLlV0aWwuX2RlZ1RvUmFkKG5ld1JvdGF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSBwYWRkaW5nO1xuICAgICAgICB2YXIgZHkgPSBwYWRkaW5nO1xuXG4gICAgICAgIHRoaXMuX2ZpdE5vZGVJbnRvKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiBLb252YS5hbmdsZURlZ1xuICAgICAgICAgICAgICA/IG5ld1JvdGF0aW9uXG4gICAgICAgICAgICAgIDogS29udmEuVXRpbC5fZGVnVG9SYWQobmV3Um90YXRpb24pLFxuICAgICAgICAgICAgeDpcbiAgICAgICAgICAgICAgYXR0cnMueCArXG4gICAgICAgICAgICAgIChhdHRycy53aWR0aCAvIDIgKyBwYWRkaW5nKSAqXG4gICAgICAgICAgICAgICAgKE1hdGguY29zKGFscGhhKSAtIE1hdGguY29zKG5ld0FscGhhKSkgK1xuICAgICAgICAgICAgICAoYXR0cnMuaGVpZ2h0IC8gMiArIHBhZGRpbmcpICpcbiAgICAgICAgICAgICAgICAoTWF0aC5zaW4oLWFscGhhKSAtIE1hdGguc2luKC1uZXdBbHBoYSkpIC1cbiAgICAgICAgICAgICAgKGR4ICogTWF0aC5jb3Mocm90KSArIGR5ICogTWF0aC5zaW4oLXJvdCkpLFxuICAgICAgICAgICAgeTpcbiAgICAgICAgICAgICAgYXR0cnMueSArXG4gICAgICAgICAgICAgIChhdHRycy5oZWlnaHQgLyAyICsgcGFkZGluZykgKlxuICAgICAgICAgICAgICAgIChNYXRoLmNvcyhhbHBoYSkgLSBNYXRoLmNvcyhuZXdBbHBoYSkpICtcbiAgICAgICAgICAgICAgKGF0dHJzLndpZHRoIC8gMiArIHBhZGRpbmcpICpcbiAgICAgICAgICAgICAgICAoTWF0aC5zaW4oYWxwaGEpIC0gTWF0aC5zaW4obmV3QWxwaGEpKSAtXG4gICAgICAgICAgICAgIChkeSAqIE1hdGguY29zKHJvdCkgKyBkeCAqIE1hdGguc2luKHJvdCkpLFxuICAgICAgICAgICAgd2lkdGg6IGF0dHJzLndpZHRoICsgcGFkZGluZyAqIDIsXG4gICAgICAgICAgICBoZWlnaHQ6IGF0dHJzLmhlaWdodCArIHBhZGRpbmcgKiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdXcm9uZyBwb3NpdGlvbiBhcmd1bWVudCBvZiBzZWxlY3Rpb24gcmVzaXplcjogJyxcbiAgICAgICAgICAgIHRoaXMubW92aW5nUmVzaXplclxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubW92aW5nUmVzaXplciA9PT0gJ3JvdGF0ZXInKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFic1BvcyA9IHRoaXMuZmluZE9uZSgnLnRvcC1sZWZ0JykuZ2V0QWJzb2x1dGVQb3NpdGlvbihcbiAgICAgICAgdGhpcy5nZXRQYXJlbnQoKVxuICAgICAgKTtcblxuICAgICAgdmFyIGNlbnRlcmVkU2NhbGluZyA9IHRoaXMuZ2V0Q2VudGVyZWRTY2FsaW5nKCkgfHwgZS5hbHRLZXk7XG4gICAgICBpZiAoY2VudGVyZWRTY2FsaW5nKSB7XG4gICAgICAgIHZhciB0b3BMZWZ0ID0gdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKTtcbiAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0Jyk7XG4gICAgICAgIHZhciB0b3BPZmZzZXRYID0gdG9wTGVmdC54KCk7XG4gICAgICAgIHZhciB0b3BPZmZzZXRZID0gdG9wTGVmdC55KCk7XG5cbiAgICAgICAgdmFyIGJvdHRvbU9mZnNldFggPSB0aGlzLmdldFdpZHRoKCkgLSBib3R0b21SaWdodC54KCk7XG4gICAgICAgIHZhciBib3R0b21PZmZzZXRZID0gdGhpcy5nZXRIZWlnaHQoKSAtIGJvdHRvbVJpZ2h0LnkoKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0b3BPZmZzZXRYLCB0b3BPZmZzZXRZLCBib3R0b21PZmZzZXRYLCBib3R0b21PZmZzZXRZKTtcblxuICAgICAgICBib3R0b21SaWdodC5tb3ZlKHtcbiAgICAgICAgICB4OiAtdG9wT2Zmc2V0WCxcbiAgICAgICAgICB5OiAtdG9wT2Zmc2V0WVxuICAgICAgICB9KTtcblxuICAgICAgICB0b3BMZWZ0Lm1vdmUoe1xuICAgICAgICAgIHg6IGJvdHRvbU9mZnNldFgsXG4gICAgICAgICAgeTogYm90dG9tT2Zmc2V0WVxuICAgICAgICB9KTtcblxuICAgICAgICBhYnNQb3MgPSB0b3BMZWZ0LmdldEFic29sdXRlUG9zaXRpb24odGhpcy5nZXRQYXJlbnQoKSk7XG4gICAgICB9XG5cbiAgICAgIHggPSBhYnNQb3MueDtcbiAgICAgIHkgPSBhYnNQb3MueTtcbiAgICAgIHZhciB3aWR0aCA9XG4gICAgICAgIHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLngoKSAtIHRoaXMuZmluZE9uZSgnLnRvcC1sZWZ0JykueCgpO1xuXG4gICAgICB2YXIgaGVpZ2h0ID1cbiAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueSgpIC0gdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS55KCk7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICB0aGlzLl9maXROb2RlSW50byhcbiAgICAgICAge1xuICAgICAgICAgIHg6IHggKyB0aGlzLm9mZnNldFgoKSxcbiAgICAgICAgICB5OiB5ICsgdGhpcy5vZmZzZXRZKCksXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudHMoZSk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVFdmVudHM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm1pbmcpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVNb3VzZVVwLCB0cnVlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlTW91c2VVcCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2ZpcmUoJ3RyYW5zZm9ybWVuZCcsIHsgZXZ0OiBlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIG5vZGUuZmlyZSgndHJhbnNmb3JtZW5kJywgeyBldnQ6IGUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZpdE5vZGVJbnRvOiBmdW5jdGlvbihuZXdBdHRycywgZXZ0KSB7XG4gICAgICAvLyB3YXJpbmchIGluIHRoaXMgYXR0cnMgcGFkZGluZyBtYXkgYmUgaW5jbHVkZWRcbiAgICAgIHZhciBib3VuZEJveEZ1bmMgPSB0aGlzLmdldEJvdW5kQm94RnVuYygpO1xuICAgICAgaWYgKGJvdW5kQm94RnVuYykge1xuICAgICAgICB2YXIgb2xkQXR0cnMgPSB0aGlzLl9nZXROb2RlUmVjdCgpO1xuICAgICAgICBuZXdBdHRycyA9IGJvdW5kQm94RnVuYy5jYWxsKHRoaXMsIG9sZEF0dHJzLCBuZXdBdHRycyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXR0aW5ncyA9IHRydWU7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKG5ld0F0dHJzLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5nZXROb2RlKCkucm90YXRpb24obmV3QXR0cnMucm90YXRpb24pO1xuICAgICAgfVxuICAgICAgdmFyIHB1cmUgPSBub2RlLmdldENsaWVudFJlY3QoeyBza2lwVHJhbnNmb3JtOiB0cnVlLCBza2lwU2hhZG93OiB0cnVlIH0pO1xuICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmdldFBhZGRpbmcoKTtcbiAgICAgIHZhciBzY2FsZVggPSAobmV3QXR0cnMud2lkdGggLSBwYWRkaW5nICogMikgLyBwdXJlLndpZHRoO1xuICAgICAgdmFyIHNjYWxlWSA9IChuZXdBdHRycy5oZWlnaHQgLSBwYWRkaW5nICogMikgLyBwdXJlLmhlaWdodDtcblxuICAgICAgdmFyIHJvdGF0aW9uID0gS29udmEuZ2V0QW5nbGUobm9kZS5nZXRSb3RhdGlvbigpKTtcbiAgICAgIHZhciBkeCA9IHB1cmUueCAqIHNjYWxlWCAtIHBhZGRpbmcgLSBub2RlLm9mZnNldFgoKSAqIHNjYWxlWDtcbiAgICAgIHZhciBkeSA9IHB1cmUueSAqIHNjYWxlWSAtIHBhZGRpbmcgLSBub2RlLm9mZnNldFkoKSAqIHNjYWxlWTtcblxuICAgICAgdGhpcy5nZXROb2RlKCkuc2V0QXR0cnMoe1xuICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiBzY2FsZVksXG4gICAgICAgIHg6IG5ld0F0dHJzLnggLSAoZHggKiBNYXRoLmNvcyhyb3RhdGlvbikgKyBkeSAqIE1hdGguc2luKC1yb3RhdGlvbikpLFxuICAgICAgICB5OiBuZXdBdHRycy55IC0gKGR5ICogTWF0aC5jb3Mocm90YXRpb24pICsgZHggKiBNYXRoLnNpbihyb3RhdGlvbikpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldHRpbmdzID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX2ZpcmUoJ3RyYW5zZm9ybScsIHsgZXZ0OiBldnQgfSk7XG4gICAgICB0aGlzLmdldE5vZGUoKS5fZmlyZSgndHJhbnNmb3JtJywgeyBldnQ6IGV2dCB9KTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLmdldExheWVyKCkuYmF0Y2hEcmF3KCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBmb3JjZSB1cGRhdGUgb2YgS29udmEuVHJhbnNmb3JtZXIuXG4gICAgICogVXNlIGl0IHdoZW4geW91IHVwZGF0ZWQgYXR0YWNoZWQgS29udmEuR3JvdXAgYW5kIG5vdyB5b3UgbmVlZCB0byByZXNldCB0cmFuc2Zvcm1lciBzaXplXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUNhY2hlKCk7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhdHRycyA9IHRoaXMuX2dldE5vZGVSZWN0KCk7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgICAgdmFyIHNjYWxlID0geyB4OiAxLCB5OiAxIH07XG4gICAgICBpZiAobm9kZSAmJiBub2RlLmdldFBhcmVudCgpKSB7XG4gICAgICAgIHNjYWxlID0gbm9kZS5nZXRQYXJlbnQoKS5nZXRBYnNvbHV0ZVNjYWxlKCk7XG4gICAgICB9XG4gICAgICB2YXIgaW52ZXJ0ZWRTY2FsZSA9IHtcbiAgICAgICAgeDogMSAvIHNjYWxlLngsXG4gICAgICAgIHk6IDEgLyBzY2FsZS55XG4gICAgICB9O1xuICAgICAgdmFyIHdpZHRoID0gYXR0cnMud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gYXR0cnMuaGVpZ2h0O1xuXG4gICAgICB2YXIgZW5hYmxlZEFuY2hvcnMgPSB0aGlzLmVuYWJsZWRBbmNob3JzKCk7XG4gICAgICB2YXIgcmVzaXplRW5hYmxlZCA9IHRoaXMucmVzaXplRW5hYmxlZCgpO1xuICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmdldFBhZGRpbmcoKTtcblxuICAgICAgdmFyIGFuY2hvclNpemUgPSB0aGlzLmdldEFuY2hvclNpemUoKTtcbiAgICAgIHRoaXMuZmluZCgnLl9hbmNob3InKS5zZXRBdHRycyh7XG4gICAgICAgIHdpZHRoOiBhbmNob3JTaXplLFxuICAgICAgICBoZWlnaHQ6IGFuY2hvclNpemUsXG4gICAgICAgIG9mZnNldFg6IGFuY2hvclNpemUgLyAyLFxuICAgICAgICBvZmZzZXRZOiBhbmNob3JTaXplIC8gMixcbiAgICAgICAgc3Ryb2tlOiB0aGlzLmdldEFuY2hvclN0cm9rZSgpLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5nZXRBbmNob3JTdHJva2VXaWR0aCgpLFxuICAgICAgICBmaWxsOiB0aGlzLmdldEFuY2hvckZpbGwoKSxcbiAgICAgICAgY29ybmVyUmFkaXVzOiB0aGlzLmdldEFuY2hvckNvcm5lclJhZGl1cygpXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS5zZXRBdHRycyh7XG4gICAgICAgIHg6IC1wYWRkaW5nLFxuICAgICAgICB5OiAtcGFkZGluZyxcbiAgICAgICAgc2NhbGU6IGludmVydGVkU2NhbGUsXG4gICAgICAgIHZpc2libGU6IHJlc2l6ZUVuYWJsZWQgJiYgZW5hYmxlZEFuY2hvcnMuaW5kZXhPZigndG9wLWxlZnQnKSA+PSAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmluZE9uZSgnLnRvcC1jZW50ZXInKS5zZXRBdHRycyh7XG4gICAgICAgIHg6IHdpZHRoIC8gMixcbiAgICAgICAgeTogLXBhZGRpbmcsXG4gICAgICAgIHNjYWxlOiBpbnZlcnRlZFNjYWxlLFxuICAgICAgICB2aXNpYmxlOiByZXNpemVFbmFibGVkICYmIGVuYWJsZWRBbmNob3JzLmluZGV4T2YoJ3RvcC1jZW50ZXInKSA+PSAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmluZE9uZSgnLnRvcC1yaWdodCcpLnNldEF0dHJzKHtcbiAgICAgICAgeDogd2lkdGggKyBwYWRkaW5nLFxuICAgICAgICB5OiAtcGFkZGluZyxcbiAgICAgICAgc2NhbGU6IGludmVydGVkU2NhbGUsXG4gICAgICAgIHZpc2libGU6IHJlc2l6ZUVuYWJsZWQgJiYgZW5hYmxlZEFuY2hvcnMuaW5kZXhPZigndG9wLXJpZ2h0JykgPj0gMFxuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbmRPbmUoJy5taWRkbGUtbGVmdCcpLnNldEF0dHJzKHtcbiAgICAgICAgeDogLXBhZGRpbmcsXG4gICAgICAgIHk6IGhlaWdodCAvIDIsXG4gICAgICAgIHNjYWxlOiBpbnZlcnRlZFNjYWxlLFxuICAgICAgICB2aXNpYmxlOiByZXNpemVFbmFibGVkICYmIGVuYWJsZWRBbmNob3JzLmluZGV4T2YoJ21pZGRsZS1sZWZ0JykgPj0gMFxuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbmRPbmUoJy5taWRkbGUtcmlnaHQnKS5zZXRBdHRycyh7XG4gICAgICAgIHg6IHdpZHRoICsgcGFkZGluZyxcbiAgICAgICAgeTogaGVpZ2h0IC8gMixcbiAgICAgICAgc2NhbGU6IGludmVydGVkU2NhbGUsXG4gICAgICAgIHZpc2libGU6IHJlc2l6ZUVuYWJsZWQgJiYgZW5hYmxlZEFuY2hvcnMuaW5kZXhPZignbWlkZGxlLXJpZ2h0JykgPj0gMFxuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbmRPbmUoJy5ib3R0b20tbGVmdCcpLnNldEF0dHJzKHtcbiAgICAgICAgeDogLXBhZGRpbmcsXG4gICAgICAgIHk6IGhlaWdodCArIHBhZGRpbmcsXG4gICAgICAgIHNjYWxlOiBpbnZlcnRlZFNjYWxlLFxuICAgICAgICB2aXNpYmxlOiByZXNpemVFbmFibGVkICYmIGVuYWJsZWRBbmNob3JzLmluZGV4T2YoJ2JvdHRvbS1sZWZ0JykgPj0gMFxuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbmRPbmUoJy5ib3R0b20tY2VudGVyJykuc2V0QXR0cnMoe1xuICAgICAgICB4OiB3aWR0aCAvIDIsXG4gICAgICAgIHk6IGhlaWdodCArIHBhZGRpbmcsXG4gICAgICAgIHNjYWxlOiBpbnZlcnRlZFNjYWxlLFxuICAgICAgICB2aXNpYmxlOiByZXNpemVFbmFibGVkICYmIGVuYWJsZWRBbmNob3JzLmluZGV4T2YoJ2JvdHRvbS1jZW50ZXInKSA+PSAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLnNldEF0dHJzKHtcbiAgICAgICAgeDogd2lkdGggKyBwYWRkaW5nLFxuICAgICAgICB5OiBoZWlnaHQgKyBwYWRkaW5nLFxuICAgICAgICBzY2FsZTogaW52ZXJ0ZWRTY2FsZSxcbiAgICAgICAgdmlzaWJsZTogcmVzaXplRW5hYmxlZCAmJiBlbmFibGVkQW5jaG9ycy5pbmRleE9mKCdib3R0b20tcmlnaHQnKSA+PSAwXG4gICAgICB9KTtcblxuICAgICAgdmFyIHNjYWxlZFJvdGF0ZUFuY2hvck9mZnNldCA9XG4gICAgICAgIC10aGlzLnJvdGF0ZUFuY2hvck9mZnNldCgpICogTWF0aC5hYnMoaW52ZXJ0ZWRTY2FsZS55KTtcbiAgICAgIHRoaXMuZmluZE9uZSgnLnJvdGF0ZXInKS5zZXRBdHRycyh7XG4gICAgICAgIHg6IHdpZHRoIC8gMixcbiAgICAgICAgeTogc2NhbGVkUm90YXRlQW5jaG9yT2Zmc2V0ICogS29udmEuVXRpbC5fc2lnbihoZWlnaHQpLFxuICAgICAgICBzY2FsZTogaW52ZXJ0ZWRTY2FsZSxcbiAgICAgICAgdmlzaWJsZTogdGhpcy5yb3RhdGVFbmFibGVkKClcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmZpbmRPbmUoJy5iYWNrJykuc2V0QXR0cnMoe1xuICAgICAgICB3aWR0aDogd2lkdGggKiBzY2FsZS54LFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCAqIHNjYWxlLnksXG4gICAgICAgIHNjYWxlOiBpbnZlcnRlZFNjYWxlLFxuICAgICAgICB2aXNpYmxlOiB0aGlzLmJvcmRlckVuYWJsZWQoKSxcbiAgICAgICAgc3Ryb2tlOiB0aGlzLmdldEJvcmRlclN0cm9rZSgpLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5nZXRCb3JkZXJTdHJva2VXaWR0aCgpLFxuICAgICAgICBkYXNoOiB0aGlzLmdldEJvcmRlckRhc2goKVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmUgaWYgdHJhbnNmb3JtZXIgaXMgaW4gYWN0aXZlIHRyYW5zZm9ybVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUcmFuc2Zvcm1pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybWluZztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFN0b3AgYWN0aXZlIHRyYW5zZm9ybSBhY3Rpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0b3BUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX3RyYW5zZm9ybWluZykge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudHMoKTtcbiAgICAgICAgdmFyIHJlc2l6ZXJOb2RlID0gdGhpcy5maW5kT25lKCcuJyArIHRoaXMubW92aW5nUmVzaXplcik7XG4gICAgICAgIGlmIChyZXNpemVyTm9kZSkge1xuICAgICAgICAgIHJlc2l6ZXJOb2RlLnN0b3BEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5pc1RyYW5zZm9ybWluZygpICYmIHRoaXMuZ2V0U3RhZ2UoKSk7XG4gICAgICBpZiAodGhpcy5nZXRTdGFnZSgpICYmIHRoaXMuX2N1cnNvckNoYW5nZSkge1xuICAgICAgICB0aGlzLmdldFN0YWdlKCkuY29udGVudC5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgIH1cbiAgICAgIEtvbnZhLkdyb3VwLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRzKCk7XG4gICAgfSxcbiAgICAvLyBkbyBub3Qgd29yayBhcyBhIGNvbnRhaW5lclxuICAgIC8vIHdlIHdpbGwgcmVjcmVhdGUgaW5uZXIgbm9kZXMgbWFudWFsbHlcbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gS29udmEuTm9kZS5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH07XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlRyYW5zZm9ybWVyLCBLb252YS5Hcm91cCk7XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVSZXNpemVycyh2YWwpIHtcbiAgICBpZiAoISh2YWwgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIEtvbnZhLlV0aWwud2FybignZW5hYmxlZEFuY2hvcnMgdmFsdWUgc2hvdWxkIGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoQU5DSE9SU19OQU1FUy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgICAgICdVbmtub3duIGFuY2hvciBuYW1lOiAnICtcbiAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICcuIEF2YWlsYWJsZSBuYW1lcyBhcmU6ICcgK1xuICAgICAgICAgICAgICBBTkNIT1JTX05BTUVTLmpvaW4oJywgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbCB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGVuYWJsZWQgaGFuZGxlcnNcbiAgICogQG5hbWUgZW5hYmxlZEFuY2hvcnNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGxpc3Qgb2YgaGFuZGxlcnNcbiAgICogdmFyIGVuYWJsZWRBbmNob3JzID0gdHJhbnNmb3JtZXIuZW5hYmxlZEFuY2hvcnMoKTtcbiAgICpcbiAgICogLy8gc2V0IGhhbmRsZXJzXG4gICAqIHRyYW5zZm9ybWVyLmVuYWJsZWRBbmNob3JzKFsndG9wLWxlZnQnLCAndG9wLWNlbnRlcicsICd0b3AtcmlnaHQnLCAnbWlkZGxlLXJpZ2h0JywgJ21pZGRsZS1sZWZ0JywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1jZW50ZXInLCAnYm90dG9tLXJpZ2h0J10pO1xuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuVHJhbnNmb3JtZXIsXG4gICAgJ2VuYWJsZWRBbmNob3JzJyxcbiAgICBBTkNIT1JTX05BTUVTLFxuICAgIHZhbGlkYXRlUmVzaXplcnNcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCByZXNpemUgYWJpbGl0eS4gSWYgZmFsc2UgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGhpZGUgcmVzaXppbmcgaGFuZGxlcnNcbiAgICogQG5hbWUgcmVzaXplRW5hYmxlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXRcbiAgICogdmFyIHJlc2l6ZUVuYWJsZWQgPSB0cmFuc2Zvcm1lci5yZXNpemVFbmFibGVkKCk7XG4gICAqXG4gICAqIC8vIHNldFxuICAgKiB0cmFuc2Zvcm1lci5yZXNpemVFbmFibGVkKGZhbHNlKTtcbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRyYW5zZm9ybWVyLCAncmVzaXplRW5hYmxlZCcsIHRydWUpO1xuICAvKipcbiAgICogZ2V0L3NldCBhbmNob3Igc2l6ZS4gRGVmYXVsdCBpcyAxMFxuICAgKiBAbmFtZSB2YWxpZGF0ZUFuY2hvcnNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAxMFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXRcbiAgICogdmFyIGFuY2hvclNpemUgPSB0cmFuc2Zvcm1lci5hbmNob3JTaXplKCk7XG4gICAqXG4gICAqIC8vIHNldFxuICAgKiB0cmFuc2Zvcm1lci5hbmNob3JTaXplKDIwKVxuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuVHJhbnNmb3JtZXIsXG4gICAgJ2FuY2hvclNpemUnLFxuICAgIDEwLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBhYmlsaXR5IHRvIHJvdGF0ZS5cbiAgICogQG5hbWUgcm90YXRlRW5hYmxlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXRcbiAgICogdmFyIHJvdGF0ZUVuYWJsZWQgPSB0cmFuc2Zvcm1lci5yb3RhdGVFbmFibGVkKCk7XG4gICAqXG4gICAqIC8vIHNldFxuICAgKiB0cmFuc2Zvcm1lci5yb3RhdGVFbmFibGVkKGZhbHNlKTtcbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRyYW5zZm9ybWVyLCAncm90YXRlRW5hYmxlZCcsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHJvdGF0aW9uIHNuYXBzIGFuZ2xlcy5cbiAgICogQG5hbWUgcm90YXRpb25TbmFwc1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXRcbiAgICogdmFyIHJvdGF0aW9uU25hcHMgPSB0cmFuc2Zvcm1lci5yb3RhdGlvblNuYXBzKCk7XG4gICAqXG4gICAqIC8vIHNldFxuICAgKiB0cmFuc2Zvcm1lci5yb3RhdGlvblNuYXBzKFswLCA5MCwgMTgwLCAyNzBdKTtcbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRyYW5zZm9ybWVyLCAncm90YXRpb25TbmFwcycsIFtdKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBkaXN0YW5jZSBmb3Igcm90YXRpb24gaGFuZGxlclxuICAgKiBAbmFtZSByb3RhdGVBbmNob3JPZmZzZXRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0XG4gICAqIHZhciByb3RhdGVBbmNob3JPZmZzZXQgPSB0cmFuc2Zvcm1lci5yb3RhdGVBbmNob3JPZmZzZXQoKTtcbiAgICpcbiAgICogLy8gc2V0XG4gICAqIHRyYW5zZm9ybWVyLnJvdGF0ZUFuY2hvck9mZnNldCgxMDApO1xuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuVHJhbnNmb3JtZXIsXG4gICAgJ3JvdGF0ZUFuY2hvck9mZnNldCcsXG4gICAgNTAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHZpc2liaWxpdHkgb2YgYm9yZGVyXG4gICAqIEBuYW1lIGJvcmRlckVuYWJsZWRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0XG4gICAqIHZhciBib3JkZXJFbmFibGVkID0gdHJhbnNmb3JtZXIuYm9yZGVyRW5hYmxlZCgpO1xuICAgKlxuICAgKiAvLyBzZXRcbiAgICogdHJhbnNmb3JtZXIuYm9yZGVyRW5hYmxlZChmYWxzZSk7XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UcmFuc2Zvcm1lciwgJ2JvcmRlckVuYWJsZWQnLCB0cnVlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBhbmNob3Igc3Ryb2tlIGNvbG9yXG4gICAqIEBuYW1lIGFuY2hvclN0cm9rZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXRcbiAgICogdmFyIGFuY2hvclN0cm9rZSA9IHRyYW5zZm9ybWVyLmFuY2hvclN0cm9rZSgpO1xuICAgKlxuICAgKiAvLyBzZXRcbiAgICogdHJhbnNmb3JtZXIuYW5jaG9yU3Ryb2tlKCdyZWQnKTtcbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlRyYW5zZm9ybWVyLFxuICAgICdhbmNob3JTdHJva2UnLFxuICAgICdyZ2IoMCwgMTYxLCAyNTUpJ1xuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGFuY2hvciBzdHJva2Ugd2lkdGhcbiAgICogQG5hbWUgYW5jaG9yU3Ryb2tlV2lkdGhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0XG4gICAqIHZhciBhbmNob3JTdHJva2VXaWR0aCA9IHRyYW5zZm9ybWVyLmFuY2hvclN0cm9rZVdpZHRoKCk7XG4gICAqXG4gICAqIC8vIHNldFxuICAgKiB0cmFuc2Zvcm1lci5hbmNob3JTdHJva2VXaWR0aCgzKTtcbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlRyYW5zZm9ybWVyLFxuICAgICdhbmNob3JTdHJva2VXaWR0aCcsXG4gICAgMSxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgYW5jaG9yIGZpbGwgY29sb3JcbiAgICogQG5hbWUgYW5jaG9yRmlsbFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXRcbiAgICogdmFyIGFuY2hvckZpbGwgPSB0cmFuc2Zvcm1lci5hbmNob3JGaWxsKCk7XG4gICAqXG4gICAqIC8vIHNldFxuICAgKiB0cmFuc2Zvcm1lci5hbmNob3JGaWxsKCdyZWQnKTtcbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRyYW5zZm9ybWVyLCAnYW5jaG9yRmlsbCcsICd3aGl0ZScpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGFuY2hvciBjb3JuZXIgcmFkaXVzXG4gICAqIEBuYW1lIGFuY2hvckNvcm5lclJhZGl1c1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuYWJsZWRcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0XG4gICAqIHZhciBhbmNob3JDb3JuZXJSYWRpdXMgPSB0cmFuc2Zvcm1lci5hbmNob3JDb3JuZXJSYWRpdXMoKTtcbiAgICpcbiAgICogLy8gc2V0XG4gICAqIHRyYW5zZm9ybWVyLmFuY2hvckNvcm5lclJhZGl1cygzKTtcbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlRyYW5zZm9ybWVyLFxuICAgICdhbmNob3JDb3JuZXJSYWRpdXMnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5nZXROdW1iZXJWYWxpZGF0b3IoKVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGJvcmRlciBzdHJva2UgY29sb3JcbiAgICogQG5hbWUgYm9yZGVyU3Ryb2tlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldFxuICAgKiB2YXIgYm9yZGVyU3Ryb2tlID0gdHJhbnNmb3JtZXIuYm9yZGVyU3Ryb2tlKCk7XG4gICAqXG4gICAqIC8vIHNldFxuICAgKiB0cmFuc2Zvcm1lci5ib3JkZXJTdHJva2UoJ3JlZCcpO1xuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuVHJhbnNmb3JtZXIsXG4gICAgJ2JvcmRlclN0cm9rZScsXG4gICAgJ3JnYigwLCAxNjEsIDI1NSknXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgYm9yZGVyIHN0cm9rZSB3aWR0aFxuICAgKiBAbmFtZSBib3JkZXJTdHJva2VXaWR0aFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXRcbiAgICogdmFyIGJvcmRlclN0cm9rZVdpZHRoID0gdHJhbnNmb3JtZXIuYm9yZGVyU3Ryb2tlV2lkdGgoKTtcbiAgICpcbiAgICogLy8gc2V0XG4gICAqIHRyYW5zZm9ybWVyLmJvcmRlclN0cm9rZVdpZHRoKDMpO1xuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuVHJhbnNmb3JtZXIsXG4gICAgJ2JvcmRlclN0cm9rZVdpZHRoJyxcbiAgICAxLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuZ2V0TnVtYmVyVmFsaWRhdG9yKClcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBib3JkZXIgZGFzaCBhcnJheVxuICAgKiBAbmFtZSBib3JkZXJEYXNoXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldFxuICAgKiB2YXIgYm9yZGVyRGFzaCA9IHRyYW5zZm9ybWVyLmJvcmRlckRhc2goKTtcbiAgICpcbiAgICogLy8gc2V0XG4gICAqIHRyYW5zZm9ybWVyLmJvcmRlckRhc2goWzIsIDJdKTtcbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRyYW5zZm9ybWVyLCAnYm9yZGVyRGFzaCcpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNob3VsZCB3ZSBrZWVwIHJhdGlvIHdoaWxlIHJlc2l6ZSBhbmNob3JzIGF0IGNvcm5lcnNcbiAgICogQG5hbWUga2VlcFJhdGlvXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGtlZXBSYXRpb1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0XG4gICAqIHZhciBrZWVwUmF0aW8gPSB0cmFuc2Zvcm1lci5rZWVwUmF0aW8oKTtcbiAgICpcbiAgICogLy8gc2V0XG4gICAqIHRyYW5zZm9ybWVyLmtlZXBSYXRpbyhmYWxzZSk7XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UcmFuc2Zvcm1lciwgJ2tlZXBSYXRpbycsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNob3VsZCB3ZSByZXNpemUgcmVsYXRpdmUgdG8gbm9kZSdzIGNlbnRlcj9cbiAgICogQG5hbWUgY2VudGVyZWRTY2FsaW5nXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNlbnRlcmVkU2NhbGluZ1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0XG4gICAqIHZhciBjZW50ZXJlZFNjYWxpbmcgPSB0cmFuc2Zvcm1lci5jZW50ZXJlZFNjYWxpbmcoKTtcbiAgICpcbiAgICogLy8gc2V0XG4gICAqIHRyYW5zZm9ybWVyLmNlbnRlcmVkU2NhbGluZyh0cnVlKTtcbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRyYW5zZm9ybWVyLCAnY2VudGVyZWRTY2FsaW5nJywgZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHBhZGRpbmdcbiAgICogQG5hbWUgcGFkZGluZ1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhZGRpbmdcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0XG4gICAqIHZhciBwYWRkaW5nID0gdHJhbnNmb3JtZXIucGFkZGluZygpO1xuICAgKlxuICAgKiAvLyBzZXRcbiAgICogdHJhbnNmb3JtZXIucGFkZGluZygxMCk7XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5UcmFuc2Zvcm1lcixcbiAgICAncGFkZGluZycsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLmdldE51bWJlclZhbGlkYXRvcigpXG4gICk7XG5cbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLlRyYW5zZm9ybWVyLCAnbm9kZScpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGJvdW5kaW5nIGJveCBmdW5jdGlvblxuICAgKiBAbmFtZSBib3VuZEJveEZ1bmNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXRcbiAgICogdmFyIGJvdW5kQm94RnVuYyA9IHRyYW5zZm9ybWVyLmJvdW5kQm94RnVuYygpO1xuICAgKlxuICAgKiAvLyBzZXRcbiAgICogdHJhbnNmb3JtZXIuYm91bmRCb3hGdW5jKGZ1bmN0aW9uKG9sZEJveCwgbmV3Qm94KSB7XG4gICAqICAgaWYgKG5ld0JveC53aWR0aCA+IDIwMCkge1xuICAgKiAgICAgcmV0dXJuIG9sZEJveDtcbiAgICogICB9XG4gICAqICAgcmV0dXJuIG5ld0JveDtcbiAgICogfSk7XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UcmFuc2Zvcm1lciwgJ2JvdW5kQm94RnVuYycpO1xuXG4gIEtvbnZhLkZhY3RvcnkuYmFja0NvbXBhdChLb252YS5UcmFuc2Zvcm1lciwge1xuICAgIGxpbmVFbmFibGVkOiAnYm9yZGVyRW5hYmxlZCcsXG4gICAgcm90YXRlSGFuZGxlck9mZnNldDogJ3JvdGF0ZUFuY2hvck9mZnNldCcsXG4gICAgZW5hYmxlZEhhbmRsZXJzOiAnZW5hYmxlZEFuY2hvcnMnXG4gIH0pO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5UcmFuc2Zvcm1lcik7XG59KShLb252YSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsIi8qZXNsaW50LWVudiBicm93c2VyKi9cblxudmFyIGNsaWVudE92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmNsaWVudE92ZXJsYXkuaWQgPSAnd2VicGFjay1ob3QtbWlkZGxld2FyZS1jbGllbnRPdmVybGF5JztcbnZhciBzdHlsZXMgPSB7XG4gIGJhY2tncm91bmQ6ICdyZ2JhKDAsMCwwLDAuODUpJyxcbiAgY29sb3I6ICcjRThFOEU4JyxcbiAgbGluZUhlaWdodDogJzEuMicsXG4gIHdoaXRlU3BhY2U6ICdwcmUnLFxuICBmb250RmFtaWx5OiAnTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2UnLFxuICBmb250U2l6ZTogJzEzcHgnLFxuICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgekluZGV4OiA5OTk5LFxuICBwYWRkaW5nOiAnMTBweCcsXG4gIGxlZnQ6IDAsXG4gIHJpZ2h0OiAwLFxuICB0b3A6IDAsXG4gIGJvdHRvbTogMCxcbiAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgZGlyOiAnbHRyJyxcbiAgdGV4dEFsaWduOiAnbGVmdCdcbn07XG5cbnZhciBhbnNpSFRNTCA9IHJlcXVpcmUoJ2Fuc2ktaHRtbCcpO1xudmFyIGNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsndHJhbnNwYXJlbnQnLCAndHJhbnNwYXJlbnQnXSxcbiAgYmxhY2s6ICcxODE4MTgnLFxuICByZWQ6ICdFMzYwNDknLFxuICBncmVlbjogJ0IzQ0I3NCcsXG4gIHllbGxvdzogJ0ZGRDA4MCcsXG4gIGJsdWU6ICc3Q0FGQzInLFxuICBtYWdlbnRhOiAnN0ZBQ0NBJyxcbiAgY3lhbjogJ0MzQzJFRicsXG4gIGxpZ2h0Z3JleTogJ0VCRTdFMycsXG4gIGRhcmtncmV5OiAnNkQ3ODkxJ1xufTtcblxudmFyIEVudGl0aWVzID0gcmVxdWlyZSgnaHRtbC1lbnRpdGllcycpLkFsbEh0bWxFbnRpdGllcztcbnZhciBlbnRpdGllcyA9IG5ldyBFbnRpdGllcygpO1xuXG5mdW5jdGlvbiBzaG93UHJvYmxlbXModHlwZSwgbGluZXMpIHtcbiAgY2xpZW50T3ZlcmxheS5pbm5lckhUTUwgPSAnJztcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbihtc2cpIHtcbiAgICBtc2cgPSBhbnNpSFRNTChlbnRpdGllcy5lbmNvZGUobXNnKSk7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMjZweCc7XG4gICAgZGl2LmlubmVySFRNTCA9IHByb2JsZW1UeXBlKHR5cGUpICsgJyBpbiAnICsgbXNnO1xuICAgIGNsaWVudE92ZXJsYXkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfSk7XG4gIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjbGllbnRPdmVybGF5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgaWYgKGRvY3VtZW50LmJvZHkgJiYgY2xpZW50T3ZlcmxheS5wYXJlbnROb2RlKSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjbGllbnRPdmVybGF5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9ibGVtVHlwZSAodHlwZSkge1xuICB2YXIgcHJvYmxlbUNvbG9ycyA9IHtcbiAgICBlcnJvcnM6IGNvbG9ycy5yZWQsXG4gICAgd2FybmluZ3M6IGNvbG9ycy55ZWxsb3dcbiAgfTtcbiAgdmFyIGNvbG9yID0gcHJvYmxlbUNvbG9yc1t0eXBlXSB8fCBjb2xvcnMucmVkO1xuICByZXR1cm4gKFxuICAgICc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IycgKyBjb2xvciArICc7IGNvbG9yOiNmZmY7IHBhZGRpbmc6MnB4IDRweDsgYm9yZGVyLXJhZGl1czogMnB4XCI+JyArXG4gICAgICB0eXBlLnNsaWNlKDAsIC0xKS50b1VwcGVyQ2FzZSgpICtcbiAgICAnPC9zcGFuPidcbiAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGZvciAodmFyIGNvbG9yIGluIG9wdGlvbnMub3ZlcmxheUNvbG9ycykge1xuICAgIGlmIChjb2xvciBpbiBjb2xvcnMpIHtcbiAgICAgIGNvbG9yc1tjb2xvcl0gPSBvcHRpb25zLm92ZXJsYXlDb2xvcnNbY29sb3JdO1xuICAgIH1cbiAgICBhbnNpSFRNTC5zZXRDb2xvcnMoY29sb3JzKTtcbiAgfVxuXG4gIGZvciAodmFyIHN0eWxlIGluIG9wdGlvbnMub3ZlcmxheVN0eWxlcykge1xuICAgIHN0eWxlc1tzdHlsZV0gPSBvcHRpb25zLm92ZXJsYXlTdHlsZXNbc3R5bGVdO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgIGNsaWVudE92ZXJsYXkuc3R5bGVba2V5XSA9IHN0eWxlc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzaG93UHJvYmxlbXM6IHNob3dQcm9ibGVtcyxcbiAgICBjbGVhcjogY2xlYXJcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuY2xlYXIgPSBjbGVhcjtcbm1vZHVsZS5leHBvcnRzLnNob3dQcm9ibGVtcyA9IHNob3dQcm9ibGVtcztcbiIsIi8qZXNsaW50LWVudiBicm93c2VyKi9cbi8qZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyovXG5cbnZhciBvcHRpb25zID0ge1xuICBwYXRoOiBcIi9fX3dlYnBhY2tfaG1yXCIsXG4gIHRpbWVvdXQ6IDIwICogMTAwMCxcbiAgb3ZlcmxheTogdHJ1ZSxcbiAgcmVsb2FkOiBmYWxzZSxcbiAgbG9nOiB0cnVlLFxuICB3YXJuOiB0cnVlLFxuICBuYW1lOiAnJyxcbiAgYXV0b0Nvbm5lY3Q6IHRydWUsXG4gIG92ZXJsYXlTdHlsZXM6IHt9LFxuICBvdmVybGF5V2FybmluZ3M6IGZhbHNlLFxuICBhbnNpQ29sb3JzOiB7fVxufTtcbmlmIChfX3Jlc291cmNlUXVlcnkpIHtcbiAgdmFyIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbiAgdmFyIG92ZXJyaWRlcyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKF9fcmVzb3VyY2VRdWVyeS5zbGljZSgxKSk7XG4gIHNldE92ZXJyaWRlcyhvdmVycmlkZXMpO1xufVxuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gZG8gbm90aGluZ1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93LkV2ZW50U291cmNlID09PSAndW5kZWZpbmVkJykge1xuICBjb25zb2xlLndhcm4oXG4gICAgXCJ3ZWJwYWNrLWhvdC1taWRkbGV3YXJlJ3MgY2xpZW50IHJlcXVpcmVzIEV2ZW50U291cmNlIHRvIHdvcmsuIFwiICtcbiAgICBcIllvdSBzaG91bGQgaW5jbHVkZSBhIHBvbHlmaWxsIGlmIHlvdSB3YW50IHRvIHN1cHBvcnQgdGhpcyBicm93c2VyOiBcIiArXG4gICAgXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzI1Rvb2xzXCJcbiAgKTtcbn0gZWxzZSB7XG4gIGlmIChvcHRpb25zLmF1dG9Db25uZWN0KSB7XG4gICAgY29ubmVjdCgpO1xuICB9XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBzZXRPcHRpb25zQW5kQ29ubmVjdChvdmVycmlkZXMpIHtcbiAgc2V0T3ZlcnJpZGVzKG92ZXJyaWRlcyk7XG4gIGNvbm5lY3QoKTtcbn1cblxuZnVuY3Rpb24gc2V0T3ZlcnJpZGVzKG92ZXJyaWRlcykge1xuICBpZiAob3ZlcnJpZGVzLmF1dG9Db25uZWN0KSBvcHRpb25zLmF1dG9Db25uZWN0ID0gb3ZlcnJpZGVzLmF1dG9Db25uZWN0ID09ICd0cnVlJztcbiAgaWYgKG92ZXJyaWRlcy5wYXRoKSBvcHRpb25zLnBhdGggPSBvdmVycmlkZXMucGF0aDtcbiAgaWYgKG92ZXJyaWRlcy50aW1lb3V0KSBvcHRpb25zLnRpbWVvdXQgPSBvdmVycmlkZXMudGltZW91dDtcbiAgaWYgKG92ZXJyaWRlcy5vdmVybGF5KSBvcHRpb25zLm92ZXJsYXkgPSBvdmVycmlkZXMub3ZlcmxheSAhPT0gJ2ZhbHNlJztcbiAgaWYgKG92ZXJyaWRlcy5yZWxvYWQpIG9wdGlvbnMucmVsb2FkID0gb3ZlcnJpZGVzLnJlbG9hZCAhPT0gJ2ZhbHNlJztcbiAgaWYgKG92ZXJyaWRlcy5ub0luZm8gJiYgb3ZlcnJpZGVzLm5vSW5mbyAhPT0gJ2ZhbHNlJykge1xuICAgIG9wdGlvbnMubG9nID0gZmFsc2U7XG4gIH1cbiAgaWYgKG92ZXJyaWRlcy5uYW1lKSB7XG4gICAgb3B0aW9ucy5uYW1lID0gb3ZlcnJpZGVzLm5hbWU7XG4gIH1cbiAgaWYgKG92ZXJyaWRlcy5xdWlldCAmJiBvdmVycmlkZXMucXVpZXQgIT09ICdmYWxzZScpIHtcbiAgICBvcHRpb25zLmxvZyA9IGZhbHNlO1xuICAgIG9wdGlvbnMud2FybiA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKG92ZXJyaWRlcy5keW5hbWljUHVibGljUGF0aCkge1xuICAgIG9wdGlvbnMucGF0aCA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgb3B0aW9ucy5wYXRoO1xuICB9XG5cbiAgaWYgKG92ZXJyaWRlcy5hbnNpQ29sb3JzKSBvcHRpb25zLmFuc2lDb2xvcnMgPSBKU09OLnBhcnNlKG92ZXJyaWRlcy5hbnNpQ29sb3JzKTtcbiAgaWYgKG92ZXJyaWRlcy5vdmVybGF5U3R5bGVzKSBvcHRpb25zLm92ZXJsYXlTdHlsZXMgPSBKU09OLnBhcnNlKG92ZXJyaWRlcy5vdmVybGF5U3R5bGVzKTtcblxuICBpZiAob3ZlcnJpZGVzLm92ZXJsYXlXYXJuaW5ncykge1xuICAgIG9wdGlvbnMub3ZlcmxheVdhcm5pbmdzID0gb3ZlcnJpZGVzLm92ZXJsYXlXYXJuaW5ncyA9PSAndHJ1ZSc7XG4gIH1cbn1cblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VXcmFwcGVyKCkge1xuICB2YXIgc291cmNlO1xuICB2YXIgbGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKTtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIGluaXQoKTtcbiAgdmFyIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgaWYgKChuZXcgRGF0ZSgpIC0gbGFzdEFjdGl2aXR5KSA+IG9wdGlvbnMudGltZW91dCkge1xuICAgICAgaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfSwgb3B0aW9ucy50aW1lb3V0IC8gMik7XG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBzb3VyY2UgPSBuZXcgd2luZG93LkV2ZW50U291cmNlKG9wdGlvbnMucGF0aCk7XG4gICAgc291cmNlLm9ub3BlbiA9IGhhbmRsZU9ubGluZTtcbiAgICBzb3VyY2Uub25lcnJvciA9IGhhbmRsZURpc2Nvbm5lY3Q7XG4gICAgc291cmNlLm9ubWVzc2FnZSA9IGhhbmRsZU1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVPbmxpbmUoKSB7XG4gICAgaWYgKG9wdGlvbnMubG9nKSBjb25zb2xlLmxvZyhcIltITVJdIGNvbm5lY3RlZFwiKTtcbiAgICBsYXN0QWN0aXZpdHkgPSBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgIGxhc3RBY3Rpdml0eSA9IG5ldyBEYXRlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICBzb3VyY2UuY2xvc2UoKTtcbiAgICBzZXRUaW1lb3V0KGluaXQsIG9wdGlvbnMudGltZW91dCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcjogZnVuY3Rpb24oZm4pIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKGZuKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50U291cmNlV3JhcHBlcigpIHtcbiAgaWYgKCF3aW5kb3cuX193aG1FdmVudFNvdXJjZVdyYXBwZXIpIHtcbiAgICB3aW5kb3cuX193aG1FdmVudFNvdXJjZVdyYXBwZXIgPSB7fTtcbiAgfVxuICBpZiAoIXdpbmRvdy5fX3dobUV2ZW50U291cmNlV3JhcHBlcltvcHRpb25zLnBhdGhdKSB7XG4gICAgLy8gY2FjaGUgdGhlIHdyYXBwZXIgZm9yIG90aGVyIGVudHJpZXMgbG9hZGVkIG9uXG4gICAgLy8gdGhlIHNhbWUgcGFnZSB3aXRoIHRoZSBzYW1lIG9wdGlvbnMucGF0aFxuICAgIHdpbmRvdy5fX3dobUV2ZW50U291cmNlV3JhcHBlcltvcHRpb25zLnBhdGhdID0gRXZlbnRTb3VyY2VXcmFwcGVyKCk7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5fX3dobUV2ZW50U291cmNlV3JhcHBlcltvcHRpb25zLnBhdGhdO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0KCkge1xuICBnZXRFdmVudFNvdXJjZVdyYXBwZXIoKS5hZGRNZXNzYWdlTGlzdGVuZXIoaGFuZGxlTWVzc2FnZSk7XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgIGlmIChldmVudC5kYXRhID09IFwiXFx1RDgzRFxcdURDOTNcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcHJvY2Vzc01lc3NhZ2UoSlNPTi5wYXJzZShldmVudC5kYXRhKSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChvcHRpb25zLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBITVIgbWVzc2FnZTogXCIgKyBldmVudC5kYXRhICsgXCJcXG5cIiArIGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gdGhlIHJlcG9ydGVyIG5lZWRzIHRvIGJlIGEgc2luZ2xldG9uIG9uIHRoZSBwYWdlXG4vLyBpbiBjYXNlIHRoZSBjbGllbnQgaXMgYmVpbmcgdXNlZCBieSBtdWx0aXBsZSBidW5kbGVzXG4vLyB3ZSBvbmx5IHdhbnQgdG8gcmVwb3J0IG9uY2UuXG4vLyBhbGwgdGhlIGVycm9ycyB3aWxsIGdvIHRvIGFsbCBjbGllbnRzXG52YXIgc2luZ2xldG9uS2V5ID0gJ19fd2VicGFja19ob3RfbWlkZGxld2FyZV9yZXBvcnRlcl9fJztcbnZhciByZXBvcnRlcjtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAoIXdpbmRvd1tzaW5nbGV0b25LZXldKSB7XG4gICAgd2luZG93W3NpbmdsZXRvbktleV0gPSBjcmVhdGVSZXBvcnRlcigpO1xuICB9XG4gIHJlcG9ydGVyID0gd2luZG93W3NpbmdsZXRvbktleV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcG9ydGVyKCkge1xuICB2YXIgc3RyaXAgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG5cbiAgdmFyIG92ZXJsYXk7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIG9wdGlvbnMub3ZlcmxheSkge1xuICAgIG92ZXJsYXkgPSByZXF1aXJlKCcuL2NsaWVudC1vdmVybGF5Jykoe1xuICAgICAgYW5zaUNvbG9yczogb3B0aW9ucy5hbnNpQ29sb3JzLFxuICAgICAgb3ZlcmxheVN0eWxlczogb3B0aW9ucy5vdmVybGF5U3R5bGVzXG4gICAgfSk7XG4gIH1cblxuICB2YXIgc3R5bGVzID0ge1xuICAgIGVycm9yczogXCJjb2xvcjogI2ZmMDAwMDtcIixcbiAgICB3YXJuaW5nczogXCJjb2xvcjogIzk5OTkzMztcIlxuICB9O1xuICB2YXIgcHJldmlvdXNQcm9ibGVtcyA9IG51bGw7XG4gIGZ1bmN0aW9uIGxvZyh0eXBlLCBvYmopIHtcbiAgICB2YXIgbmV3UHJvYmxlbXMgPSBvYmpbdHlwZV0ubWFwKGZ1bmN0aW9uKG1zZykgeyByZXR1cm4gc3RyaXAobXNnKTsgfSkuam9pbignXFxuJyk7XG4gICAgaWYgKHByZXZpb3VzUHJvYmxlbXMgPT0gbmV3UHJvYmxlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNQcm9ibGVtcyA9IG5ld1Byb2JsZW1zO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHN0eWxlc1t0eXBlXTtcbiAgICB2YXIgbmFtZSA9IG9iai5uYW1lID8gXCInXCIgKyBvYmoubmFtZSArIFwiJyBcIiA6IFwiXCI7XG4gICAgdmFyIHRpdGxlID0gXCJbSE1SXSBidW5kbGUgXCIgKyBuYW1lICsgXCJoYXMgXCIgKyBvYmpbdHlwZV0ubGVuZ3RoICsgXCIgXCIgKyB0eXBlO1xuICAgIC8vIE5PVEU6IGNvbnNvbGUud2FybiBvciBjb25zb2xlLmVycm9yIHdpbGwgcHJpbnQgdGhlIHN0YWNrIHRyYWNlXG4gICAgLy8gd2hpY2ggaXNuJ3QgaGVscGZ1bCBoZXJlLCBzbyB1c2luZyBjb25zb2xlLmxvZyB0byBlc2NhcGUgaXQuXG4gICAgaWYgKGNvbnNvbGUuZ3JvdXAgJiYgY29uc29sZS5ncm91cEVuZCkge1xuICAgICAgY29uc29sZS5ncm91cChcIiVjXCIgKyB0aXRsZSwgc3R5bGUpO1xuICAgICAgY29uc29sZS5sb2coXCIlY1wiICsgbmV3UHJvYmxlbXMsIHN0eWxlKTtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiJWNcIiArIHRpdGxlICsgXCJcXG5cXHQlY1wiICsgbmV3UHJvYmxlbXMucmVwbGFjZSgvXFxuL2csIFwiXFxuXFx0XCIpLFxuICAgICAgICBzdHlsZSArIFwiZm9udC13ZWlnaHQ6IGJvbGQ7XCIsXG4gICAgICAgIHN0eWxlICsgXCJmb250LXdlaWdodDogbm9ybWFsO1wiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2xlYW5Qcm9ibGVtc0NhY2hlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBwcmV2aW91c1Byb2JsZW1zID0gbnVsbDtcbiAgICB9LFxuICAgIHByb2JsZW1zOiBmdW5jdGlvbih0eXBlLCBvYmopIHtcbiAgICAgIGlmIChvcHRpb25zLndhcm4pIHtcbiAgICAgICAgbG9nKHR5cGUsIG9iaik7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdmVybGF5V2FybmluZ3MgfHwgdHlwZSA9PT0gJ2Vycm9ycycpIHtcbiAgICAgICAgICBvdmVybGF5LnNob3dQcm9ibGVtcyh0eXBlLCBvYmpbdHlwZV0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKG92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9LFxuICAgIHVzZUN1c3RvbU92ZXJsYXk6IGZ1bmN0aW9uKGN1c3RvbU92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkgPSBjdXN0b21PdmVybGF5O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHByb2Nlc3NVcGRhdGUgPSByZXF1aXJlKCcuL3Byb2Nlc3MtdXBkYXRlJyk7XG5cbnZhciBjdXN0b21IYW5kbGVyO1xudmFyIHN1YnNjcmliZUFsbEhhbmRsZXI7XG5mdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShvYmopIHtcbiAgc3dpdGNoKG9iai5hY3Rpb24pIHtcbiAgICBjYXNlIFwiYnVpbGRpbmdcIjpcbiAgICAgIGlmIChvcHRpb25zLmxvZykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIltITVJdIGJ1bmRsZSBcIiArIChvYmoubmFtZSA/IFwiJ1wiICsgb2JqLm5hbWUgKyBcIicgXCIgOiBcIlwiKSArXG4gICAgICAgICAgXCJyZWJ1aWxkaW5nXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJidWlsdFwiOlxuICAgICAgaWYgKG9wdGlvbnMubG9nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwiW0hNUl0gYnVuZGxlIFwiICsgKG9iai5uYW1lID8gXCInXCIgKyBvYmoubmFtZSArIFwiJyBcIiA6IFwiXCIpICtcbiAgICAgICAgICBcInJlYnVpbHQgaW4gXCIgKyBvYmoudGltZSArIFwibXNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgY2FzZSBcInN5bmNcIjpcbiAgICAgIGlmIChvYmoubmFtZSAmJiBvcHRpb25zLm5hbWUgJiYgb2JqLm5hbWUgIT09IG9wdGlvbnMubmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYXBwbHlVcGRhdGUgPSB0cnVlO1xuICAgICAgaWYgKG9iai5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAocmVwb3J0ZXIpIHJlcG9ydGVyLnByb2JsZW1zKCdlcnJvcnMnLCBvYmopO1xuICAgICAgICBhcHBseVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChvYmoud2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAocmVwb3J0ZXIpIHtcbiAgICAgICAgICB2YXIgb3ZlcmxheVNob3duID0gcmVwb3J0ZXIucHJvYmxlbXMoJ3dhcm5pbmdzJywgb2JqKTtcbiAgICAgICAgICBhcHBseVVwZGF0ZSA9IG92ZXJsYXlTaG93bjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcG9ydGVyKSB7XG4gICAgICAgICAgcmVwb3J0ZXIuY2xlYW5Qcm9ibGVtc0NhY2hlKCk7XG4gICAgICAgICAgcmVwb3J0ZXIuc3VjY2VzcygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXBwbHlVcGRhdGUpIHtcbiAgICAgICAgcHJvY2Vzc1VwZGF0ZShvYmouaGFzaCwgb2JqLm1vZHVsZXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjdXN0b21IYW5kbGVyKSB7XG4gICAgICAgIGN1c3RvbUhhbmRsZXIob2JqKTtcbiAgICAgIH1cbiAgfVxuXG4gIGlmIChzdWJzY3JpYmVBbGxIYW5kbGVyKSB7XG4gICAgc3Vic2NyaWJlQWxsSGFuZGxlcihvYmopO1xuICB9XG59XG5cbmlmIChtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3Vic2NyaWJlQWxsOiBmdW5jdGlvbiBzdWJzY3JpYmVBbGwoaGFuZGxlcikge1xuICAgICAgc3Vic2NyaWJlQWxsSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICBjdXN0b21IYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9LFxuICAgIHVzZUN1c3RvbU92ZXJsYXk6IGZ1bmN0aW9uIHVzZUN1c3RvbU92ZXJsYXkoY3VzdG9tT3ZlcmxheSkge1xuICAgICAgaWYgKHJlcG9ydGVyKSByZXBvcnRlci51c2VDdXN0b21PdmVybGF5KGN1c3RvbU92ZXJsYXkpO1xuICAgIH0sXG4gICAgc2V0T3B0aW9uc0FuZENvbm5lY3Q6IHNldE9wdGlvbnNBbmRDb25uZWN0XG4gIH07XG59XG4iLCIvKipcbiAqIEJhc2VkIGhlYXZpbHkgb24gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9ibG9iL1xuICogIGMwYWZkZjljNmFiYzFkZDcwNzA3YzU5NGU0NzM4MDJhNTY2ZjdiNmUvaG90L29ubHktZGV2LXNlcnZlci5qc1xuICogT3JpZ2luYWwgY29weXJpZ2h0IFRvYmlhcyBLb3BwZXJzIEBzb2tyYSAoTUlUIGxpY2Vuc2UpXG4gKi9cblxuLyogZ2xvYmFsIHdpbmRvdyBfX3dlYnBhY2tfaGFzaF9fICovXG5cbmlmICghbW9kdWxlLmhvdCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJbSE1SXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGlzIGRpc2FibGVkLlwiKTtcbn1cblxudmFyIGhtckRvY3NVcmwgPSBcImh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uY2VwdHMvaG90LW1vZHVsZS1yZXBsYWNlbWVudC9cIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG5cbnZhciBsYXN0SGFzaDtcbnZhciBmYWlsdXJlU3RhdHVzZXMgPSB7IGFib3J0OiAxLCBmYWlsOiAxIH07XG52YXIgYXBwbHlPcHRpb25zID0geyBcdFx0XHRcdFxuICBpZ25vcmVVbmFjY2VwdGVkOiB0cnVlLFxuICBpZ25vcmVEZWNsaW5lZDogdHJ1ZSxcbiAgaWdub3JlRXJyb3JlZDogdHJ1ZSxcbiAgb25VbmFjY2VwdGVkOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgY29uc29sZS53YXJuKFwiSWdub3JlZCBhbiB1cGRhdGUgdG8gdW5hY2NlcHRlZCBtb2R1bGUgXCIgKyBkYXRhLmNoYWluLmpvaW4oXCIgLT4gXCIpKTtcbiAgfSxcbiAgb25EZWNsaW5lZDogZnVuY3Rpb24oZGF0YSkge1xuICAgIGNvbnNvbGUud2FybihcIklnbm9yZWQgYW4gdXBkYXRlIHRvIGRlY2xpbmVkIG1vZHVsZSBcIiArIGRhdGEuY2hhaW4uam9pbihcIiAtPiBcIikpO1xuICB9LFxuICBvbkVycm9yZWQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBjb25zb2xlLmVycm9yKGRhdGEuZXJyb3IpO1xuICAgIGNvbnNvbGUud2FybihcIklnbm9yZWQgYW4gZXJyb3Igd2hpbGUgdXBkYXRpbmcgbW9kdWxlIFwiICsgZGF0YS5tb2R1bGVJZCArIFwiIChcIiArIGRhdGEudHlwZSArIFwiKVwiKTtcbiAgfSBcbn1cblxuZnVuY3Rpb24gdXBUb0RhdGUoaGFzaCkge1xuICBpZiAoaGFzaCkgbGFzdEhhc2ggPSBoYXNoO1xuICByZXR1cm4gbGFzdEhhc2ggPT0gX193ZWJwYWNrX2hhc2hfXztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihoYXNoLCBtb2R1bGVNYXAsIG9wdGlvbnMpIHtcbiAgdmFyIHJlbG9hZCA9IG9wdGlvbnMucmVsb2FkO1xuICBpZiAoIXVwVG9EYXRlKGhhc2gpICYmIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT0gXCJpZGxlXCIpIHtcbiAgICBpZiAob3B0aW9ucy5sb2cpIGNvbnNvbGUubG9nKFwiW0hNUl0gQ2hlY2tpbmcgZm9yIHVwZGF0ZXMgb24gdGhlIHNlcnZlci4uLlwiKTtcbiAgICBjaGVjaygpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oZXJyLCB1cGRhdGVkTW9kdWxlcykge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGhhbmRsZUVycm9yKGVycik7XG5cbiAgICAgIGlmKCF1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICBpZiAob3B0aW9ucy53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiW0hNUl0gQ2Fubm90IGZpbmQgdXBkYXRlIChGdWxsIHJlbG9hZCBuZWVkZWQpXCIpO1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltITVJdIChQcm9iYWJseSBiZWNhdXNlIG9mIHJlc3RhcnRpbmcgdGhlIHNlcnZlcilcIik7XG4gICAgICAgIH1cbiAgICAgICAgcGVyZm9ybVJlbG9hZCgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGFwcGx5Q2FsbGJhY2sgPSBmdW5jdGlvbihhcHBseUVyciwgcmVuZXdlZE1vZHVsZXMpIHtcbiAgICAgICAgaWYgKGFwcGx5RXJyKSByZXR1cm4gaGFuZGxlRXJyb3IoYXBwbHlFcnIpO1xuXG4gICAgICAgIGlmICghdXBUb0RhdGUoKSkgY2hlY2soKTtcblxuICAgICAgICBsb2dVcGRhdGVzKHVwZGF0ZWRNb2R1bGVzLCByZW5ld2VkTW9kdWxlcyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgYXBwbHlSZXN1bHQgPSBtb2R1bGUuaG90LmFwcGx5KGFwcGx5T3B0aW9ucywgYXBwbHlDYWxsYmFjayk7XG4gICAgICAvLyB3ZWJwYWNrIDIgcHJvbWlzZVxuICAgICAgaWYgKGFwcGx5UmVzdWx0ICYmIGFwcGx5UmVzdWx0LnRoZW4pIHtcbiAgICAgICAgLy8gSG90TW9kdWxlUmVwbGFjZW1lbnQucnVudGltZS5qcyByZWZlcnMgdG8gdGhlIHJlc3VsdCBhcyBgb3V0ZGF0ZWRNb2R1bGVzYFxuICAgICAgICBhcHBseVJlc3VsdC50aGVuKGZ1bmN0aW9uKG91dGRhdGVkTW9kdWxlcykge1xuICAgICAgICAgIGFwcGx5Q2FsbGJhY2sobnVsbCwgb3V0ZGF0ZWRNb2R1bGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFwcGx5UmVzdWx0LmNhdGNoKGFwcGx5Q2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIHZhciByZXN1bHQgPSBtb2R1bGUuaG90LmNoZWNrKGZhbHNlLCBjYik7XG4gICAgLy8gd2VicGFjayAyIHByb21pc2VcbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uKHVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgICAgICAgICBjYihudWxsLCB1cGRhdGVkTW9kdWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuY2F0Y2goY2IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ1VwZGF0ZXModXBkYXRlZE1vZHVsZXMsIHJlbmV3ZWRNb2R1bGVzKSB7XG4gICAgdmFyIHVuYWNjZXB0ZWRNb2R1bGVzID0gdXBkYXRlZE1vZHVsZXMuZmlsdGVyKGZ1bmN0aW9uKG1vZHVsZUlkKSB7XG4gICAgICByZXR1cm4gcmVuZXdlZE1vZHVsZXMgJiYgcmVuZXdlZE1vZHVsZXMuaW5kZXhPZihtb2R1bGVJZCkgPCAwO1xuICAgIH0pO1xuXG4gICAgaWYodW5hY2NlcHRlZE1vZHVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKG9wdGlvbnMud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJbSE1SXSBUaGUgZm9sbG93aW5nIG1vZHVsZXMgY291bGRuJ3QgYmUgaG90IHVwZGF0ZWQ6IFwiICtcbiAgICAgICAgICBcIihGdWxsIHJlbG9hZCBuZWVkZWQpXFxuXCIgK1xuICAgICAgICAgIFwiVGhpcyBpcyB1c3VhbGx5IGJlY2F1c2UgdGhlIG1vZHVsZXMgd2hpY2ggaGF2ZSBjaGFuZ2VkIFwiICtcbiAgICAgICAgICBcIihhbmQgdGhlaXIgcGFyZW50cykgZG8gbm90IGtub3cgaG93IHRvIGhvdCByZWxvYWQgdGhlbXNlbHZlcy4gXCIgK1xuICAgICAgICAgIFwiU2VlIFwiICsgaG1yRG9jc1VybCArIFwiIGZvciBtb3JlIGRldGFpbHMuXCJcbiAgICAgICAgKTtcbiAgICAgICAgdW5hY2NlcHRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGVJZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltITVJdICAtIFwiICsgKG1vZHVsZU1hcFttb2R1bGVJZF0gfHwgbW9kdWxlSWQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwZXJmb3JtUmVsb2FkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubG9nKSB7XG4gICAgICBpZighcmVuZXdlZE1vZHVsZXMgfHwgcmVuZXdlZE1vZHVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0hNUl0gTm90aGluZyBob3QgdXBkYXRlZC5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltITVJdIFVwZGF0ZWQgbW9kdWxlczpcIik7XG4gICAgICAgIHJlbmV3ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIltITVJdICAtIFwiICsgKG1vZHVsZU1hcFttb2R1bGVJZF0gfHwgbW9kdWxlSWQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1cFRvRGF0ZSgpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0hNUl0gQXBwIGlzIHVwIHRvIGRhdGUuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycikge1xuICAgIGlmIChtb2R1bGUuaG90LnN0YXR1cygpIGluIGZhaWx1cmVTdGF0dXNlcykge1xuICAgICAgaWYgKG9wdGlvbnMud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbSE1SXSBDYW5ub3QgY2hlY2sgZm9yIHVwZGF0ZSAoRnVsbCByZWxvYWQgbmVlZGVkKVwiKTtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW0hNUl0gXCIgKyAoZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgICBwZXJmb3JtUmVsb2FkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndhcm4pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltITVJdIFVwZGF0ZSBjaGVjayBmYWlsZWQ6IFwiICsgKGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1SZWxvYWQoKSB7XG4gICAgaWYgKHJlbG9hZCkge1xuICAgICAgaWYgKG9wdGlvbnMud2FybikgY29uc29sZS53YXJuKFwiW0hNUl0gUmVsb2FkaW5nIHBhZ2VcIik7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfVxuICB9XG59O1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxucmVxdWlyZShcIi4vY3NzL21haW4uY3NzXCIpO1xyXG52YXIgc2lnbmFsUiA9IHJlcXVpcmUoXCJAYXNwbmV0L3NpZ25hbHJcIik7XHJcbnZhciBLb252YSA9IHJlcXVpcmUoXCJrb252YVwiKTtcclxudmFyIGRpdk1lc3NhZ2VzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNkaXZNZXNzYWdlc1wiKTtcclxudmFyIHRiTWVzc2FnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjdGJNZXNzYWdlXCIpO1xyXG52YXIgYnRuU2VuZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYnRuU2VuZFwiKTtcclxudmFyIGRpdkNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZGl2Q2FudmFzXCIpO1xyXG52YXIgdXNlcm5hbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxudmFyIGNvbm5lY3Rpb24gPSBuZXcgc2lnbmFsUi5IdWJDb25uZWN0aW9uQnVpbGRlcigpXHJcbiAgICAud2l0aFVybChcIi9odWJcIilcclxuICAgIC5idWlsZCgpO1xyXG5jb25uZWN0aW9uLnN0YXJ0KCkuY2F0Y2goZnVuY3Rpb24gKGVycikgeyByZXR1cm4gZG9jdW1lbnQud3JpdGUoZXJyKTsgfSk7XHJcbmNvbm5lY3Rpb24ub24oXCJtZXNzYWdlUmVjZWl2ZWRcIiwgZnVuY3Rpb24gKHVzZXJuYW1lLCBtZXNzYWdlKSB7XHJcbiAgICBjb25zb2xlLmxvZygnY29ubmVjdGlvbi5vbiBTVEFSVCcpO1xyXG4gICAgdmFyIG1lc3NhZ2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgbWVzc2FnZUNvbnRhaW5lci5pbm5lckhUTUwgPVxyXG4gICAgICAgIFwiPGRpdiBjbGFzcz1cXFwibWVzc2FnZS1hdXRob3JcXFwiPlwiICsgdXNlcm5hbWUgKyBcIjwvZGl2PjxkaXY+XCIgKyBtZXNzYWdlICsgXCI8L2Rpdj5cIjtcclxuICAgIGRpdk1lc3NhZ2VzLmFwcGVuZENoaWxkKG1lc3NhZ2VDb250YWluZXIpO1xyXG4gICAgZGl2TWVzc2FnZXMuc2Nyb2xsVG9wID0gZGl2TWVzc2FnZXMuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgc2hvd0dyaWQoKTtcclxuICAgIGNvbnNvbGUubG9nKCdjb25uZWN0aW9uLm9uIEVORCcpO1xyXG59KTtcclxudGJNZXNzYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcclxuICAgICAgICBzZW5kKCk7XHJcbiAgICB9XHJcbn0pO1xyXG5idG5TZW5kLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBzZW5kKTtcclxuZnVuY3Rpb24gc2VuZCgpIHtcclxuICAgIGNvbm5lY3Rpb24uc2VuZChcIm5ld01lc3NhZ2VcIiwgdXNlcm5hbWUsIHRiTWVzc2FnZS52YWx1ZSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB0Yk1lc3NhZ2UudmFsdWUgPSBcIlwiOyB9KTtcclxufVxyXG5mdW5jdGlvbiBzaG93R3JpZCgpIHtcclxuICAgIHZhciBXSURUSCA9IDMwMDA7XHJcbiAgICB2YXIgSEVJR0hUID0gMzAwMDtcclxuICAgIHZhciBOVU1CRVIgPSAyMDA7XHJcbiAgICB2YXIgc3RhZ2UgPSBuZXcgS29udmEuU3RhZ2Uoe1xyXG4gICAgICAgIGNvbnRhaW5lcjogJ2NvbnRhaW5lcicsXHJcbiAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxyXG4gICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxyXG4gICAgfSk7XHJcbiAgICB2YXIgbGF5ZXIgPSBuZXcgS29udmEuTGF5ZXIoKTtcclxuICAgIHN0YWdlLmFkZChsYXllcik7XHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZU5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBLb252YS5DaXJjbGUoe1xyXG4gICAgICAgICAgICB4OiBXSURUSCAqIE1hdGgucmFuZG9tKCksXHJcbiAgICAgICAgICAgIHk6IEhFSUdIVCAqIE1hdGgucmFuZG9tKCksXHJcbiAgICAgICAgICAgIHJhZGl1czogNTAsXHJcbiAgICAgICAgICAgIGZpbGw6ICdyZWQnLFxyXG4gICAgICAgICAgICBzdHJva2U6ICdibGFjaydcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlVNQkVSOyBpKyspIHtcclxuICAgICAgICBsYXllci5hZGQoZ2VuZXJhdGVOb2RlKCkpO1xyXG4gICAgfVxyXG4gICAgbGF5ZXIuZHJhdygpO1xyXG4gICAgdmFyIHNjcm9sbENvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY3JvbGwtY29udGFpbmVyJyk7XHJcbiAgICBzY3JvbGxDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkeCA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0O1xyXG4gICAgICAgIHZhciBkeSA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3A7XHJcbiAgICAgICAgc3RhZ2UuY29udGFpbmVyKCkuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgZHggKyAncHgsICcgKyBkeSArICdweCknO1xyXG4gICAgICAgIHN0YWdlLngoLWR4KTtcclxuICAgICAgICBzdGFnZS55KC1keSk7XHJcbiAgICAgICAgc3RhZ2UuYmF0Y2hEcmF3KCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBwYWludENhbnZhcygpIHtcclxuICAgIC8vIGZpcnN0IHdlIG5lZWQgdG8gY3JlYXRlIGEgc3RhZ2VcclxuICAgIHZhciBzdGFnZSA9IG5ldyBLb252YS5TdGFnZSh7XHJcbiAgICAgICAgY29udGFpbmVyOiAnZGl2Q2FudmFzJyxcclxuICAgICAgICB3aWR0aDogNTAwLFxyXG4gICAgICAgIGhlaWdodDogNTAwXHJcbiAgICB9KTtcclxuICAgIC8vIHRoZW4gY3JlYXRlIGxheWVyXHJcbiAgICB2YXIgbGF5ZXIgPSBuZXcgS29udmEuTGF5ZXIoKTtcclxuICAgIC8vIGNyZWF0ZSBvdXIgc2hhcGVcclxuICAgIHZhciBjaXJjbGUgPSBuZXcgS29udmEuQ2lyY2xlKHtcclxuICAgICAgICB4OiBzdGFnZS5nZXRXaWR0aCgpIC8gMixcclxuICAgICAgICB5OiBzdGFnZS5nZXRIZWlnaHQoKSAvIDIsXHJcbiAgICAgICAgcmFkaXVzOiA3MCxcclxuICAgICAgICBmaWxsOiAneWVsbG93JyxcclxuICAgICAgICBzdHJva2U6ICdibGFjaycsXHJcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDRcclxuICAgIH0pO1xyXG4gICAgLy8gYWRkIHRoZSBzaGFwZSB0byB0aGUgbGF5ZXJcclxuICAgIGxheWVyLmFkZChjaXJjbGUpO1xyXG4gICAgLy8gYWRkIHRoZSBsYXllciB0byB0aGUgc3RhZ2VcclxuICAgIHN0YWdlLmFkZChsYXllcik7XHJcbiAgICAvLyBkcmF3IHRoZSBpbWFnZVxyXG4gICAgbGF5ZXIuZHJhdygpO1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=